
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model affiliate
 * 
 */
export type affiliate = $Result.DefaultSelection<Prisma.$affiliatePayload>
/**
 * Model auth_account
 * 
 */
export type auth_account = $Result.DefaultSelection<Prisma.$auth_accountPayload>
/**
 * Model auth_session
 * 
 */
export type auth_session = $Result.DefaultSelection<Prisma.$auth_sessionPayload>
/**
 * Model auth_two_factor
 * 
 */
export type auth_two_factor = $Result.DefaultSelection<Prisma.$auth_two_factorPayload>
/**
 * Model auth_user
 * 
 */
export type auth_user = $Result.DefaultSelection<Prisma.$auth_userPayload>
/**
 * Model auth_verification
 * 
 */
export type auth_verification = $Result.DefaultSelection<Prisma.$auth_verificationPayload>
/**
 * Model author
 * 
 */
export type author = $Result.DefaultSelection<Prisma.$authorPayload>
/**
 * Model banner
 * 
 */
export type banner = $Result.DefaultSelection<Prisma.$bannerPayload>
/**
 * Model book
 * 
 */
export type book = $Result.DefaultSelection<Prisma.$bookPayload>
/**
 * Model book_approval
 * 
 */
export type book_approval = $Result.DefaultSelection<Prisma.$book_approvalPayload>
/**
 * Model book_changes_log
 * 
 */
export type book_changes_log = $Result.DefaultSelection<Prisma.$book_changes_logPayload>
/**
 * Model book_genre
 * 
 */
export type book_genre = $Result.DefaultSelection<Prisma.$book_genrePayload>
/**
 * Model book_tags
 * 
 */
export type book_tags = $Result.DefaultSelection<Prisma.$book_tagsPayload>
/**
 * Model bundle
 * 
 */
export type bundle = $Result.DefaultSelection<Prisma.$bundlePayload>
/**
 * Model bundle_category
 * 
 */
export type bundle_category = $Result.DefaultSelection<Prisma.$bundle_categoryPayload>
/**
 * Model bundle_product
 * 
 */
export type bundle_product = $Result.DefaultSelection<Prisma.$bundle_productPayload>
/**
 * Model category
 * 
 */
export type category = $Result.DefaultSelection<Prisma.$categoryPayload>
/**
 * Model chapter
 * 
 */
export type chapter = $Result.DefaultSelection<Prisma.$chapterPayload>
/**
 * Model customer
 * 
 */
export type customer = $Result.DefaultSelection<Prisma.$customerPayload>
/**
 * Model customer_reader
 * 
 */
export type customer_reader = $Result.DefaultSelection<Prisma.$customer_readerPayload>
/**
 * Model customer_track
 * 
 */
export type customer_track = $Result.DefaultSelection<Prisma.$customer_trackPayload>
/**
 * Model genre
 * 
 */
export type genre = $Result.DefaultSelection<Prisma.$genrePayload>
/**
 * Model internal
 * 
 */
export type internal = $Result.DefaultSelection<Prisma.$internalPayload>
/**
 * Model landing
 * 
 */
export type landing = $Result.DefaultSelection<Prisma.$landingPayload>
/**
 * Model landing_items
 * 
 */
export type landing_items = $Result.DefaultSelection<Prisma.$landing_itemsPayload>
/**
 * Model midtrx
 * 
 */
export type midtrx = $Result.DefaultSelection<Prisma.$midtrxPayload>
/**
 * Model preorder
 * 
 */
export type preorder = $Result.DefaultSelection<Prisma.$preorderPayload>
/**
 * Model product
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type product = $Result.DefaultSelection<Prisma.$productPayload>
/**
 * Model product_category
 * 
 */
export type product_category = $Result.DefaultSelection<Prisma.$product_categoryPayload>
/**
 * Model promo_code
 * 
 */
export type promo_code = $Result.DefaultSelection<Prisma.$promo_codePayload>
/**
 * Model publisher
 * 
 */
export type publisher = $Result.DefaultSelection<Prisma.$publisherPayload>
/**
 * Model publisher_author
 * 
 */
export type publisher_author = $Result.DefaultSelection<Prisma.$publisher_authorPayload>
/**
 * Model ranking
 * 
 */
export type ranking = $Result.DefaultSelection<Prisma.$rankingPayload>
/**
 * Model reviews
 * 
 */
export type reviews = $Result.DefaultSelection<Prisma.$reviewsPayload>
/**
 * Model reviews_likes
 * 
 */
export type reviews_likes = $Result.DefaultSelection<Prisma.$reviews_likesPayload>
/**
 * Model t_ai_credit
 * 
 */
export type t_ai_credit = $Result.DefaultSelection<Prisma.$t_ai_creditPayload>
/**
 * Model t_ai_credit_topup
 * 
 */
export type t_ai_credit_topup = $Result.DefaultSelection<Prisma.$t_ai_credit_topupPayload>
/**
 * Model t_sales
 * 
 */
export type t_sales = $Result.DefaultSelection<Prisma.$t_salesPayload>
/**
 * Model t_sales_download
 * 
 */
export type t_sales_download = $Result.DefaultSelection<Prisma.$t_sales_downloadPayload>
/**
 * Model t_sales_line
 * 
 */
export type t_sales_line = $Result.DefaultSelection<Prisma.$t_sales_linePayload>
/**
 * Model tags
 * 
 */
export type tags = $Result.DefaultSelection<Prisma.$tagsPayload>
/**
 * Model transaction
 * 
 */
export type transaction = $Result.DefaultSelection<Prisma.$transactionPayload>
/**
 * Model withdrawal
 * 
 */
export type withdrawal = $Result.DefaultSelection<Prisma.$withdrawalPayload>

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Affiliates
 * const affiliates = await prisma.affiliate.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Affiliates
   * const affiliates = await prisma.affiliate.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.affiliate`: Exposes CRUD operations for the **affiliate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Affiliates
    * const affiliates = await prisma.affiliate.findMany()
    * ```
    */
  get affiliate(): Prisma.affiliateDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.auth_account`: Exposes CRUD operations for the **auth_account** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Auth_accounts
    * const auth_accounts = await prisma.auth_account.findMany()
    * ```
    */
  get auth_account(): Prisma.auth_accountDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.auth_session`: Exposes CRUD operations for the **auth_session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Auth_sessions
    * const auth_sessions = await prisma.auth_session.findMany()
    * ```
    */
  get auth_session(): Prisma.auth_sessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.auth_two_factor`: Exposes CRUD operations for the **auth_two_factor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Auth_two_factors
    * const auth_two_factors = await prisma.auth_two_factor.findMany()
    * ```
    */
  get auth_two_factor(): Prisma.auth_two_factorDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.auth_user`: Exposes CRUD operations for the **auth_user** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Auth_users
    * const auth_users = await prisma.auth_user.findMany()
    * ```
    */
  get auth_user(): Prisma.auth_userDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.auth_verification`: Exposes CRUD operations for the **auth_verification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Auth_verifications
    * const auth_verifications = await prisma.auth_verification.findMany()
    * ```
    */
  get auth_verification(): Prisma.auth_verificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.author`: Exposes CRUD operations for the **author** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Authors
    * const authors = await prisma.author.findMany()
    * ```
    */
  get author(): Prisma.authorDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.banner`: Exposes CRUD operations for the **banner** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Banners
    * const banners = await prisma.banner.findMany()
    * ```
    */
  get banner(): Prisma.bannerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.book`: Exposes CRUD operations for the **book** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Books
    * const books = await prisma.book.findMany()
    * ```
    */
  get book(): Prisma.bookDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.book_approval`: Exposes CRUD operations for the **book_approval** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Book_approvals
    * const book_approvals = await prisma.book_approval.findMany()
    * ```
    */
  get book_approval(): Prisma.book_approvalDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.book_changes_log`: Exposes CRUD operations for the **book_changes_log** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Book_changes_logs
    * const book_changes_logs = await prisma.book_changes_log.findMany()
    * ```
    */
  get book_changes_log(): Prisma.book_changes_logDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.book_genre`: Exposes CRUD operations for the **book_genre** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Book_genres
    * const book_genres = await prisma.book_genre.findMany()
    * ```
    */
  get book_genre(): Prisma.book_genreDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.book_tags`: Exposes CRUD operations for the **book_tags** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Book_tags
    * const book_tags = await prisma.book_tags.findMany()
    * ```
    */
  get book_tags(): Prisma.book_tagsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bundle`: Exposes CRUD operations for the **bundle** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Bundles
    * const bundles = await prisma.bundle.findMany()
    * ```
    */
  get bundle(): Prisma.bundleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bundle_category`: Exposes CRUD operations for the **bundle_category** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Bundle_categories
    * const bundle_categories = await prisma.bundle_category.findMany()
    * ```
    */
  get bundle_category(): Prisma.bundle_categoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bundle_product`: Exposes CRUD operations for the **bundle_product** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Bundle_products
    * const bundle_products = await prisma.bundle_product.findMany()
    * ```
    */
  get bundle_product(): Prisma.bundle_productDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.category`: Exposes CRUD operations for the **category** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Categories
    * const categories = await prisma.category.findMany()
    * ```
    */
  get category(): Prisma.categoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.chapter`: Exposes CRUD operations for the **chapter** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Chapters
    * const chapters = await prisma.chapter.findMany()
    * ```
    */
  get chapter(): Prisma.chapterDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.customer`: Exposes CRUD operations for the **customer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Customers
    * const customers = await prisma.customer.findMany()
    * ```
    */
  get customer(): Prisma.customerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.customer_reader`: Exposes CRUD operations for the **customer_reader** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Customer_readers
    * const customer_readers = await prisma.customer_reader.findMany()
    * ```
    */
  get customer_reader(): Prisma.customer_readerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.customer_track`: Exposes CRUD operations for the **customer_track** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Customer_tracks
    * const customer_tracks = await prisma.customer_track.findMany()
    * ```
    */
  get customer_track(): Prisma.customer_trackDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.genre`: Exposes CRUD operations for the **genre** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Genres
    * const genres = await prisma.genre.findMany()
    * ```
    */
  get genre(): Prisma.genreDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.internal`: Exposes CRUD operations for the **internal** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Internals
    * const internals = await prisma.internal.findMany()
    * ```
    */
  get internal(): Prisma.internalDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.landing`: Exposes CRUD operations for the **landing** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Landings
    * const landings = await prisma.landing.findMany()
    * ```
    */
  get landing(): Prisma.landingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.landing_items`: Exposes CRUD operations for the **landing_items** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Landing_items
    * const landing_items = await prisma.landing_items.findMany()
    * ```
    */
  get landing_items(): Prisma.landing_itemsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.midtrx`: Exposes CRUD operations for the **midtrx** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Midtrxes
    * const midtrxes = await prisma.midtrx.findMany()
    * ```
    */
  get midtrx(): Prisma.midtrxDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.preorder`: Exposes CRUD operations for the **preorder** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Preorders
    * const preorders = await prisma.preorder.findMany()
    * ```
    */
  get preorder(): Prisma.preorderDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.product`: Exposes CRUD operations for the **product** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Products
    * const products = await prisma.product.findMany()
    * ```
    */
  get product(): Prisma.productDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.product_category`: Exposes CRUD operations for the **product_category** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Product_categories
    * const product_categories = await prisma.product_category.findMany()
    * ```
    */
  get product_category(): Prisma.product_categoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.promo_code`: Exposes CRUD operations for the **promo_code** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Promo_codes
    * const promo_codes = await prisma.promo_code.findMany()
    * ```
    */
  get promo_code(): Prisma.promo_codeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.publisher`: Exposes CRUD operations for the **publisher** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Publishers
    * const publishers = await prisma.publisher.findMany()
    * ```
    */
  get publisher(): Prisma.publisherDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.publisher_author`: Exposes CRUD operations for the **publisher_author** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Publisher_authors
    * const publisher_authors = await prisma.publisher_author.findMany()
    * ```
    */
  get publisher_author(): Prisma.publisher_authorDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.ranking`: Exposes CRUD operations for the **ranking** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Rankings
    * const rankings = await prisma.ranking.findMany()
    * ```
    */
  get ranking(): Prisma.rankingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.reviews`: Exposes CRUD operations for the **reviews** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reviews
    * const reviews = await prisma.reviews.findMany()
    * ```
    */
  get reviews(): Prisma.reviewsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.reviews_likes`: Exposes CRUD operations for the **reviews_likes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reviews_likes
    * const reviews_likes = await prisma.reviews_likes.findMany()
    * ```
    */
  get reviews_likes(): Prisma.reviews_likesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.t_ai_credit`: Exposes CRUD operations for the **t_ai_credit** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more T_ai_credits
    * const t_ai_credits = await prisma.t_ai_credit.findMany()
    * ```
    */
  get t_ai_credit(): Prisma.t_ai_creditDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.t_ai_credit_topup`: Exposes CRUD operations for the **t_ai_credit_topup** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more T_ai_credit_topups
    * const t_ai_credit_topups = await prisma.t_ai_credit_topup.findMany()
    * ```
    */
  get t_ai_credit_topup(): Prisma.t_ai_credit_topupDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.t_sales`: Exposes CRUD operations for the **t_sales** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more T_sales
    * const t_sales = await prisma.t_sales.findMany()
    * ```
    */
  get t_sales(): Prisma.t_salesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.t_sales_download`: Exposes CRUD operations for the **t_sales_download** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more T_sales_downloads
    * const t_sales_downloads = await prisma.t_sales_download.findMany()
    * ```
    */
  get t_sales_download(): Prisma.t_sales_downloadDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.t_sales_line`: Exposes CRUD operations for the **t_sales_line** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more T_sales_lines
    * const t_sales_lines = await prisma.t_sales_line.findMany()
    * ```
    */
  get t_sales_line(): Prisma.t_sales_lineDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tags`: Exposes CRUD operations for the **tags** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tags
    * const tags = await prisma.tags.findMany()
    * ```
    */
  get tags(): Prisma.tagsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.transaction`: Exposes CRUD operations for the **transaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Transactions
    * const transactions = await prisma.transaction.findMany()
    * ```
    */
  get transaction(): Prisma.transactionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.withdrawal`: Exposes CRUD operations for the **withdrawal** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Withdrawals
    * const withdrawals = await prisma.withdrawal.findMany()
    * ```
    */
  get withdrawal(): Prisma.withdrawalDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.8.2
   * Query Engine version: 2060c79ba17c6bb9f5823312b6f6b7f4a845738e
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    affiliate: 'affiliate',
    auth_account: 'auth_account',
    auth_session: 'auth_session',
    auth_two_factor: 'auth_two_factor',
    auth_user: 'auth_user',
    auth_verification: 'auth_verification',
    author: 'author',
    banner: 'banner',
    book: 'book',
    book_approval: 'book_approval',
    book_changes_log: 'book_changes_log',
    book_genre: 'book_genre',
    book_tags: 'book_tags',
    bundle: 'bundle',
    bundle_category: 'bundle_category',
    bundle_product: 'bundle_product',
    category: 'category',
    chapter: 'chapter',
    customer: 'customer',
    customer_reader: 'customer_reader',
    customer_track: 'customer_track',
    genre: 'genre',
    internal: 'internal',
    landing: 'landing',
    landing_items: 'landing_items',
    midtrx: 'midtrx',
    preorder: 'preorder',
    product: 'product',
    product_category: 'product_category',
    promo_code: 'promo_code',
    publisher: 'publisher',
    publisher_author: 'publisher_author',
    ranking: 'ranking',
    reviews: 'reviews',
    reviews_likes: 'reviews_likes',
    t_ai_credit: 't_ai_credit',
    t_ai_credit_topup: 't_ai_credit_topup',
    t_sales: 't_sales',
    t_sales_download: 't_sales_download',
    t_sales_line: 't_sales_line',
    tags: 'tags',
    transaction: 'transaction',
    withdrawal: 'withdrawal'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "affiliate" | "auth_account" | "auth_session" | "auth_two_factor" | "auth_user" | "auth_verification" | "author" | "banner" | "book" | "book_approval" | "book_changes_log" | "book_genre" | "book_tags" | "bundle" | "bundle_category" | "bundle_product" | "category" | "chapter" | "customer" | "customer_reader" | "customer_track" | "genre" | "internal" | "landing" | "landing_items" | "midtrx" | "preorder" | "product" | "product_category" | "promo_code" | "publisher" | "publisher_author" | "ranking" | "reviews" | "reviews_likes" | "t_ai_credit" | "t_ai_credit_topup" | "t_sales" | "t_sales_download" | "t_sales_line" | "tags" | "transaction" | "withdrawal"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      affiliate: {
        payload: Prisma.$affiliatePayload<ExtArgs>
        fields: Prisma.affiliateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.affiliateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$affiliatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.affiliateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$affiliatePayload>
          }
          findFirst: {
            args: Prisma.affiliateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$affiliatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.affiliateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$affiliatePayload>
          }
          findMany: {
            args: Prisma.affiliateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$affiliatePayload>[]
          }
          create: {
            args: Prisma.affiliateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$affiliatePayload>
          }
          createMany: {
            args: Prisma.affiliateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.affiliateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$affiliatePayload>[]
          }
          delete: {
            args: Prisma.affiliateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$affiliatePayload>
          }
          update: {
            args: Prisma.affiliateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$affiliatePayload>
          }
          deleteMany: {
            args: Prisma.affiliateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.affiliateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.affiliateUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$affiliatePayload>[]
          }
          upsert: {
            args: Prisma.affiliateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$affiliatePayload>
          }
          aggregate: {
            args: Prisma.AffiliateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAffiliate>
          }
          groupBy: {
            args: Prisma.affiliateGroupByArgs<ExtArgs>
            result: $Utils.Optional<AffiliateGroupByOutputType>[]
          }
          count: {
            args: Prisma.affiliateCountArgs<ExtArgs>
            result: $Utils.Optional<AffiliateCountAggregateOutputType> | number
          }
        }
      }
      auth_account: {
        payload: Prisma.$auth_accountPayload<ExtArgs>
        fields: Prisma.auth_accountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.auth_accountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auth_accountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.auth_accountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auth_accountPayload>
          }
          findFirst: {
            args: Prisma.auth_accountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auth_accountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.auth_accountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auth_accountPayload>
          }
          findMany: {
            args: Prisma.auth_accountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auth_accountPayload>[]
          }
          create: {
            args: Prisma.auth_accountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auth_accountPayload>
          }
          createMany: {
            args: Prisma.auth_accountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.auth_accountCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auth_accountPayload>[]
          }
          delete: {
            args: Prisma.auth_accountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auth_accountPayload>
          }
          update: {
            args: Prisma.auth_accountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auth_accountPayload>
          }
          deleteMany: {
            args: Prisma.auth_accountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.auth_accountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.auth_accountUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auth_accountPayload>[]
          }
          upsert: {
            args: Prisma.auth_accountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auth_accountPayload>
          }
          aggregate: {
            args: Prisma.Auth_accountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuth_account>
          }
          groupBy: {
            args: Prisma.auth_accountGroupByArgs<ExtArgs>
            result: $Utils.Optional<Auth_accountGroupByOutputType>[]
          }
          count: {
            args: Prisma.auth_accountCountArgs<ExtArgs>
            result: $Utils.Optional<Auth_accountCountAggregateOutputType> | number
          }
        }
      }
      auth_session: {
        payload: Prisma.$auth_sessionPayload<ExtArgs>
        fields: Prisma.auth_sessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.auth_sessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auth_sessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.auth_sessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auth_sessionPayload>
          }
          findFirst: {
            args: Prisma.auth_sessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auth_sessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.auth_sessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auth_sessionPayload>
          }
          findMany: {
            args: Prisma.auth_sessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auth_sessionPayload>[]
          }
          create: {
            args: Prisma.auth_sessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auth_sessionPayload>
          }
          createMany: {
            args: Prisma.auth_sessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.auth_sessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auth_sessionPayload>[]
          }
          delete: {
            args: Prisma.auth_sessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auth_sessionPayload>
          }
          update: {
            args: Prisma.auth_sessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auth_sessionPayload>
          }
          deleteMany: {
            args: Prisma.auth_sessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.auth_sessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.auth_sessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auth_sessionPayload>[]
          }
          upsert: {
            args: Prisma.auth_sessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auth_sessionPayload>
          }
          aggregate: {
            args: Prisma.Auth_sessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuth_session>
          }
          groupBy: {
            args: Prisma.auth_sessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<Auth_sessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.auth_sessionCountArgs<ExtArgs>
            result: $Utils.Optional<Auth_sessionCountAggregateOutputType> | number
          }
        }
      }
      auth_two_factor: {
        payload: Prisma.$auth_two_factorPayload<ExtArgs>
        fields: Prisma.auth_two_factorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.auth_two_factorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auth_two_factorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.auth_two_factorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auth_two_factorPayload>
          }
          findFirst: {
            args: Prisma.auth_two_factorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auth_two_factorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.auth_two_factorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auth_two_factorPayload>
          }
          findMany: {
            args: Prisma.auth_two_factorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auth_two_factorPayload>[]
          }
          create: {
            args: Prisma.auth_two_factorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auth_two_factorPayload>
          }
          createMany: {
            args: Prisma.auth_two_factorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.auth_two_factorCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auth_two_factorPayload>[]
          }
          delete: {
            args: Prisma.auth_two_factorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auth_two_factorPayload>
          }
          update: {
            args: Prisma.auth_two_factorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auth_two_factorPayload>
          }
          deleteMany: {
            args: Prisma.auth_two_factorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.auth_two_factorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.auth_two_factorUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auth_two_factorPayload>[]
          }
          upsert: {
            args: Prisma.auth_two_factorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auth_two_factorPayload>
          }
          aggregate: {
            args: Prisma.Auth_two_factorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuth_two_factor>
          }
          groupBy: {
            args: Prisma.auth_two_factorGroupByArgs<ExtArgs>
            result: $Utils.Optional<Auth_two_factorGroupByOutputType>[]
          }
          count: {
            args: Prisma.auth_two_factorCountArgs<ExtArgs>
            result: $Utils.Optional<Auth_two_factorCountAggregateOutputType> | number
          }
        }
      }
      auth_user: {
        payload: Prisma.$auth_userPayload<ExtArgs>
        fields: Prisma.auth_userFieldRefs
        operations: {
          findUnique: {
            args: Prisma.auth_userFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auth_userPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.auth_userFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auth_userPayload>
          }
          findFirst: {
            args: Prisma.auth_userFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auth_userPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.auth_userFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auth_userPayload>
          }
          findMany: {
            args: Prisma.auth_userFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auth_userPayload>[]
          }
          create: {
            args: Prisma.auth_userCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auth_userPayload>
          }
          createMany: {
            args: Prisma.auth_userCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.auth_userCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auth_userPayload>[]
          }
          delete: {
            args: Prisma.auth_userDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auth_userPayload>
          }
          update: {
            args: Prisma.auth_userUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auth_userPayload>
          }
          deleteMany: {
            args: Prisma.auth_userDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.auth_userUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.auth_userUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auth_userPayload>[]
          }
          upsert: {
            args: Prisma.auth_userUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auth_userPayload>
          }
          aggregate: {
            args: Prisma.Auth_userAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuth_user>
          }
          groupBy: {
            args: Prisma.auth_userGroupByArgs<ExtArgs>
            result: $Utils.Optional<Auth_userGroupByOutputType>[]
          }
          count: {
            args: Prisma.auth_userCountArgs<ExtArgs>
            result: $Utils.Optional<Auth_userCountAggregateOutputType> | number
          }
        }
      }
      auth_verification: {
        payload: Prisma.$auth_verificationPayload<ExtArgs>
        fields: Prisma.auth_verificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.auth_verificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auth_verificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.auth_verificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auth_verificationPayload>
          }
          findFirst: {
            args: Prisma.auth_verificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auth_verificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.auth_verificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auth_verificationPayload>
          }
          findMany: {
            args: Prisma.auth_verificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auth_verificationPayload>[]
          }
          create: {
            args: Prisma.auth_verificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auth_verificationPayload>
          }
          createMany: {
            args: Prisma.auth_verificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.auth_verificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auth_verificationPayload>[]
          }
          delete: {
            args: Prisma.auth_verificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auth_verificationPayload>
          }
          update: {
            args: Prisma.auth_verificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auth_verificationPayload>
          }
          deleteMany: {
            args: Prisma.auth_verificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.auth_verificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.auth_verificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auth_verificationPayload>[]
          }
          upsert: {
            args: Prisma.auth_verificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auth_verificationPayload>
          }
          aggregate: {
            args: Prisma.Auth_verificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuth_verification>
          }
          groupBy: {
            args: Prisma.auth_verificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<Auth_verificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.auth_verificationCountArgs<ExtArgs>
            result: $Utils.Optional<Auth_verificationCountAggregateOutputType> | number
          }
        }
      }
      author: {
        payload: Prisma.$authorPayload<ExtArgs>
        fields: Prisma.authorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.authorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$authorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.authorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$authorPayload>
          }
          findFirst: {
            args: Prisma.authorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$authorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.authorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$authorPayload>
          }
          findMany: {
            args: Prisma.authorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$authorPayload>[]
          }
          create: {
            args: Prisma.authorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$authorPayload>
          }
          createMany: {
            args: Prisma.authorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.authorCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$authorPayload>[]
          }
          delete: {
            args: Prisma.authorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$authorPayload>
          }
          update: {
            args: Prisma.authorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$authorPayload>
          }
          deleteMany: {
            args: Prisma.authorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.authorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.authorUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$authorPayload>[]
          }
          upsert: {
            args: Prisma.authorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$authorPayload>
          }
          aggregate: {
            args: Prisma.AuthorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuthor>
          }
          groupBy: {
            args: Prisma.authorGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuthorGroupByOutputType>[]
          }
          count: {
            args: Prisma.authorCountArgs<ExtArgs>
            result: $Utils.Optional<AuthorCountAggregateOutputType> | number
          }
        }
      }
      banner: {
        payload: Prisma.$bannerPayload<ExtArgs>
        fields: Prisma.bannerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.bannerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bannerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.bannerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bannerPayload>
          }
          findFirst: {
            args: Prisma.bannerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bannerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.bannerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bannerPayload>
          }
          findMany: {
            args: Prisma.bannerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bannerPayload>[]
          }
          create: {
            args: Prisma.bannerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bannerPayload>
          }
          createMany: {
            args: Prisma.bannerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.bannerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bannerPayload>[]
          }
          delete: {
            args: Prisma.bannerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bannerPayload>
          }
          update: {
            args: Prisma.bannerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bannerPayload>
          }
          deleteMany: {
            args: Prisma.bannerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.bannerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.bannerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bannerPayload>[]
          }
          upsert: {
            args: Prisma.bannerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bannerPayload>
          }
          aggregate: {
            args: Prisma.BannerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBanner>
          }
          groupBy: {
            args: Prisma.bannerGroupByArgs<ExtArgs>
            result: $Utils.Optional<BannerGroupByOutputType>[]
          }
          count: {
            args: Prisma.bannerCountArgs<ExtArgs>
            result: $Utils.Optional<BannerCountAggregateOutputType> | number
          }
        }
      }
      book: {
        payload: Prisma.$bookPayload<ExtArgs>
        fields: Prisma.bookFieldRefs
        operations: {
          findUnique: {
            args: Prisma.bookFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bookPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.bookFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bookPayload>
          }
          findFirst: {
            args: Prisma.bookFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bookPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.bookFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bookPayload>
          }
          findMany: {
            args: Prisma.bookFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bookPayload>[]
          }
          create: {
            args: Prisma.bookCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bookPayload>
          }
          createMany: {
            args: Prisma.bookCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.bookCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bookPayload>[]
          }
          delete: {
            args: Prisma.bookDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bookPayload>
          }
          update: {
            args: Prisma.bookUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bookPayload>
          }
          deleteMany: {
            args: Prisma.bookDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.bookUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.bookUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bookPayload>[]
          }
          upsert: {
            args: Prisma.bookUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bookPayload>
          }
          aggregate: {
            args: Prisma.BookAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBook>
          }
          groupBy: {
            args: Prisma.bookGroupByArgs<ExtArgs>
            result: $Utils.Optional<BookGroupByOutputType>[]
          }
          count: {
            args: Prisma.bookCountArgs<ExtArgs>
            result: $Utils.Optional<BookCountAggregateOutputType> | number
          }
        }
      }
      book_approval: {
        payload: Prisma.$book_approvalPayload<ExtArgs>
        fields: Prisma.book_approvalFieldRefs
        operations: {
          findUnique: {
            args: Prisma.book_approvalFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$book_approvalPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.book_approvalFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$book_approvalPayload>
          }
          findFirst: {
            args: Prisma.book_approvalFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$book_approvalPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.book_approvalFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$book_approvalPayload>
          }
          findMany: {
            args: Prisma.book_approvalFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$book_approvalPayload>[]
          }
          create: {
            args: Prisma.book_approvalCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$book_approvalPayload>
          }
          createMany: {
            args: Prisma.book_approvalCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.book_approvalCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$book_approvalPayload>[]
          }
          delete: {
            args: Prisma.book_approvalDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$book_approvalPayload>
          }
          update: {
            args: Prisma.book_approvalUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$book_approvalPayload>
          }
          deleteMany: {
            args: Prisma.book_approvalDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.book_approvalUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.book_approvalUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$book_approvalPayload>[]
          }
          upsert: {
            args: Prisma.book_approvalUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$book_approvalPayload>
          }
          aggregate: {
            args: Prisma.Book_approvalAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBook_approval>
          }
          groupBy: {
            args: Prisma.book_approvalGroupByArgs<ExtArgs>
            result: $Utils.Optional<Book_approvalGroupByOutputType>[]
          }
          count: {
            args: Prisma.book_approvalCountArgs<ExtArgs>
            result: $Utils.Optional<Book_approvalCountAggregateOutputType> | number
          }
        }
      }
      book_changes_log: {
        payload: Prisma.$book_changes_logPayload<ExtArgs>
        fields: Prisma.book_changes_logFieldRefs
        operations: {
          findUnique: {
            args: Prisma.book_changes_logFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$book_changes_logPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.book_changes_logFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$book_changes_logPayload>
          }
          findFirst: {
            args: Prisma.book_changes_logFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$book_changes_logPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.book_changes_logFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$book_changes_logPayload>
          }
          findMany: {
            args: Prisma.book_changes_logFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$book_changes_logPayload>[]
          }
          create: {
            args: Prisma.book_changes_logCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$book_changes_logPayload>
          }
          createMany: {
            args: Prisma.book_changes_logCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.book_changes_logCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$book_changes_logPayload>[]
          }
          delete: {
            args: Prisma.book_changes_logDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$book_changes_logPayload>
          }
          update: {
            args: Prisma.book_changes_logUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$book_changes_logPayload>
          }
          deleteMany: {
            args: Prisma.book_changes_logDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.book_changes_logUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.book_changes_logUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$book_changes_logPayload>[]
          }
          upsert: {
            args: Prisma.book_changes_logUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$book_changes_logPayload>
          }
          aggregate: {
            args: Prisma.Book_changes_logAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBook_changes_log>
          }
          groupBy: {
            args: Prisma.book_changes_logGroupByArgs<ExtArgs>
            result: $Utils.Optional<Book_changes_logGroupByOutputType>[]
          }
          count: {
            args: Prisma.book_changes_logCountArgs<ExtArgs>
            result: $Utils.Optional<Book_changes_logCountAggregateOutputType> | number
          }
        }
      }
      book_genre: {
        payload: Prisma.$book_genrePayload<ExtArgs>
        fields: Prisma.book_genreFieldRefs
        operations: {
          findUnique: {
            args: Prisma.book_genreFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$book_genrePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.book_genreFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$book_genrePayload>
          }
          findFirst: {
            args: Prisma.book_genreFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$book_genrePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.book_genreFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$book_genrePayload>
          }
          findMany: {
            args: Prisma.book_genreFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$book_genrePayload>[]
          }
          create: {
            args: Prisma.book_genreCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$book_genrePayload>
          }
          createMany: {
            args: Prisma.book_genreCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.book_genreCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$book_genrePayload>[]
          }
          delete: {
            args: Prisma.book_genreDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$book_genrePayload>
          }
          update: {
            args: Prisma.book_genreUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$book_genrePayload>
          }
          deleteMany: {
            args: Prisma.book_genreDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.book_genreUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.book_genreUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$book_genrePayload>[]
          }
          upsert: {
            args: Prisma.book_genreUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$book_genrePayload>
          }
          aggregate: {
            args: Prisma.Book_genreAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBook_genre>
          }
          groupBy: {
            args: Prisma.book_genreGroupByArgs<ExtArgs>
            result: $Utils.Optional<Book_genreGroupByOutputType>[]
          }
          count: {
            args: Prisma.book_genreCountArgs<ExtArgs>
            result: $Utils.Optional<Book_genreCountAggregateOutputType> | number
          }
        }
      }
      book_tags: {
        payload: Prisma.$book_tagsPayload<ExtArgs>
        fields: Prisma.book_tagsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.book_tagsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$book_tagsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.book_tagsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$book_tagsPayload>
          }
          findFirst: {
            args: Prisma.book_tagsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$book_tagsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.book_tagsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$book_tagsPayload>
          }
          findMany: {
            args: Prisma.book_tagsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$book_tagsPayload>[]
          }
          create: {
            args: Prisma.book_tagsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$book_tagsPayload>
          }
          createMany: {
            args: Prisma.book_tagsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.book_tagsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$book_tagsPayload>[]
          }
          delete: {
            args: Prisma.book_tagsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$book_tagsPayload>
          }
          update: {
            args: Prisma.book_tagsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$book_tagsPayload>
          }
          deleteMany: {
            args: Prisma.book_tagsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.book_tagsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.book_tagsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$book_tagsPayload>[]
          }
          upsert: {
            args: Prisma.book_tagsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$book_tagsPayload>
          }
          aggregate: {
            args: Prisma.Book_tagsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBook_tags>
          }
          groupBy: {
            args: Prisma.book_tagsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Book_tagsGroupByOutputType>[]
          }
          count: {
            args: Prisma.book_tagsCountArgs<ExtArgs>
            result: $Utils.Optional<Book_tagsCountAggregateOutputType> | number
          }
        }
      }
      bundle: {
        payload: Prisma.$bundlePayload<ExtArgs>
        fields: Prisma.bundleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.bundleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bundlePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.bundleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bundlePayload>
          }
          findFirst: {
            args: Prisma.bundleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bundlePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.bundleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bundlePayload>
          }
          findMany: {
            args: Prisma.bundleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bundlePayload>[]
          }
          create: {
            args: Prisma.bundleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bundlePayload>
          }
          createMany: {
            args: Prisma.bundleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.bundleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bundlePayload>[]
          }
          delete: {
            args: Prisma.bundleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bundlePayload>
          }
          update: {
            args: Prisma.bundleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bundlePayload>
          }
          deleteMany: {
            args: Prisma.bundleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.bundleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.bundleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bundlePayload>[]
          }
          upsert: {
            args: Prisma.bundleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bundlePayload>
          }
          aggregate: {
            args: Prisma.BundleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBundle>
          }
          groupBy: {
            args: Prisma.bundleGroupByArgs<ExtArgs>
            result: $Utils.Optional<BundleGroupByOutputType>[]
          }
          count: {
            args: Prisma.bundleCountArgs<ExtArgs>
            result: $Utils.Optional<BundleCountAggregateOutputType> | number
          }
        }
      }
      bundle_category: {
        payload: Prisma.$bundle_categoryPayload<ExtArgs>
        fields: Prisma.bundle_categoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.bundle_categoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bundle_categoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.bundle_categoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bundle_categoryPayload>
          }
          findFirst: {
            args: Prisma.bundle_categoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bundle_categoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.bundle_categoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bundle_categoryPayload>
          }
          findMany: {
            args: Prisma.bundle_categoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bundle_categoryPayload>[]
          }
          create: {
            args: Prisma.bundle_categoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bundle_categoryPayload>
          }
          createMany: {
            args: Prisma.bundle_categoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.bundle_categoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bundle_categoryPayload>[]
          }
          delete: {
            args: Prisma.bundle_categoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bundle_categoryPayload>
          }
          update: {
            args: Prisma.bundle_categoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bundle_categoryPayload>
          }
          deleteMany: {
            args: Prisma.bundle_categoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.bundle_categoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.bundle_categoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bundle_categoryPayload>[]
          }
          upsert: {
            args: Prisma.bundle_categoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bundle_categoryPayload>
          }
          aggregate: {
            args: Prisma.Bundle_categoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBundle_category>
          }
          groupBy: {
            args: Prisma.bundle_categoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<Bundle_categoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.bundle_categoryCountArgs<ExtArgs>
            result: $Utils.Optional<Bundle_categoryCountAggregateOutputType> | number
          }
        }
      }
      bundle_product: {
        payload: Prisma.$bundle_productPayload<ExtArgs>
        fields: Prisma.bundle_productFieldRefs
        operations: {
          findUnique: {
            args: Prisma.bundle_productFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bundle_productPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.bundle_productFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bundle_productPayload>
          }
          findFirst: {
            args: Prisma.bundle_productFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bundle_productPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.bundle_productFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bundle_productPayload>
          }
          findMany: {
            args: Prisma.bundle_productFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bundle_productPayload>[]
          }
          create: {
            args: Prisma.bundle_productCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bundle_productPayload>
          }
          createMany: {
            args: Prisma.bundle_productCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.bundle_productCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bundle_productPayload>[]
          }
          delete: {
            args: Prisma.bundle_productDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bundle_productPayload>
          }
          update: {
            args: Prisma.bundle_productUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bundle_productPayload>
          }
          deleteMany: {
            args: Prisma.bundle_productDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.bundle_productUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.bundle_productUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bundle_productPayload>[]
          }
          upsert: {
            args: Prisma.bundle_productUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bundle_productPayload>
          }
          aggregate: {
            args: Prisma.Bundle_productAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBundle_product>
          }
          groupBy: {
            args: Prisma.bundle_productGroupByArgs<ExtArgs>
            result: $Utils.Optional<Bundle_productGroupByOutputType>[]
          }
          count: {
            args: Prisma.bundle_productCountArgs<ExtArgs>
            result: $Utils.Optional<Bundle_productCountAggregateOutputType> | number
          }
        }
      }
      category: {
        payload: Prisma.$categoryPayload<ExtArgs>
        fields: Prisma.categoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.categoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.categoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoryPayload>
          }
          findFirst: {
            args: Prisma.categoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.categoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoryPayload>
          }
          findMany: {
            args: Prisma.categoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoryPayload>[]
          }
          create: {
            args: Prisma.categoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoryPayload>
          }
          createMany: {
            args: Prisma.categoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.categoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoryPayload>[]
          }
          delete: {
            args: Prisma.categoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoryPayload>
          }
          update: {
            args: Prisma.categoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoryPayload>
          }
          deleteMany: {
            args: Prisma.categoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.categoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.categoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoryPayload>[]
          }
          upsert: {
            args: Prisma.categoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoryPayload>
          }
          aggregate: {
            args: Prisma.CategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCategory>
          }
          groupBy: {
            args: Prisma.categoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<CategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.categoryCountArgs<ExtArgs>
            result: $Utils.Optional<CategoryCountAggregateOutputType> | number
          }
        }
      }
      chapter: {
        payload: Prisma.$chapterPayload<ExtArgs>
        fields: Prisma.chapterFieldRefs
        operations: {
          findUnique: {
            args: Prisma.chapterFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chapterPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.chapterFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chapterPayload>
          }
          findFirst: {
            args: Prisma.chapterFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chapterPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.chapterFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chapterPayload>
          }
          findMany: {
            args: Prisma.chapterFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chapterPayload>[]
          }
          create: {
            args: Prisma.chapterCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chapterPayload>
          }
          createMany: {
            args: Prisma.chapterCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.chapterCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chapterPayload>[]
          }
          delete: {
            args: Prisma.chapterDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chapterPayload>
          }
          update: {
            args: Prisma.chapterUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chapterPayload>
          }
          deleteMany: {
            args: Prisma.chapterDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.chapterUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.chapterUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chapterPayload>[]
          }
          upsert: {
            args: Prisma.chapterUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chapterPayload>
          }
          aggregate: {
            args: Prisma.ChapterAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChapter>
          }
          groupBy: {
            args: Prisma.chapterGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChapterGroupByOutputType>[]
          }
          count: {
            args: Prisma.chapterCountArgs<ExtArgs>
            result: $Utils.Optional<ChapterCountAggregateOutputType> | number
          }
        }
      }
      customer: {
        payload: Prisma.$customerPayload<ExtArgs>
        fields: Prisma.customerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.customerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.customerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customerPayload>
          }
          findFirst: {
            args: Prisma.customerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.customerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customerPayload>
          }
          findMany: {
            args: Prisma.customerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customerPayload>[]
          }
          create: {
            args: Prisma.customerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customerPayload>
          }
          createMany: {
            args: Prisma.customerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.customerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customerPayload>[]
          }
          delete: {
            args: Prisma.customerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customerPayload>
          }
          update: {
            args: Prisma.customerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customerPayload>
          }
          deleteMany: {
            args: Prisma.customerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.customerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.customerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customerPayload>[]
          }
          upsert: {
            args: Prisma.customerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customerPayload>
          }
          aggregate: {
            args: Prisma.CustomerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustomer>
          }
          groupBy: {
            args: Prisma.customerGroupByArgs<ExtArgs>
            result: $Utils.Optional<CustomerGroupByOutputType>[]
          }
          count: {
            args: Prisma.customerCountArgs<ExtArgs>
            result: $Utils.Optional<CustomerCountAggregateOutputType> | number
          }
        }
      }
      customer_reader: {
        payload: Prisma.$customer_readerPayload<ExtArgs>
        fields: Prisma.customer_readerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.customer_readerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customer_readerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.customer_readerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customer_readerPayload>
          }
          findFirst: {
            args: Prisma.customer_readerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customer_readerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.customer_readerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customer_readerPayload>
          }
          findMany: {
            args: Prisma.customer_readerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customer_readerPayload>[]
          }
          create: {
            args: Prisma.customer_readerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customer_readerPayload>
          }
          createMany: {
            args: Prisma.customer_readerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.customer_readerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customer_readerPayload>[]
          }
          delete: {
            args: Prisma.customer_readerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customer_readerPayload>
          }
          update: {
            args: Prisma.customer_readerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customer_readerPayload>
          }
          deleteMany: {
            args: Prisma.customer_readerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.customer_readerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.customer_readerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customer_readerPayload>[]
          }
          upsert: {
            args: Prisma.customer_readerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customer_readerPayload>
          }
          aggregate: {
            args: Prisma.Customer_readerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustomer_reader>
          }
          groupBy: {
            args: Prisma.customer_readerGroupByArgs<ExtArgs>
            result: $Utils.Optional<Customer_readerGroupByOutputType>[]
          }
          count: {
            args: Prisma.customer_readerCountArgs<ExtArgs>
            result: $Utils.Optional<Customer_readerCountAggregateOutputType> | number
          }
        }
      }
      customer_track: {
        payload: Prisma.$customer_trackPayload<ExtArgs>
        fields: Prisma.customer_trackFieldRefs
        operations: {
          findUnique: {
            args: Prisma.customer_trackFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customer_trackPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.customer_trackFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customer_trackPayload>
          }
          findFirst: {
            args: Prisma.customer_trackFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customer_trackPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.customer_trackFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customer_trackPayload>
          }
          findMany: {
            args: Prisma.customer_trackFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customer_trackPayload>[]
          }
          create: {
            args: Prisma.customer_trackCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customer_trackPayload>
          }
          createMany: {
            args: Prisma.customer_trackCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.customer_trackCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customer_trackPayload>[]
          }
          delete: {
            args: Prisma.customer_trackDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customer_trackPayload>
          }
          update: {
            args: Prisma.customer_trackUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customer_trackPayload>
          }
          deleteMany: {
            args: Prisma.customer_trackDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.customer_trackUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.customer_trackUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customer_trackPayload>[]
          }
          upsert: {
            args: Prisma.customer_trackUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customer_trackPayload>
          }
          aggregate: {
            args: Prisma.Customer_trackAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustomer_track>
          }
          groupBy: {
            args: Prisma.customer_trackGroupByArgs<ExtArgs>
            result: $Utils.Optional<Customer_trackGroupByOutputType>[]
          }
          count: {
            args: Prisma.customer_trackCountArgs<ExtArgs>
            result: $Utils.Optional<Customer_trackCountAggregateOutputType> | number
          }
        }
      }
      genre: {
        payload: Prisma.$genrePayload<ExtArgs>
        fields: Prisma.genreFieldRefs
        operations: {
          findUnique: {
            args: Prisma.genreFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$genrePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.genreFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$genrePayload>
          }
          findFirst: {
            args: Prisma.genreFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$genrePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.genreFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$genrePayload>
          }
          findMany: {
            args: Prisma.genreFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$genrePayload>[]
          }
          create: {
            args: Prisma.genreCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$genrePayload>
          }
          createMany: {
            args: Prisma.genreCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.genreCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$genrePayload>[]
          }
          delete: {
            args: Prisma.genreDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$genrePayload>
          }
          update: {
            args: Prisma.genreUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$genrePayload>
          }
          deleteMany: {
            args: Prisma.genreDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.genreUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.genreUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$genrePayload>[]
          }
          upsert: {
            args: Prisma.genreUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$genrePayload>
          }
          aggregate: {
            args: Prisma.GenreAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGenre>
          }
          groupBy: {
            args: Prisma.genreGroupByArgs<ExtArgs>
            result: $Utils.Optional<GenreGroupByOutputType>[]
          }
          count: {
            args: Prisma.genreCountArgs<ExtArgs>
            result: $Utils.Optional<GenreCountAggregateOutputType> | number
          }
        }
      }
      internal: {
        payload: Prisma.$internalPayload<ExtArgs>
        fields: Prisma.internalFieldRefs
        operations: {
          findUnique: {
            args: Prisma.internalFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$internalPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.internalFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$internalPayload>
          }
          findFirst: {
            args: Prisma.internalFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$internalPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.internalFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$internalPayload>
          }
          findMany: {
            args: Prisma.internalFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$internalPayload>[]
          }
          create: {
            args: Prisma.internalCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$internalPayload>
          }
          createMany: {
            args: Prisma.internalCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.internalCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$internalPayload>[]
          }
          delete: {
            args: Prisma.internalDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$internalPayload>
          }
          update: {
            args: Prisma.internalUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$internalPayload>
          }
          deleteMany: {
            args: Prisma.internalDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.internalUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.internalUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$internalPayload>[]
          }
          upsert: {
            args: Prisma.internalUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$internalPayload>
          }
          aggregate: {
            args: Prisma.InternalAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInternal>
          }
          groupBy: {
            args: Prisma.internalGroupByArgs<ExtArgs>
            result: $Utils.Optional<InternalGroupByOutputType>[]
          }
          count: {
            args: Prisma.internalCountArgs<ExtArgs>
            result: $Utils.Optional<InternalCountAggregateOutputType> | number
          }
        }
      }
      landing: {
        payload: Prisma.$landingPayload<ExtArgs>
        fields: Prisma.landingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.landingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$landingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.landingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$landingPayload>
          }
          findFirst: {
            args: Prisma.landingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$landingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.landingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$landingPayload>
          }
          findMany: {
            args: Prisma.landingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$landingPayload>[]
          }
          create: {
            args: Prisma.landingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$landingPayload>
          }
          createMany: {
            args: Prisma.landingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.landingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$landingPayload>[]
          }
          delete: {
            args: Prisma.landingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$landingPayload>
          }
          update: {
            args: Prisma.landingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$landingPayload>
          }
          deleteMany: {
            args: Prisma.landingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.landingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.landingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$landingPayload>[]
          }
          upsert: {
            args: Prisma.landingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$landingPayload>
          }
          aggregate: {
            args: Prisma.LandingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLanding>
          }
          groupBy: {
            args: Prisma.landingGroupByArgs<ExtArgs>
            result: $Utils.Optional<LandingGroupByOutputType>[]
          }
          count: {
            args: Prisma.landingCountArgs<ExtArgs>
            result: $Utils.Optional<LandingCountAggregateOutputType> | number
          }
        }
      }
      landing_items: {
        payload: Prisma.$landing_itemsPayload<ExtArgs>
        fields: Prisma.landing_itemsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.landing_itemsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$landing_itemsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.landing_itemsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$landing_itemsPayload>
          }
          findFirst: {
            args: Prisma.landing_itemsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$landing_itemsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.landing_itemsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$landing_itemsPayload>
          }
          findMany: {
            args: Prisma.landing_itemsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$landing_itemsPayload>[]
          }
          create: {
            args: Prisma.landing_itemsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$landing_itemsPayload>
          }
          createMany: {
            args: Prisma.landing_itemsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.landing_itemsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$landing_itemsPayload>[]
          }
          delete: {
            args: Prisma.landing_itemsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$landing_itemsPayload>
          }
          update: {
            args: Prisma.landing_itemsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$landing_itemsPayload>
          }
          deleteMany: {
            args: Prisma.landing_itemsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.landing_itemsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.landing_itemsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$landing_itemsPayload>[]
          }
          upsert: {
            args: Prisma.landing_itemsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$landing_itemsPayload>
          }
          aggregate: {
            args: Prisma.Landing_itemsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLanding_items>
          }
          groupBy: {
            args: Prisma.landing_itemsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Landing_itemsGroupByOutputType>[]
          }
          count: {
            args: Prisma.landing_itemsCountArgs<ExtArgs>
            result: $Utils.Optional<Landing_itemsCountAggregateOutputType> | number
          }
        }
      }
      midtrx: {
        payload: Prisma.$midtrxPayload<ExtArgs>
        fields: Prisma.midtrxFieldRefs
        operations: {
          findUnique: {
            args: Prisma.midtrxFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$midtrxPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.midtrxFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$midtrxPayload>
          }
          findFirst: {
            args: Prisma.midtrxFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$midtrxPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.midtrxFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$midtrxPayload>
          }
          findMany: {
            args: Prisma.midtrxFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$midtrxPayload>[]
          }
          create: {
            args: Prisma.midtrxCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$midtrxPayload>
          }
          createMany: {
            args: Prisma.midtrxCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.midtrxCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$midtrxPayload>[]
          }
          delete: {
            args: Prisma.midtrxDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$midtrxPayload>
          }
          update: {
            args: Prisma.midtrxUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$midtrxPayload>
          }
          deleteMany: {
            args: Prisma.midtrxDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.midtrxUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.midtrxUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$midtrxPayload>[]
          }
          upsert: {
            args: Prisma.midtrxUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$midtrxPayload>
          }
          aggregate: {
            args: Prisma.MidtrxAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMidtrx>
          }
          groupBy: {
            args: Prisma.midtrxGroupByArgs<ExtArgs>
            result: $Utils.Optional<MidtrxGroupByOutputType>[]
          }
          count: {
            args: Prisma.midtrxCountArgs<ExtArgs>
            result: $Utils.Optional<MidtrxCountAggregateOutputType> | number
          }
        }
      }
      preorder: {
        payload: Prisma.$preorderPayload<ExtArgs>
        fields: Prisma.preorderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.preorderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$preorderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.preorderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$preorderPayload>
          }
          findFirst: {
            args: Prisma.preorderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$preorderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.preorderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$preorderPayload>
          }
          findMany: {
            args: Prisma.preorderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$preorderPayload>[]
          }
          create: {
            args: Prisma.preorderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$preorderPayload>
          }
          createMany: {
            args: Prisma.preorderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.preorderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$preorderPayload>[]
          }
          delete: {
            args: Prisma.preorderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$preorderPayload>
          }
          update: {
            args: Prisma.preorderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$preorderPayload>
          }
          deleteMany: {
            args: Prisma.preorderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.preorderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.preorderUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$preorderPayload>[]
          }
          upsert: {
            args: Prisma.preorderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$preorderPayload>
          }
          aggregate: {
            args: Prisma.PreorderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePreorder>
          }
          groupBy: {
            args: Prisma.preorderGroupByArgs<ExtArgs>
            result: $Utils.Optional<PreorderGroupByOutputType>[]
          }
          count: {
            args: Prisma.preorderCountArgs<ExtArgs>
            result: $Utils.Optional<PreorderCountAggregateOutputType> | number
          }
        }
      }
      product: {
        payload: Prisma.$productPayload<ExtArgs>
        fields: Prisma.productFieldRefs
        operations: {
          findUnique: {
            args: Prisma.productFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.productFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productPayload>
          }
          findFirst: {
            args: Prisma.productFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.productFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productPayload>
          }
          findMany: {
            args: Prisma.productFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productPayload>[]
          }
          create: {
            args: Prisma.productCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productPayload>
          }
          createMany: {
            args: Prisma.productCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.productCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productPayload>[]
          }
          delete: {
            args: Prisma.productDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productPayload>
          }
          update: {
            args: Prisma.productUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productPayload>
          }
          deleteMany: {
            args: Prisma.productDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.productUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.productUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productPayload>[]
          }
          upsert: {
            args: Prisma.productUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productPayload>
          }
          aggregate: {
            args: Prisma.ProductAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProduct>
          }
          groupBy: {
            args: Prisma.productGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductGroupByOutputType>[]
          }
          count: {
            args: Prisma.productCountArgs<ExtArgs>
            result: $Utils.Optional<ProductCountAggregateOutputType> | number
          }
        }
      }
      product_category: {
        payload: Prisma.$product_categoryPayload<ExtArgs>
        fields: Prisma.product_categoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.product_categoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$product_categoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.product_categoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$product_categoryPayload>
          }
          findFirst: {
            args: Prisma.product_categoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$product_categoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.product_categoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$product_categoryPayload>
          }
          findMany: {
            args: Prisma.product_categoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$product_categoryPayload>[]
          }
          create: {
            args: Prisma.product_categoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$product_categoryPayload>
          }
          createMany: {
            args: Prisma.product_categoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.product_categoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$product_categoryPayload>[]
          }
          delete: {
            args: Prisma.product_categoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$product_categoryPayload>
          }
          update: {
            args: Prisma.product_categoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$product_categoryPayload>
          }
          deleteMany: {
            args: Prisma.product_categoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.product_categoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.product_categoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$product_categoryPayload>[]
          }
          upsert: {
            args: Prisma.product_categoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$product_categoryPayload>
          }
          aggregate: {
            args: Prisma.Product_categoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProduct_category>
          }
          groupBy: {
            args: Prisma.product_categoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<Product_categoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.product_categoryCountArgs<ExtArgs>
            result: $Utils.Optional<Product_categoryCountAggregateOutputType> | number
          }
        }
      }
      promo_code: {
        payload: Prisma.$promo_codePayload<ExtArgs>
        fields: Prisma.promo_codeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.promo_codeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$promo_codePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.promo_codeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$promo_codePayload>
          }
          findFirst: {
            args: Prisma.promo_codeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$promo_codePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.promo_codeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$promo_codePayload>
          }
          findMany: {
            args: Prisma.promo_codeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$promo_codePayload>[]
          }
          create: {
            args: Prisma.promo_codeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$promo_codePayload>
          }
          createMany: {
            args: Prisma.promo_codeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.promo_codeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$promo_codePayload>[]
          }
          delete: {
            args: Prisma.promo_codeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$promo_codePayload>
          }
          update: {
            args: Prisma.promo_codeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$promo_codePayload>
          }
          deleteMany: {
            args: Prisma.promo_codeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.promo_codeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.promo_codeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$promo_codePayload>[]
          }
          upsert: {
            args: Prisma.promo_codeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$promo_codePayload>
          }
          aggregate: {
            args: Prisma.Promo_codeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePromo_code>
          }
          groupBy: {
            args: Prisma.promo_codeGroupByArgs<ExtArgs>
            result: $Utils.Optional<Promo_codeGroupByOutputType>[]
          }
          count: {
            args: Prisma.promo_codeCountArgs<ExtArgs>
            result: $Utils.Optional<Promo_codeCountAggregateOutputType> | number
          }
        }
      }
      publisher: {
        payload: Prisma.$publisherPayload<ExtArgs>
        fields: Prisma.publisherFieldRefs
        operations: {
          findUnique: {
            args: Prisma.publisherFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$publisherPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.publisherFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$publisherPayload>
          }
          findFirst: {
            args: Prisma.publisherFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$publisherPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.publisherFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$publisherPayload>
          }
          findMany: {
            args: Prisma.publisherFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$publisherPayload>[]
          }
          create: {
            args: Prisma.publisherCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$publisherPayload>
          }
          createMany: {
            args: Prisma.publisherCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.publisherCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$publisherPayload>[]
          }
          delete: {
            args: Prisma.publisherDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$publisherPayload>
          }
          update: {
            args: Prisma.publisherUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$publisherPayload>
          }
          deleteMany: {
            args: Prisma.publisherDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.publisherUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.publisherUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$publisherPayload>[]
          }
          upsert: {
            args: Prisma.publisherUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$publisherPayload>
          }
          aggregate: {
            args: Prisma.PublisherAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePublisher>
          }
          groupBy: {
            args: Prisma.publisherGroupByArgs<ExtArgs>
            result: $Utils.Optional<PublisherGroupByOutputType>[]
          }
          count: {
            args: Prisma.publisherCountArgs<ExtArgs>
            result: $Utils.Optional<PublisherCountAggregateOutputType> | number
          }
        }
      }
      publisher_author: {
        payload: Prisma.$publisher_authorPayload<ExtArgs>
        fields: Prisma.publisher_authorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.publisher_authorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$publisher_authorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.publisher_authorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$publisher_authorPayload>
          }
          findFirst: {
            args: Prisma.publisher_authorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$publisher_authorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.publisher_authorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$publisher_authorPayload>
          }
          findMany: {
            args: Prisma.publisher_authorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$publisher_authorPayload>[]
          }
          create: {
            args: Prisma.publisher_authorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$publisher_authorPayload>
          }
          createMany: {
            args: Prisma.publisher_authorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.publisher_authorCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$publisher_authorPayload>[]
          }
          delete: {
            args: Prisma.publisher_authorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$publisher_authorPayload>
          }
          update: {
            args: Prisma.publisher_authorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$publisher_authorPayload>
          }
          deleteMany: {
            args: Prisma.publisher_authorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.publisher_authorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.publisher_authorUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$publisher_authorPayload>[]
          }
          upsert: {
            args: Prisma.publisher_authorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$publisher_authorPayload>
          }
          aggregate: {
            args: Prisma.Publisher_authorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePublisher_author>
          }
          groupBy: {
            args: Prisma.publisher_authorGroupByArgs<ExtArgs>
            result: $Utils.Optional<Publisher_authorGroupByOutputType>[]
          }
          count: {
            args: Prisma.publisher_authorCountArgs<ExtArgs>
            result: $Utils.Optional<Publisher_authorCountAggregateOutputType> | number
          }
        }
      }
      ranking: {
        payload: Prisma.$rankingPayload<ExtArgs>
        fields: Prisma.rankingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.rankingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rankingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.rankingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rankingPayload>
          }
          findFirst: {
            args: Prisma.rankingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rankingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.rankingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rankingPayload>
          }
          findMany: {
            args: Prisma.rankingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rankingPayload>[]
          }
          create: {
            args: Prisma.rankingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rankingPayload>
          }
          createMany: {
            args: Prisma.rankingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.rankingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rankingPayload>[]
          }
          delete: {
            args: Prisma.rankingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rankingPayload>
          }
          update: {
            args: Prisma.rankingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rankingPayload>
          }
          deleteMany: {
            args: Prisma.rankingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.rankingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.rankingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rankingPayload>[]
          }
          upsert: {
            args: Prisma.rankingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rankingPayload>
          }
          aggregate: {
            args: Prisma.RankingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRanking>
          }
          groupBy: {
            args: Prisma.rankingGroupByArgs<ExtArgs>
            result: $Utils.Optional<RankingGroupByOutputType>[]
          }
          count: {
            args: Prisma.rankingCountArgs<ExtArgs>
            result: $Utils.Optional<RankingCountAggregateOutputType> | number
          }
        }
      }
      reviews: {
        payload: Prisma.$reviewsPayload<ExtArgs>
        fields: Prisma.reviewsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.reviewsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reviewsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.reviewsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reviewsPayload>
          }
          findFirst: {
            args: Prisma.reviewsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reviewsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.reviewsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reviewsPayload>
          }
          findMany: {
            args: Prisma.reviewsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reviewsPayload>[]
          }
          create: {
            args: Prisma.reviewsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reviewsPayload>
          }
          createMany: {
            args: Prisma.reviewsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.reviewsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reviewsPayload>[]
          }
          delete: {
            args: Prisma.reviewsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reviewsPayload>
          }
          update: {
            args: Prisma.reviewsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reviewsPayload>
          }
          deleteMany: {
            args: Prisma.reviewsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.reviewsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.reviewsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reviewsPayload>[]
          }
          upsert: {
            args: Prisma.reviewsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reviewsPayload>
          }
          aggregate: {
            args: Prisma.ReviewsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReviews>
          }
          groupBy: {
            args: Prisma.reviewsGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReviewsGroupByOutputType>[]
          }
          count: {
            args: Prisma.reviewsCountArgs<ExtArgs>
            result: $Utils.Optional<ReviewsCountAggregateOutputType> | number
          }
        }
      }
      reviews_likes: {
        payload: Prisma.$reviews_likesPayload<ExtArgs>
        fields: Prisma.reviews_likesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.reviews_likesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reviews_likesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.reviews_likesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reviews_likesPayload>
          }
          findFirst: {
            args: Prisma.reviews_likesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reviews_likesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.reviews_likesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reviews_likesPayload>
          }
          findMany: {
            args: Prisma.reviews_likesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reviews_likesPayload>[]
          }
          create: {
            args: Prisma.reviews_likesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reviews_likesPayload>
          }
          createMany: {
            args: Prisma.reviews_likesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.reviews_likesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reviews_likesPayload>[]
          }
          delete: {
            args: Prisma.reviews_likesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reviews_likesPayload>
          }
          update: {
            args: Prisma.reviews_likesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reviews_likesPayload>
          }
          deleteMany: {
            args: Prisma.reviews_likesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.reviews_likesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.reviews_likesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reviews_likesPayload>[]
          }
          upsert: {
            args: Prisma.reviews_likesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reviews_likesPayload>
          }
          aggregate: {
            args: Prisma.Reviews_likesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReviews_likes>
          }
          groupBy: {
            args: Prisma.reviews_likesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Reviews_likesGroupByOutputType>[]
          }
          count: {
            args: Prisma.reviews_likesCountArgs<ExtArgs>
            result: $Utils.Optional<Reviews_likesCountAggregateOutputType> | number
          }
        }
      }
      t_ai_credit: {
        payload: Prisma.$t_ai_creditPayload<ExtArgs>
        fields: Prisma.t_ai_creditFieldRefs
        operations: {
          findUnique: {
            args: Prisma.t_ai_creditFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$t_ai_creditPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.t_ai_creditFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$t_ai_creditPayload>
          }
          findFirst: {
            args: Prisma.t_ai_creditFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$t_ai_creditPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.t_ai_creditFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$t_ai_creditPayload>
          }
          findMany: {
            args: Prisma.t_ai_creditFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$t_ai_creditPayload>[]
          }
          create: {
            args: Prisma.t_ai_creditCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$t_ai_creditPayload>
          }
          createMany: {
            args: Prisma.t_ai_creditCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.t_ai_creditCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$t_ai_creditPayload>[]
          }
          delete: {
            args: Prisma.t_ai_creditDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$t_ai_creditPayload>
          }
          update: {
            args: Prisma.t_ai_creditUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$t_ai_creditPayload>
          }
          deleteMany: {
            args: Prisma.t_ai_creditDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.t_ai_creditUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.t_ai_creditUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$t_ai_creditPayload>[]
          }
          upsert: {
            args: Prisma.t_ai_creditUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$t_ai_creditPayload>
          }
          aggregate: {
            args: Prisma.T_ai_creditAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateT_ai_credit>
          }
          groupBy: {
            args: Prisma.t_ai_creditGroupByArgs<ExtArgs>
            result: $Utils.Optional<T_ai_creditGroupByOutputType>[]
          }
          count: {
            args: Prisma.t_ai_creditCountArgs<ExtArgs>
            result: $Utils.Optional<T_ai_creditCountAggregateOutputType> | number
          }
        }
      }
      t_ai_credit_topup: {
        payload: Prisma.$t_ai_credit_topupPayload<ExtArgs>
        fields: Prisma.t_ai_credit_topupFieldRefs
        operations: {
          findUnique: {
            args: Prisma.t_ai_credit_topupFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$t_ai_credit_topupPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.t_ai_credit_topupFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$t_ai_credit_topupPayload>
          }
          findFirst: {
            args: Prisma.t_ai_credit_topupFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$t_ai_credit_topupPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.t_ai_credit_topupFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$t_ai_credit_topupPayload>
          }
          findMany: {
            args: Prisma.t_ai_credit_topupFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$t_ai_credit_topupPayload>[]
          }
          create: {
            args: Prisma.t_ai_credit_topupCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$t_ai_credit_topupPayload>
          }
          createMany: {
            args: Prisma.t_ai_credit_topupCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.t_ai_credit_topupCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$t_ai_credit_topupPayload>[]
          }
          delete: {
            args: Prisma.t_ai_credit_topupDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$t_ai_credit_topupPayload>
          }
          update: {
            args: Prisma.t_ai_credit_topupUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$t_ai_credit_topupPayload>
          }
          deleteMany: {
            args: Prisma.t_ai_credit_topupDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.t_ai_credit_topupUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.t_ai_credit_topupUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$t_ai_credit_topupPayload>[]
          }
          upsert: {
            args: Prisma.t_ai_credit_topupUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$t_ai_credit_topupPayload>
          }
          aggregate: {
            args: Prisma.T_ai_credit_topupAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateT_ai_credit_topup>
          }
          groupBy: {
            args: Prisma.t_ai_credit_topupGroupByArgs<ExtArgs>
            result: $Utils.Optional<T_ai_credit_topupGroupByOutputType>[]
          }
          count: {
            args: Prisma.t_ai_credit_topupCountArgs<ExtArgs>
            result: $Utils.Optional<T_ai_credit_topupCountAggregateOutputType> | number
          }
        }
      }
      t_sales: {
        payload: Prisma.$t_salesPayload<ExtArgs>
        fields: Prisma.t_salesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.t_salesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$t_salesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.t_salesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$t_salesPayload>
          }
          findFirst: {
            args: Prisma.t_salesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$t_salesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.t_salesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$t_salesPayload>
          }
          findMany: {
            args: Prisma.t_salesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$t_salesPayload>[]
          }
          create: {
            args: Prisma.t_salesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$t_salesPayload>
          }
          createMany: {
            args: Prisma.t_salesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.t_salesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$t_salesPayload>[]
          }
          delete: {
            args: Prisma.t_salesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$t_salesPayload>
          }
          update: {
            args: Prisma.t_salesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$t_salesPayload>
          }
          deleteMany: {
            args: Prisma.t_salesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.t_salesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.t_salesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$t_salesPayload>[]
          }
          upsert: {
            args: Prisma.t_salesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$t_salesPayload>
          }
          aggregate: {
            args: Prisma.T_salesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateT_sales>
          }
          groupBy: {
            args: Prisma.t_salesGroupByArgs<ExtArgs>
            result: $Utils.Optional<T_salesGroupByOutputType>[]
          }
          count: {
            args: Prisma.t_salesCountArgs<ExtArgs>
            result: $Utils.Optional<T_salesCountAggregateOutputType> | number
          }
        }
      }
      t_sales_download: {
        payload: Prisma.$t_sales_downloadPayload<ExtArgs>
        fields: Prisma.t_sales_downloadFieldRefs
        operations: {
          findUnique: {
            args: Prisma.t_sales_downloadFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$t_sales_downloadPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.t_sales_downloadFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$t_sales_downloadPayload>
          }
          findFirst: {
            args: Prisma.t_sales_downloadFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$t_sales_downloadPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.t_sales_downloadFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$t_sales_downloadPayload>
          }
          findMany: {
            args: Prisma.t_sales_downloadFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$t_sales_downloadPayload>[]
          }
          create: {
            args: Prisma.t_sales_downloadCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$t_sales_downloadPayload>
          }
          createMany: {
            args: Prisma.t_sales_downloadCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.t_sales_downloadCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$t_sales_downloadPayload>[]
          }
          delete: {
            args: Prisma.t_sales_downloadDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$t_sales_downloadPayload>
          }
          update: {
            args: Prisma.t_sales_downloadUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$t_sales_downloadPayload>
          }
          deleteMany: {
            args: Prisma.t_sales_downloadDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.t_sales_downloadUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.t_sales_downloadUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$t_sales_downloadPayload>[]
          }
          upsert: {
            args: Prisma.t_sales_downloadUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$t_sales_downloadPayload>
          }
          aggregate: {
            args: Prisma.T_sales_downloadAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateT_sales_download>
          }
          groupBy: {
            args: Prisma.t_sales_downloadGroupByArgs<ExtArgs>
            result: $Utils.Optional<T_sales_downloadGroupByOutputType>[]
          }
          count: {
            args: Prisma.t_sales_downloadCountArgs<ExtArgs>
            result: $Utils.Optional<T_sales_downloadCountAggregateOutputType> | number
          }
        }
      }
      t_sales_line: {
        payload: Prisma.$t_sales_linePayload<ExtArgs>
        fields: Prisma.t_sales_lineFieldRefs
        operations: {
          findUnique: {
            args: Prisma.t_sales_lineFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$t_sales_linePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.t_sales_lineFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$t_sales_linePayload>
          }
          findFirst: {
            args: Prisma.t_sales_lineFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$t_sales_linePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.t_sales_lineFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$t_sales_linePayload>
          }
          findMany: {
            args: Prisma.t_sales_lineFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$t_sales_linePayload>[]
          }
          create: {
            args: Prisma.t_sales_lineCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$t_sales_linePayload>
          }
          createMany: {
            args: Prisma.t_sales_lineCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.t_sales_lineCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$t_sales_linePayload>[]
          }
          delete: {
            args: Prisma.t_sales_lineDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$t_sales_linePayload>
          }
          update: {
            args: Prisma.t_sales_lineUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$t_sales_linePayload>
          }
          deleteMany: {
            args: Prisma.t_sales_lineDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.t_sales_lineUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.t_sales_lineUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$t_sales_linePayload>[]
          }
          upsert: {
            args: Prisma.t_sales_lineUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$t_sales_linePayload>
          }
          aggregate: {
            args: Prisma.T_sales_lineAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateT_sales_line>
          }
          groupBy: {
            args: Prisma.t_sales_lineGroupByArgs<ExtArgs>
            result: $Utils.Optional<T_sales_lineGroupByOutputType>[]
          }
          count: {
            args: Prisma.t_sales_lineCountArgs<ExtArgs>
            result: $Utils.Optional<T_sales_lineCountAggregateOutputType> | number
          }
        }
      }
      tags: {
        payload: Prisma.$tagsPayload<ExtArgs>
        fields: Prisma.tagsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.tagsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tagsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.tagsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tagsPayload>
          }
          findFirst: {
            args: Prisma.tagsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tagsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.tagsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tagsPayload>
          }
          findMany: {
            args: Prisma.tagsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tagsPayload>[]
          }
          create: {
            args: Prisma.tagsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tagsPayload>
          }
          createMany: {
            args: Prisma.tagsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.tagsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tagsPayload>[]
          }
          delete: {
            args: Prisma.tagsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tagsPayload>
          }
          update: {
            args: Prisma.tagsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tagsPayload>
          }
          deleteMany: {
            args: Prisma.tagsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.tagsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.tagsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tagsPayload>[]
          }
          upsert: {
            args: Prisma.tagsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tagsPayload>
          }
          aggregate: {
            args: Prisma.TagsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTags>
          }
          groupBy: {
            args: Prisma.tagsGroupByArgs<ExtArgs>
            result: $Utils.Optional<TagsGroupByOutputType>[]
          }
          count: {
            args: Prisma.tagsCountArgs<ExtArgs>
            result: $Utils.Optional<TagsCountAggregateOutputType> | number
          }
        }
      }
      transaction: {
        payload: Prisma.$transactionPayload<ExtArgs>
        fields: Prisma.transactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.transactionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.transactionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transactionPayload>
          }
          findFirst: {
            args: Prisma.transactionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.transactionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transactionPayload>
          }
          findMany: {
            args: Prisma.transactionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transactionPayload>[]
          }
          create: {
            args: Prisma.transactionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transactionPayload>
          }
          createMany: {
            args: Prisma.transactionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.transactionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transactionPayload>[]
          }
          delete: {
            args: Prisma.transactionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transactionPayload>
          }
          update: {
            args: Prisma.transactionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transactionPayload>
          }
          deleteMany: {
            args: Prisma.transactionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.transactionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.transactionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transactionPayload>[]
          }
          upsert: {
            args: Prisma.transactionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transactionPayload>
          }
          aggregate: {
            args: Prisma.TransactionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTransaction>
          }
          groupBy: {
            args: Prisma.transactionGroupByArgs<ExtArgs>
            result: $Utils.Optional<TransactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.transactionCountArgs<ExtArgs>
            result: $Utils.Optional<TransactionCountAggregateOutputType> | number
          }
        }
      }
      withdrawal: {
        payload: Prisma.$withdrawalPayload<ExtArgs>
        fields: Prisma.withdrawalFieldRefs
        operations: {
          findUnique: {
            args: Prisma.withdrawalFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$withdrawalPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.withdrawalFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$withdrawalPayload>
          }
          findFirst: {
            args: Prisma.withdrawalFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$withdrawalPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.withdrawalFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$withdrawalPayload>
          }
          findMany: {
            args: Prisma.withdrawalFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$withdrawalPayload>[]
          }
          create: {
            args: Prisma.withdrawalCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$withdrawalPayload>
          }
          createMany: {
            args: Prisma.withdrawalCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.withdrawalCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$withdrawalPayload>[]
          }
          delete: {
            args: Prisma.withdrawalDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$withdrawalPayload>
          }
          update: {
            args: Prisma.withdrawalUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$withdrawalPayload>
          }
          deleteMany: {
            args: Prisma.withdrawalDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.withdrawalUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.withdrawalUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$withdrawalPayload>[]
          }
          upsert: {
            args: Prisma.withdrawalUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$withdrawalPayload>
          }
          aggregate: {
            args: Prisma.WithdrawalAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWithdrawal>
          }
          groupBy: {
            args: Prisma.withdrawalGroupByArgs<ExtArgs>
            result: $Utils.Optional<WithdrawalGroupByOutputType>[]
          }
          count: {
            args: Prisma.withdrawalCountArgs<ExtArgs>
            result: $Utils.Optional<WithdrawalCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    affiliate?: affiliateOmit
    auth_account?: auth_accountOmit
    auth_session?: auth_sessionOmit
    auth_two_factor?: auth_two_factorOmit
    auth_user?: auth_userOmit
    auth_verification?: auth_verificationOmit
    author?: authorOmit
    banner?: bannerOmit
    book?: bookOmit
    book_approval?: book_approvalOmit
    book_changes_log?: book_changes_logOmit
    book_genre?: book_genreOmit
    book_tags?: book_tagsOmit
    bundle?: bundleOmit
    bundle_category?: bundle_categoryOmit
    bundle_product?: bundle_productOmit
    category?: categoryOmit
    chapter?: chapterOmit
    customer?: customerOmit
    customer_reader?: customer_readerOmit
    customer_track?: customer_trackOmit
    genre?: genreOmit
    internal?: internalOmit
    landing?: landingOmit
    landing_items?: landing_itemsOmit
    midtrx?: midtrxOmit
    preorder?: preorderOmit
    product?: productOmit
    product_category?: product_categoryOmit
    promo_code?: promo_codeOmit
    publisher?: publisherOmit
    publisher_author?: publisher_authorOmit
    ranking?: rankingOmit
    reviews?: reviewsOmit
    reviews_likes?: reviews_likesOmit
    t_ai_credit?: t_ai_creditOmit
    t_ai_credit_topup?: t_ai_credit_topupOmit
    t_sales?: t_salesOmit
    t_sales_download?: t_sales_downloadOmit
    t_sales_line?: t_sales_lineOmit
    tags?: tagsOmit
    transaction?: transactionOmit
    withdrawal?: withdrawalOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type AffiliateCountOutputType
   */

  export type AffiliateCountOutputType = {
    auth_user: number
  }

  export type AffiliateCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    auth_user?: boolean | AffiliateCountOutputTypeCountAuth_userArgs
  }

  // Custom InputTypes
  /**
   * AffiliateCountOutputType without action
   */
  export type AffiliateCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliateCountOutputType
     */
    select?: AffiliateCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AffiliateCountOutputType without action
   */
  export type AffiliateCountOutputTypeCountAuth_userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: auth_userWhereInput
  }


  /**
   * Count Type Auth_accountCountOutputType
   */

  export type Auth_accountCountOutputType = {
    affiliate: number
    author: number
    customer: number
    internal: number
    publisher: number
  }

  export type Auth_accountCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    affiliate?: boolean | Auth_accountCountOutputTypeCountAffiliateArgs
    author?: boolean | Auth_accountCountOutputTypeCountAuthorArgs
    customer?: boolean | Auth_accountCountOutputTypeCountCustomerArgs
    internal?: boolean | Auth_accountCountOutputTypeCountInternalArgs
    publisher?: boolean | Auth_accountCountOutputTypeCountPublisherArgs
  }

  // Custom InputTypes
  /**
   * Auth_accountCountOutputType without action
   */
  export type Auth_accountCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Auth_accountCountOutputType
     */
    select?: Auth_accountCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Auth_accountCountOutputType without action
   */
  export type Auth_accountCountOutputTypeCountAffiliateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: affiliateWhereInput
  }

  /**
   * Auth_accountCountOutputType without action
   */
  export type Auth_accountCountOutputTypeCountAuthorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: authorWhereInput
  }

  /**
   * Auth_accountCountOutputType without action
   */
  export type Auth_accountCountOutputTypeCountCustomerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: customerWhereInput
  }

  /**
   * Auth_accountCountOutputType without action
   */
  export type Auth_accountCountOutputTypeCountInternalArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: internalWhereInput
  }

  /**
   * Auth_accountCountOutputType without action
   */
  export type Auth_accountCountOutputTypeCountPublisherArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: publisherWhereInput
  }


  /**
   * Count Type Auth_userCountOutputType
   */

  export type Auth_userCountOutputType = {
    auth_account: number
    auth_session: number
    auth_two_factor: number
    reviews: number
    reviews_likes: number
  }

  export type Auth_userCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    auth_account?: boolean | Auth_userCountOutputTypeCountAuth_accountArgs
    auth_session?: boolean | Auth_userCountOutputTypeCountAuth_sessionArgs
    auth_two_factor?: boolean | Auth_userCountOutputTypeCountAuth_two_factorArgs
    reviews?: boolean | Auth_userCountOutputTypeCountReviewsArgs
    reviews_likes?: boolean | Auth_userCountOutputTypeCountReviews_likesArgs
  }

  // Custom InputTypes
  /**
   * Auth_userCountOutputType without action
   */
  export type Auth_userCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Auth_userCountOutputType
     */
    select?: Auth_userCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Auth_userCountOutputType without action
   */
  export type Auth_userCountOutputTypeCountAuth_accountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: auth_accountWhereInput
  }

  /**
   * Auth_userCountOutputType without action
   */
  export type Auth_userCountOutputTypeCountAuth_sessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: auth_sessionWhereInput
  }

  /**
   * Auth_userCountOutputType without action
   */
  export type Auth_userCountOutputTypeCountAuth_two_factorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: auth_two_factorWhereInput
  }

  /**
   * Auth_userCountOutputType without action
   */
  export type Auth_userCountOutputTypeCountReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: reviewsWhereInput
  }

  /**
   * Auth_userCountOutputType without action
   */
  export type Auth_userCountOutputTypeCountReviews_likesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: reviews_likesWhereInput
  }


  /**
   * Count Type AuthorCountOutputType
   */

  export type AuthorCountOutputType = {
    auth_user: number
    book: number
    product: number
    publisher_author: number
  }

  export type AuthorCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    auth_user?: boolean | AuthorCountOutputTypeCountAuth_userArgs
    book?: boolean | AuthorCountOutputTypeCountBookArgs
    product?: boolean | AuthorCountOutputTypeCountProductArgs
    publisher_author?: boolean | AuthorCountOutputTypeCountPublisher_authorArgs
  }

  // Custom InputTypes
  /**
   * AuthorCountOutputType without action
   */
  export type AuthorCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuthorCountOutputType
     */
    select?: AuthorCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AuthorCountOutputType without action
   */
  export type AuthorCountOutputTypeCountAuth_userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: auth_userWhereInput
  }

  /**
   * AuthorCountOutputType without action
   */
  export type AuthorCountOutputTypeCountBookArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: bookWhereInput
  }

  /**
   * AuthorCountOutputType without action
   */
  export type AuthorCountOutputTypeCountProductArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: productWhereInput
  }

  /**
   * AuthorCountOutputType without action
   */
  export type AuthorCountOutputTypeCountPublisher_authorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: publisher_authorWhereInput
  }


  /**
   * Count Type BookCountOutputType
   */

  export type BookCountOutputType = {
    book_approval: number
    book_changes_log: number
    book_genre: number
    book_tags: number
    chapter: number
    ranking: number
    reviews: number
  }

  export type BookCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    book_approval?: boolean | BookCountOutputTypeCountBook_approvalArgs
    book_changes_log?: boolean | BookCountOutputTypeCountBook_changes_logArgs
    book_genre?: boolean | BookCountOutputTypeCountBook_genreArgs
    book_tags?: boolean | BookCountOutputTypeCountBook_tagsArgs
    chapter?: boolean | BookCountOutputTypeCountChapterArgs
    ranking?: boolean | BookCountOutputTypeCountRankingArgs
    reviews?: boolean | BookCountOutputTypeCountReviewsArgs
  }

  // Custom InputTypes
  /**
   * BookCountOutputType without action
   */
  export type BookCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookCountOutputType
     */
    select?: BookCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BookCountOutputType without action
   */
  export type BookCountOutputTypeCountBook_approvalArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: book_approvalWhereInput
  }

  /**
   * BookCountOutputType without action
   */
  export type BookCountOutputTypeCountBook_changes_logArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: book_changes_logWhereInput
  }

  /**
   * BookCountOutputType without action
   */
  export type BookCountOutputTypeCountBook_genreArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: book_genreWhereInput
  }

  /**
   * BookCountOutputType without action
   */
  export type BookCountOutputTypeCountBook_tagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: book_tagsWhereInput
  }

  /**
   * BookCountOutputType without action
   */
  export type BookCountOutputTypeCountChapterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: chapterWhereInput
  }

  /**
   * BookCountOutputType without action
   */
  export type BookCountOutputTypeCountRankingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: rankingWhereInput
  }

  /**
   * BookCountOutputType without action
   */
  export type BookCountOutputTypeCountReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: reviewsWhereInput
  }


  /**
   * Count Type BundleCountOutputType
   */

  export type BundleCountOutputType = {
    bundle_category: number
    bundle_product: number
    t_sales_line: number
  }

  export type BundleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bundle_category?: boolean | BundleCountOutputTypeCountBundle_categoryArgs
    bundle_product?: boolean | BundleCountOutputTypeCountBundle_productArgs
    t_sales_line?: boolean | BundleCountOutputTypeCountT_sales_lineArgs
  }

  // Custom InputTypes
  /**
   * BundleCountOutputType without action
   */
  export type BundleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BundleCountOutputType
     */
    select?: BundleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BundleCountOutputType without action
   */
  export type BundleCountOutputTypeCountBundle_categoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: bundle_categoryWhereInput
  }

  /**
   * BundleCountOutputType without action
   */
  export type BundleCountOutputTypeCountBundle_productArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: bundle_productWhereInput
  }

  /**
   * BundleCountOutputType without action
   */
  export type BundleCountOutputTypeCountT_sales_lineArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: t_sales_lineWhereInput
  }


  /**
   * Count Type CategoryCountOutputType
   */

  export type CategoryCountOutputType = {
    bundle_category: number
    other_category: number
    product_category: number
  }

  export type CategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bundle_category?: boolean | CategoryCountOutputTypeCountBundle_categoryArgs
    other_category?: boolean | CategoryCountOutputTypeCountOther_categoryArgs
    product_category?: boolean | CategoryCountOutputTypeCountProduct_categoryArgs
  }

  // Custom InputTypes
  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryCountOutputType
     */
    select?: CategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeCountBundle_categoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: bundle_categoryWhereInput
  }

  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeCountOther_categoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: categoryWhereInput
  }

  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeCountProduct_categoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: product_categoryWhereInput
  }


  /**
   * Count Type CustomerCountOutputType
   */

  export type CustomerCountOutputType = {
    auth_user: number
    customer_reader: number
    customer_track: number
    t_sales: number
    t_sales_download: number
  }

  export type CustomerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    auth_user?: boolean | CustomerCountOutputTypeCountAuth_userArgs
    customer_reader?: boolean | CustomerCountOutputTypeCountCustomer_readerArgs
    customer_track?: boolean | CustomerCountOutputTypeCountCustomer_trackArgs
    t_sales?: boolean | CustomerCountOutputTypeCountT_salesArgs
    t_sales_download?: boolean | CustomerCountOutputTypeCountT_sales_downloadArgs
  }

  // Custom InputTypes
  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerCountOutputType
     */
    select?: CustomerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountAuth_userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: auth_userWhereInput
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountCustomer_readerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: customer_readerWhereInput
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountCustomer_trackArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: customer_trackWhereInput
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountT_salesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: t_salesWhereInput
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountT_sales_downloadArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: t_sales_downloadWhereInput
  }


  /**
   * Count Type GenreCountOutputType
   */

  export type GenreCountOutputType = {
    book_genre: number
    other_genre: number
  }

  export type GenreCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    book_genre?: boolean | GenreCountOutputTypeCountBook_genreArgs
    other_genre?: boolean | GenreCountOutputTypeCountOther_genreArgs
  }

  // Custom InputTypes
  /**
   * GenreCountOutputType without action
   */
  export type GenreCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GenreCountOutputType
     */
    select?: GenreCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * GenreCountOutputType without action
   */
  export type GenreCountOutputTypeCountBook_genreArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: book_genreWhereInput
  }

  /**
   * GenreCountOutputType without action
   */
  export type GenreCountOutputTypeCountOther_genreArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: genreWhereInput
  }


  /**
   * Count Type InternalCountOutputType
   */

  export type InternalCountOutputType = {
    auth_user: number
    book_approval: number
  }

  export type InternalCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    auth_user?: boolean | InternalCountOutputTypeCountAuth_userArgs
    book_approval?: boolean | InternalCountOutputTypeCountBook_approvalArgs
  }

  // Custom InputTypes
  /**
   * InternalCountOutputType without action
   */
  export type InternalCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InternalCountOutputType
     */
    select?: InternalCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * InternalCountOutputType without action
   */
  export type InternalCountOutputTypeCountAuth_userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: auth_userWhereInput
  }

  /**
   * InternalCountOutputType without action
   */
  export type InternalCountOutputTypeCountBook_approvalArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: book_approvalWhereInput
  }


  /**
   * Count Type LandingCountOutputType
   */

  export type LandingCountOutputType = {
    landing_items: number
  }

  export type LandingCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    landing_items?: boolean | LandingCountOutputTypeCountLanding_itemsArgs
  }

  // Custom InputTypes
  /**
   * LandingCountOutputType without action
   */
  export type LandingCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LandingCountOutputType
     */
    select?: LandingCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LandingCountOutputType without action
   */
  export type LandingCountOutputTypeCountLanding_itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: landing_itemsWhereInput
  }


  /**
   * Count Type ProductCountOutputType
   */

  export type ProductCountOutputType = {
    book: number
    bundle_product: number
    chapter: number
    customer_reader: number
    preorder: number
    product_category: number
    t_sales_download: number
    t_sales_line: number
  }

  export type ProductCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    book?: boolean | ProductCountOutputTypeCountBookArgs
    bundle_product?: boolean | ProductCountOutputTypeCountBundle_productArgs
    chapter?: boolean | ProductCountOutputTypeCountChapterArgs
    customer_reader?: boolean | ProductCountOutputTypeCountCustomer_readerArgs
    preorder?: boolean | ProductCountOutputTypeCountPreorderArgs
    product_category?: boolean | ProductCountOutputTypeCountProduct_categoryArgs
    t_sales_download?: boolean | ProductCountOutputTypeCountT_sales_downloadArgs
    t_sales_line?: boolean | ProductCountOutputTypeCountT_sales_lineArgs
  }

  // Custom InputTypes
  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCountOutputType
     */
    select?: ProductCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountBookArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: bookWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountBundle_productArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: bundle_productWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountChapterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: chapterWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountCustomer_readerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: customer_readerWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountPreorderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: preorderWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountProduct_categoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: product_categoryWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountT_sales_downloadArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: t_sales_downloadWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountT_sales_lineArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: t_sales_lineWhereInput
  }


  /**
   * Count Type PublisherCountOutputType
   */

  export type PublisherCountOutputType = {
    auth_user: number
    promo_code: number
    publisher_author: number
    t_ai_credit: number
    transaction: number
    withdrawal: number
  }

  export type PublisherCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    auth_user?: boolean | PublisherCountOutputTypeCountAuth_userArgs
    promo_code?: boolean | PublisherCountOutputTypeCountPromo_codeArgs
    publisher_author?: boolean | PublisherCountOutputTypeCountPublisher_authorArgs
    t_ai_credit?: boolean | PublisherCountOutputTypeCountT_ai_creditArgs
    transaction?: boolean | PublisherCountOutputTypeCountTransactionArgs
    withdrawal?: boolean | PublisherCountOutputTypeCountWithdrawalArgs
  }

  // Custom InputTypes
  /**
   * PublisherCountOutputType without action
   */
  export type PublisherCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PublisherCountOutputType
     */
    select?: PublisherCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PublisherCountOutputType without action
   */
  export type PublisherCountOutputTypeCountAuth_userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: auth_userWhereInput
  }

  /**
   * PublisherCountOutputType without action
   */
  export type PublisherCountOutputTypeCountPromo_codeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: promo_codeWhereInput
  }

  /**
   * PublisherCountOutputType without action
   */
  export type PublisherCountOutputTypeCountPublisher_authorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: publisher_authorWhereInput
  }

  /**
   * PublisherCountOutputType without action
   */
  export type PublisherCountOutputTypeCountT_ai_creditArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: t_ai_creditWhereInput
  }

  /**
   * PublisherCountOutputType without action
   */
  export type PublisherCountOutputTypeCountTransactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: transactionWhereInput
  }

  /**
   * PublisherCountOutputType without action
   */
  export type PublisherCountOutputTypeCountWithdrawalArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: withdrawalWhereInput
  }


  /**
   * Count Type ReviewsCountOutputType
   */

  export type ReviewsCountOutputType = {
    reviews_likes: number
  }

  export type ReviewsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reviews_likes?: boolean | ReviewsCountOutputTypeCountReviews_likesArgs
  }

  // Custom InputTypes
  /**
   * ReviewsCountOutputType without action
   */
  export type ReviewsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewsCountOutputType
     */
    select?: ReviewsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ReviewsCountOutputType without action
   */
  export type ReviewsCountOutputTypeCountReviews_likesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: reviews_likesWhereInput
  }


  /**
   * Count Type T_ai_creditCountOutputType
   */

  export type T_ai_creditCountOutputType = {
    t_ai_credit_topup: number
  }

  export type T_ai_creditCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    t_ai_credit_topup?: boolean | T_ai_creditCountOutputTypeCountT_ai_credit_topupArgs
  }

  // Custom InputTypes
  /**
   * T_ai_creditCountOutputType without action
   */
  export type T_ai_creditCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the T_ai_creditCountOutputType
     */
    select?: T_ai_creditCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * T_ai_creditCountOutputType without action
   */
  export type T_ai_creditCountOutputTypeCountT_ai_credit_topupArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: t_ai_credit_topupWhereInput
  }


  /**
   * Count Type T_salesCountOutputType
   */

  export type T_salesCountOutputType = {
    t_sales_line: number
  }

  export type T_salesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    t_sales_line?: boolean | T_salesCountOutputTypeCountT_sales_lineArgs
  }

  // Custom InputTypes
  /**
   * T_salesCountOutputType without action
   */
  export type T_salesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the T_salesCountOutputType
     */
    select?: T_salesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * T_salesCountOutputType without action
   */
  export type T_salesCountOutputTypeCountT_sales_lineArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: t_sales_lineWhereInput
  }


  /**
   * Count Type TagsCountOutputType
   */

  export type TagsCountOutputType = {
    book_tags: number
    other_tags: number
  }

  export type TagsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    book_tags?: boolean | TagsCountOutputTypeCountBook_tagsArgs
    other_tags?: boolean | TagsCountOutputTypeCountOther_tagsArgs
  }

  // Custom InputTypes
  /**
   * TagsCountOutputType without action
   */
  export type TagsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagsCountOutputType
     */
    select?: TagsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TagsCountOutputType without action
   */
  export type TagsCountOutputTypeCountBook_tagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: book_tagsWhereInput
  }

  /**
   * TagsCountOutputType without action
   */
  export type TagsCountOutputTypeCountOther_tagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tagsWhereInput
  }


  /**
   * Models
   */

  /**
   * Model affiliate
   */

  export type AggregateAffiliate = {
    _count: AffiliateCountAggregateOutputType | null
    _min: AffiliateMinAggregateOutputType | null
    _max: AffiliateMaxAggregateOutputType | null
  }

  export type AffiliateMinAggregateOutputType = {
    id: string | null
    name: string | null
    id_account: string | null
  }

  export type AffiliateMaxAggregateOutputType = {
    id: string | null
    name: string | null
    id_account: string | null
  }

  export type AffiliateCountAggregateOutputType = {
    id: number
    name: number
    id_account: number
    _all: number
  }


  export type AffiliateMinAggregateInputType = {
    id?: true
    name?: true
    id_account?: true
  }

  export type AffiliateMaxAggregateInputType = {
    id?: true
    name?: true
    id_account?: true
  }

  export type AffiliateCountAggregateInputType = {
    id?: true
    name?: true
    id_account?: true
    _all?: true
  }

  export type AffiliateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which affiliate to aggregate.
     */
    where?: affiliateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of affiliates to fetch.
     */
    orderBy?: affiliateOrderByWithRelationInput | affiliateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: affiliateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` affiliates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` affiliates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned affiliates
    **/
    _count?: true | AffiliateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AffiliateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AffiliateMaxAggregateInputType
  }

  export type GetAffiliateAggregateType<T extends AffiliateAggregateArgs> = {
        [P in keyof T & keyof AggregateAffiliate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAffiliate[P]>
      : GetScalarType<T[P], AggregateAffiliate[P]>
  }




  export type affiliateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: affiliateWhereInput
    orderBy?: affiliateOrderByWithAggregationInput | affiliateOrderByWithAggregationInput[]
    by: AffiliateScalarFieldEnum[] | AffiliateScalarFieldEnum
    having?: affiliateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AffiliateCountAggregateInputType | true
    _min?: AffiliateMinAggregateInputType
    _max?: AffiliateMaxAggregateInputType
  }

  export type AffiliateGroupByOutputType = {
    id: string
    name: string
    id_account: string | null
    _count: AffiliateCountAggregateOutputType | null
    _min: AffiliateMinAggregateOutputType | null
    _max: AffiliateMaxAggregateOutputType | null
  }

  type GetAffiliateGroupByPayload<T extends affiliateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AffiliateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AffiliateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AffiliateGroupByOutputType[P]>
            : GetScalarType<T[P], AffiliateGroupByOutputType[P]>
        }
      >
    >


  export type affiliateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    id_account?: boolean
    auth_account?: boolean | affiliate$auth_accountArgs<ExtArgs>
    auth_user?: boolean | affiliate$auth_userArgs<ExtArgs>
    _count?: boolean | AffiliateCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["affiliate"]>

  export type affiliateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    id_account?: boolean
    auth_account?: boolean | affiliate$auth_accountArgs<ExtArgs>
  }, ExtArgs["result"]["affiliate"]>

  export type affiliateSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    id_account?: boolean
    auth_account?: boolean | affiliate$auth_accountArgs<ExtArgs>
  }, ExtArgs["result"]["affiliate"]>

  export type affiliateSelectScalar = {
    id?: boolean
    name?: boolean
    id_account?: boolean
  }

  export type affiliateOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "id_account", ExtArgs["result"]["affiliate"]>
  export type affiliateInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    auth_account?: boolean | affiliate$auth_accountArgs<ExtArgs>
    auth_user?: boolean | affiliate$auth_userArgs<ExtArgs>
    _count?: boolean | AffiliateCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type affiliateIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    auth_account?: boolean | affiliate$auth_accountArgs<ExtArgs>
  }
  export type affiliateIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    auth_account?: boolean | affiliate$auth_accountArgs<ExtArgs>
  }

  export type $affiliatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "affiliate"
    objects: {
      auth_account: Prisma.$auth_accountPayload<ExtArgs> | null
      auth_user: Prisma.$auth_userPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      id_account: string | null
    }, ExtArgs["result"]["affiliate"]>
    composites: {}
  }

  type affiliateGetPayload<S extends boolean | null | undefined | affiliateDefaultArgs> = $Result.GetResult<Prisma.$affiliatePayload, S>

  type affiliateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<affiliateFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AffiliateCountAggregateInputType | true
    }

  export interface affiliateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['affiliate'], meta: { name: 'affiliate' } }
    /**
     * Find zero or one Affiliate that matches the filter.
     * @param {affiliateFindUniqueArgs} args - Arguments to find a Affiliate
     * @example
     * // Get one Affiliate
     * const affiliate = await prisma.affiliate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends affiliateFindUniqueArgs>(args: SelectSubset<T, affiliateFindUniqueArgs<ExtArgs>>): Prisma__affiliateClient<$Result.GetResult<Prisma.$affiliatePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Affiliate that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {affiliateFindUniqueOrThrowArgs} args - Arguments to find a Affiliate
     * @example
     * // Get one Affiliate
     * const affiliate = await prisma.affiliate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends affiliateFindUniqueOrThrowArgs>(args: SelectSubset<T, affiliateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__affiliateClient<$Result.GetResult<Prisma.$affiliatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Affiliate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {affiliateFindFirstArgs} args - Arguments to find a Affiliate
     * @example
     * // Get one Affiliate
     * const affiliate = await prisma.affiliate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends affiliateFindFirstArgs>(args?: SelectSubset<T, affiliateFindFirstArgs<ExtArgs>>): Prisma__affiliateClient<$Result.GetResult<Prisma.$affiliatePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Affiliate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {affiliateFindFirstOrThrowArgs} args - Arguments to find a Affiliate
     * @example
     * // Get one Affiliate
     * const affiliate = await prisma.affiliate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends affiliateFindFirstOrThrowArgs>(args?: SelectSubset<T, affiliateFindFirstOrThrowArgs<ExtArgs>>): Prisma__affiliateClient<$Result.GetResult<Prisma.$affiliatePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Affiliates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {affiliateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Affiliates
     * const affiliates = await prisma.affiliate.findMany()
     * 
     * // Get first 10 Affiliates
     * const affiliates = await prisma.affiliate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const affiliateWithIdOnly = await prisma.affiliate.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends affiliateFindManyArgs>(args?: SelectSubset<T, affiliateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$affiliatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Affiliate.
     * @param {affiliateCreateArgs} args - Arguments to create a Affiliate.
     * @example
     * // Create one Affiliate
     * const Affiliate = await prisma.affiliate.create({
     *   data: {
     *     // ... data to create a Affiliate
     *   }
     * })
     * 
     */
    create<T extends affiliateCreateArgs>(args: SelectSubset<T, affiliateCreateArgs<ExtArgs>>): Prisma__affiliateClient<$Result.GetResult<Prisma.$affiliatePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Affiliates.
     * @param {affiliateCreateManyArgs} args - Arguments to create many Affiliates.
     * @example
     * // Create many Affiliates
     * const affiliate = await prisma.affiliate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends affiliateCreateManyArgs>(args?: SelectSubset<T, affiliateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Affiliates and returns the data saved in the database.
     * @param {affiliateCreateManyAndReturnArgs} args - Arguments to create many Affiliates.
     * @example
     * // Create many Affiliates
     * const affiliate = await prisma.affiliate.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Affiliates and only return the `id`
     * const affiliateWithIdOnly = await prisma.affiliate.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends affiliateCreateManyAndReturnArgs>(args?: SelectSubset<T, affiliateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$affiliatePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Affiliate.
     * @param {affiliateDeleteArgs} args - Arguments to delete one Affiliate.
     * @example
     * // Delete one Affiliate
     * const Affiliate = await prisma.affiliate.delete({
     *   where: {
     *     // ... filter to delete one Affiliate
     *   }
     * })
     * 
     */
    delete<T extends affiliateDeleteArgs>(args: SelectSubset<T, affiliateDeleteArgs<ExtArgs>>): Prisma__affiliateClient<$Result.GetResult<Prisma.$affiliatePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Affiliate.
     * @param {affiliateUpdateArgs} args - Arguments to update one Affiliate.
     * @example
     * // Update one Affiliate
     * const affiliate = await prisma.affiliate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends affiliateUpdateArgs>(args: SelectSubset<T, affiliateUpdateArgs<ExtArgs>>): Prisma__affiliateClient<$Result.GetResult<Prisma.$affiliatePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Affiliates.
     * @param {affiliateDeleteManyArgs} args - Arguments to filter Affiliates to delete.
     * @example
     * // Delete a few Affiliates
     * const { count } = await prisma.affiliate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends affiliateDeleteManyArgs>(args?: SelectSubset<T, affiliateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Affiliates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {affiliateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Affiliates
     * const affiliate = await prisma.affiliate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends affiliateUpdateManyArgs>(args: SelectSubset<T, affiliateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Affiliates and returns the data updated in the database.
     * @param {affiliateUpdateManyAndReturnArgs} args - Arguments to update many Affiliates.
     * @example
     * // Update many Affiliates
     * const affiliate = await prisma.affiliate.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Affiliates and only return the `id`
     * const affiliateWithIdOnly = await prisma.affiliate.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends affiliateUpdateManyAndReturnArgs>(args: SelectSubset<T, affiliateUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$affiliatePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Affiliate.
     * @param {affiliateUpsertArgs} args - Arguments to update or create a Affiliate.
     * @example
     * // Update or create a Affiliate
     * const affiliate = await prisma.affiliate.upsert({
     *   create: {
     *     // ... data to create a Affiliate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Affiliate we want to update
     *   }
     * })
     */
    upsert<T extends affiliateUpsertArgs>(args: SelectSubset<T, affiliateUpsertArgs<ExtArgs>>): Prisma__affiliateClient<$Result.GetResult<Prisma.$affiliatePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Affiliates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {affiliateCountArgs} args - Arguments to filter Affiliates to count.
     * @example
     * // Count the number of Affiliates
     * const count = await prisma.affiliate.count({
     *   where: {
     *     // ... the filter for the Affiliates we want to count
     *   }
     * })
    **/
    count<T extends affiliateCountArgs>(
      args?: Subset<T, affiliateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AffiliateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Affiliate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AffiliateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AffiliateAggregateArgs>(args: Subset<T, AffiliateAggregateArgs>): Prisma.PrismaPromise<GetAffiliateAggregateType<T>>

    /**
     * Group by Affiliate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {affiliateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends affiliateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: affiliateGroupByArgs['orderBy'] }
        : { orderBy?: affiliateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, affiliateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAffiliateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the affiliate model
   */
  readonly fields: affiliateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for affiliate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__affiliateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    auth_account<T extends affiliate$auth_accountArgs<ExtArgs> = {}>(args?: Subset<T, affiliate$auth_accountArgs<ExtArgs>>): Prisma__auth_accountClient<$Result.GetResult<Prisma.$auth_accountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    auth_user<T extends affiliate$auth_userArgs<ExtArgs> = {}>(args?: Subset<T, affiliate$auth_userArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$auth_userPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the affiliate model
   */
  interface affiliateFieldRefs {
    readonly id: FieldRef<"affiliate", 'String'>
    readonly name: FieldRef<"affiliate", 'String'>
    readonly id_account: FieldRef<"affiliate", 'String'>
  }
    

  // Custom InputTypes
  /**
   * affiliate findUnique
   */
  export type affiliateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the affiliate
     */
    select?: affiliateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the affiliate
     */
    omit?: affiliateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: affiliateInclude<ExtArgs> | null
    /**
     * Filter, which affiliate to fetch.
     */
    where: affiliateWhereUniqueInput
  }

  /**
   * affiliate findUniqueOrThrow
   */
  export type affiliateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the affiliate
     */
    select?: affiliateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the affiliate
     */
    omit?: affiliateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: affiliateInclude<ExtArgs> | null
    /**
     * Filter, which affiliate to fetch.
     */
    where: affiliateWhereUniqueInput
  }

  /**
   * affiliate findFirst
   */
  export type affiliateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the affiliate
     */
    select?: affiliateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the affiliate
     */
    omit?: affiliateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: affiliateInclude<ExtArgs> | null
    /**
     * Filter, which affiliate to fetch.
     */
    where?: affiliateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of affiliates to fetch.
     */
    orderBy?: affiliateOrderByWithRelationInput | affiliateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for affiliates.
     */
    cursor?: affiliateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` affiliates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` affiliates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of affiliates.
     */
    distinct?: AffiliateScalarFieldEnum | AffiliateScalarFieldEnum[]
  }

  /**
   * affiliate findFirstOrThrow
   */
  export type affiliateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the affiliate
     */
    select?: affiliateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the affiliate
     */
    omit?: affiliateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: affiliateInclude<ExtArgs> | null
    /**
     * Filter, which affiliate to fetch.
     */
    where?: affiliateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of affiliates to fetch.
     */
    orderBy?: affiliateOrderByWithRelationInput | affiliateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for affiliates.
     */
    cursor?: affiliateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` affiliates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` affiliates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of affiliates.
     */
    distinct?: AffiliateScalarFieldEnum | AffiliateScalarFieldEnum[]
  }

  /**
   * affiliate findMany
   */
  export type affiliateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the affiliate
     */
    select?: affiliateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the affiliate
     */
    omit?: affiliateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: affiliateInclude<ExtArgs> | null
    /**
     * Filter, which affiliates to fetch.
     */
    where?: affiliateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of affiliates to fetch.
     */
    orderBy?: affiliateOrderByWithRelationInput | affiliateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing affiliates.
     */
    cursor?: affiliateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` affiliates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` affiliates.
     */
    skip?: number
    distinct?: AffiliateScalarFieldEnum | AffiliateScalarFieldEnum[]
  }

  /**
   * affiliate create
   */
  export type affiliateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the affiliate
     */
    select?: affiliateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the affiliate
     */
    omit?: affiliateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: affiliateInclude<ExtArgs> | null
    /**
     * The data needed to create a affiliate.
     */
    data: XOR<affiliateCreateInput, affiliateUncheckedCreateInput>
  }

  /**
   * affiliate createMany
   */
  export type affiliateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many affiliates.
     */
    data: affiliateCreateManyInput | affiliateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * affiliate createManyAndReturn
   */
  export type affiliateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the affiliate
     */
    select?: affiliateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the affiliate
     */
    omit?: affiliateOmit<ExtArgs> | null
    /**
     * The data used to create many affiliates.
     */
    data: affiliateCreateManyInput | affiliateCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: affiliateIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * affiliate update
   */
  export type affiliateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the affiliate
     */
    select?: affiliateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the affiliate
     */
    omit?: affiliateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: affiliateInclude<ExtArgs> | null
    /**
     * The data needed to update a affiliate.
     */
    data: XOR<affiliateUpdateInput, affiliateUncheckedUpdateInput>
    /**
     * Choose, which affiliate to update.
     */
    where: affiliateWhereUniqueInput
  }

  /**
   * affiliate updateMany
   */
  export type affiliateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update affiliates.
     */
    data: XOR<affiliateUpdateManyMutationInput, affiliateUncheckedUpdateManyInput>
    /**
     * Filter which affiliates to update
     */
    where?: affiliateWhereInput
    /**
     * Limit how many affiliates to update.
     */
    limit?: number
  }

  /**
   * affiliate updateManyAndReturn
   */
  export type affiliateUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the affiliate
     */
    select?: affiliateSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the affiliate
     */
    omit?: affiliateOmit<ExtArgs> | null
    /**
     * The data used to update affiliates.
     */
    data: XOR<affiliateUpdateManyMutationInput, affiliateUncheckedUpdateManyInput>
    /**
     * Filter which affiliates to update
     */
    where?: affiliateWhereInput
    /**
     * Limit how many affiliates to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: affiliateIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * affiliate upsert
   */
  export type affiliateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the affiliate
     */
    select?: affiliateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the affiliate
     */
    omit?: affiliateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: affiliateInclude<ExtArgs> | null
    /**
     * The filter to search for the affiliate to update in case it exists.
     */
    where: affiliateWhereUniqueInput
    /**
     * In case the affiliate found by the `where` argument doesn't exist, create a new affiliate with this data.
     */
    create: XOR<affiliateCreateInput, affiliateUncheckedCreateInput>
    /**
     * In case the affiliate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<affiliateUpdateInput, affiliateUncheckedUpdateInput>
  }

  /**
   * affiliate delete
   */
  export type affiliateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the affiliate
     */
    select?: affiliateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the affiliate
     */
    omit?: affiliateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: affiliateInclude<ExtArgs> | null
    /**
     * Filter which affiliate to delete.
     */
    where: affiliateWhereUniqueInput
  }

  /**
   * affiliate deleteMany
   */
  export type affiliateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which affiliates to delete
     */
    where?: affiliateWhereInput
    /**
     * Limit how many affiliates to delete.
     */
    limit?: number
  }

  /**
   * affiliate.auth_account
   */
  export type affiliate$auth_accountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auth_account
     */
    select?: auth_accountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the auth_account
     */
    omit?: auth_accountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auth_accountInclude<ExtArgs> | null
    where?: auth_accountWhereInput
  }

  /**
   * affiliate.auth_user
   */
  export type affiliate$auth_userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auth_user
     */
    select?: auth_userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the auth_user
     */
    omit?: auth_userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auth_userInclude<ExtArgs> | null
    where?: auth_userWhereInput
    orderBy?: auth_userOrderByWithRelationInput | auth_userOrderByWithRelationInput[]
    cursor?: auth_userWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Auth_userScalarFieldEnum | Auth_userScalarFieldEnum[]
  }

  /**
   * affiliate without action
   */
  export type affiliateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the affiliate
     */
    select?: affiliateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the affiliate
     */
    omit?: affiliateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: affiliateInclude<ExtArgs> | null
  }


  /**
   * Model auth_account
   */

  export type AggregateAuth_account = {
    _count: Auth_accountCountAggregateOutputType | null
    _min: Auth_accountMinAggregateOutputType | null
    _max: Auth_accountMaxAggregateOutputType | null
  }

  export type Auth_accountMinAggregateOutputType = {
    id: string | null
    password: string | null
    id_provider: string | null
    access_token: string | null
    refresh_token: string | null
    id_token: string | null
    access_token_expires_at: Date | null
    refresh_token_expires_at: Date | null
    scope: string | null
    created_at: Date | null
    updated_at: Date | null
    id_user: string | null
    id_account: string | null
  }

  export type Auth_accountMaxAggregateOutputType = {
    id: string | null
    password: string | null
    id_provider: string | null
    access_token: string | null
    refresh_token: string | null
    id_token: string | null
    access_token_expires_at: Date | null
    refresh_token_expires_at: Date | null
    scope: string | null
    created_at: Date | null
    updated_at: Date | null
    id_user: string | null
    id_account: string | null
  }

  export type Auth_accountCountAggregateOutputType = {
    id: number
    password: number
    id_provider: number
    access_token: number
    refresh_token: number
    id_token: number
    access_token_expires_at: number
    refresh_token_expires_at: number
    scope: number
    created_at: number
    updated_at: number
    id_user: number
    id_account: number
    _all: number
  }


  export type Auth_accountMinAggregateInputType = {
    id?: true
    password?: true
    id_provider?: true
    access_token?: true
    refresh_token?: true
    id_token?: true
    access_token_expires_at?: true
    refresh_token_expires_at?: true
    scope?: true
    created_at?: true
    updated_at?: true
    id_user?: true
    id_account?: true
  }

  export type Auth_accountMaxAggregateInputType = {
    id?: true
    password?: true
    id_provider?: true
    access_token?: true
    refresh_token?: true
    id_token?: true
    access_token_expires_at?: true
    refresh_token_expires_at?: true
    scope?: true
    created_at?: true
    updated_at?: true
    id_user?: true
    id_account?: true
  }

  export type Auth_accountCountAggregateInputType = {
    id?: true
    password?: true
    id_provider?: true
    access_token?: true
    refresh_token?: true
    id_token?: true
    access_token_expires_at?: true
    refresh_token_expires_at?: true
    scope?: true
    created_at?: true
    updated_at?: true
    id_user?: true
    id_account?: true
    _all?: true
  }

  export type Auth_accountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which auth_account to aggregate.
     */
    where?: auth_accountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of auth_accounts to fetch.
     */
    orderBy?: auth_accountOrderByWithRelationInput | auth_accountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: auth_accountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` auth_accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` auth_accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned auth_accounts
    **/
    _count?: true | Auth_accountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Auth_accountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Auth_accountMaxAggregateInputType
  }

  export type GetAuth_accountAggregateType<T extends Auth_accountAggregateArgs> = {
        [P in keyof T & keyof AggregateAuth_account]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuth_account[P]>
      : GetScalarType<T[P], AggregateAuth_account[P]>
  }




  export type auth_accountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: auth_accountWhereInput
    orderBy?: auth_accountOrderByWithAggregationInput | auth_accountOrderByWithAggregationInput[]
    by: Auth_accountScalarFieldEnum[] | Auth_accountScalarFieldEnum
    having?: auth_accountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Auth_accountCountAggregateInputType | true
    _min?: Auth_accountMinAggregateInputType
    _max?: Auth_accountMaxAggregateInputType
  }

  export type Auth_accountGroupByOutputType = {
    id: string
    password: string | null
    id_provider: string | null
    access_token: string | null
    refresh_token: string | null
    id_token: string | null
    access_token_expires_at: Date | null
    refresh_token_expires_at: Date | null
    scope: string | null
    created_at: Date
    updated_at: Date | null
    id_user: string | null
    id_account: string | null
    _count: Auth_accountCountAggregateOutputType | null
    _min: Auth_accountMinAggregateOutputType | null
    _max: Auth_accountMaxAggregateOutputType | null
  }

  type GetAuth_accountGroupByPayload<T extends auth_accountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Auth_accountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Auth_accountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Auth_accountGroupByOutputType[P]>
            : GetScalarType<T[P], Auth_accountGroupByOutputType[P]>
        }
      >
    >


  export type auth_accountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    password?: boolean
    id_provider?: boolean
    access_token?: boolean
    refresh_token?: boolean
    id_token?: boolean
    access_token_expires_at?: boolean
    refresh_token_expires_at?: boolean
    scope?: boolean
    created_at?: boolean
    updated_at?: boolean
    id_user?: boolean
    id_account?: boolean
    affiliate?: boolean | auth_account$affiliateArgs<ExtArgs>
    auth_user?: boolean | auth_account$auth_userArgs<ExtArgs>
    author?: boolean | auth_account$authorArgs<ExtArgs>
    customer?: boolean | auth_account$customerArgs<ExtArgs>
    internal?: boolean | auth_account$internalArgs<ExtArgs>
    publisher?: boolean | auth_account$publisherArgs<ExtArgs>
    _count?: boolean | Auth_accountCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auth_account"]>

  export type auth_accountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    password?: boolean
    id_provider?: boolean
    access_token?: boolean
    refresh_token?: boolean
    id_token?: boolean
    access_token_expires_at?: boolean
    refresh_token_expires_at?: boolean
    scope?: boolean
    created_at?: boolean
    updated_at?: boolean
    id_user?: boolean
    id_account?: boolean
    auth_user?: boolean | auth_account$auth_userArgs<ExtArgs>
  }, ExtArgs["result"]["auth_account"]>

  export type auth_accountSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    password?: boolean
    id_provider?: boolean
    access_token?: boolean
    refresh_token?: boolean
    id_token?: boolean
    access_token_expires_at?: boolean
    refresh_token_expires_at?: boolean
    scope?: boolean
    created_at?: boolean
    updated_at?: boolean
    id_user?: boolean
    id_account?: boolean
    auth_user?: boolean | auth_account$auth_userArgs<ExtArgs>
  }, ExtArgs["result"]["auth_account"]>

  export type auth_accountSelectScalar = {
    id?: boolean
    password?: boolean
    id_provider?: boolean
    access_token?: boolean
    refresh_token?: boolean
    id_token?: boolean
    access_token_expires_at?: boolean
    refresh_token_expires_at?: boolean
    scope?: boolean
    created_at?: boolean
    updated_at?: boolean
    id_user?: boolean
    id_account?: boolean
  }

  export type auth_accountOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "password" | "id_provider" | "access_token" | "refresh_token" | "id_token" | "access_token_expires_at" | "refresh_token_expires_at" | "scope" | "created_at" | "updated_at" | "id_user" | "id_account", ExtArgs["result"]["auth_account"]>
  export type auth_accountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    affiliate?: boolean | auth_account$affiliateArgs<ExtArgs>
    auth_user?: boolean | auth_account$auth_userArgs<ExtArgs>
    author?: boolean | auth_account$authorArgs<ExtArgs>
    customer?: boolean | auth_account$customerArgs<ExtArgs>
    internal?: boolean | auth_account$internalArgs<ExtArgs>
    publisher?: boolean | auth_account$publisherArgs<ExtArgs>
    _count?: boolean | Auth_accountCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type auth_accountIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    auth_user?: boolean | auth_account$auth_userArgs<ExtArgs>
  }
  export type auth_accountIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    auth_user?: boolean | auth_account$auth_userArgs<ExtArgs>
  }

  export type $auth_accountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "auth_account"
    objects: {
      affiliate: Prisma.$affiliatePayload<ExtArgs>[]
      auth_user: Prisma.$auth_userPayload<ExtArgs> | null
      author: Prisma.$authorPayload<ExtArgs>[]
      customer: Prisma.$customerPayload<ExtArgs>[]
      internal: Prisma.$internalPayload<ExtArgs>[]
      publisher: Prisma.$publisherPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      password: string | null
      id_provider: string | null
      access_token: string | null
      refresh_token: string | null
      id_token: string | null
      access_token_expires_at: Date | null
      refresh_token_expires_at: Date | null
      scope: string | null
      created_at: Date
      updated_at: Date | null
      id_user: string | null
      id_account: string | null
    }, ExtArgs["result"]["auth_account"]>
    composites: {}
  }

  type auth_accountGetPayload<S extends boolean | null | undefined | auth_accountDefaultArgs> = $Result.GetResult<Prisma.$auth_accountPayload, S>

  type auth_accountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<auth_accountFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Auth_accountCountAggregateInputType | true
    }

  export interface auth_accountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['auth_account'], meta: { name: 'auth_account' } }
    /**
     * Find zero or one Auth_account that matches the filter.
     * @param {auth_accountFindUniqueArgs} args - Arguments to find a Auth_account
     * @example
     * // Get one Auth_account
     * const auth_account = await prisma.auth_account.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends auth_accountFindUniqueArgs>(args: SelectSubset<T, auth_accountFindUniqueArgs<ExtArgs>>): Prisma__auth_accountClient<$Result.GetResult<Prisma.$auth_accountPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Auth_account that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {auth_accountFindUniqueOrThrowArgs} args - Arguments to find a Auth_account
     * @example
     * // Get one Auth_account
     * const auth_account = await prisma.auth_account.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends auth_accountFindUniqueOrThrowArgs>(args: SelectSubset<T, auth_accountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__auth_accountClient<$Result.GetResult<Prisma.$auth_accountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Auth_account that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {auth_accountFindFirstArgs} args - Arguments to find a Auth_account
     * @example
     * // Get one Auth_account
     * const auth_account = await prisma.auth_account.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends auth_accountFindFirstArgs>(args?: SelectSubset<T, auth_accountFindFirstArgs<ExtArgs>>): Prisma__auth_accountClient<$Result.GetResult<Prisma.$auth_accountPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Auth_account that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {auth_accountFindFirstOrThrowArgs} args - Arguments to find a Auth_account
     * @example
     * // Get one Auth_account
     * const auth_account = await prisma.auth_account.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends auth_accountFindFirstOrThrowArgs>(args?: SelectSubset<T, auth_accountFindFirstOrThrowArgs<ExtArgs>>): Prisma__auth_accountClient<$Result.GetResult<Prisma.$auth_accountPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Auth_accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {auth_accountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Auth_accounts
     * const auth_accounts = await prisma.auth_account.findMany()
     * 
     * // Get first 10 Auth_accounts
     * const auth_accounts = await prisma.auth_account.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auth_accountWithIdOnly = await prisma.auth_account.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends auth_accountFindManyArgs>(args?: SelectSubset<T, auth_accountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$auth_accountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Auth_account.
     * @param {auth_accountCreateArgs} args - Arguments to create a Auth_account.
     * @example
     * // Create one Auth_account
     * const Auth_account = await prisma.auth_account.create({
     *   data: {
     *     // ... data to create a Auth_account
     *   }
     * })
     * 
     */
    create<T extends auth_accountCreateArgs>(args: SelectSubset<T, auth_accountCreateArgs<ExtArgs>>): Prisma__auth_accountClient<$Result.GetResult<Prisma.$auth_accountPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Auth_accounts.
     * @param {auth_accountCreateManyArgs} args - Arguments to create many Auth_accounts.
     * @example
     * // Create many Auth_accounts
     * const auth_account = await prisma.auth_account.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends auth_accountCreateManyArgs>(args?: SelectSubset<T, auth_accountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Auth_accounts and returns the data saved in the database.
     * @param {auth_accountCreateManyAndReturnArgs} args - Arguments to create many Auth_accounts.
     * @example
     * // Create many Auth_accounts
     * const auth_account = await prisma.auth_account.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Auth_accounts and only return the `id`
     * const auth_accountWithIdOnly = await prisma.auth_account.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends auth_accountCreateManyAndReturnArgs>(args?: SelectSubset<T, auth_accountCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$auth_accountPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Auth_account.
     * @param {auth_accountDeleteArgs} args - Arguments to delete one Auth_account.
     * @example
     * // Delete one Auth_account
     * const Auth_account = await prisma.auth_account.delete({
     *   where: {
     *     // ... filter to delete one Auth_account
     *   }
     * })
     * 
     */
    delete<T extends auth_accountDeleteArgs>(args: SelectSubset<T, auth_accountDeleteArgs<ExtArgs>>): Prisma__auth_accountClient<$Result.GetResult<Prisma.$auth_accountPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Auth_account.
     * @param {auth_accountUpdateArgs} args - Arguments to update one Auth_account.
     * @example
     * // Update one Auth_account
     * const auth_account = await prisma.auth_account.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends auth_accountUpdateArgs>(args: SelectSubset<T, auth_accountUpdateArgs<ExtArgs>>): Prisma__auth_accountClient<$Result.GetResult<Prisma.$auth_accountPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Auth_accounts.
     * @param {auth_accountDeleteManyArgs} args - Arguments to filter Auth_accounts to delete.
     * @example
     * // Delete a few Auth_accounts
     * const { count } = await prisma.auth_account.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends auth_accountDeleteManyArgs>(args?: SelectSubset<T, auth_accountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Auth_accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {auth_accountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Auth_accounts
     * const auth_account = await prisma.auth_account.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends auth_accountUpdateManyArgs>(args: SelectSubset<T, auth_accountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Auth_accounts and returns the data updated in the database.
     * @param {auth_accountUpdateManyAndReturnArgs} args - Arguments to update many Auth_accounts.
     * @example
     * // Update many Auth_accounts
     * const auth_account = await prisma.auth_account.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Auth_accounts and only return the `id`
     * const auth_accountWithIdOnly = await prisma.auth_account.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends auth_accountUpdateManyAndReturnArgs>(args: SelectSubset<T, auth_accountUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$auth_accountPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Auth_account.
     * @param {auth_accountUpsertArgs} args - Arguments to update or create a Auth_account.
     * @example
     * // Update or create a Auth_account
     * const auth_account = await prisma.auth_account.upsert({
     *   create: {
     *     // ... data to create a Auth_account
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Auth_account we want to update
     *   }
     * })
     */
    upsert<T extends auth_accountUpsertArgs>(args: SelectSubset<T, auth_accountUpsertArgs<ExtArgs>>): Prisma__auth_accountClient<$Result.GetResult<Prisma.$auth_accountPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Auth_accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {auth_accountCountArgs} args - Arguments to filter Auth_accounts to count.
     * @example
     * // Count the number of Auth_accounts
     * const count = await prisma.auth_account.count({
     *   where: {
     *     // ... the filter for the Auth_accounts we want to count
     *   }
     * })
    **/
    count<T extends auth_accountCountArgs>(
      args?: Subset<T, auth_accountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Auth_accountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Auth_account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Auth_accountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Auth_accountAggregateArgs>(args: Subset<T, Auth_accountAggregateArgs>): Prisma.PrismaPromise<GetAuth_accountAggregateType<T>>

    /**
     * Group by Auth_account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {auth_accountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends auth_accountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: auth_accountGroupByArgs['orderBy'] }
        : { orderBy?: auth_accountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, auth_accountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuth_accountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the auth_account model
   */
  readonly fields: auth_accountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for auth_account.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__auth_accountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    affiliate<T extends auth_account$affiliateArgs<ExtArgs> = {}>(args?: Subset<T, auth_account$affiliateArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$affiliatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    auth_user<T extends auth_account$auth_userArgs<ExtArgs> = {}>(args?: Subset<T, auth_account$auth_userArgs<ExtArgs>>): Prisma__auth_userClient<$Result.GetResult<Prisma.$auth_userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    author<T extends auth_account$authorArgs<ExtArgs> = {}>(args?: Subset<T, auth_account$authorArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$authorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    customer<T extends auth_account$customerArgs<ExtArgs> = {}>(args?: Subset<T, auth_account$customerArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$customerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    internal<T extends auth_account$internalArgs<ExtArgs> = {}>(args?: Subset<T, auth_account$internalArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$internalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    publisher<T extends auth_account$publisherArgs<ExtArgs> = {}>(args?: Subset<T, auth_account$publisherArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$publisherPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the auth_account model
   */
  interface auth_accountFieldRefs {
    readonly id: FieldRef<"auth_account", 'String'>
    readonly password: FieldRef<"auth_account", 'String'>
    readonly id_provider: FieldRef<"auth_account", 'String'>
    readonly access_token: FieldRef<"auth_account", 'String'>
    readonly refresh_token: FieldRef<"auth_account", 'String'>
    readonly id_token: FieldRef<"auth_account", 'String'>
    readonly access_token_expires_at: FieldRef<"auth_account", 'DateTime'>
    readonly refresh_token_expires_at: FieldRef<"auth_account", 'DateTime'>
    readonly scope: FieldRef<"auth_account", 'String'>
    readonly created_at: FieldRef<"auth_account", 'DateTime'>
    readonly updated_at: FieldRef<"auth_account", 'DateTime'>
    readonly id_user: FieldRef<"auth_account", 'String'>
    readonly id_account: FieldRef<"auth_account", 'String'>
  }
    

  // Custom InputTypes
  /**
   * auth_account findUnique
   */
  export type auth_accountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auth_account
     */
    select?: auth_accountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the auth_account
     */
    omit?: auth_accountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auth_accountInclude<ExtArgs> | null
    /**
     * Filter, which auth_account to fetch.
     */
    where: auth_accountWhereUniqueInput
  }

  /**
   * auth_account findUniqueOrThrow
   */
  export type auth_accountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auth_account
     */
    select?: auth_accountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the auth_account
     */
    omit?: auth_accountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auth_accountInclude<ExtArgs> | null
    /**
     * Filter, which auth_account to fetch.
     */
    where: auth_accountWhereUniqueInput
  }

  /**
   * auth_account findFirst
   */
  export type auth_accountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auth_account
     */
    select?: auth_accountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the auth_account
     */
    omit?: auth_accountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auth_accountInclude<ExtArgs> | null
    /**
     * Filter, which auth_account to fetch.
     */
    where?: auth_accountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of auth_accounts to fetch.
     */
    orderBy?: auth_accountOrderByWithRelationInput | auth_accountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for auth_accounts.
     */
    cursor?: auth_accountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` auth_accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` auth_accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of auth_accounts.
     */
    distinct?: Auth_accountScalarFieldEnum | Auth_accountScalarFieldEnum[]
  }

  /**
   * auth_account findFirstOrThrow
   */
  export type auth_accountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auth_account
     */
    select?: auth_accountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the auth_account
     */
    omit?: auth_accountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auth_accountInclude<ExtArgs> | null
    /**
     * Filter, which auth_account to fetch.
     */
    where?: auth_accountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of auth_accounts to fetch.
     */
    orderBy?: auth_accountOrderByWithRelationInput | auth_accountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for auth_accounts.
     */
    cursor?: auth_accountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` auth_accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` auth_accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of auth_accounts.
     */
    distinct?: Auth_accountScalarFieldEnum | Auth_accountScalarFieldEnum[]
  }

  /**
   * auth_account findMany
   */
  export type auth_accountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auth_account
     */
    select?: auth_accountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the auth_account
     */
    omit?: auth_accountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auth_accountInclude<ExtArgs> | null
    /**
     * Filter, which auth_accounts to fetch.
     */
    where?: auth_accountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of auth_accounts to fetch.
     */
    orderBy?: auth_accountOrderByWithRelationInput | auth_accountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing auth_accounts.
     */
    cursor?: auth_accountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` auth_accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` auth_accounts.
     */
    skip?: number
    distinct?: Auth_accountScalarFieldEnum | Auth_accountScalarFieldEnum[]
  }

  /**
   * auth_account create
   */
  export type auth_accountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auth_account
     */
    select?: auth_accountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the auth_account
     */
    omit?: auth_accountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auth_accountInclude<ExtArgs> | null
    /**
     * The data needed to create a auth_account.
     */
    data?: XOR<auth_accountCreateInput, auth_accountUncheckedCreateInput>
  }

  /**
   * auth_account createMany
   */
  export type auth_accountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many auth_accounts.
     */
    data: auth_accountCreateManyInput | auth_accountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * auth_account createManyAndReturn
   */
  export type auth_accountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auth_account
     */
    select?: auth_accountSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the auth_account
     */
    omit?: auth_accountOmit<ExtArgs> | null
    /**
     * The data used to create many auth_accounts.
     */
    data: auth_accountCreateManyInput | auth_accountCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auth_accountIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * auth_account update
   */
  export type auth_accountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auth_account
     */
    select?: auth_accountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the auth_account
     */
    omit?: auth_accountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auth_accountInclude<ExtArgs> | null
    /**
     * The data needed to update a auth_account.
     */
    data: XOR<auth_accountUpdateInput, auth_accountUncheckedUpdateInput>
    /**
     * Choose, which auth_account to update.
     */
    where: auth_accountWhereUniqueInput
  }

  /**
   * auth_account updateMany
   */
  export type auth_accountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update auth_accounts.
     */
    data: XOR<auth_accountUpdateManyMutationInput, auth_accountUncheckedUpdateManyInput>
    /**
     * Filter which auth_accounts to update
     */
    where?: auth_accountWhereInput
    /**
     * Limit how many auth_accounts to update.
     */
    limit?: number
  }

  /**
   * auth_account updateManyAndReturn
   */
  export type auth_accountUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auth_account
     */
    select?: auth_accountSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the auth_account
     */
    omit?: auth_accountOmit<ExtArgs> | null
    /**
     * The data used to update auth_accounts.
     */
    data: XOR<auth_accountUpdateManyMutationInput, auth_accountUncheckedUpdateManyInput>
    /**
     * Filter which auth_accounts to update
     */
    where?: auth_accountWhereInput
    /**
     * Limit how many auth_accounts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auth_accountIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * auth_account upsert
   */
  export type auth_accountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auth_account
     */
    select?: auth_accountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the auth_account
     */
    omit?: auth_accountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auth_accountInclude<ExtArgs> | null
    /**
     * The filter to search for the auth_account to update in case it exists.
     */
    where: auth_accountWhereUniqueInput
    /**
     * In case the auth_account found by the `where` argument doesn't exist, create a new auth_account with this data.
     */
    create: XOR<auth_accountCreateInput, auth_accountUncheckedCreateInput>
    /**
     * In case the auth_account was found with the provided `where` argument, update it with this data.
     */
    update: XOR<auth_accountUpdateInput, auth_accountUncheckedUpdateInput>
  }

  /**
   * auth_account delete
   */
  export type auth_accountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auth_account
     */
    select?: auth_accountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the auth_account
     */
    omit?: auth_accountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auth_accountInclude<ExtArgs> | null
    /**
     * Filter which auth_account to delete.
     */
    where: auth_accountWhereUniqueInput
  }

  /**
   * auth_account deleteMany
   */
  export type auth_accountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which auth_accounts to delete
     */
    where?: auth_accountWhereInput
    /**
     * Limit how many auth_accounts to delete.
     */
    limit?: number
  }

  /**
   * auth_account.affiliate
   */
  export type auth_account$affiliateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the affiliate
     */
    select?: affiliateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the affiliate
     */
    omit?: affiliateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: affiliateInclude<ExtArgs> | null
    where?: affiliateWhereInput
    orderBy?: affiliateOrderByWithRelationInput | affiliateOrderByWithRelationInput[]
    cursor?: affiliateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AffiliateScalarFieldEnum | AffiliateScalarFieldEnum[]
  }

  /**
   * auth_account.auth_user
   */
  export type auth_account$auth_userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auth_user
     */
    select?: auth_userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the auth_user
     */
    omit?: auth_userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auth_userInclude<ExtArgs> | null
    where?: auth_userWhereInput
  }

  /**
   * auth_account.author
   */
  export type auth_account$authorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the author
     */
    select?: authorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the author
     */
    omit?: authorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: authorInclude<ExtArgs> | null
    where?: authorWhereInput
    orderBy?: authorOrderByWithRelationInput | authorOrderByWithRelationInput[]
    cursor?: authorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuthorScalarFieldEnum | AuthorScalarFieldEnum[]
  }

  /**
   * auth_account.customer
   */
  export type auth_account$customerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer
     */
    select?: customerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customer
     */
    omit?: customerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customerInclude<ExtArgs> | null
    where?: customerWhereInput
    orderBy?: customerOrderByWithRelationInput | customerOrderByWithRelationInput[]
    cursor?: customerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * auth_account.internal
   */
  export type auth_account$internalArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the internal
     */
    select?: internalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the internal
     */
    omit?: internalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: internalInclude<ExtArgs> | null
    where?: internalWhereInput
    orderBy?: internalOrderByWithRelationInput | internalOrderByWithRelationInput[]
    cursor?: internalWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InternalScalarFieldEnum | InternalScalarFieldEnum[]
  }

  /**
   * auth_account.publisher
   */
  export type auth_account$publisherArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the publisher
     */
    select?: publisherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the publisher
     */
    omit?: publisherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: publisherInclude<ExtArgs> | null
    where?: publisherWhereInput
    orderBy?: publisherOrderByWithRelationInput | publisherOrderByWithRelationInput[]
    cursor?: publisherWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PublisherScalarFieldEnum | PublisherScalarFieldEnum[]
  }

  /**
   * auth_account without action
   */
  export type auth_accountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auth_account
     */
    select?: auth_accountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the auth_account
     */
    omit?: auth_accountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auth_accountInclude<ExtArgs> | null
  }


  /**
   * Model auth_session
   */

  export type AggregateAuth_session = {
    _count: Auth_sessionCountAggregateOutputType | null
    _min: Auth_sessionMinAggregateOutputType | null
    _max: Auth_sessionMaxAggregateOutputType | null
  }

  export type Auth_sessionMinAggregateOutputType = {
    id: string | null
    expires_at: Date | null
    token: string | null
    created_at: Date | null
    updated_at: Date | null
    ip_address: string | null
    user_agent: string | null
    id_user: string | null
  }

  export type Auth_sessionMaxAggregateOutputType = {
    id: string | null
    expires_at: Date | null
    token: string | null
    created_at: Date | null
    updated_at: Date | null
    ip_address: string | null
    user_agent: string | null
    id_user: string | null
  }

  export type Auth_sessionCountAggregateOutputType = {
    id: number
    expires_at: number
    token: number
    created_at: number
    updated_at: number
    ip_address: number
    user_agent: number
    id_user: number
    _all: number
  }


  export type Auth_sessionMinAggregateInputType = {
    id?: true
    expires_at?: true
    token?: true
    created_at?: true
    updated_at?: true
    ip_address?: true
    user_agent?: true
    id_user?: true
  }

  export type Auth_sessionMaxAggregateInputType = {
    id?: true
    expires_at?: true
    token?: true
    created_at?: true
    updated_at?: true
    ip_address?: true
    user_agent?: true
    id_user?: true
  }

  export type Auth_sessionCountAggregateInputType = {
    id?: true
    expires_at?: true
    token?: true
    created_at?: true
    updated_at?: true
    ip_address?: true
    user_agent?: true
    id_user?: true
    _all?: true
  }

  export type Auth_sessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which auth_session to aggregate.
     */
    where?: auth_sessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of auth_sessions to fetch.
     */
    orderBy?: auth_sessionOrderByWithRelationInput | auth_sessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: auth_sessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` auth_sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` auth_sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned auth_sessions
    **/
    _count?: true | Auth_sessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Auth_sessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Auth_sessionMaxAggregateInputType
  }

  export type GetAuth_sessionAggregateType<T extends Auth_sessionAggregateArgs> = {
        [P in keyof T & keyof AggregateAuth_session]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuth_session[P]>
      : GetScalarType<T[P], AggregateAuth_session[P]>
  }




  export type auth_sessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: auth_sessionWhereInput
    orderBy?: auth_sessionOrderByWithAggregationInput | auth_sessionOrderByWithAggregationInput[]
    by: Auth_sessionScalarFieldEnum[] | Auth_sessionScalarFieldEnum
    having?: auth_sessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Auth_sessionCountAggregateInputType | true
    _min?: Auth_sessionMinAggregateInputType
    _max?: Auth_sessionMaxAggregateInputType
  }

  export type Auth_sessionGroupByOutputType = {
    id: string
    expires_at: Date
    token: string
    created_at: Date
    updated_at: Date | null
    ip_address: string | null
    user_agent: string | null
    id_user: string
    _count: Auth_sessionCountAggregateOutputType | null
    _min: Auth_sessionMinAggregateOutputType | null
    _max: Auth_sessionMaxAggregateOutputType | null
  }

  type GetAuth_sessionGroupByPayload<T extends auth_sessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Auth_sessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Auth_sessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Auth_sessionGroupByOutputType[P]>
            : GetScalarType<T[P], Auth_sessionGroupByOutputType[P]>
        }
      >
    >


  export type auth_sessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    expires_at?: boolean
    token?: boolean
    created_at?: boolean
    updated_at?: boolean
    ip_address?: boolean
    user_agent?: boolean
    id_user?: boolean
    auth_user?: boolean | auth_userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auth_session"]>

  export type auth_sessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    expires_at?: boolean
    token?: boolean
    created_at?: boolean
    updated_at?: boolean
    ip_address?: boolean
    user_agent?: boolean
    id_user?: boolean
    auth_user?: boolean | auth_userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auth_session"]>

  export type auth_sessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    expires_at?: boolean
    token?: boolean
    created_at?: boolean
    updated_at?: boolean
    ip_address?: boolean
    user_agent?: boolean
    id_user?: boolean
    auth_user?: boolean | auth_userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auth_session"]>

  export type auth_sessionSelectScalar = {
    id?: boolean
    expires_at?: boolean
    token?: boolean
    created_at?: boolean
    updated_at?: boolean
    ip_address?: boolean
    user_agent?: boolean
    id_user?: boolean
  }

  export type auth_sessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "expires_at" | "token" | "created_at" | "updated_at" | "ip_address" | "user_agent" | "id_user", ExtArgs["result"]["auth_session"]>
  export type auth_sessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    auth_user?: boolean | auth_userDefaultArgs<ExtArgs>
  }
  export type auth_sessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    auth_user?: boolean | auth_userDefaultArgs<ExtArgs>
  }
  export type auth_sessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    auth_user?: boolean | auth_userDefaultArgs<ExtArgs>
  }

  export type $auth_sessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "auth_session"
    objects: {
      auth_user: Prisma.$auth_userPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      expires_at: Date
      token: string
      created_at: Date
      updated_at: Date | null
      ip_address: string | null
      user_agent: string | null
      id_user: string
    }, ExtArgs["result"]["auth_session"]>
    composites: {}
  }

  type auth_sessionGetPayload<S extends boolean | null | undefined | auth_sessionDefaultArgs> = $Result.GetResult<Prisma.$auth_sessionPayload, S>

  type auth_sessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<auth_sessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Auth_sessionCountAggregateInputType | true
    }

  export interface auth_sessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['auth_session'], meta: { name: 'auth_session' } }
    /**
     * Find zero or one Auth_session that matches the filter.
     * @param {auth_sessionFindUniqueArgs} args - Arguments to find a Auth_session
     * @example
     * // Get one Auth_session
     * const auth_session = await prisma.auth_session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends auth_sessionFindUniqueArgs>(args: SelectSubset<T, auth_sessionFindUniqueArgs<ExtArgs>>): Prisma__auth_sessionClient<$Result.GetResult<Prisma.$auth_sessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Auth_session that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {auth_sessionFindUniqueOrThrowArgs} args - Arguments to find a Auth_session
     * @example
     * // Get one Auth_session
     * const auth_session = await prisma.auth_session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends auth_sessionFindUniqueOrThrowArgs>(args: SelectSubset<T, auth_sessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__auth_sessionClient<$Result.GetResult<Prisma.$auth_sessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Auth_session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {auth_sessionFindFirstArgs} args - Arguments to find a Auth_session
     * @example
     * // Get one Auth_session
     * const auth_session = await prisma.auth_session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends auth_sessionFindFirstArgs>(args?: SelectSubset<T, auth_sessionFindFirstArgs<ExtArgs>>): Prisma__auth_sessionClient<$Result.GetResult<Prisma.$auth_sessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Auth_session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {auth_sessionFindFirstOrThrowArgs} args - Arguments to find a Auth_session
     * @example
     * // Get one Auth_session
     * const auth_session = await prisma.auth_session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends auth_sessionFindFirstOrThrowArgs>(args?: SelectSubset<T, auth_sessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__auth_sessionClient<$Result.GetResult<Prisma.$auth_sessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Auth_sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {auth_sessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Auth_sessions
     * const auth_sessions = await prisma.auth_session.findMany()
     * 
     * // Get first 10 Auth_sessions
     * const auth_sessions = await prisma.auth_session.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auth_sessionWithIdOnly = await prisma.auth_session.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends auth_sessionFindManyArgs>(args?: SelectSubset<T, auth_sessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$auth_sessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Auth_session.
     * @param {auth_sessionCreateArgs} args - Arguments to create a Auth_session.
     * @example
     * // Create one Auth_session
     * const Auth_session = await prisma.auth_session.create({
     *   data: {
     *     // ... data to create a Auth_session
     *   }
     * })
     * 
     */
    create<T extends auth_sessionCreateArgs>(args: SelectSubset<T, auth_sessionCreateArgs<ExtArgs>>): Prisma__auth_sessionClient<$Result.GetResult<Prisma.$auth_sessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Auth_sessions.
     * @param {auth_sessionCreateManyArgs} args - Arguments to create many Auth_sessions.
     * @example
     * // Create many Auth_sessions
     * const auth_session = await prisma.auth_session.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends auth_sessionCreateManyArgs>(args?: SelectSubset<T, auth_sessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Auth_sessions and returns the data saved in the database.
     * @param {auth_sessionCreateManyAndReturnArgs} args - Arguments to create many Auth_sessions.
     * @example
     * // Create many Auth_sessions
     * const auth_session = await prisma.auth_session.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Auth_sessions and only return the `id`
     * const auth_sessionWithIdOnly = await prisma.auth_session.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends auth_sessionCreateManyAndReturnArgs>(args?: SelectSubset<T, auth_sessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$auth_sessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Auth_session.
     * @param {auth_sessionDeleteArgs} args - Arguments to delete one Auth_session.
     * @example
     * // Delete one Auth_session
     * const Auth_session = await prisma.auth_session.delete({
     *   where: {
     *     // ... filter to delete one Auth_session
     *   }
     * })
     * 
     */
    delete<T extends auth_sessionDeleteArgs>(args: SelectSubset<T, auth_sessionDeleteArgs<ExtArgs>>): Prisma__auth_sessionClient<$Result.GetResult<Prisma.$auth_sessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Auth_session.
     * @param {auth_sessionUpdateArgs} args - Arguments to update one Auth_session.
     * @example
     * // Update one Auth_session
     * const auth_session = await prisma.auth_session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends auth_sessionUpdateArgs>(args: SelectSubset<T, auth_sessionUpdateArgs<ExtArgs>>): Prisma__auth_sessionClient<$Result.GetResult<Prisma.$auth_sessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Auth_sessions.
     * @param {auth_sessionDeleteManyArgs} args - Arguments to filter Auth_sessions to delete.
     * @example
     * // Delete a few Auth_sessions
     * const { count } = await prisma.auth_session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends auth_sessionDeleteManyArgs>(args?: SelectSubset<T, auth_sessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Auth_sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {auth_sessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Auth_sessions
     * const auth_session = await prisma.auth_session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends auth_sessionUpdateManyArgs>(args: SelectSubset<T, auth_sessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Auth_sessions and returns the data updated in the database.
     * @param {auth_sessionUpdateManyAndReturnArgs} args - Arguments to update many Auth_sessions.
     * @example
     * // Update many Auth_sessions
     * const auth_session = await prisma.auth_session.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Auth_sessions and only return the `id`
     * const auth_sessionWithIdOnly = await prisma.auth_session.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends auth_sessionUpdateManyAndReturnArgs>(args: SelectSubset<T, auth_sessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$auth_sessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Auth_session.
     * @param {auth_sessionUpsertArgs} args - Arguments to update or create a Auth_session.
     * @example
     * // Update or create a Auth_session
     * const auth_session = await prisma.auth_session.upsert({
     *   create: {
     *     // ... data to create a Auth_session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Auth_session we want to update
     *   }
     * })
     */
    upsert<T extends auth_sessionUpsertArgs>(args: SelectSubset<T, auth_sessionUpsertArgs<ExtArgs>>): Prisma__auth_sessionClient<$Result.GetResult<Prisma.$auth_sessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Auth_sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {auth_sessionCountArgs} args - Arguments to filter Auth_sessions to count.
     * @example
     * // Count the number of Auth_sessions
     * const count = await prisma.auth_session.count({
     *   where: {
     *     // ... the filter for the Auth_sessions we want to count
     *   }
     * })
    **/
    count<T extends auth_sessionCountArgs>(
      args?: Subset<T, auth_sessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Auth_sessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Auth_session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Auth_sessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Auth_sessionAggregateArgs>(args: Subset<T, Auth_sessionAggregateArgs>): Prisma.PrismaPromise<GetAuth_sessionAggregateType<T>>

    /**
     * Group by Auth_session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {auth_sessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends auth_sessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: auth_sessionGroupByArgs['orderBy'] }
        : { orderBy?: auth_sessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, auth_sessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuth_sessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the auth_session model
   */
  readonly fields: auth_sessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for auth_session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__auth_sessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    auth_user<T extends auth_userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, auth_userDefaultArgs<ExtArgs>>): Prisma__auth_userClient<$Result.GetResult<Prisma.$auth_userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the auth_session model
   */
  interface auth_sessionFieldRefs {
    readonly id: FieldRef<"auth_session", 'String'>
    readonly expires_at: FieldRef<"auth_session", 'DateTime'>
    readonly token: FieldRef<"auth_session", 'String'>
    readonly created_at: FieldRef<"auth_session", 'DateTime'>
    readonly updated_at: FieldRef<"auth_session", 'DateTime'>
    readonly ip_address: FieldRef<"auth_session", 'String'>
    readonly user_agent: FieldRef<"auth_session", 'String'>
    readonly id_user: FieldRef<"auth_session", 'String'>
  }
    

  // Custom InputTypes
  /**
   * auth_session findUnique
   */
  export type auth_sessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auth_session
     */
    select?: auth_sessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the auth_session
     */
    omit?: auth_sessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auth_sessionInclude<ExtArgs> | null
    /**
     * Filter, which auth_session to fetch.
     */
    where: auth_sessionWhereUniqueInput
  }

  /**
   * auth_session findUniqueOrThrow
   */
  export type auth_sessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auth_session
     */
    select?: auth_sessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the auth_session
     */
    omit?: auth_sessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auth_sessionInclude<ExtArgs> | null
    /**
     * Filter, which auth_session to fetch.
     */
    where: auth_sessionWhereUniqueInput
  }

  /**
   * auth_session findFirst
   */
  export type auth_sessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auth_session
     */
    select?: auth_sessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the auth_session
     */
    omit?: auth_sessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auth_sessionInclude<ExtArgs> | null
    /**
     * Filter, which auth_session to fetch.
     */
    where?: auth_sessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of auth_sessions to fetch.
     */
    orderBy?: auth_sessionOrderByWithRelationInput | auth_sessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for auth_sessions.
     */
    cursor?: auth_sessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` auth_sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` auth_sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of auth_sessions.
     */
    distinct?: Auth_sessionScalarFieldEnum | Auth_sessionScalarFieldEnum[]
  }

  /**
   * auth_session findFirstOrThrow
   */
  export type auth_sessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auth_session
     */
    select?: auth_sessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the auth_session
     */
    omit?: auth_sessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auth_sessionInclude<ExtArgs> | null
    /**
     * Filter, which auth_session to fetch.
     */
    where?: auth_sessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of auth_sessions to fetch.
     */
    orderBy?: auth_sessionOrderByWithRelationInput | auth_sessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for auth_sessions.
     */
    cursor?: auth_sessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` auth_sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` auth_sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of auth_sessions.
     */
    distinct?: Auth_sessionScalarFieldEnum | Auth_sessionScalarFieldEnum[]
  }

  /**
   * auth_session findMany
   */
  export type auth_sessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auth_session
     */
    select?: auth_sessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the auth_session
     */
    omit?: auth_sessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auth_sessionInclude<ExtArgs> | null
    /**
     * Filter, which auth_sessions to fetch.
     */
    where?: auth_sessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of auth_sessions to fetch.
     */
    orderBy?: auth_sessionOrderByWithRelationInput | auth_sessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing auth_sessions.
     */
    cursor?: auth_sessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` auth_sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` auth_sessions.
     */
    skip?: number
    distinct?: Auth_sessionScalarFieldEnum | Auth_sessionScalarFieldEnum[]
  }

  /**
   * auth_session create
   */
  export type auth_sessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auth_session
     */
    select?: auth_sessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the auth_session
     */
    omit?: auth_sessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auth_sessionInclude<ExtArgs> | null
    /**
     * The data needed to create a auth_session.
     */
    data: XOR<auth_sessionCreateInput, auth_sessionUncheckedCreateInput>
  }

  /**
   * auth_session createMany
   */
  export type auth_sessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many auth_sessions.
     */
    data: auth_sessionCreateManyInput | auth_sessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * auth_session createManyAndReturn
   */
  export type auth_sessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auth_session
     */
    select?: auth_sessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the auth_session
     */
    omit?: auth_sessionOmit<ExtArgs> | null
    /**
     * The data used to create many auth_sessions.
     */
    data: auth_sessionCreateManyInput | auth_sessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auth_sessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * auth_session update
   */
  export type auth_sessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auth_session
     */
    select?: auth_sessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the auth_session
     */
    omit?: auth_sessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auth_sessionInclude<ExtArgs> | null
    /**
     * The data needed to update a auth_session.
     */
    data: XOR<auth_sessionUpdateInput, auth_sessionUncheckedUpdateInput>
    /**
     * Choose, which auth_session to update.
     */
    where: auth_sessionWhereUniqueInput
  }

  /**
   * auth_session updateMany
   */
  export type auth_sessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update auth_sessions.
     */
    data: XOR<auth_sessionUpdateManyMutationInput, auth_sessionUncheckedUpdateManyInput>
    /**
     * Filter which auth_sessions to update
     */
    where?: auth_sessionWhereInput
    /**
     * Limit how many auth_sessions to update.
     */
    limit?: number
  }

  /**
   * auth_session updateManyAndReturn
   */
  export type auth_sessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auth_session
     */
    select?: auth_sessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the auth_session
     */
    omit?: auth_sessionOmit<ExtArgs> | null
    /**
     * The data used to update auth_sessions.
     */
    data: XOR<auth_sessionUpdateManyMutationInput, auth_sessionUncheckedUpdateManyInput>
    /**
     * Filter which auth_sessions to update
     */
    where?: auth_sessionWhereInput
    /**
     * Limit how many auth_sessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auth_sessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * auth_session upsert
   */
  export type auth_sessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auth_session
     */
    select?: auth_sessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the auth_session
     */
    omit?: auth_sessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auth_sessionInclude<ExtArgs> | null
    /**
     * The filter to search for the auth_session to update in case it exists.
     */
    where: auth_sessionWhereUniqueInput
    /**
     * In case the auth_session found by the `where` argument doesn't exist, create a new auth_session with this data.
     */
    create: XOR<auth_sessionCreateInput, auth_sessionUncheckedCreateInput>
    /**
     * In case the auth_session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<auth_sessionUpdateInput, auth_sessionUncheckedUpdateInput>
  }

  /**
   * auth_session delete
   */
  export type auth_sessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auth_session
     */
    select?: auth_sessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the auth_session
     */
    omit?: auth_sessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auth_sessionInclude<ExtArgs> | null
    /**
     * Filter which auth_session to delete.
     */
    where: auth_sessionWhereUniqueInput
  }

  /**
   * auth_session deleteMany
   */
  export type auth_sessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which auth_sessions to delete
     */
    where?: auth_sessionWhereInput
    /**
     * Limit how many auth_sessions to delete.
     */
    limit?: number
  }

  /**
   * auth_session without action
   */
  export type auth_sessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auth_session
     */
    select?: auth_sessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the auth_session
     */
    omit?: auth_sessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auth_sessionInclude<ExtArgs> | null
  }


  /**
   * Model auth_two_factor
   */

  export type AggregateAuth_two_factor = {
    _count: Auth_two_factorCountAggregateOutputType | null
    _min: Auth_two_factorMinAggregateOutputType | null
    _max: Auth_two_factorMaxAggregateOutputType | null
  }

  export type Auth_two_factorMinAggregateOutputType = {
    id: string | null
    secret: string | null
    backup_codes: string | null
    id_user: string | null
  }

  export type Auth_two_factorMaxAggregateOutputType = {
    id: string | null
    secret: string | null
    backup_codes: string | null
    id_user: string | null
  }

  export type Auth_two_factorCountAggregateOutputType = {
    id: number
    secret: number
    backup_codes: number
    id_user: number
    _all: number
  }


  export type Auth_two_factorMinAggregateInputType = {
    id?: true
    secret?: true
    backup_codes?: true
    id_user?: true
  }

  export type Auth_two_factorMaxAggregateInputType = {
    id?: true
    secret?: true
    backup_codes?: true
    id_user?: true
  }

  export type Auth_two_factorCountAggregateInputType = {
    id?: true
    secret?: true
    backup_codes?: true
    id_user?: true
    _all?: true
  }

  export type Auth_two_factorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which auth_two_factor to aggregate.
     */
    where?: auth_two_factorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of auth_two_factors to fetch.
     */
    orderBy?: auth_two_factorOrderByWithRelationInput | auth_two_factorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: auth_two_factorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` auth_two_factors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` auth_two_factors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned auth_two_factors
    **/
    _count?: true | Auth_two_factorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Auth_two_factorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Auth_two_factorMaxAggregateInputType
  }

  export type GetAuth_two_factorAggregateType<T extends Auth_two_factorAggregateArgs> = {
        [P in keyof T & keyof AggregateAuth_two_factor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuth_two_factor[P]>
      : GetScalarType<T[P], AggregateAuth_two_factor[P]>
  }




  export type auth_two_factorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: auth_two_factorWhereInput
    orderBy?: auth_two_factorOrderByWithAggregationInput | auth_two_factorOrderByWithAggregationInput[]
    by: Auth_two_factorScalarFieldEnum[] | Auth_two_factorScalarFieldEnum
    having?: auth_two_factorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Auth_two_factorCountAggregateInputType | true
    _min?: Auth_two_factorMinAggregateInputType
    _max?: Auth_two_factorMaxAggregateInputType
  }

  export type Auth_two_factorGroupByOutputType = {
    id: string
    secret: string | null
    backup_codes: string | null
    id_user: string
    _count: Auth_two_factorCountAggregateOutputType | null
    _min: Auth_two_factorMinAggregateOutputType | null
    _max: Auth_two_factorMaxAggregateOutputType | null
  }

  type GetAuth_two_factorGroupByPayload<T extends auth_two_factorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Auth_two_factorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Auth_two_factorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Auth_two_factorGroupByOutputType[P]>
            : GetScalarType<T[P], Auth_two_factorGroupByOutputType[P]>
        }
      >
    >


  export type auth_two_factorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    secret?: boolean
    backup_codes?: boolean
    id_user?: boolean
    auth_user?: boolean | auth_userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auth_two_factor"]>

  export type auth_two_factorSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    secret?: boolean
    backup_codes?: boolean
    id_user?: boolean
    auth_user?: boolean | auth_userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auth_two_factor"]>

  export type auth_two_factorSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    secret?: boolean
    backup_codes?: boolean
    id_user?: boolean
    auth_user?: boolean | auth_userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auth_two_factor"]>

  export type auth_two_factorSelectScalar = {
    id?: boolean
    secret?: boolean
    backup_codes?: boolean
    id_user?: boolean
  }

  export type auth_two_factorOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "secret" | "backup_codes" | "id_user", ExtArgs["result"]["auth_two_factor"]>
  export type auth_two_factorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    auth_user?: boolean | auth_userDefaultArgs<ExtArgs>
  }
  export type auth_two_factorIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    auth_user?: boolean | auth_userDefaultArgs<ExtArgs>
  }
  export type auth_two_factorIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    auth_user?: boolean | auth_userDefaultArgs<ExtArgs>
  }

  export type $auth_two_factorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "auth_two_factor"
    objects: {
      auth_user: Prisma.$auth_userPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      secret: string | null
      backup_codes: string | null
      id_user: string
    }, ExtArgs["result"]["auth_two_factor"]>
    composites: {}
  }

  type auth_two_factorGetPayload<S extends boolean | null | undefined | auth_two_factorDefaultArgs> = $Result.GetResult<Prisma.$auth_two_factorPayload, S>

  type auth_two_factorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<auth_two_factorFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Auth_two_factorCountAggregateInputType | true
    }

  export interface auth_two_factorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['auth_two_factor'], meta: { name: 'auth_two_factor' } }
    /**
     * Find zero or one Auth_two_factor that matches the filter.
     * @param {auth_two_factorFindUniqueArgs} args - Arguments to find a Auth_two_factor
     * @example
     * // Get one Auth_two_factor
     * const auth_two_factor = await prisma.auth_two_factor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends auth_two_factorFindUniqueArgs>(args: SelectSubset<T, auth_two_factorFindUniqueArgs<ExtArgs>>): Prisma__auth_two_factorClient<$Result.GetResult<Prisma.$auth_two_factorPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Auth_two_factor that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {auth_two_factorFindUniqueOrThrowArgs} args - Arguments to find a Auth_two_factor
     * @example
     * // Get one Auth_two_factor
     * const auth_two_factor = await prisma.auth_two_factor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends auth_two_factorFindUniqueOrThrowArgs>(args: SelectSubset<T, auth_two_factorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__auth_two_factorClient<$Result.GetResult<Prisma.$auth_two_factorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Auth_two_factor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {auth_two_factorFindFirstArgs} args - Arguments to find a Auth_two_factor
     * @example
     * // Get one Auth_two_factor
     * const auth_two_factor = await prisma.auth_two_factor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends auth_two_factorFindFirstArgs>(args?: SelectSubset<T, auth_two_factorFindFirstArgs<ExtArgs>>): Prisma__auth_two_factorClient<$Result.GetResult<Prisma.$auth_two_factorPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Auth_two_factor that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {auth_two_factorFindFirstOrThrowArgs} args - Arguments to find a Auth_two_factor
     * @example
     * // Get one Auth_two_factor
     * const auth_two_factor = await prisma.auth_two_factor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends auth_two_factorFindFirstOrThrowArgs>(args?: SelectSubset<T, auth_two_factorFindFirstOrThrowArgs<ExtArgs>>): Prisma__auth_two_factorClient<$Result.GetResult<Prisma.$auth_two_factorPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Auth_two_factors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {auth_two_factorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Auth_two_factors
     * const auth_two_factors = await prisma.auth_two_factor.findMany()
     * 
     * // Get first 10 Auth_two_factors
     * const auth_two_factors = await prisma.auth_two_factor.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auth_two_factorWithIdOnly = await prisma.auth_two_factor.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends auth_two_factorFindManyArgs>(args?: SelectSubset<T, auth_two_factorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$auth_two_factorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Auth_two_factor.
     * @param {auth_two_factorCreateArgs} args - Arguments to create a Auth_two_factor.
     * @example
     * // Create one Auth_two_factor
     * const Auth_two_factor = await prisma.auth_two_factor.create({
     *   data: {
     *     // ... data to create a Auth_two_factor
     *   }
     * })
     * 
     */
    create<T extends auth_two_factorCreateArgs>(args: SelectSubset<T, auth_two_factorCreateArgs<ExtArgs>>): Prisma__auth_two_factorClient<$Result.GetResult<Prisma.$auth_two_factorPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Auth_two_factors.
     * @param {auth_two_factorCreateManyArgs} args - Arguments to create many Auth_two_factors.
     * @example
     * // Create many Auth_two_factors
     * const auth_two_factor = await prisma.auth_two_factor.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends auth_two_factorCreateManyArgs>(args?: SelectSubset<T, auth_two_factorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Auth_two_factors and returns the data saved in the database.
     * @param {auth_two_factorCreateManyAndReturnArgs} args - Arguments to create many Auth_two_factors.
     * @example
     * // Create many Auth_two_factors
     * const auth_two_factor = await prisma.auth_two_factor.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Auth_two_factors and only return the `id`
     * const auth_two_factorWithIdOnly = await prisma.auth_two_factor.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends auth_two_factorCreateManyAndReturnArgs>(args?: SelectSubset<T, auth_two_factorCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$auth_two_factorPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Auth_two_factor.
     * @param {auth_two_factorDeleteArgs} args - Arguments to delete one Auth_two_factor.
     * @example
     * // Delete one Auth_two_factor
     * const Auth_two_factor = await prisma.auth_two_factor.delete({
     *   where: {
     *     // ... filter to delete one Auth_two_factor
     *   }
     * })
     * 
     */
    delete<T extends auth_two_factorDeleteArgs>(args: SelectSubset<T, auth_two_factorDeleteArgs<ExtArgs>>): Prisma__auth_two_factorClient<$Result.GetResult<Prisma.$auth_two_factorPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Auth_two_factor.
     * @param {auth_two_factorUpdateArgs} args - Arguments to update one Auth_two_factor.
     * @example
     * // Update one Auth_two_factor
     * const auth_two_factor = await prisma.auth_two_factor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends auth_two_factorUpdateArgs>(args: SelectSubset<T, auth_two_factorUpdateArgs<ExtArgs>>): Prisma__auth_two_factorClient<$Result.GetResult<Prisma.$auth_two_factorPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Auth_two_factors.
     * @param {auth_two_factorDeleteManyArgs} args - Arguments to filter Auth_two_factors to delete.
     * @example
     * // Delete a few Auth_two_factors
     * const { count } = await prisma.auth_two_factor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends auth_two_factorDeleteManyArgs>(args?: SelectSubset<T, auth_two_factorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Auth_two_factors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {auth_two_factorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Auth_two_factors
     * const auth_two_factor = await prisma.auth_two_factor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends auth_two_factorUpdateManyArgs>(args: SelectSubset<T, auth_two_factorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Auth_two_factors and returns the data updated in the database.
     * @param {auth_two_factorUpdateManyAndReturnArgs} args - Arguments to update many Auth_two_factors.
     * @example
     * // Update many Auth_two_factors
     * const auth_two_factor = await prisma.auth_two_factor.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Auth_two_factors and only return the `id`
     * const auth_two_factorWithIdOnly = await prisma.auth_two_factor.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends auth_two_factorUpdateManyAndReturnArgs>(args: SelectSubset<T, auth_two_factorUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$auth_two_factorPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Auth_two_factor.
     * @param {auth_two_factorUpsertArgs} args - Arguments to update or create a Auth_two_factor.
     * @example
     * // Update or create a Auth_two_factor
     * const auth_two_factor = await prisma.auth_two_factor.upsert({
     *   create: {
     *     // ... data to create a Auth_two_factor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Auth_two_factor we want to update
     *   }
     * })
     */
    upsert<T extends auth_two_factorUpsertArgs>(args: SelectSubset<T, auth_two_factorUpsertArgs<ExtArgs>>): Prisma__auth_two_factorClient<$Result.GetResult<Prisma.$auth_two_factorPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Auth_two_factors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {auth_two_factorCountArgs} args - Arguments to filter Auth_two_factors to count.
     * @example
     * // Count the number of Auth_two_factors
     * const count = await prisma.auth_two_factor.count({
     *   where: {
     *     // ... the filter for the Auth_two_factors we want to count
     *   }
     * })
    **/
    count<T extends auth_two_factorCountArgs>(
      args?: Subset<T, auth_two_factorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Auth_two_factorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Auth_two_factor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Auth_two_factorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Auth_two_factorAggregateArgs>(args: Subset<T, Auth_two_factorAggregateArgs>): Prisma.PrismaPromise<GetAuth_two_factorAggregateType<T>>

    /**
     * Group by Auth_two_factor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {auth_two_factorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends auth_two_factorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: auth_two_factorGroupByArgs['orderBy'] }
        : { orderBy?: auth_two_factorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, auth_two_factorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuth_two_factorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the auth_two_factor model
   */
  readonly fields: auth_two_factorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for auth_two_factor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__auth_two_factorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    auth_user<T extends auth_userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, auth_userDefaultArgs<ExtArgs>>): Prisma__auth_userClient<$Result.GetResult<Prisma.$auth_userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the auth_two_factor model
   */
  interface auth_two_factorFieldRefs {
    readonly id: FieldRef<"auth_two_factor", 'String'>
    readonly secret: FieldRef<"auth_two_factor", 'String'>
    readonly backup_codes: FieldRef<"auth_two_factor", 'String'>
    readonly id_user: FieldRef<"auth_two_factor", 'String'>
  }
    

  // Custom InputTypes
  /**
   * auth_two_factor findUnique
   */
  export type auth_two_factorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auth_two_factor
     */
    select?: auth_two_factorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the auth_two_factor
     */
    omit?: auth_two_factorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auth_two_factorInclude<ExtArgs> | null
    /**
     * Filter, which auth_two_factor to fetch.
     */
    where: auth_two_factorWhereUniqueInput
  }

  /**
   * auth_two_factor findUniqueOrThrow
   */
  export type auth_two_factorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auth_two_factor
     */
    select?: auth_two_factorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the auth_two_factor
     */
    omit?: auth_two_factorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auth_two_factorInclude<ExtArgs> | null
    /**
     * Filter, which auth_two_factor to fetch.
     */
    where: auth_two_factorWhereUniqueInput
  }

  /**
   * auth_two_factor findFirst
   */
  export type auth_two_factorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auth_two_factor
     */
    select?: auth_two_factorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the auth_two_factor
     */
    omit?: auth_two_factorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auth_two_factorInclude<ExtArgs> | null
    /**
     * Filter, which auth_two_factor to fetch.
     */
    where?: auth_two_factorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of auth_two_factors to fetch.
     */
    orderBy?: auth_two_factorOrderByWithRelationInput | auth_two_factorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for auth_two_factors.
     */
    cursor?: auth_two_factorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` auth_two_factors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` auth_two_factors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of auth_two_factors.
     */
    distinct?: Auth_two_factorScalarFieldEnum | Auth_two_factorScalarFieldEnum[]
  }

  /**
   * auth_two_factor findFirstOrThrow
   */
  export type auth_two_factorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auth_two_factor
     */
    select?: auth_two_factorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the auth_two_factor
     */
    omit?: auth_two_factorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auth_two_factorInclude<ExtArgs> | null
    /**
     * Filter, which auth_two_factor to fetch.
     */
    where?: auth_two_factorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of auth_two_factors to fetch.
     */
    orderBy?: auth_two_factorOrderByWithRelationInput | auth_two_factorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for auth_two_factors.
     */
    cursor?: auth_two_factorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` auth_two_factors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` auth_two_factors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of auth_two_factors.
     */
    distinct?: Auth_two_factorScalarFieldEnum | Auth_two_factorScalarFieldEnum[]
  }

  /**
   * auth_two_factor findMany
   */
  export type auth_two_factorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auth_two_factor
     */
    select?: auth_two_factorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the auth_two_factor
     */
    omit?: auth_two_factorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auth_two_factorInclude<ExtArgs> | null
    /**
     * Filter, which auth_two_factors to fetch.
     */
    where?: auth_two_factorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of auth_two_factors to fetch.
     */
    orderBy?: auth_two_factorOrderByWithRelationInput | auth_two_factorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing auth_two_factors.
     */
    cursor?: auth_two_factorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` auth_two_factors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` auth_two_factors.
     */
    skip?: number
    distinct?: Auth_two_factorScalarFieldEnum | Auth_two_factorScalarFieldEnum[]
  }

  /**
   * auth_two_factor create
   */
  export type auth_two_factorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auth_two_factor
     */
    select?: auth_two_factorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the auth_two_factor
     */
    omit?: auth_two_factorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auth_two_factorInclude<ExtArgs> | null
    /**
     * The data needed to create a auth_two_factor.
     */
    data: XOR<auth_two_factorCreateInput, auth_two_factorUncheckedCreateInput>
  }

  /**
   * auth_two_factor createMany
   */
  export type auth_two_factorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many auth_two_factors.
     */
    data: auth_two_factorCreateManyInput | auth_two_factorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * auth_two_factor createManyAndReturn
   */
  export type auth_two_factorCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auth_two_factor
     */
    select?: auth_two_factorSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the auth_two_factor
     */
    omit?: auth_two_factorOmit<ExtArgs> | null
    /**
     * The data used to create many auth_two_factors.
     */
    data: auth_two_factorCreateManyInput | auth_two_factorCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auth_two_factorIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * auth_two_factor update
   */
  export type auth_two_factorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auth_two_factor
     */
    select?: auth_two_factorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the auth_two_factor
     */
    omit?: auth_two_factorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auth_two_factorInclude<ExtArgs> | null
    /**
     * The data needed to update a auth_two_factor.
     */
    data: XOR<auth_two_factorUpdateInput, auth_two_factorUncheckedUpdateInput>
    /**
     * Choose, which auth_two_factor to update.
     */
    where: auth_two_factorWhereUniqueInput
  }

  /**
   * auth_two_factor updateMany
   */
  export type auth_two_factorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update auth_two_factors.
     */
    data: XOR<auth_two_factorUpdateManyMutationInput, auth_two_factorUncheckedUpdateManyInput>
    /**
     * Filter which auth_two_factors to update
     */
    where?: auth_two_factorWhereInput
    /**
     * Limit how many auth_two_factors to update.
     */
    limit?: number
  }

  /**
   * auth_two_factor updateManyAndReturn
   */
  export type auth_two_factorUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auth_two_factor
     */
    select?: auth_two_factorSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the auth_two_factor
     */
    omit?: auth_two_factorOmit<ExtArgs> | null
    /**
     * The data used to update auth_two_factors.
     */
    data: XOR<auth_two_factorUpdateManyMutationInput, auth_two_factorUncheckedUpdateManyInput>
    /**
     * Filter which auth_two_factors to update
     */
    where?: auth_two_factorWhereInput
    /**
     * Limit how many auth_two_factors to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auth_two_factorIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * auth_two_factor upsert
   */
  export type auth_two_factorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auth_two_factor
     */
    select?: auth_two_factorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the auth_two_factor
     */
    omit?: auth_two_factorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auth_two_factorInclude<ExtArgs> | null
    /**
     * The filter to search for the auth_two_factor to update in case it exists.
     */
    where: auth_two_factorWhereUniqueInput
    /**
     * In case the auth_two_factor found by the `where` argument doesn't exist, create a new auth_two_factor with this data.
     */
    create: XOR<auth_two_factorCreateInput, auth_two_factorUncheckedCreateInput>
    /**
     * In case the auth_two_factor was found with the provided `where` argument, update it with this data.
     */
    update: XOR<auth_two_factorUpdateInput, auth_two_factorUncheckedUpdateInput>
  }

  /**
   * auth_two_factor delete
   */
  export type auth_two_factorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auth_two_factor
     */
    select?: auth_two_factorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the auth_two_factor
     */
    omit?: auth_two_factorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auth_two_factorInclude<ExtArgs> | null
    /**
     * Filter which auth_two_factor to delete.
     */
    where: auth_two_factorWhereUniqueInput
  }

  /**
   * auth_two_factor deleteMany
   */
  export type auth_two_factorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which auth_two_factors to delete
     */
    where?: auth_two_factorWhereInput
    /**
     * Limit how many auth_two_factors to delete.
     */
    limit?: number
  }

  /**
   * auth_two_factor without action
   */
  export type auth_two_factorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auth_two_factor
     */
    select?: auth_two_factorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the auth_two_factor
     */
    omit?: auth_two_factorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auth_two_factorInclude<ExtArgs> | null
  }


  /**
   * Model auth_user
   */

  export type AggregateAuth_user = {
    _count: Auth_userCountAggregateOutputType | null
    _min: Auth_userMinAggregateOutputType | null
    _max: Auth_userMaxAggregateOutputType | null
  }

  export type Auth_userMinAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    email_verified: boolean | null
    image: string | null
    created_at: Date | null
    updated_at: Date | null
    username: string | null
    display_username: string | null
    two_factor_enabled: boolean | null
    id_customer: string | null
    id_author: string | null
    id_affiliate: string | null
    id_publisher: string | null
    id_internal: string | null
  }

  export type Auth_userMaxAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    email_verified: boolean | null
    image: string | null
    created_at: Date | null
    updated_at: Date | null
    username: string | null
    display_username: string | null
    two_factor_enabled: boolean | null
    id_customer: string | null
    id_author: string | null
    id_affiliate: string | null
    id_publisher: string | null
    id_internal: string | null
  }

  export type Auth_userCountAggregateOutputType = {
    id: number
    name: number
    email: number
    email_verified: number
    image: number
    created_at: number
    updated_at: number
    username: number
    display_username: number
    two_factor_enabled: number
    id_customer: number
    id_author: number
    id_affiliate: number
    id_publisher: number
    id_internal: number
    _all: number
  }


  export type Auth_userMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    email_verified?: true
    image?: true
    created_at?: true
    updated_at?: true
    username?: true
    display_username?: true
    two_factor_enabled?: true
    id_customer?: true
    id_author?: true
    id_affiliate?: true
    id_publisher?: true
    id_internal?: true
  }

  export type Auth_userMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    email_verified?: true
    image?: true
    created_at?: true
    updated_at?: true
    username?: true
    display_username?: true
    two_factor_enabled?: true
    id_customer?: true
    id_author?: true
    id_affiliate?: true
    id_publisher?: true
    id_internal?: true
  }

  export type Auth_userCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    email_verified?: true
    image?: true
    created_at?: true
    updated_at?: true
    username?: true
    display_username?: true
    two_factor_enabled?: true
    id_customer?: true
    id_author?: true
    id_affiliate?: true
    id_publisher?: true
    id_internal?: true
    _all?: true
  }

  export type Auth_userAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which auth_user to aggregate.
     */
    where?: auth_userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of auth_users to fetch.
     */
    orderBy?: auth_userOrderByWithRelationInput | auth_userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: auth_userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` auth_users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` auth_users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned auth_users
    **/
    _count?: true | Auth_userCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Auth_userMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Auth_userMaxAggregateInputType
  }

  export type GetAuth_userAggregateType<T extends Auth_userAggregateArgs> = {
        [P in keyof T & keyof AggregateAuth_user]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuth_user[P]>
      : GetScalarType<T[P], AggregateAuth_user[P]>
  }




  export type auth_userGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: auth_userWhereInput
    orderBy?: auth_userOrderByWithAggregationInput | auth_userOrderByWithAggregationInput[]
    by: Auth_userScalarFieldEnum[] | Auth_userScalarFieldEnum
    having?: auth_userScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Auth_userCountAggregateInputType | true
    _min?: Auth_userMinAggregateInputType
    _max?: Auth_userMaxAggregateInputType
  }

  export type Auth_userGroupByOutputType = {
    id: string
    name: string
    email: string
    email_verified: boolean
    image: string | null
    created_at: Date
    updated_at: Date | null
    username: string | null
    display_username: string | null
    two_factor_enabled: boolean | null
    id_customer: string | null
    id_author: string | null
    id_affiliate: string | null
    id_publisher: string | null
    id_internal: string | null
    _count: Auth_userCountAggregateOutputType | null
    _min: Auth_userMinAggregateOutputType | null
    _max: Auth_userMaxAggregateOutputType | null
  }

  type GetAuth_userGroupByPayload<T extends auth_userGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Auth_userGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Auth_userGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Auth_userGroupByOutputType[P]>
            : GetScalarType<T[P], Auth_userGroupByOutputType[P]>
        }
      >
    >


  export type auth_userSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    email_verified?: boolean
    image?: boolean
    created_at?: boolean
    updated_at?: boolean
    username?: boolean
    display_username?: boolean
    two_factor_enabled?: boolean
    id_customer?: boolean
    id_author?: boolean
    id_affiliate?: boolean
    id_publisher?: boolean
    id_internal?: boolean
    auth_account?: boolean | auth_user$auth_accountArgs<ExtArgs>
    auth_session?: boolean | auth_user$auth_sessionArgs<ExtArgs>
    auth_two_factor?: boolean | auth_user$auth_two_factorArgs<ExtArgs>
    affiliate?: boolean | auth_user$affiliateArgs<ExtArgs>
    author?: boolean | auth_user$authorArgs<ExtArgs>
    customer?: boolean | auth_user$customerArgs<ExtArgs>
    internal?: boolean | auth_user$internalArgs<ExtArgs>
    publisher?: boolean | auth_user$publisherArgs<ExtArgs>
    reviews?: boolean | auth_user$reviewsArgs<ExtArgs>
    reviews_likes?: boolean | auth_user$reviews_likesArgs<ExtArgs>
    _count?: boolean | Auth_userCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auth_user"]>

  export type auth_userSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    email_verified?: boolean
    image?: boolean
    created_at?: boolean
    updated_at?: boolean
    username?: boolean
    display_username?: boolean
    two_factor_enabled?: boolean
    id_customer?: boolean
    id_author?: boolean
    id_affiliate?: boolean
    id_publisher?: boolean
    id_internal?: boolean
    affiliate?: boolean | auth_user$affiliateArgs<ExtArgs>
    author?: boolean | auth_user$authorArgs<ExtArgs>
    customer?: boolean | auth_user$customerArgs<ExtArgs>
    internal?: boolean | auth_user$internalArgs<ExtArgs>
    publisher?: boolean | auth_user$publisherArgs<ExtArgs>
  }, ExtArgs["result"]["auth_user"]>

  export type auth_userSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    email_verified?: boolean
    image?: boolean
    created_at?: boolean
    updated_at?: boolean
    username?: boolean
    display_username?: boolean
    two_factor_enabled?: boolean
    id_customer?: boolean
    id_author?: boolean
    id_affiliate?: boolean
    id_publisher?: boolean
    id_internal?: boolean
    affiliate?: boolean | auth_user$affiliateArgs<ExtArgs>
    author?: boolean | auth_user$authorArgs<ExtArgs>
    customer?: boolean | auth_user$customerArgs<ExtArgs>
    internal?: boolean | auth_user$internalArgs<ExtArgs>
    publisher?: boolean | auth_user$publisherArgs<ExtArgs>
  }, ExtArgs["result"]["auth_user"]>

  export type auth_userSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    email_verified?: boolean
    image?: boolean
    created_at?: boolean
    updated_at?: boolean
    username?: boolean
    display_username?: boolean
    two_factor_enabled?: boolean
    id_customer?: boolean
    id_author?: boolean
    id_affiliate?: boolean
    id_publisher?: boolean
    id_internal?: boolean
  }

  export type auth_userOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "email" | "email_verified" | "image" | "created_at" | "updated_at" | "username" | "display_username" | "two_factor_enabled" | "id_customer" | "id_author" | "id_affiliate" | "id_publisher" | "id_internal", ExtArgs["result"]["auth_user"]>
  export type auth_userInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    auth_account?: boolean | auth_user$auth_accountArgs<ExtArgs>
    auth_session?: boolean | auth_user$auth_sessionArgs<ExtArgs>
    auth_two_factor?: boolean | auth_user$auth_two_factorArgs<ExtArgs>
    affiliate?: boolean | auth_user$affiliateArgs<ExtArgs>
    author?: boolean | auth_user$authorArgs<ExtArgs>
    customer?: boolean | auth_user$customerArgs<ExtArgs>
    internal?: boolean | auth_user$internalArgs<ExtArgs>
    publisher?: boolean | auth_user$publisherArgs<ExtArgs>
    reviews?: boolean | auth_user$reviewsArgs<ExtArgs>
    reviews_likes?: boolean | auth_user$reviews_likesArgs<ExtArgs>
    _count?: boolean | Auth_userCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type auth_userIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    affiliate?: boolean | auth_user$affiliateArgs<ExtArgs>
    author?: boolean | auth_user$authorArgs<ExtArgs>
    customer?: boolean | auth_user$customerArgs<ExtArgs>
    internal?: boolean | auth_user$internalArgs<ExtArgs>
    publisher?: boolean | auth_user$publisherArgs<ExtArgs>
  }
  export type auth_userIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    affiliate?: boolean | auth_user$affiliateArgs<ExtArgs>
    author?: boolean | auth_user$authorArgs<ExtArgs>
    customer?: boolean | auth_user$customerArgs<ExtArgs>
    internal?: boolean | auth_user$internalArgs<ExtArgs>
    publisher?: boolean | auth_user$publisherArgs<ExtArgs>
  }

  export type $auth_userPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "auth_user"
    objects: {
      auth_account: Prisma.$auth_accountPayload<ExtArgs>[]
      auth_session: Prisma.$auth_sessionPayload<ExtArgs>[]
      auth_two_factor: Prisma.$auth_two_factorPayload<ExtArgs>[]
      affiliate: Prisma.$affiliatePayload<ExtArgs> | null
      author: Prisma.$authorPayload<ExtArgs> | null
      customer: Prisma.$customerPayload<ExtArgs> | null
      internal: Prisma.$internalPayload<ExtArgs> | null
      publisher: Prisma.$publisherPayload<ExtArgs> | null
      reviews: Prisma.$reviewsPayload<ExtArgs>[]
      reviews_likes: Prisma.$reviews_likesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      email: string
      email_verified: boolean
      image: string | null
      created_at: Date
      updated_at: Date | null
      username: string | null
      display_username: string | null
      two_factor_enabled: boolean | null
      id_customer: string | null
      id_author: string | null
      id_affiliate: string | null
      id_publisher: string | null
      id_internal: string | null
    }, ExtArgs["result"]["auth_user"]>
    composites: {}
  }

  type auth_userGetPayload<S extends boolean | null | undefined | auth_userDefaultArgs> = $Result.GetResult<Prisma.$auth_userPayload, S>

  type auth_userCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<auth_userFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Auth_userCountAggregateInputType | true
    }

  export interface auth_userDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['auth_user'], meta: { name: 'auth_user' } }
    /**
     * Find zero or one Auth_user that matches the filter.
     * @param {auth_userFindUniqueArgs} args - Arguments to find a Auth_user
     * @example
     * // Get one Auth_user
     * const auth_user = await prisma.auth_user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends auth_userFindUniqueArgs>(args: SelectSubset<T, auth_userFindUniqueArgs<ExtArgs>>): Prisma__auth_userClient<$Result.GetResult<Prisma.$auth_userPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Auth_user that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {auth_userFindUniqueOrThrowArgs} args - Arguments to find a Auth_user
     * @example
     * // Get one Auth_user
     * const auth_user = await prisma.auth_user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends auth_userFindUniqueOrThrowArgs>(args: SelectSubset<T, auth_userFindUniqueOrThrowArgs<ExtArgs>>): Prisma__auth_userClient<$Result.GetResult<Prisma.$auth_userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Auth_user that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {auth_userFindFirstArgs} args - Arguments to find a Auth_user
     * @example
     * // Get one Auth_user
     * const auth_user = await prisma.auth_user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends auth_userFindFirstArgs>(args?: SelectSubset<T, auth_userFindFirstArgs<ExtArgs>>): Prisma__auth_userClient<$Result.GetResult<Prisma.$auth_userPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Auth_user that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {auth_userFindFirstOrThrowArgs} args - Arguments to find a Auth_user
     * @example
     * // Get one Auth_user
     * const auth_user = await prisma.auth_user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends auth_userFindFirstOrThrowArgs>(args?: SelectSubset<T, auth_userFindFirstOrThrowArgs<ExtArgs>>): Prisma__auth_userClient<$Result.GetResult<Prisma.$auth_userPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Auth_users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {auth_userFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Auth_users
     * const auth_users = await prisma.auth_user.findMany()
     * 
     * // Get first 10 Auth_users
     * const auth_users = await prisma.auth_user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auth_userWithIdOnly = await prisma.auth_user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends auth_userFindManyArgs>(args?: SelectSubset<T, auth_userFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$auth_userPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Auth_user.
     * @param {auth_userCreateArgs} args - Arguments to create a Auth_user.
     * @example
     * // Create one Auth_user
     * const Auth_user = await prisma.auth_user.create({
     *   data: {
     *     // ... data to create a Auth_user
     *   }
     * })
     * 
     */
    create<T extends auth_userCreateArgs>(args: SelectSubset<T, auth_userCreateArgs<ExtArgs>>): Prisma__auth_userClient<$Result.GetResult<Prisma.$auth_userPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Auth_users.
     * @param {auth_userCreateManyArgs} args - Arguments to create many Auth_users.
     * @example
     * // Create many Auth_users
     * const auth_user = await prisma.auth_user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends auth_userCreateManyArgs>(args?: SelectSubset<T, auth_userCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Auth_users and returns the data saved in the database.
     * @param {auth_userCreateManyAndReturnArgs} args - Arguments to create many Auth_users.
     * @example
     * // Create many Auth_users
     * const auth_user = await prisma.auth_user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Auth_users and only return the `id`
     * const auth_userWithIdOnly = await prisma.auth_user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends auth_userCreateManyAndReturnArgs>(args?: SelectSubset<T, auth_userCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$auth_userPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Auth_user.
     * @param {auth_userDeleteArgs} args - Arguments to delete one Auth_user.
     * @example
     * // Delete one Auth_user
     * const Auth_user = await prisma.auth_user.delete({
     *   where: {
     *     // ... filter to delete one Auth_user
     *   }
     * })
     * 
     */
    delete<T extends auth_userDeleteArgs>(args: SelectSubset<T, auth_userDeleteArgs<ExtArgs>>): Prisma__auth_userClient<$Result.GetResult<Prisma.$auth_userPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Auth_user.
     * @param {auth_userUpdateArgs} args - Arguments to update one Auth_user.
     * @example
     * // Update one Auth_user
     * const auth_user = await prisma.auth_user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends auth_userUpdateArgs>(args: SelectSubset<T, auth_userUpdateArgs<ExtArgs>>): Prisma__auth_userClient<$Result.GetResult<Prisma.$auth_userPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Auth_users.
     * @param {auth_userDeleteManyArgs} args - Arguments to filter Auth_users to delete.
     * @example
     * // Delete a few Auth_users
     * const { count } = await prisma.auth_user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends auth_userDeleteManyArgs>(args?: SelectSubset<T, auth_userDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Auth_users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {auth_userUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Auth_users
     * const auth_user = await prisma.auth_user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends auth_userUpdateManyArgs>(args: SelectSubset<T, auth_userUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Auth_users and returns the data updated in the database.
     * @param {auth_userUpdateManyAndReturnArgs} args - Arguments to update many Auth_users.
     * @example
     * // Update many Auth_users
     * const auth_user = await prisma.auth_user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Auth_users and only return the `id`
     * const auth_userWithIdOnly = await prisma.auth_user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends auth_userUpdateManyAndReturnArgs>(args: SelectSubset<T, auth_userUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$auth_userPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Auth_user.
     * @param {auth_userUpsertArgs} args - Arguments to update or create a Auth_user.
     * @example
     * // Update or create a Auth_user
     * const auth_user = await prisma.auth_user.upsert({
     *   create: {
     *     // ... data to create a Auth_user
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Auth_user we want to update
     *   }
     * })
     */
    upsert<T extends auth_userUpsertArgs>(args: SelectSubset<T, auth_userUpsertArgs<ExtArgs>>): Prisma__auth_userClient<$Result.GetResult<Prisma.$auth_userPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Auth_users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {auth_userCountArgs} args - Arguments to filter Auth_users to count.
     * @example
     * // Count the number of Auth_users
     * const count = await prisma.auth_user.count({
     *   where: {
     *     // ... the filter for the Auth_users we want to count
     *   }
     * })
    **/
    count<T extends auth_userCountArgs>(
      args?: Subset<T, auth_userCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Auth_userCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Auth_user.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Auth_userAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Auth_userAggregateArgs>(args: Subset<T, Auth_userAggregateArgs>): Prisma.PrismaPromise<GetAuth_userAggregateType<T>>

    /**
     * Group by Auth_user.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {auth_userGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends auth_userGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: auth_userGroupByArgs['orderBy'] }
        : { orderBy?: auth_userGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, auth_userGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuth_userGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the auth_user model
   */
  readonly fields: auth_userFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for auth_user.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__auth_userClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    auth_account<T extends auth_user$auth_accountArgs<ExtArgs> = {}>(args?: Subset<T, auth_user$auth_accountArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$auth_accountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    auth_session<T extends auth_user$auth_sessionArgs<ExtArgs> = {}>(args?: Subset<T, auth_user$auth_sessionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$auth_sessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    auth_two_factor<T extends auth_user$auth_two_factorArgs<ExtArgs> = {}>(args?: Subset<T, auth_user$auth_two_factorArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$auth_two_factorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    affiliate<T extends auth_user$affiliateArgs<ExtArgs> = {}>(args?: Subset<T, auth_user$affiliateArgs<ExtArgs>>): Prisma__affiliateClient<$Result.GetResult<Prisma.$affiliatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    author<T extends auth_user$authorArgs<ExtArgs> = {}>(args?: Subset<T, auth_user$authorArgs<ExtArgs>>): Prisma__authorClient<$Result.GetResult<Prisma.$authorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    customer<T extends auth_user$customerArgs<ExtArgs> = {}>(args?: Subset<T, auth_user$customerArgs<ExtArgs>>): Prisma__customerClient<$Result.GetResult<Prisma.$customerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    internal<T extends auth_user$internalArgs<ExtArgs> = {}>(args?: Subset<T, auth_user$internalArgs<ExtArgs>>): Prisma__internalClient<$Result.GetResult<Prisma.$internalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    publisher<T extends auth_user$publisherArgs<ExtArgs> = {}>(args?: Subset<T, auth_user$publisherArgs<ExtArgs>>): Prisma__publisherClient<$Result.GetResult<Prisma.$publisherPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    reviews<T extends auth_user$reviewsArgs<ExtArgs> = {}>(args?: Subset<T, auth_user$reviewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$reviewsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reviews_likes<T extends auth_user$reviews_likesArgs<ExtArgs> = {}>(args?: Subset<T, auth_user$reviews_likesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$reviews_likesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the auth_user model
   */
  interface auth_userFieldRefs {
    readonly id: FieldRef<"auth_user", 'String'>
    readonly name: FieldRef<"auth_user", 'String'>
    readonly email: FieldRef<"auth_user", 'String'>
    readonly email_verified: FieldRef<"auth_user", 'Boolean'>
    readonly image: FieldRef<"auth_user", 'String'>
    readonly created_at: FieldRef<"auth_user", 'DateTime'>
    readonly updated_at: FieldRef<"auth_user", 'DateTime'>
    readonly username: FieldRef<"auth_user", 'String'>
    readonly display_username: FieldRef<"auth_user", 'String'>
    readonly two_factor_enabled: FieldRef<"auth_user", 'Boolean'>
    readonly id_customer: FieldRef<"auth_user", 'String'>
    readonly id_author: FieldRef<"auth_user", 'String'>
    readonly id_affiliate: FieldRef<"auth_user", 'String'>
    readonly id_publisher: FieldRef<"auth_user", 'String'>
    readonly id_internal: FieldRef<"auth_user", 'String'>
  }
    

  // Custom InputTypes
  /**
   * auth_user findUnique
   */
  export type auth_userFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auth_user
     */
    select?: auth_userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the auth_user
     */
    omit?: auth_userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auth_userInclude<ExtArgs> | null
    /**
     * Filter, which auth_user to fetch.
     */
    where: auth_userWhereUniqueInput
  }

  /**
   * auth_user findUniqueOrThrow
   */
  export type auth_userFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auth_user
     */
    select?: auth_userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the auth_user
     */
    omit?: auth_userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auth_userInclude<ExtArgs> | null
    /**
     * Filter, which auth_user to fetch.
     */
    where: auth_userWhereUniqueInput
  }

  /**
   * auth_user findFirst
   */
  export type auth_userFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auth_user
     */
    select?: auth_userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the auth_user
     */
    omit?: auth_userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auth_userInclude<ExtArgs> | null
    /**
     * Filter, which auth_user to fetch.
     */
    where?: auth_userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of auth_users to fetch.
     */
    orderBy?: auth_userOrderByWithRelationInput | auth_userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for auth_users.
     */
    cursor?: auth_userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` auth_users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` auth_users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of auth_users.
     */
    distinct?: Auth_userScalarFieldEnum | Auth_userScalarFieldEnum[]
  }

  /**
   * auth_user findFirstOrThrow
   */
  export type auth_userFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auth_user
     */
    select?: auth_userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the auth_user
     */
    omit?: auth_userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auth_userInclude<ExtArgs> | null
    /**
     * Filter, which auth_user to fetch.
     */
    where?: auth_userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of auth_users to fetch.
     */
    orderBy?: auth_userOrderByWithRelationInput | auth_userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for auth_users.
     */
    cursor?: auth_userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` auth_users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` auth_users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of auth_users.
     */
    distinct?: Auth_userScalarFieldEnum | Auth_userScalarFieldEnum[]
  }

  /**
   * auth_user findMany
   */
  export type auth_userFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auth_user
     */
    select?: auth_userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the auth_user
     */
    omit?: auth_userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auth_userInclude<ExtArgs> | null
    /**
     * Filter, which auth_users to fetch.
     */
    where?: auth_userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of auth_users to fetch.
     */
    orderBy?: auth_userOrderByWithRelationInput | auth_userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing auth_users.
     */
    cursor?: auth_userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` auth_users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` auth_users.
     */
    skip?: number
    distinct?: Auth_userScalarFieldEnum | Auth_userScalarFieldEnum[]
  }

  /**
   * auth_user create
   */
  export type auth_userCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auth_user
     */
    select?: auth_userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the auth_user
     */
    omit?: auth_userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auth_userInclude<ExtArgs> | null
    /**
     * The data needed to create a auth_user.
     */
    data: XOR<auth_userCreateInput, auth_userUncheckedCreateInput>
  }

  /**
   * auth_user createMany
   */
  export type auth_userCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many auth_users.
     */
    data: auth_userCreateManyInput | auth_userCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * auth_user createManyAndReturn
   */
  export type auth_userCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auth_user
     */
    select?: auth_userSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the auth_user
     */
    omit?: auth_userOmit<ExtArgs> | null
    /**
     * The data used to create many auth_users.
     */
    data: auth_userCreateManyInput | auth_userCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auth_userIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * auth_user update
   */
  export type auth_userUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auth_user
     */
    select?: auth_userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the auth_user
     */
    omit?: auth_userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auth_userInclude<ExtArgs> | null
    /**
     * The data needed to update a auth_user.
     */
    data: XOR<auth_userUpdateInput, auth_userUncheckedUpdateInput>
    /**
     * Choose, which auth_user to update.
     */
    where: auth_userWhereUniqueInput
  }

  /**
   * auth_user updateMany
   */
  export type auth_userUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update auth_users.
     */
    data: XOR<auth_userUpdateManyMutationInput, auth_userUncheckedUpdateManyInput>
    /**
     * Filter which auth_users to update
     */
    where?: auth_userWhereInput
    /**
     * Limit how many auth_users to update.
     */
    limit?: number
  }

  /**
   * auth_user updateManyAndReturn
   */
  export type auth_userUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auth_user
     */
    select?: auth_userSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the auth_user
     */
    omit?: auth_userOmit<ExtArgs> | null
    /**
     * The data used to update auth_users.
     */
    data: XOR<auth_userUpdateManyMutationInput, auth_userUncheckedUpdateManyInput>
    /**
     * Filter which auth_users to update
     */
    where?: auth_userWhereInput
    /**
     * Limit how many auth_users to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auth_userIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * auth_user upsert
   */
  export type auth_userUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auth_user
     */
    select?: auth_userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the auth_user
     */
    omit?: auth_userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auth_userInclude<ExtArgs> | null
    /**
     * The filter to search for the auth_user to update in case it exists.
     */
    where: auth_userWhereUniqueInput
    /**
     * In case the auth_user found by the `where` argument doesn't exist, create a new auth_user with this data.
     */
    create: XOR<auth_userCreateInput, auth_userUncheckedCreateInput>
    /**
     * In case the auth_user was found with the provided `where` argument, update it with this data.
     */
    update: XOR<auth_userUpdateInput, auth_userUncheckedUpdateInput>
  }

  /**
   * auth_user delete
   */
  export type auth_userDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auth_user
     */
    select?: auth_userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the auth_user
     */
    omit?: auth_userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auth_userInclude<ExtArgs> | null
    /**
     * Filter which auth_user to delete.
     */
    where: auth_userWhereUniqueInput
  }

  /**
   * auth_user deleteMany
   */
  export type auth_userDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which auth_users to delete
     */
    where?: auth_userWhereInput
    /**
     * Limit how many auth_users to delete.
     */
    limit?: number
  }

  /**
   * auth_user.auth_account
   */
  export type auth_user$auth_accountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auth_account
     */
    select?: auth_accountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the auth_account
     */
    omit?: auth_accountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auth_accountInclude<ExtArgs> | null
    where?: auth_accountWhereInput
    orderBy?: auth_accountOrderByWithRelationInput | auth_accountOrderByWithRelationInput[]
    cursor?: auth_accountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Auth_accountScalarFieldEnum | Auth_accountScalarFieldEnum[]
  }

  /**
   * auth_user.auth_session
   */
  export type auth_user$auth_sessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auth_session
     */
    select?: auth_sessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the auth_session
     */
    omit?: auth_sessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auth_sessionInclude<ExtArgs> | null
    where?: auth_sessionWhereInput
    orderBy?: auth_sessionOrderByWithRelationInput | auth_sessionOrderByWithRelationInput[]
    cursor?: auth_sessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Auth_sessionScalarFieldEnum | Auth_sessionScalarFieldEnum[]
  }

  /**
   * auth_user.auth_two_factor
   */
  export type auth_user$auth_two_factorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auth_two_factor
     */
    select?: auth_two_factorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the auth_two_factor
     */
    omit?: auth_two_factorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auth_two_factorInclude<ExtArgs> | null
    where?: auth_two_factorWhereInput
    orderBy?: auth_two_factorOrderByWithRelationInput | auth_two_factorOrderByWithRelationInput[]
    cursor?: auth_two_factorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Auth_two_factorScalarFieldEnum | Auth_two_factorScalarFieldEnum[]
  }

  /**
   * auth_user.affiliate
   */
  export type auth_user$affiliateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the affiliate
     */
    select?: affiliateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the affiliate
     */
    omit?: affiliateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: affiliateInclude<ExtArgs> | null
    where?: affiliateWhereInput
  }

  /**
   * auth_user.author
   */
  export type auth_user$authorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the author
     */
    select?: authorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the author
     */
    omit?: authorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: authorInclude<ExtArgs> | null
    where?: authorWhereInput
  }

  /**
   * auth_user.customer
   */
  export type auth_user$customerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer
     */
    select?: customerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customer
     */
    omit?: customerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customerInclude<ExtArgs> | null
    where?: customerWhereInput
  }

  /**
   * auth_user.internal
   */
  export type auth_user$internalArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the internal
     */
    select?: internalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the internal
     */
    omit?: internalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: internalInclude<ExtArgs> | null
    where?: internalWhereInput
  }

  /**
   * auth_user.publisher
   */
  export type auth_user$publisherArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the publisher
     */
    select?: publisherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the publisher
     */
    omit?: publisherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: publisherInclude<ExtArgs> | null
    where?: publisherWhereInput
  }

  /**
   * auth_user.reviews
   */
  export type auth_user$reviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reviews
     */
    select?: reviewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reviews
     */
    omit?: reviewsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reviewsInclude<ExtArgs> | null
    where?: reviewsWhereInput
    orderBy?: reviewsOrderByWithRelationInput | reviewsOrderByWithRelationInput[]
    cursor?: reviewsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReviewsScalarFieldEnum | ReviewsScalarFieldEnum[]
  }

  /**
   * auth_user.reviews_likes
   */
  export type auth_user$reviews_likesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reviews_likes
     */
    select?: reviews_likesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reviews_likes
     */
    omit?: reviews_likesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reviews_likesInclude<ExtArgs> | null
    where?: reviews_likesWhereInput
    orderBy?: reviews_likesOrderByWithRelationInput | reviews_likesOrderByWithRelationInput[]
    cursor?: reviews_likesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Reviews_likesScalarFieldEnum | Reviews_likesScalarFieldEnum[]
  }

  /**
   * auth_user without action
   */
  export type auth_userDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auth_user
     */
    select?: auth_userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the auth_user
     */
    omit?: auth_userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auth_userInclude<ExtArgs> | null
  }


  /**
   * Model auth_verification
   */

  export type AggregateAuth_verification = {
    _count: Auth_verificationCountAggregateOutputType | null
    _min: Auth_verificationMinAggregateOutputType | null
    _max: Auth_verificationMaxAggregateOutputType | null
  }

  export type Auth_verificationMinAggregateOutputType = {
    id: string | null
    identifier: string | null
    value: string | null
    expires_at: Date | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Auth_verificationMaxAggregateOutputType = {
    id: string | null
    identifier: string | null
    value: string | null
    expires_at: Date | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Auth_verificationCountAggregateOutputType = {
    id: number
    identifier: number
    value: number
    expires_at: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Auth_verificationMinAggregateInputType = {
    id?: true
    identifier?: true
    value?: true
    expires_at?: true
    created_at?: true
    updated_at?: true
  }

  export type Auth_verificationMaxAggregateInputType = {
    id?: true
    identifier?: true
    value?: true
    expires_at?: true
    created_at?: true
    updated_at?: true
  }

  export type Auth_verificationCountAggregateInputType = {
    id?: true
    identifier?: true
    value?: true
    expires_at?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Auth_verificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which auth_verification to aggregate.
     */
    where?: auth_verificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of auth_verifications to fetch.
     */
    orderBy?: auth_verificationOrderByWithRelationInput | auth_verificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: auth_verificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` auth_verifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` auth_verifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned auth_verifications
    **/
    _count?: true | Auth_verificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Auth_verificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Auth_verificationMaxAggregateInputType
  }

  export type GetAuth_verificationAggregateType<T extends Auth_verificationAggregateArgs> = {
        [P in keyof T & keyof AggregateAuth_verification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuth_verification[P]>
      : GetScalarType<T[P], AggregateAuth_verification[P]>
  }




  export type auth_verificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: auth_verificationWhereInput
    orderBy?: auth_verificationOrderByWithAggregationInput | auth_verificationOrderByWithAggregationInput[]
    by: Auth_verificationScalarFieldEnum[] | Auth_verificationScalarFieldEnum
    having?: auth_verificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Auth_verificationCountAggregateInputType | true
    _min?: Auth_verificationMinAggregateInputType
    _max?: Auth_verificationMaxAggregateInputType
  }

  export type Auth_verificationGroupByOutputType = {
    id: string
    identifier: string
    value: string
    expires_at: Date
    created_at: Date
    updated_at: Date | null
    _count: Auth_verificationCountAggregateOutputType | null
    _min: Auth_verificationMinAggregateOutputType | null
    _max: Auth_verificationMaxAggregateOutputType | null
  }

  type GetAuth_verificationGroupByPayload<T extends auth_verificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Auth_verificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Auth_verificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Auth_verificationGroupByOutputType[P]>
            : GetScalarType<T[P], Auth_verificationGroupByOutputType[P]>
        }
      >
    >


  export type auth_verificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    identifier?: boolean
    value?: boolean
    expires_at?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["auth_verification"]>

  export type auth_verificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    identifier?: boolean
    value?: boolean
    expires_at?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["auth_verification"]>

  export type auth_verificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    identifier?: boolean
    value?: boolean
    expires_at?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["auth_verification"]>

  export type auth_verificationSelectScalar = {
    id?: boolean
    identifier?: boolean
    value?: boolean
    expires_at?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type auth_verificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "identifier" | "value" | "expires_at" | "created_at" | "updated_at", ExtArgs["result"]["auth_verification"]>

  export type $auth_verificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "auth_verification"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      identifier: string
      value: string
      expires_at: Date
      created_at: Date
      updated_at: Date | null
    }, ExtArgs["result"]["auth_verification"]>
    composites: {}
  }

  type auth_verificationGetPayload<S extends boolean | null | undefined | auth_verificationDefaultArgs> = $Result.GetResult<Prisma.$auth_verificationPayload, S>

  type auth_verificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<auth_verificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Auth_verificationCountAggregateInputType | true
    }

  export interface auth_verificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['auth_verification'], meta: { name: 'auth_verification' } }
    /**
     * Find zero or one Auth_verification that matches the filter.
     * @param {auth_verificationFindUniqueArgs} args - Arguments to find a Auth_verification
     * @example
     * // Get one Auth_verification
     * const auth_verification = await prisma.auth_verification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends auth_verificationFindUniqueArgs>(args: SelectSubset<T, auth_verificationFindUniqueArgs<ExtArgs>>): Prisma__auth_verificationClient<$Result.GetResult<Prisma.$auth_verificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Auth_verification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {auth_verificationFindUniqueOrThrowArgs} args - Arguments to find a Auth_verification
     * @example
     * // Get one Auth_verification
     * const auth_verification = await prisma.auth_verification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends auth_verificationFindUniqueOrThrowArgs>(args: SelectSubset<T, auth_verificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__auth_verificationClient<$Result.GetResult<Prisma.$auth_verificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Auth_verification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {auth_verificationFindFirstArgs} args - Arguments to find a Auth_verification
     * @example
     * // Get one Auth_verification
     * const auth_verification = await prisma.auth_verification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends auth_verificationFindFirstArgs>(args?: SelectSubset<T, auth_verificationFindFirstArgs<ExtArgs>>): Prisma__auth_verificationClient<$Result.GetResult<Prisma.$auth_verificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Auth_verification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {auth_verificationFindFirstOrThrowArgs} args - Arguments to find a Auth_verification
     * @example
     * // Get one Auth_verification
     * const auth_verification = await prisma.auth_verification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends auth_verificationFindFirstOrThrowArgs>(args?: SelectSubset<T, auth_verificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__auth_verificationClient<$Result.GetResult<Prisma.$auth_verificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Auth_verifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {auth_verificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Auth_verifications
     * const auth_verifications = await prisma.auth_verification.findMany()
     * 
     * // Get first 10 Auth_verifications
     * const auth_verifications = await prisma.auth_verification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auth_verificationWithIdOnly = await prisma.auth_verification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends auth_verificationFindManyArgs>(args?: SelectSubset<T, auth_verificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$auth_verificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Auth_verification.
     * @param {auth_verificationCreateArgs} args - Arguments to create a Auth_verification.
     * @example
     * // Create one Auth_verification
     * const Auth_verification = await prisma.auth_verification.create({
     *   data: {
     *     // ... data to create a Auth_verification
     *   }
     * })
     * 
     */
    create<T extends auth_verificationCreateArgs>(args: SelectSubset<T, auth_verificationCreateArgs<ExtArgs>>): Prisma__auth_verificationClient<$Result.GetResult<Prisma.$auth_verificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Auth_verifications.
     * @param {auth_verificationCreateManyArgs} args - Arguments to create many Auth_verifications.
     * @example
     * // Create many Auth_verifications
     * const auth_verification = await prisma.auth_verification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends auth_verificationCreateManyArgs>(args?: SelectSubset<T, auth_verificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Auth_verifications and returns the data saved in the database.
     * @param {auth_verificationCreateManyAndReturnArgs} args - Arguments to create many Auth_verifications.
     * @example
     * // Create many Auth_verifications
     * const auth_verification = await prisma.auth_verification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Auth_verifications and only return the `id`
     * const auth_verificationWithIdOnly = await prisma.auth_verification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends auth_verificationCreateManyAndReturnArgs>(args?: SelectSubset<T, auth_verificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$auth_verificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Auth_verification.
     * @param {auth_verificationDeleteArgs} args - Arguments to delete one Auth_verification.
     * @example
     * // Delete one Auth_verification
     * const Auth_verification = await prisma.auth_verification.delete({
     *   where: {
     *     // ... filter to delete one Auth_verification
     *   }
     * })
     * 
     */
    delete<T extends auth_verificationDeleteArgs>(args: SelectSubset<T, auth_verificationDeleteArgs<ExtArgs>>): Prisma__auth_verificationClient<$Result.GetResult<Prisma.$auth_verificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Auth_verification.
     * @param {auth_verificationUpdateArgs} args - Arguments to update one Auth_verification.
     * @example
     * // Update one Auth_verification
     * const auth_verification = await prisma.auth_verification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends auth_verificationUpdateArgs>(args: SelectSubset<T, auth_verificationUpdateArgs<ExtArgs>>): Prisma__auth_verificationClient<$Result.GetResult<Prisma.$auth_verificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Auth_verifications.
     * @param {auth_verificationDeleteManyArgs} args - Arguments to filter Auth_verifications to delete.
     * @example
     * // Delete a few Auth_verifications
     * const { count } = await prisma.auth_verification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends auth_verificationDeleteManyArgs>(args?: SelectSubset<T, auth_verificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Auth_verifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {auth_verificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Auth_verifications
     * const auth_verification = await prisma.auth_verification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends auth_verificationUpdateManyArgs>(args: SelectSubset<T, auth_verificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Auth_verifications and returns the data updated in the database.
     * @param {auth_verificationUpdateManyAndReturnArgs} args - Arguments to update many Auth_verifications.
     * @example
     * // Update many Auth_verifications
     * const auth_verification = await prisma.auth_verification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Auth_verifications and only return the `id`
     * const auth_verificationWithIdOnly = await prisma.auth_verification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends auth_verificationUpdateManyAndReturnArgs>(args: SelectSubset<T, auth_verificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$auth_verificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Auth_verification.
     * @param {auth_verificationUpsertArgs} args - Arguments to update or create a Auth_verification.
     * @example
     * // Update or create a Auth_verification
     * const auth_verification = await prisma.auth_verification.upsert({
     *   create: {
     *     // ... data to create a Auth_verification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Auth_verification we want to update
     *   }
     * })
     */
    upsert<T extends auth_verificationUpsertArgs>(args: SelectSubset<T, auth_verificationUpsertArgs<ExtArgs>>): Prisma__auth_verificationClient<$Result.GetResult<Prisma.$auth_verificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Auth_verifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {auth_verificationCountArgs} args - Arguments to filter Auth_verifications to count.
     * @example
     * // Count the number of Auth_verifications
     * const count = await prisma.auth_verification.count({
     *   where: {
     *     // ... the filter for the Auth_verifications we want to count
     *   }
     * })
    **/
    count<T extends auth_verificationCountArgs>(
      args?: Subset<T, auth_verificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Auth_verificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Auth_verification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Auth_verificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Auth_verificationAggregateArgs>(args: Subset<T, Auth_verificationAggregateArgs>): Prisma.PrismaPromise<GetAuth_verificationAggregateType<T>>

    /**
     * Group by Auth_verification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {auth_verificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends auth_verificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: auth_verificationGroupByArgs['orderBy'] }
        : { orderBy?: auth_verificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, auth_verificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuth_verificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the auth_verification model
   */
  readonly fields: auth_verificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for auth_verification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__auth_verificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the auth_verification model
   */
  interface auth_verificationFieldRefs {
    readonly id: FieldRef<"auth_verification", 'String'>
    readonly identifier: FieldRef<"auth_verification", 'String'>
    readonly value: FieldRef<"auth_verification", 'String'>
    readonly expires_at: FieldRef<"auth_verification", 'DateTime'>
    readonly created_at: FieldRef<"auth_verification", 'DateTime'>
    readonly updated_at: FieldRef<"auth_verification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * auth_verification findUnique
   */
  export type auth_verificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auth_verification
     */
    select?: auth_verificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the auth_verification
     */
    omit?: auth_verificationOmit<ExtArgs> | null
    /**
     * Filter, which auth_verification to fetch.
     */
    where: auth_verificationWhereUniqueInput
  }

  /**
   * auth_verification findUniqueOrThrow
   */
  export type auth_verificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auth_verification
     */
    select?: auth_verificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the auth_verification
     */
    omit?: auth_verificationOmit<ExtArgs> | null
    /**
     * Filter, which auth_verification to fetch.
     */
    where: auth_verificationWhereUniqueInput
  }

  /**
   * auth_verification findFirst
   */
  export type auth_verificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auth_verification
     */
    select?: auth_verificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the auth_verification
     */
    omit?: auth_verificationOmit<ExtArgs> | null
    /**
     * Filter, which auth_verification to fetch.
     */
    where?: auth_verificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of auth_verifications to fetch.
     */
    orderBy?: auth_verificationOrderByWithRelationInput | auth_verificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for auth_verifications.
     */
    cursor?: auth_verificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` auth_verifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` auth_verifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of auth_verifications.
     */
    distinct?: Auth_verificationScalarFieldEnum | Auth_verificationScalarFieldEnum[]
  }

  /**
   * auth_verification findFirstOrThrow
   */
  export type auth_verificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auth_verification
     */
    select?: auth_verificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the auth_verification
     */
    omit?: auth_verificationOmit<ExtArgs> | null
    /**
     * Filter, which auth_verification to fetch.
     */
    where?: auth_verificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of auth_verifications to fetch.
     */
    orderBy?: auth_verificationOrderByWithRelationInput | auth_verificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for auth_verifications.
     */
    cursor?: auth_verificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` auth_verifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` auth_verifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of auth_verifications.
     */
    distinct?: Auth_verificationScalarFieldEnum | Auth_verificationScalarFieldEnum[]
  }

  /**
   * auth_verification findMany
   */
  export type auth_verificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auth_verification
     */
    select?: auth_verificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the auth_verification
     */
    omit?: auth_verificationOmit<ExtArgs> | null
    /**
     * Filter, which auth_verifications to fetch.
     */
    where?: auth_verificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of auth_verifications to fetch.
     */
    orderBy?: auth_verificationOrderByWithRelationInput | auth_verificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing auth_verifications.
     */
    cursor?: auth_verificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` auth_verifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` auth_verifications.
     */
    skip?: number
    distinct?: Auth_verificationScalarFieldEnum | Auth_verificationScalarFieldEnum[]
  }

  /**
   * auth_verification create
   */
  export type auth_verificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auth_verification
     */
    select?: auth_verificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the auth_verification
     */
    omit?: auth_verificationOmit<ExtArgs> | null
    /**
     * The data needed to create a auth_verification.
     */
    data: XOR<auth_verificationCreateInput, auth_verificationUncheckedCreateInput>
  }

  /**
   * auth_verification createMany
   */
  export type auth_verificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many auth_verifications.
     */
    data: auth_verificationCreateManyInput | auth_verificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * auth_verification createManyAndReturn
   */
  export type auth_verificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auth_verification
     */
    select?: auth_verificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the auth_verification
     */
    omit?: auth_verificationOmit<ExtArgs> | null
    /**
     * The data used to create many auth_verifications.
     */
    data: auth_verificationCreateManyInput | auth_verificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * auth_verification update
   */
  export type auth_verificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auth_verification
     */
    select?: auth_verificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the auth_verification
     */
    omit?: auth_verificationOmit<ExtArgs> | null
    /**
     * The data needed to update a auth_verification.
     */
    data: XOR<auth_verificationUpdateInput, auth_verificationUncheckedUpdateInput>
    /**
     * Choose, which auth_verification to update.
     */
    where: auth_verificationWhereUniqueInput
  }

  /**
   * auth_verification updateMany
   */
  export type auth_verificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update auth_verifications.
     */
    data: XOR<auth_verificationUpdateManyMutationInput, auth_verificationUncheckedUpdateManyInput>
    /**
     * Filter which auth_verifications to update
     */
    where?: auth_verificationWhereInput
    /**
     * Limit how many auth_verifications to update.
     */
    limit?: number
  }

  /**
   * auth_verification updateManyAndReturn
   */
  export type auth_verificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auth_verification
     */
    select?: auth_verificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the auth_verification
     */
    omit?: auth_verificationOmit<ExtArgs> | null
    /**
     * The data used to update auth_verifications.
     */
    data: XOR<auth_verificationUpdateManyMutationInput, auth_verificationUncheckedUpdateManyInput>
    /**
     * Filter which auth_verifications to update
     */
    where?: auth_verificationWhereInput
    /**
     * Limit how many auth_verifications to update.
     */
    limit?: number
  }

  /**
   * auth_verification upsert
   */
  export type auth_verificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auth_verification
     */
    select?: auth_verificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the auth_verification
     */
    omit?: auth_verificationOmit<ExtArgs> | null
    /**
     * The filter to search for the auth_verification to update in case it exists.
     */
    where: auth_verificationWhereUniqueInput
    /**
     * In case the auth_verification found by the `where` argument doesn't exist, create a new auth_verification with this data.
     */
    create: XOR<auth_verificationCreateInput, auth_verificationUncheckedCreateInput>
    /**
     * In case the auth_verification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<auth_verificationUpdateInput, auth_verificationUncheckedUpdateInput>
  }

  /**
   * auth_verification delete
   */
  export type auth_verificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auth_verification
     */
    select?: auth_verificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the auth_verification
     */
    omit?: auth_verificationOmit<ExtArgs> | null
    /**
     * Filter which auth_verification to delete.
     */
    where: auth_verificationWhereUniqueInput
  }

  /**
   * auth_verification deleteMany
   */
  export type auth_verificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which auth_verifications to delete
     */
    where?: auth_verificationWhereInput
    /**
     * Limit how many auth_verifications to delete.
     */
    limit?: number
  }

  /**
   * auth_verification without action
   */
  export type auth_verificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auth_verification
     */
    select?: auth_verificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the auth_verification
     */
    omit?: auth_verificationOmit<ExtArgs> | null
  }


  /**
   * Model author
   */

  export type AggregateAuthor = {
    _count: AuthorCountAggregateOutputType | null
    _min: AuthorMinAggregateOutputType | null
    _max: AuthorMaxAggregateOutputType | null
  }

  export type AuthorMinAggregateOutputType = {
    id: string | null
    name: string | null
    id_account: string | null
    biography: string | null
    social_media: string | null
    avatar: string | null
  }

  export type AuthorMaxAggregateOutputType = {
    id: string | null
    name: string | null
    id_account: string | null
    biography: string | null
    social_media: string | null
    avatar: string | null
  }

  export type AuthorCountAggregateOutputType = {
    id: number
    name: number
    id_account: number
    biography: number
    social_media: number
    avatar: number
    _all: number
  }


  export type AuthorMinAggregateInputType = {
    id?: true
    name?: true
    id_account?: true
    biography?: true
    social_media?: true
    avatar?: true
  }

  export type AuthorMaxAggregateInputType = {
    id?: true
    name?: true
    id_account?: true
    biography?: true
    social_media?: true
    avatar?: true
  }

  export type AuthorCountAggregateInputType = {
    id?: true
    name?: true
    id_account?: true
    biography?: true
    social_media?: true
    avatar?: true
    _all?: true
  }

  export type AuthorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which author to aggregate.
     */
    where?: authorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of authors to fetch.
     */
    orderBy?: authorOrderByWithRelationInput | authorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: authorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` authors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` authors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned authors
    **/
    _count?: true | AuthorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuthorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuthorMaxAggregateInputType
  }

  export type GetAuthorAggregateType<T extends AuthorAggregateArgs> = {
        [P in keyof T & keyof AggregateAuthor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuthor[P]>
      : GetScalarType<T[P], AggregateAuthor[P]>
  }




  export type authorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: authorWhereInput
    orderBy?: authorOrderByWithAggregationInput | authorOrderByWithAggregationInput[]
    by: AuthorScalarFieldEnum[] | AuthorScalarFieldEnum
    having?: authorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuthorCountAggregateInputType | true
    _min?: AuthorMinAggregateInputType
    _max?: AuthorMaxAggregateInputType
  }

  export type AuthorGroupByOutputType = {
    id: string
    name: string
    id_account: string | null
    biography: string | null
    social_media: string | null
    avatar: string | null
    _count: AuthorCountAggregateOutputType | null
    _min: AuthorMinAggregateOutputType | null
    _max: AuthorMaxAggregateOutputType | null
  }

  type GetAuthorGroupByPayload<T extends authorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuthorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuthorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuthorGroupByOutputType[P]>
            : GetScalarType<T[P], AuthorGroupByOutputType[P]>
        }
      >
    >


  export type authorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    id_account?: boolean
    biography?: boolean
    social_media?: boolean
    avatar?: boolean
    auth_user?: boolean | author$auth_userArgs<ExtArgs>
    auth_account?: boolean | author$auth_accountArgs<ExtArgs>
    book?: boolean | author$bookArgs<ExtArgs>
    product?: boolean | author$productArgs<ExtArgs>
    publisher_author?: boolean | author$publisher_authorArgs<ExtArgs>
    _count?: boolean | AuthorCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["author"]>

  export type authorSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    id_account?: boolean
    biography?: boolean
    social_media?: boolean
    avatar?: boolean
    auth_account?: boolean | author$auth_accountArgs<ExtArgs>
  }, ExtArgs["result"]["author"]>

  export type authorSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    id_account?: boolean
    biography?: boolean
    social_media?: boolean
    avatar?: boolean
    auth_account?: boolean | author$auth_accountArgs<ExtArgs>
  }, ExtArgs["result"]["author"]>

  export type authorSelectScalar = {
    id?: boolean
    name?: boolean
    id_account?: boolean
    biography?: boolean
    social_media?: boolean
    avatar?: boolean
  }

  export type authorOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "id_account" | "biography" | "social_media" | "avatar", ExtArgs["result"]["author"]>
  export type authorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    auth_user?: boolean | author$auth_userArgs<ExtArgs>
    auth_account?: boolean | author$auth_accountArgs<ExtArgs>
    book?: boolean | author$bookArgs<ExtArgs>
    product?: boolean | author$productArgs<ExtArgs>
    publisher_author?: boolean | author$publisher_authorArgs<ExtArgs>
    _count?: boolean | AuthorCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type authorIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    auth_account?: boolean | author$auth_accountArgs<ExtArgs>
  }
  export type authorIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    auth_account?: boolean | author$auth_accountArgs<ExtArgs>
  }

  export type $authorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "author"
    objects: {
      auth_user: Prisma.$auth_userPayload<ExtArgs>[]
      auth_account: Prisma.$auth_accountPayload<ExtArgs> | null
      book: Prisma.$bookPayload<ExtArgs>[]
      product: Prisma.$productPayload<ExtArgs>[]
      publisher_author: Prisma.$publisher_authorPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      id_account: string | null
      biography: string | null
      social_media: string | null
      avatar: string | null
    }, ExtArgs["result"]["author"]>
    composites: {}
  }

  type authorGetPayload<S extends boolean | null | undefined | authorDefaultArgs> = $Result.GetResult<Prisma.$authorPayload, S>

  type authorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<authorFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AuthorCountAggregateInputType | true
    }

  export interface authorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['author'], meta: { name: 'author' } }
    /**
     * Find zero or one Author that matches the filter.
     * @param {authorFindUniqueArgs} args - Arguments to find a Author
     * @example
     * // Get one Author
     * const author = await prisma.author.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends authorFindUniqueArgs>(args: SelectSubset<T, authorFindUniqueArgs<ExtArgs>>): Prisma__authorClient<$Result.GetResult<Prisma.$authorPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Author that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {authorFindUniqueOrThrowArgs} args - Arguments to find a Author
     * @example
     * // Get one Author
     * const author = await prisma.author.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends authorFindUniqueOrThrowArgs>(args: SelectSubset<T, authorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__authorClient<$Result.GetResult<Prisma.$authorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Author that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {authorFindFirstArgs} args - Arguments to find a Author
     * @example
     * // Get one Author
     * const author = await prisma.author.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends authorFindFirstArgs>(args?: SelectSubset<T, authorFindFirstArgs<ExtArgs>>): Prisma__authorClient<$Result.GetResult<Prisma.$authorPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Author that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {authorFindFirstOrThrowArgs} args - Arguments to find a Author
     * @example
     * // Get one Author
     * const author = await prisma.author.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends authorFindFirstOrThrowArgs>(args?: SelectSubset<T, authorFindFirstOrThrowArgs<ExtArgs>>): Prisma__authorClient<$Result.GetResult<Prisma.$authorPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Authors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {authorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Authors
     * const authors = await prisma.author.findMany()
     * 
     * // Get first 10 Authors
     * const authors = await prisma.author.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const authorWithIdOnly = await prisma.author.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends authorFindManyArgs>(args?: SelectSubset<T, authorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$authorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Author.
     * @param {authorCreateArgs} args - Arguments to create a Author.
     * @example
     * // Create one Author
     * const Author = await prisma.author.create({
     *   data: {
     *     // ... data to create a Author
     *   }
     * })
     * 
     */
    create<T extends authorCreateArgs>(args: SelectSubset<T, authorCreateArgs<ExtArgs>>): Prisma__authorClient<$Result.GetResult<Prisma.$authorPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Authors.
     * @param {authorCreateManyArgs} args - Arguments to create many Authors.
     * @example
     * // Create many Authors
     * const author = await prisma.author.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends authorCreateManyArgs>(args?: SelectSubset<T, authorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Authors and returns the data saved in the database.
     * @param {authorCreateManyAndReturnArgs} args - Arguments to create many Authors.
     * @example
     * // Create many Authors
     * const author = await prisma.author.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Authors and only return the `id`
     * const authorWithIdOnly = await prisma.author.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends authorCreateManyAndReturnArgs>(args?: SelectSubset<T, authorCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$authorPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Author.
     * @param {authorDeleteArgs} args - Arguments to delete one Author.
     * @example
     * // Delete one Author
     * const Author = await prisma.author.delete({
     *   where: {
     *     // ... filter to delete one Author
     *   }
     * })
     * 
     */
    delete<T extends authorDeleteArgs>(args: SelectSubset<T, authorDeleteArgs<ExtArgs>>): Prisma__authorClient<$Result.GetResult<Prisma.$authorPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Author.
     * @param {authorUpdateArgs} args - Arguments to update one Author.
     * @example
     * // Update one Author
     * const author = await prisma.author.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends authorUpdateArgs>(args: SelectSubset<T, authorUpdateArgs<ExtArgs>>): Prisma__authorClient<$Result.GetResult<Prisma.$authorPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Authors.
     * @param {authorDeleteManyArgs} args - Arguments to filter Authors to delete.
     * @example
     * // Delete a few Authors
     * const { count } = await prisma.author.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends authorDeleteManyArgs>(args?: SelectSubset<T, authorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Authors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {authorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Authors
     * const author = await prisma.author.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends authorUpdateManyArgs>(args: SelectSubset<T, authorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Authors and returns the data updated in the database.
     * @param {authorUpdateManyAndReturnArgs} args - Arguments to update many Authors.
     * @example
     * // Update many Authors
     * const author = await prisma.author.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Authors and only return the `id`
     * const authorWithIdOnly = await prisma.author.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends authorUpdateManyAndReturnArgs>(args: SelectSubset<T, authorUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$authorPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Author.
     * @param {authorUpsertArgs} args - Arguments to update or create a Author.
     * @example
     * // Update or create a Author
     * const author = await prisma.author.upsert({
     *   create: {
     *     // ... data to create a Author
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Author we want to update
     *   }
     * })
     */
    upsert<T extends authorUpsertArgs>(args: SelectSubset<T, authorUpsertArgs<ExtArgs>>): Prisma__authorClient<$Result.GetResult<Prisma.$authorPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Authors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {authorCountArgs} args - Arguments to filter Authors to count.
     * @example
     * // Count the number of Authors
     * const count = await prisma.author.count({
     *   where: {
     *     // ... the filter for the Authors we want to count
     *   }
     * })
    **/
    count<T extends authorCountArgs>(
      args?: Subset<T, authorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuthorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Author.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuthorAggregateArgs>(args: Subset<T, AuthorAggregateArgs>): Prisma.PrismaPromise<GetAuthorAggregateType<T>>

    /**
     * Group by Author.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {authorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends authorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: authorGroupByArgs['orderBy'] }
        : { orderBy?: authorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, authorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuthorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the author model
   */
  readonly fields: authorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for author.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__authorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    auth_user<T extends author$auth_userArgs<ExtArgs> = {}>(args?: Subset<T, author$auth_userArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$auth_userPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    auth_account<T extends author$auth_accountArgs<ExtArgs> = {}>(args?: Subset<T, author$auth_accountArgs<ExtArgs>>): Prisma__auth_accountClient<$Result.GetResult<Prisma.$auth_accountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    book<T extends author$bookArgs<ExtArgs> = {}>(args?: Subset<T, author$bookArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$bookPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    product<T extends author$productArgs<ExtArgs> = {}>(args?: Subset<T, author$productArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$productPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    publisher_author<T extends author$publisher_authorArgs<ExtArgs> = {}>(args?: Subset<T, author$publisher_authorArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$publisher_authorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the author model
   */
  interface authorFieldRefs {
    readonly id: FieldRef<"author", 'String'>
    readonly name: FieldRef<"author", 'String'>
    readonly id_account: FieldRef<"author", 'String'>
    readonly biography: FieldRef<"author", 'String'>
    readonly social_media: FieldRef<"author", 'String'>
    readonly avatar: FieldRef<"author", 'String'>
  }
    

  // Custom InputTypes
  /**
   * author findUnique
   */
  export type authorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the author
     */
    select?: authorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the author
     */
    omit?: authorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: authorInclude<ExtArgs> | null
    /**
     * Filter, which author to fetch.
     */
    where: authorWhereUniqueInput
  }

  /**
   * author findUniqueOrThrow
   */
  export type authorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the author
     */
    select?: authorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the author
     */
    omit?: authorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: authorInclude<ExtArgs> | null
    /**
     * Filter, which author to fetch.
     */
    where: authorWhereUniqueInput
  }

  /**
   * author findFirst
   */
  export type authorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the author
     */
    select?: authorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the author
     */
    omit?: authorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: authorInclude<ExtArgs> | null
    /**
     * Filter, which author to fetch.
     */
    where?: authorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of authors to fetch.
     */
    orderBy?: authorOrderByWithRelationInput | authorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for authors.
     */
    cursor?: authorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` authors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` authors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of authors.
     */
    distinct?: AuthorScalarFieldEnum | AuthorScalarFieldEnum[]
  }

  /**
   * author findFirstOrThrow
   */
  export type authorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the author
     */
    select?: authorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the author
     */
    omit?: authorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: authorInclude<ExtArgs> | null
    /**
     * Filter, which author to fetch.
     */
    where?: authorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of authors to fetch.
     */
    orderBy?: authorOrderByWithRelationInput | authorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for authors.
     */
    cursor?: authorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` authors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` authors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of authors.
     */
    distinct?: AuthorScalarFieldEnum | AuthorScalarFieldEnum[]
  }

  /**
   * author findMany
   */
  export type authorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the author
     */
    select?: authorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the author
     */
    omit?: authorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: authorInclude<ExtArgs> | null
    /**
     * Filter, which authors to fetch.
     */
    where?: authorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of authors to fetch.
     */
    orderBy?: authorOrderByWithRelationInput | authorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing authors.
     */
    cursor?: authorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` authors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` authors.
     */
    skip?: number
    distinct?: AuthorScalarFieldEnum | AuthorScalarFieldEnum[]
  }

  /**
   * author create
   */
  export type authorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the author
     */
    select?: authorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the author
     */
    omit?: authorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: authorInclude<ExtArgs> | null
    /**
     * The data needed to create a author.
     */
    data: XOR<authorCreateInput, authorUncheckedCreateInput>
  }

  /**
   * author createMany
   */
  export type authorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many authors.
     */
    data: authorCreateManyInput | authorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * author createManyAndReturn
   */
  export type authorCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the author
     */
    select?: authorSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the author
     */
    omit?: authorOmit<ExtArgs> | null
    /**
     * The data used to create many authors.
     */
    data: authorCreateManyInput | authorCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: authorIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * author update
   */
  export type authorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the author
     */
    select?: authorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the author
     */
    omit?: authorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: authorInclude<ExtArgs> | null
    /**
     * The data needed to update a author.
     */
    data: XOR<authorUpdateInput, authorUncheckedUpdateInput>
    /**
     * Choose, which author to update.
     */
    where: authorWhereUniqueInput
  }

  /**
   * author updateMany
   */
  export type authorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update authors.
     */
    data: XOR<authorUpdateManyMutationInput, authorUncheckedUpdateManyInput>
    /**
     * Filter which authors to update
     */
    where?: authorWhereInput
    /**
     * Limit how many authors to update.
     */
    limit?: number
  }

  /**
   * author updateManyAndReturn
   */
  export type authorUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the author
     */
    select?: authorSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the author
     */
    omit?: authorOmit<ExtArgs> | null
    /**
     * The data used to update authors.
     */
    data: XOR<authorUpdateManyMutationInput, authorUncheckedUpdateManyInput>
    /**
     * Filter which authors to update
     */
    where?: authorWhereInput
    /**
     * Limit how many authors to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: authorIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * author upsert
   */
  export type authorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the author
     */
    select?: authorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the author
     */
    omit?: authorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: authorInclude<ExtArgs> | null
    /**
     * The filter to search for the author to update in case it exists.
     */
    where: authorWhereUniqueInput
    /**
     * In case the author found by the `where` argument doesn't exist, create a new author with this data.
     */
    create: XOR<authorCreateInput, authorUncheckedCreateInput>
    /**
     * In case the author was found with the provided `where` argument, update it with this data.
     */
    update: XOR<authorUpdateInput, authorUncheckedUpdateInput>
  }

  /**
   * author delete
   */
  export type authorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the author
     */
    select?: authorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the author
     */
    omit?: authorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: authorInclude<ExtArgs> | null
    /**
     * Filter which author to delete.
     */
    where: authorWhereUniqueInput
  }

  /**
   * author deleteMany
   */
  export type authorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which authors to delete
     */
    where?: authorWhereInput
    /**
     * Limit how many authors to delete.
     */
    limit?: number
  }

  /**
   * author.auth_user
   */
  export type author$auth_userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auth_user
     */
    select?: auth_userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the auth_user
     */
    omit?: auth_userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auth_userInclude<ExtArgs> | null
    where?: auth_userWhereInput
    orderBy?: auth_userOrderByWithRelationInput | auth_userOrderByWithRelationInput[]
    cursor?: auth_userWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Auth_userScalarFieldEnum | Auth_userScalarFieldEnum[]
  }

  /**
   * author.auth_account
   */
  export type author$auth_accountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auth_account
     */
    select?: auth_accountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the auth_account
     */
    omit?: auth_accountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auth_accountInclude<ExtArgs> | null
    where?: auth_accountWhereInput
  }

  /**
   * author.book
   */
  export type author$bookArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the book
     */
    select?: bookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the book
     */
    omit?: bookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bookInclude<ExtArgs> | null
    where?: bookWhereInput
    orderBy?: bookOrderByWithRelationInput | bookOrderByWithRelationInput[]
    cursor?: bookWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookScalarFieldEnum | BookScalarFieldEnum[]
  }

  /**
   * author.product
   */
  export type author$productArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product
     */
    select?: productSelect<ExtArgs> | null
    /**
     * Omit specific fields from the product
     */
    omit?: productOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productInclude<ExtArgs> | null
    where?: productWhereInput
    orderBy?: productOrderByWithRelationInput | productOrderByWithRelationInput[]
    cursor?: productWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * author.publisher_author
   */
  export type author$publisher_authorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the publisher_author
     */
    select?: publisher_authorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the publisher_author
     */
    omit?: publisher_authorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: publisher_authorInclude<ExtArgs> | null
    where?: publisher_authorWhereInput
    orderBy?: publisher_authorOrderByWithRelationInput | publisher_authorOrderByWithRelationInput[]
    cursor?: publisher_authorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Publisher_authorScalarFieldEnum | Publisher_authorScalarFieldEnum[]
  }

  /**
   * author without action
   */
  export type authorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the author
     */
    select?: authorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the author
     */
    omit?: authorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: authorInclude<ExtArgs> | null
  }


  /**
   * Model banner
   */

  export type AggregateBanner = {
    _count: BannerCountAggregateOutputType | null
    _min: BannerMinAggregateOutputType | null
    _max: BannerMaxAggregateOutputType | null
  }

  export type BannerMinAggregateOutputType = {
    id: string | null
    title: string | null
    banner_file: string | null
    status: string | null
    deleted_at: Date | null
    link: string | null
  }

  export type BannerMaxAggregateOutputType = {
    id: string | null
    title: string | null
    banner_file: string | null
    status: string | null
    deleted_at: Date | null
    link: string | null
  }

  export type BannerCountAggregateOutputType = {
    id: number
    title: number
    banner_file: number
    status: number
    deleted_at: number
    link: number
    _all: number
  }


  export type BannerMinAggregateInputType = {
    id?: true
    title?: true
    banner_file?: true
    status?: true
    deleted_at?: true
    link?: true
  }

  export type BannerMaxAggregateInputType = {
    id?: true
    title?: true
    banner_file?: true
    status?: true
    deleted_at?: true
    link?: true
  }

  export type BannerCountAggregateInputType = {
    id?: true
    title?: true
    banner_file?: true
    status?: true
    deleted_at?: true
    link?: true
    _all?: true
  }

  export type BannerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which banner to aggregate.
     */
    where?: bannerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of banners to fetch.
     */
    orderBy?: bannerOrderByWithRelationInput | bannerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: bannerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` banners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` banners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned banners
    **/
    _count?: true | BannerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BannerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BannerMaxAggregateInputType
  }

  export type GetBannerAggregateType<T extends BannerAggregateArgs> = {
        [P in keyof T & keyof AggregateBanner]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBanner[P]>
      : GetScalarType<T[P], AggregateBanner[P]>
  }




  export type bannerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: bannerWhereInput
    orderBy?: bannerOrderByWithAggregationInput | bannerOrderByWithAggregationInput[]
    by: BannerScalarFieldEnum[] | BannerScalarFieldEnum
    having?: bannerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BannerCountAggregateInputType | true
    _min?: BannerMinAggregateInputType
    _max?: BannerMaxAggregateInputType
  }

  export type BannerGroupByOutputType = {
    id: string
    title: string
    banner_file: string
    status: string | null
    deleted_at: Date | null
    link: string | null
    _count: BannerCountAggregateOutputType | null
    _min: BannerMinAggregateOutputType | null
    _max: BannerMaxAggregateOutputType | null
  }

  type GetBannerGroupByPayload<T extends bannerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BannerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BannerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BannerGroupByOutputType[P]>
            : GetScalarType<T[P], BannerGroupByOutputType[P]>
        }
      >
    >


  export type bannerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    banner_file?: boolean
    status?: boolean
    deleted_at?: boolean
    link?: boolean
  }, ExtArgs["result"]["banner"]>

  export type bannerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    banner_file?: boolean
    status?: boolean
    deleted_at?: boolean
    link?: boolean
  }, ExtArgs["result"]["banner"]>

  export type bannerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    banner_file?: boolean
    status?: boolean
    deleted_at?: boolean
    link?: boolean
  }, ExtArgs["result"]["banner"]>

  export type bannerSelectScalar = {
    id?: boolean
    title?: boolean
    banner_file?: boolean
    status?: boolean
    deleted_at?: boolean
    link?: boolean
  }

  export type bannerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "banner_file" | "status" | "deleted_at" | "link", ExtArgs["result"]["banner"]>

  export type $bannerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "banner"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      banner_file: string
      status: string | null
      deleted_at: Date | null
      link: string | null
    }, ExtArgs["result"]["banner"]>
    composites: {}
  }

  type bannerGetPayload<S extends boolean | null | undefined | bannerDefaultArgs> = $Result.GetResult<Prisma.$bannerPayload, S>

  type bannerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<bannerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BannerCountAggregateInputType | true
    }

  export interface bannerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['banner'], meta: { name: 'banner' } }
    /**
     * Find zero or one Banner that matches the filter.
     * @param {bannerFindUniqueArgs} args - Arguments to find a Banner
     * @example
     * // Get one Banner
     * const banner = await prisma.banner.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends bannerFindUniqueArgs>(args: SelectSubset<T, bannerFindUniqueArgs<ExtArgs>>): Prisma__bannerClient<$Result.GetResult<Prisma.$bannerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Banner that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {bannerFindUniqueOrThrowArgs} args - Arguments to find a Banner
     * @example
     * // Get one Banner
     * const banner = await prisma.banner.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends bannerFindUniqueOrThrowArgs>(args: SelectSubset<T, bannerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__bannerClient<$Result.GetResult<Prisma.$bannerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Banner that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bannerFindFirstArgs} args - Arguments to find a Banner
     * @example
     * // Get one Banner
     * const banner = await prisma.banner.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends bannerFindFirstArgs>(args?: SelectSubset<T, bannerFindFirstArgs<ExtArgs>>): Prisma__bannerClient<$Result.GetResult<Prisma.$bannerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Banner that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bannerFindFirstOrThrowArgs} args - Arguments to find a Banner
     * @example
     * // Get one Banner
     * const banner = await prisma.banner.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends bannerFindFirstOrThrowArgs>(args?: SelectSubset<T, bannerFindFirstOrThrowArgs<ExtArgs>>): Prisma__bannerClient<$Result.GetResult<Prisma.$bannerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Banners that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bannerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Banners
     * const banners = await prisma.banner.findMany()
     * 
     * // Get first 10 Banners
     * const banners = await prisma.banner.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bannerWithIdOnly = await prisma.banner.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends bannerFindManyArgs>(args?: SelectSubset<T, bannerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$bannerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Banner.
     * @param {bannerCreateArgs} args - Arguments to create a Banner.
     * @example
     * // Create one Banner
     * const Banner = await prisma.banner.create({
     *   data: {
     *     // ... data to create a Banner
     *   }
     * })
     * 
     */
    create<T extends bannerCreateArgs>(args: SelectSubset<T, bannerCreateArgs<ExtArgs>>): Prisma__bannerClient<$Result.GetResult<Prisma.$bannerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Banners.
     * @param {bannerCreateManyArgs} args - Arguments to create many Banners.
     * @example
     * // Create many Banners
     * const banner = await prisma.banner.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends bannerCreateManyArgs>(args?: SelectSubset<T, bannerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Banners and returns the data saved in the database.
     * @param {bannerCreateManyAndReturnArgs} args - Arguments to create many Banners.
     * @example
     * // Create many Banners
     * const banner = await prisma.banner.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Banners and only return the `id`
     * const bannerWithIdOnly = await prisma.banner.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends bannerCreateManyAndReturnArgs>(args?: SelectSubset<T, bannerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$bannerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Banner.
     * @param {bannerDeleteArgs} args - Arguments to delete one Banner.
     * @example
     * // Delete one Banner
     * const Banner = await prisma.banner.delete({
     *   where: {
     *     // ... filter to delete one Banner
     *   }
     * })
     * 
     */
    delete<T extends bannerDeleteArgs>(args: SelectSubset<T, bannerDeleteArgs<ExtArgs>>): Prisma__bannerClient<$Result.GetResult<Prisma.$bannerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Banner.
     * @param {bannerUpdateArgs} args - Arguments to update one Banner.
     * @example
     * // Update one Banner
     * const banner = await prisma.banner.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends bannerUpdateArgs>(args: SelectSubset<T, bannerUpdateArgs<ExtArgs>>): Prisma__bannerClient<$Result.GetResult<Prisma.$bannerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Banners.
     * @param {bannerDeleteManyArgs} args - Arguments to filter Banners to delete.
     * @example
     * // Delete a few Banners
     * const { count } = await prisma.banner.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends bannerDeleteManyArgs>(args?: SelectSubset<T, bannerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Banners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bannerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Banners
     * const banner = await prisma.banner.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends bannerUpdateManyArgs>(args: SelectSubset<T, bannerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Banners and returns the data updated in the database.
     * @param {bannerUpdateManyAndReturnArgs} args - Arguments to update many Banners.
     * @example
     * // Update many Banners
     * const banner = await prisma.banner.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Banners and only return the `id`
     * const bannerWithIdOnly = await prisma.banner.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends bannerUpdateManyAndReturnArgs>(args: SelectSubset<T, bannerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$bannerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Banner.
     * @param {bannerUpsertArgs} args - Arguments to update or create a Banner.
     * @example
     * // Update or create a Banner
     * const banner = await prisma.banner.upsert({
     *   create: {
     *     // ... data to create a Banner
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Banner we want to update
     *   }
     * })
     */
    upsert<T extends bannerUpsertArgs>(args: SelectSubset<T, bannerUpsertArgs<ExtArgs>>): Prisma__bannerClient<$Result.GetResult<Prisma.$bannerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Banners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bannerCountArgs} args - Arguments to filter Banners to count.
     * @example
     * // Count the number of Banners
     * const count = await prisma.banner.count({
     *   where: {
     *     // ... the filter for the Banners we want to count
     *   }
     * })
    **/
    count<T extends bannerCountArgs>(
      args?: Subset<T, bannerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BannerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Banner.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BannerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BannerAggregateArgs>(args: Subset<T, BannerAggregateArgs>): Prisma.PrismaPromise<GetBannerAggregateType<T>>

    /**
     * Group by Banner.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bannerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends bannerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: bannerGroupByArgs['orderBy'] }
        : { orderBy?: bannerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, bannerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBannerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the banner model
   */
  readonly fields: bannerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for banner.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__bannerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the banner model
   */
  interface bannerFieldRefs {
    readonly id: FieldRef<"banner", 'String'>
    readonly title: FieldRef<"banner", 'String'>
    readonly banner_file: FieldRef<"banner", 'String'>
    readonly status: FieldRef<"banner", 'String'>
    readonly deleted_at: FieldRef<"banner", 'DateTime'>
    readonly link: FieldRef<"banner", 'String'>
  }
    

  // Custom InputTypes
  /**
   * banner findUnique
   */
  export type bannerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the banner
     */
    select?: bannerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the banner
     */
    omit?: bannerOmit<ExtArgs> | null
    /**
     * Filter, which banner to fetch.
     */
    where: bannerWhereUniqueInput
  }

  /**
   * banner findUniqueOrThrow
   */
  export type bannerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the banner
     */
    select?: bannerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the banner
     */
    omit?: bannerOmit<ExtArgs> | null
    /**
     * Filter, which banner to fetch.
     */
    where: bannerWhereUniqueInput
  }

  /**
   * banner findFirst
   */
  export type bannerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the banner
     */
    select?: bannerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the banner
     */
    omit?: bannerOmit<ExtArgs> | null
    /**
     * Filter, which banner to fetch.
     */
    where?: bannerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of banners to fetch.
     */
    orderBy?: bannerOrderByWithRelationInput | bannerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for banners.
     */
    cursor?: bannerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` banners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` banners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of banners.
     */
    distinct?: BannerScalarFieldEnum | BannerScalarFieldEnum[]
  }

  /**
   * banner findFirstOrThrow
   */
  export type bannerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the banner
     */
    select?: bannerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the banner
     */
    omit?: bannerOmit<ExtArgs> | null
    /**
     * Filter, which banner to fetch.
     */
    where?: bannerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of banners to fetch.
     */
    orderBy?: bannerOrderByWithRelationInput | bannerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for banners.
     */
    cursor?: bannerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` banners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` banners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of banners.
     */
    distinct?: BannerScalarFieldEnum | BannerScalarFieldEnum[]
  }

  /**
   * banner findMany
   */
  export type bannerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the banner
     */
    select?: bannerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the banner
     */
    omit?: bannerOmit<ExtArgs> | null
    /**
     * Filter, which banners to fetch.
     */
    where?: bannerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of banners to fetch.
     */
    orderBy?: bannerOrderByWithRelationInput | bannerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing banners.
     */
    cursor?: bannerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` banners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` banners.
     */
    skip?: number
    distinct?: BannerScalarFieldEnum | BannerScalarFieldEnum[]
  }

  /**
   * banner create
   */
  export type bannerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the banner
     */
    select?: bannerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the banner
     */
    omit?: bannerOmit<ExtArgs> | null
    /**
     * The data needed to create a banner.
     */
    data: XOR<bannerCreateInput, bannerUncheckedCreateInput>
  }

  /**
   * banner createMany
   */
  export type bannerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many banners.
     */
    data: bannerCreateManyInput | bannerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * banner createManyAndReturn
   */
  export type bannerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the banner
     */
    select?: bannerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the banner
     */
    omit?: bannerOmit<ExtArgs> | null
    /**
     * The data used to create many banners.
     */
    data: bannerCreateManyInput | bannerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * banner update
   */
  export type bannerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the banner
     */
    select?: bannerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the banner
     */
    omit?: bannerOmit<ExtArgs> | null
    /**
     * The data needed to update a banner.
     */
    data: XOR<bannerUpdateInput, bannerUncheckedUpdateInput>
    /**
     * Choose, which banner to update.
     */
    where: bannerWhereUniqueInput
  }

  /**
   * banner updateMany
   */
  export type bannerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update banners.
     */
    data: XOR<bannerUpdateManyMutationInput, bannerUncheckedUpdateManyInput>
    /**
     * Filter which banners to update
     */
    where?: bannerWhereInput
    /**
     * Limit how many banners to update.
     */
    limit?: number
  }

  /**
   * banner updateManyAndReturn
   */
  export type bannerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the banner
     */
    select?: bannerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the banner
     */
    omit?: bannerOmit<ExtArgs> | null
    /**
     * The data used to update banners.
     */
    data: XOR<bannerUpdateManyMutationInput, bannerUncheckedUpdateManyInput>
    /**
     * Filter which banners to update
     */
    where?: bannerWhereInput
    /**
     * Limit how many banners to update.
     */
    limit?: number
  }

  /**
   * banner upsert
   */
  export type bannerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the banner
     */
    select?: bannerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the banner
     */
    omit?: bannerOmit<ExtArgs> | null
    /**
     * The filter to search for the banner to update in case it exists.
     */
    where: bannerWhereUniqueInput
    /**
     * In case the banner found by the `where` argument doesn't exist, create a new banner with this data.
     */
    create: XOR<bannerCreateInput, bannerUncheckedCreateInput>
    /**
     * In case the banner was found with the provided `where` argument, update it with this data.
     */
    update: XOR<bannerUpdateInput, bannerUncheckedUpdateInput>
  }

  /**
   * banner delete
   */
  export type bannerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the banner
     */
    select?: bannerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the banner
     */
    omit?: bannerOmit<ExtArgs> | null
    /**
     * Filter which banner to delete.
     */
    where: bannerWhereUniqueInput
  }

  /**
   * banner deleteMany
   */
  export type bannerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which banners to delete
     */
    where?: bannerWhereInput
    /**
     * Limit how many banners to delete.
     */
    limit?: number
  }

  /**
   * banner without action
   */
  export type bannerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the banner
     */
    select?: bannerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the banner
     */
    omit?: bannerOmit<ExtArgs> | null
  }


  /**
   * Model book
   */

  export type AggregateBook = {
    _count: BookCountAggregateOutputType | null
    _avg: BookAvgAggregateOutputType | null
    _sum: BookSumAggregateOutputType | null
    _min: BookMinAggregateOutputType | null
    _max: BookMaxAggregateOutputType | null
  }

  export type BookAvgAggregateOutputType = {
    submitted_price: Decimal | null
    preorder_min_qty: number | null
  }

  export type BookSumAggregateOutputType = {
    submitted_price: Decimal | null
    preorder_min_qty: number | null
  }

  export type BookMinAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    alias: string | null
    submitted_price: Decimal | null
    desc: string | null
    status: string | null
    currency: string | null
    deleted_at: Date | null
    img_file: string | null
    cover: string | null
    product_file: string | null
    sku: string | null
    id_author: string | null
    published_date: Date | null
    is_physical: boolean | null
    preorder_min_qty: number | null
    content_type: string | null
    is_chapter: boolean | null
    id_product: string | null
    created_at: Date | null
  }

  export type BookMaxAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    alias: string | null
    submitted_price: Decimal | null
    desc: string | null
    status: string | null
    currency: string | null
    deleted_at: Date | null
    img_file: string | null
    cover: string | null
    product_file: string | null
    sku: string | null
    id_author: string | null
    published_date: Date | null
    is_physical: boolean | null
    preorder_min_qty: number | null
    content_type: string | null
    is_chapter: boolean | null
    id_product: string | null
    created_at: Date | null
  }

  export type BookCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    alias: number
    submitted_price: number
    desc: number
    info: number
    status: number
    currency: number
    deleted_at: number
    img_file: number
    cover: number
    product_file: number
    sku: number
    id_author: number
    published_date: number
    is_physical: number
    preorder_min_qty: number
    content_type: number
    is_chapter: number
    id_product: number
    created_at: number
    _all: number
  }


  export type BookAvgAggregateInputType = {
    submitted_price?: true
    preorder_min_qty?: true
  }

  export type BookSumAggregateInputType = {
    submitted_price?: true
    preorder_min_qty?: true
  }

  export type BookMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    alias?: true
    submitted_price?: true
    desc?: true
    status?: true
    currency?: true
    deleted_at?: true
    img_file?: true
    cover?: true
    product_file?: true
    sku?: true
    id_author?: true
    published_date?: true
    is_physical?: true
    preorder_min_qty?: true
    content_type?: true
    is_chapter?: true
    id_product?: true
    created_at?: true
  }

  export type BookMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    alias?: true
    submitted_price?: true
    desc?: true
    status?: true
    currency?: true
    deleted_at?: true
    img_file?: true
    cover?: true
    product_file?: true
    sku?: true
    id_author?: true
    published_date?: true
    is_physical?: true
    preorder_min_qty?: true
    content_type?: true
    is_chapter?: true
    id_product?: true
    created_at?: true
  }

  export type BookCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    alias?: true
    submitted_price?: true
    desc?: true
    info?: true
    status?: true
    currency?: true
    deleted_at?: true
    img_file?: true
    cover?: true
    product_file?: true
    sku?: true
    id_author?: true
    published_date?: true
    is_physical?: true
    preorder_min_qty?: true
    content_type?: true
    is_chapter?: true
    id_product?: true
    created_at?: true
    _all?: true
  }

  export type BookAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which book to aggregate.
     */
    where?: bookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of books to fetch.
     */
    orderBy?: bookOrderByWithRelationInput | bookOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: bookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` books from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` books.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned books
    **/
    _count?: true | BookCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BookAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BookSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BookMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BookMaxAggregateInputType
  }

  export type GetBookAggregateType<T extends BookAggregateArgs> = {
        [P in keyof T & keyof AggregateBook]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBook[P]>
      : GetScalarType<T[P], AggregateBook[P]>
  }




  export type bookGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: bookWhereInput
    orderBy?: bookOrderByWithAggregationInput | bookOrderByWithAggregationInput[]
    by: BookScalarFieldEnum[] | BookScalarFieldEnum
    having?: bookScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BookCountAggregateInputType | true
    _avg?: BookAvgAggregateInputType
    _sum?: BookSumAggregateInputType
    _min?: BookMinAggregateInputType
    _max?: BookMaxAggregateInputType
  }

  export type BookGroupByOutputType = {
    id: string
    name: string
    slug: string
    alias: string
    submitted_price: Decimal
    desc: string
    info: JsonValue | null
    status: string
    currency: string
    deleted_at: Date | null
    img_file: string
    cover: string
    product_file: string
    sku: string
    id_author: string | null
    published_date: Date
    is_physical: boolean
    preorder_min_qty: number | null
    content_type: string | null
    is_chapter: boolean
    id_product: string | null
    created_at: Date
    _count: BookCountAggregateOutputType | null
    _avg: BookAvgAggregateOutputType | null
    _sum: BookSumAggregateOutputType | null
    _min: BookMinAggregateOutputType | null
    _max: BookMaxAggregateOutputType | null
  }

  type GetBookGroupByPayload<T extends bookGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BookGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BookGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BookGroupByOutputType[P]>
            : GetScalarType<T[P], BookGroupByOutputType[P]>
        }
      >
    >


  export type bookSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    alias?: boolean
    submitted_price?: boolean
    desc?: boolean
    info?: boolean
    status?: boolean
    currency?: boolean
    deleted_at?: boolean
    img_file?: boolean
    cover?: boolean
    product_file?: boolean
    sku?: boolean
    id_author?: boolean
    published_date?: boolean
    is_physical?: boolean
    preorder_min_qty?: boolean
    content_type?: boolean
    is_chapter?: boolean
    id_product?: boolean
    created_at?: boolean
    author?: boolean | book$authorArgs<ExtArgs>
    product?: boolean | book$productArgs<ExtArgs>
    book_approval?: boolean | book$book_approvalArgs<ExtArgs>
    book_changes_log?: boolean | book$book_changes_logArgs<ExtArgs>
    book_genre?: boolean | book$book_genreArgs<ExtArgs>
    book_tags?: boolean | book$book_tagsArgs<ExtArgs>
    chapter?: boolean | book$chapterArgs<ExtArgs>
    ranking?: boolean | book$rankingArgs<ExtArgs>
    reviews?: boolean | book$reviewsArgs<ExtArgs>
    _count?: boolean | BookCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["book"]>

  export type bookSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    alias?: boolean
    submitted_price?: boolean
    desc?: boolean
    info?: boolean
    status?: boolean
    currency?: boolean
    deleted_at?: boolean
    img_file?: boolean
    cover?: boolean
    product_file?: boolean
    sku?: boolean
    id_author?: boolean
    published_date?: boolean
    is_physical?: boolean
    preorder_min_qty?: boolean
    content_type?: boolean
    is_chapter?: boolean
    id_product?: boolean
    created_at?: boolean
    author?: boolean | book$authorArgs<ExtArgs>
    product?: boolean | book$productArgs<ExtArgs>
  }, ExtArgs["result"]["book"]>

  export type bookSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    alias?: boolean
    submitted_price?: boolean
    desc?: boolean
    info?: boolean
    status?: boolean
    currency?: boolean
    deleted_at?: boolean
    img_file?: boolean
    cover?: boolean
    product_file?: boolean
    sku?: boolean
    id_author?: boolean
    published_date?: boolean
    is_physical?: boolean
    preorder_min_qty?: boolean
    content_type?: boolean
    is_chapter?: boolean
    id_product?: boolean
    created_at?: boolean
    author?: boolean | book$authorArgs<ExtArgs>
    product?: boolean | book$productArgs<ExtArgs>
  }, ExtArgs["result"]["book"]>

  export type bookSelectScalar = {
    id?: boolean
    name?: boolean
    slug?: boolean
    alias?: boolean
    submitted_price?: boolean
    desc?: boolean
    info?: boolean
    status?: boolean
    currency?: boolean
    deleted_at?: boolean
    img_file?: boolean
    cover?: boolean
    product_file?: boolean
    sku?: boolean
    id_author?: boolean
    published_date?: boolean
    is_physical?: boolean
    preorder_min_qty?: boolean
    content_type?: boolean
    is_chapter?: boolean
    id_product?: boolean
    created_at?: boolean
  }

  export type bookOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "slug" | "alias" | "submitted_price" | "desc" | "info" | "status" | "currency" | "deleted_at" | "img_file" | "cover" | "product_file" | "sku" | "id_author" | "published_date" | "is_physical" | "preorder_min_qty" | "content_type" | "is_chapter" | "id_product" | "created_at", ExtArgs["result"]["book"]>
  export type bookInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    author?: boolean | book$authorArgs<ExtArgs>
    product?: boolean | book$productArgs<ExtArgs>
    book_approval?: boolean | book$book_approvalArgs<ExtArgs>
    book_changes_log?: boolean | book$book_changes_logArgs<ExtArgs>
    book_genre?: boolean | book$book_genreArgs<ExtArgs>
    book_tags?: boolean | book$book_tagsArgs<ExtArgs>
    chapter?: boolean | book$chapterArgs<ExtArgs>
    ranking?: boolean | book$rankingArgs<ExtArgs>
    reviews?: boolean | book$reviewsArgs<ExtArgs>
    _count?: boolean | BookCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type bookIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    author?: boolean | book$authorArgs<ExtArgs>
    product?: boolean | book$productArgs<ExtArgs>
  }
  export type bookIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    author?: boolean | book$authorArgs<ExtArgs>
    product?: boolean | book$productArgs<ExtArgs>
  }

  export type $bookPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "book"
    objects: {
      author: Prisma.$authorPayload<ExtArgs> | null
      product: Prisma.$productPayload<ExtArgs> | null
      book_approval: Prisma.$book_approvalPayload<ExtArgs>[]
      book_changes_log: Prisma.$book_changes_logPayload<ExtArgs>[]
      book_genre: Prisma.$book_genrePayload<ExtArgs>[]
      book_tags: Prisma.$book_tagsPayload<ExtArgs>[]
      chapter: Prisma.$chapterPayload<ExtArgs>[]
      ranking: Prisma.$rankingPayload<ExtArgs>[]
      reviews: Prisma.$reviewsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      slug: string
      alias: string
      submitted_price: Prisma.Decimal
      desc: string
      info: Prisma.JsonValue | null
      status: string
      currency: string
      deleted_at: Date | null
      img_file: string
      cover: string
      product_file: string
      sku: string
      id_author: string | null
      published_date: Date
      is_physical: boolean
      preorder_min_qty: number | null
      content_type: string | null
      is_chapter: boolean
      id_product: string | null
      created_at: Date
    }, ExtArgs["result"]["book"]>
    composites: {}
  }

  type bookGetPayload<S extends boolean | null | undefined | bookDefaultArgs> = $Result.GetResult<Prisma.$bookPayload, S>

  type bookCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<bookFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BookCountAggregateInputType | true
    }

  export interface bookDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['book'], meta: { name: 'book' } }
    /**
     * Find zero or one Book that matches the filter.
     * @param {bookFindUniqueArgs} args - Arguments to find a Book
     * @example
     * // Get one Book
     * const book = await prisma.book.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends bookFindUniqueArgs>(args: SelectSubset<T, bookFindUniqueArgs<ExtArgs>>): Prisma__bookClient<$Result.GetResult<Prisma.$bookPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Book that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {bookFindUniqueOrThrowArgs} args - Arguments to find a Book
     * @example
     * // Get one Book
     * const book = await prisma.book.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends bookFindUniqueOrThrowArgs>(args: SelectSubset<T, bookFindUniqueOrThrowArgs<ExtArgs>>): Prisma__bookClient<$Result.GetResult<Prisma.$bookPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Book that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bookFindFirstArgs} args - Arguments to find a Book
     * @example
     * // Get one Book
     * const book = await prisma.book.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends bookFindFirstArgs>(args?: SelectSubset<T, bookFindFirstArgs<ExtArgs>>): Prisma__bookClient<$Result.GetResult<Prisma.$bookPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Book that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bookFindFirstOrThrowArgs} args - Arguments to find a Book
     * @example
     * // Get one Book
     * const book = await prisma.book.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends bookFindFirstOrThrowArgs>(args?: SelectSubset<T, bookFindFirstOrThrowArgs<ExtArgs>>): Prisma__bookClient<$Result.GetResult<Prisma.$bookPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Books that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bookFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Books
     * const books = await prisma.book.findMany()
     * 
     * // Get first 10 Books
     * const books = await prisma.book.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bookWithIdOnly = await prisma.book.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends bookFindManyArgs>(args?: SelectSubset<T, bookFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$bookPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Book.
     * @param {bookCreateArgs} args - Arguments to create a Book.
     * @example
     * // Create one Book
     * const Book = await prisma.book.create({
     *   data: {
     *     // ... data to create a Book
     *   }
     * })
     * 
     */
    create<T extends bookCreateArgs>(args: SelectSubset<T, bookCreateArgs<ExtArgs>>): Prisma__bookClient<$Result.GetResult<Prisma.$bookPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Books.
     * @param {bookCreateManyArgs} args - Arguments to create many Books.
     * @example
     * // Create many Books
     * const book = await prisma.book.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends bookCreateManyArgs>(args?: SelectSubset<T, bookCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Books and returns the data saved in the database.
     * @param {bookCreateManyAndReturnArgs} args - Arguments to create many Books.
     * @example
     * // Create many Books
     * const book = await prisma.book.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Books and only return the `id`
     * const bookWithIdOnly = await prisma.book.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends bookCreateManyAndReturnArgs>(args?: SelectSubset<T, bookCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$bookPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Book.
     * @param {bookDeleteArgs} args - Arguments to delete one Book.
     * @example
     * // Delete one Book
     * const Book = await prisma.book.delete({
     *   where: {
     *     // ... filter to delete one Book
     *   }
     * })
     * 
     */
    delete<T extends bookDeleteArgs>(args: SelectSubset<T, bookDeleteArgs<ExtArgs>>): Prisma__bookClient<$Result.GetResult<Prisma.$bookPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Book.
     * @param {bookUpdateArgs} args - Arguments to update one Book.
     * @example
     * // Update one Book
     * const book = await prisma.book.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends bookUpdateArgs>(args: SelectSubset<T, bookUpdateArgs<ExtArgs>>): Prisma__bookClient<$Result.GetResult<Prisma.$bookPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Books.
     * @param {bookDeleteManyArgs} args - Arguments to filter Books to delete.
     * @example
     * // Delete a few Books
     * const { count } = await prisma.book.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends bookDeleteManyArgs>(args?: SelectSubset<T, bookDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Books.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bookUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Books
     * const book = await prisma.book.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends bookUpdateManyArgs>(args: SelectSubset<T, bookUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Books and returns the data updated in the database.
     * @param {bookUpdateManyAndReturnArgs} args - Arguments to update many Books.
     * @example
     * // Update many Books
     * const book = await prisma.book.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Books and only return the `id`
     * const bookWithIdOnly = await prisma.book.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends bookUpdateManyAndReturnArgs>(args: SelectSubset<T, bookUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$bookPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Book.
     * @param {bookUpsertArgs} args - Arguments to update or create a Book.
     * @example
     * // Update or create a Book
     * const book = await prisma.book.upsert({
     *   create: {
     *     // ... data to create a Book
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Book we want to update
     *   }
     * })
     */
    upsert<T extends bookUpsertArgs>(args: SelectSubset<T, bookUpsertArgs<ExtArgs>>): Prisma__bookClient<$Result.GetResult<Prisma.$bookPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Books.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bookCountArgs} args - Arguments to filter Books to count.
     * @example
     * // Count the number of Books
     * const count = await prisma.book.count({
     *   where: {
     *     // ... the filter for the Books we want to count
     *   }
     * })
    **/
    count<T extends bookCountArgs>(
      args?: Subset<T, bookCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BookCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Book.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BookAggregateArgs>(args: Subset<T, BookAggregateArgs>): Prisma.PrismaPromise<GetBookAggregateType<T>>

    /**
     * Group by Book.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bookGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends bookGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: bookGroupByArgs['orderBy'] }
        : { orderBy?: bookGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, bookGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBookGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the book model
   */
  readonly fields: bookFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for book.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__bookClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    author<T extends book$authorArgs<ExtArgs> = {}>(args?: Subset<T, book$authorArgs<ExtArgs>>): Prisma__authorClient<$Result.GetResult<Prisma.$authorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    product<T extends book$productArgs<ExtArgs> = {}>(args?: Subset<T, book$productArgs<ExtArgs>>): Prisma__productClient<$Result.GetResult<Prisma.$productPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    book_approval<T extends book$book_approvalArgs<ExtArgs> = {}>(args?: Subset<T, book$book_approvalArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$book_approvalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    book_changes_log<T extends book$book_changes_logArgs<ExtArgs> = {}>(args?: Subset<T, book$book_changes_logArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$book_changes_logPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    book_genre<T extends book$book_genreArgs<ExtArgs> = {}>(args?: Subset<T, book$book_genreArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$book_genrePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    book_tags<T extends book$book_tagsArgs<ExtArgs> = {}>(args?: Subset<T, book$book_tagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$book_tagsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    chapter<T extends book$chapterArgs<ExtArgs> = {}>(args?: Subset<T, book$chapterArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$chapterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ranking<T extends book$rankingArgs<ExtArgs> = {}>(args?: Subset<T, book$rankingArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$rankingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reviews<T extends book$reviewsArgs<ExtArgs> = {}>(args?: Subset<T, book$reviewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$reviewsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the book model
   */
  interface bookFieldRefs {
    readonly id: FieldRef<"book", 'String'>
    readonly name: FieldRef<"book", 'String'>
    readonly slug: FieldRef<"book", 'String'>
    readonly alias: FieldRef<"book", 'String'>
    readonly submitted_price: FieldRef<"book", 'Decimal'>
    readonly desc: FieldRef<"book", 'String'>
    readonly info: FieldRef<"book", 'Json'>
    readonly status: FieldRef<"book", 'String'>
    readonly currency: FieldRef<"book", 'String'>
    readonly deleted_at: FieldRef<"book", 'DateTime'>
    readonly img_file: FieldRef<"book", 'String'>
    readonly cover: FieldRef<"book", 'String'>
    readonly product_file: FieldRef<"book", 'String'>
    readonly sku: FieldRef<"book", 'String'>
    readonly id_author: FieldRef<"book", 'String'>
    readonly published_date: FieldRef<"book", 'DateTime'>
    readonly is_physical: FieldRef<"book", 'Boolean'>
    readonly preorder_min_qty: FieldRef<"book", 'Int'>
    readonly content_type: FieldRef<"book", 'String'>
    readonly is_chapter: FieldRef<"book", 'Boolean'>
    readonly id_product: FieldRef<"book", 'String'>
    readonly created_at: FieldRef<"book", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * book findUnique
   */
  export type bookFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the book
     */
    select?: bookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the book
     */
    omit?: bookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bookInclude<ExtArgs> | null
    /**
     * Filter, which book to fetch.
     */
    where: bookWhereUniqueInput
  }

  /**
   * book findUniqueOrThrow
   */
  export type bookFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the book
     */
    select?: bookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the book
     */
    omit?: bookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bookInclude<ExtArgs> | null
    /**
     * Filter, which book to fetch.
     */
    where: bookWhereUniqueInput
  }

  /**
   * book findFirst
   */
  export type bookFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the book
     */
    select?: bookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the book
     */
    omit?: bookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bookInclude<ExtArgs> | null
    /**
     * Filter, which book to fetch.
     */
    where?: bookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of books to fetch.
     */
    orderBy?: bookOrderByWithRelationInput | bookOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for books.
     */
    cursor?: bookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` books from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` books.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of books.
     */
    distinct?: BookScalarFieldEnum | BookScalarFieldEnum[]
  }

  /**
   * book findFirstOrThrow
   */
  export type bookFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the book
     */
    select?: bookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the book
     */
    omit?: bookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bookInclude<ExtArgs> | null
    /**
     * Filter, which book to fetch.
     */
    where?: bookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of books to fetch.
     */
    orderBy?: bookOrderByWithRelationInput | bookOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for books.
     */
    cursor?: bookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` books from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` books.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of books.
     */
    distinct?: BookScalarFieldEnum | BookScalarFieldEnum[]
  }

  /**
   * book findMany
   */
  export type bookFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the book
     */
    select?: bookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the book
     */
    omit?: bookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bookInclude<ExtArgs> | null
    /**
     * Filter, which books to fetch.
     */
    where?: bookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of books to fetch.
     */
    orderBy?: bookOrderByWithRelationInput | bookOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing books.
     */
    cursor?: bookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` books from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` books.
     */
    skip?: number
    distinct?: BookScalarFieldEnum | BookScalarFieldEnum[]
  }

  /**
   * book create
   */
  export type bookCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the book
     */
    select?: bookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the book
     */
    omit?: bookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bookInclude<ExtArgs> | null
    /**
     * The data needed to create a book.
     */
    data: XOR<bookCreateInput, bookUncheckedCreateInput>
  }

  /**
   * book createMany
   */
  export type bookCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many books.
     */
    data: bookCreateManyInput | bookCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * book createManyAndReturn
   */
  export type bookCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the book
     */
    select?: bookSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the book
     */
    omit?: bookOmit<ExtArgs> | null
    /**
     * The data used to create many books.
     */
    data: bookCreateManyInput | bookCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bookIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * book update
   */
  export type bookUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the book
     */
    select?: bookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the book
     */
    omit?: bookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bookInclude<ExtArgs> | null
    /**
     * The data needed to update a book.
     */
    data: XOR<bookUpdateInput, bookUncheckedUpdateInput>
    /**
     * Choose, which book to update.
     */
    where: bookWhereUniqueInput
  }

  /**
   * book updateMany
   */
  export type bookUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update books.
     */
    data: XOR<bookUpdateManyMutationInput, bookUncheckedUpdateManyInput>
    /**
     * Filter which books to update
     */
    where?: bookWhereInput
    /**
     * Limit how many books to update.
     */
    limit?: number
  }

  /**
   * book updateManyAndReturn
   */
  export type bookUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the book
     */
    select?: bookSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the book
     */
    omit?: bookOmit<ExtArgs> | null
    /**
     * The data used to update books.
     */
    data: XOR<bookUpdateManyMutationInput, bookUncheckedUpdateManyInput>
    /**
     * Filter which books to update
     */
    where?: bookWhereInput
    /**
     * Limit how many books to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bookIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * book upsert
   */
  export type bookUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the book
     */
    select?: bookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the book
     */
    omit?: bookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bookInclude<ExtArgs> | null
    /**
     * The filter to search for the book to update in case it exists.
     */
    where: bookWhereUniqueInput
    /**
     * In case the book found by the `where` argument doesn't exist, create a new book with this data.
     */
    create: XOR<bookCreateInput, bookUncheckedCreateInput>
    /**
     * In case the book was found with the provided `where` argument, update it with this data.
     */
    update: XOR<bookUpdateInput, bookUncheckedUpdateInput>
  }

  /**
   * book delete
   */
  export type bookDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the book
     */
    select?: bookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the book
     */
    omit?: bookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bookInclude<ExtArgs> | null
    /**
     * Filter which book to delete.
     */
    where: bookWhereUniqueInput
  }

  /**
   * book deleteMany
   */
  export type bookDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which books to delete
     */
    where?: bookWhereInput
    /**
     * Limit how many books to delete.
     */
    limit?: number
  }

  /**
   * book.author
   */
  export type book$authorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the author
     */
    select?: authorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the author
     */
    omit?: authorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: authorInclude<ExtArgs> | null
    where?: authorWhereInput
  }

  /**
   * book.product
   */
  export type book$productArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product
     */
    select?: productSelect<ExtArgs> | null
    /**
     * Omit specific fields from the product
     */
    omit?: productOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productInclude<ExtArgs> | null
    where?: productWhereInput
  }

  /**
   * book.book_approval
   */
  export type book$book_approvalArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the book_approval
     */
    select?: book_approvalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the book_approval
     */
    omit?: book_approvalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: book_approvalInclude<ExtArgs> | null
    where?: book_approvalWhereInput
    orderBy?: book_approvalOrderByWithRelationInput | book_approvalOrderByWithRelationInput[]
    cursor?: book_approvalWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Book_approvalScalarFieldEnum | Book_approvalScalarFieldEnum[]
  }

  /**
   * book.book_changes_log
   */
  export type book$book_changes_logArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the book_changes_log
     */
    select?: book_changes_logSelect<ExtArgs> | null
    /**
     * Omit specific fields from the book_changes_log
     */
    omit?: book_changes_logOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: book_changes_logInclude<ExtArgs> | null
    where?: book_changes_logWhereInput
    orderBy?: book_changes_logOrderByWithRelationInput | book_changes_logOrderByWithRelationInput[]
    cursor?: book_changes_logWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Book_changes_logScalarFieldEnum | Book_changes_logScalarFieldEnum[]
  }

  /**
   * book.book_genre
   */
  export type book$book_genreArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the book_genre
     */
    select?: book_genreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the book_genre
     */
    omit?: book_genreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: book_genreInclude<ExtArgs> | null
    where?: book_genreWhereInput
    orderBy?: book_genreOrderByWithRelationInput | book_genreOrderByWithRelationInput[]
    cursor?: book_genreWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Book_genreScalarFieldEnum | Book_genreScalarFieldEnum[]
  }

  /**
   * book.book_tags
   */
  export type book$book_tagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the book_tags
     */
    select?: book_tagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the book_tags
     */
    omit?: book_tagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: book_tagsInclude<ExtArgs> | null
    where?: book_tagsWhereInput
    orderBy?: book_tagsOrderByWithRelationInput | book_tagsOrderByWithRelationInput[]
    cursor?: book_tagsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Book_tagsScalarFieldEnum | Book_tagsScalarFieldEnum[]
  }

  /**
   * book.chapter
   */
  export type book$chapterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chapter
     */
    select?: chapterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chapter
     */
    omit?: chapterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chapterInclude<ExtArgs> | null
    where?: chapterWhereInput
    orderBy?: chapterOrderByWithRelationInput | chapterOrderByWithRelationInput[]
    cursor?: chapterWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChapterScalarFieldEnum | ChapterScalarFieldEnum[]
  }

  /**
   * book.ranking
   */
  export type book$rankingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ranking
     */
    select?: rankingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ranking
     */
    omit?: rankingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rankingInclude<ExtArgs> | null
    where?: rankingWhereInput
    orderBy?: rankingOrderByWithRelationInput | rankingOrderByWithRelationInput[]
    cursor?: rankingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RankingScalarFieldEnum | RankingScalarFieldEnum[]
  }

  /**
   * book.reviews
   */
  export type book$reviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reviews
     */
    select?: reviewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reviews
     */
    omit?: reviewsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reviewsInclude<ExtArgs> | null
    where?: reviewsWhereInput
    orderBy?: reviewsOrderByWithRelationInput | reviewsOrderByWithRelationInput[]
    cursor?: reviewsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReviewsScalarFieldEnum | ReviewsScalarFieldEnum[]
  }

  /**
   * book without action
   */
  export type bookDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the book
     */
    select?: bookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the book
     */
    omit?: bookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bookInclude<ExtArgs> | null
  }


  /**
   * Model book_approval
   */

  export type AggregateBook_approval = {
    _count: Book_approvalCountAggregateOutputType | null
    _min: Book_approvalMinAggregateOutputType | null
    _max: Book_approvalMaxAggregateOutputType | null
  }

  export type Book_approvalMinAggregateOutputType = {
    id: string | null
    id_book: string | null
    id_internal: string | null
    status: string | null
    created_at: Date | null
  }

  export type Book_approvalMaxAggregateOutputType = {
    id: string | null
    id_book: string | null
    id_internal: string | null
    status: string | null
    created_at: Date | null
  }

  export type Book_approvalCountAggregateOutputType = {
    id: number
    id_book: number
    id_internal: number
    comment: number
    status: number
    created_at: number
    _all: number
  }


  export type Book_approvalMinAggregateInputType = {
    id?: true
    id_book?: true
    id_internal?: true
    status?: true
    created_at?: true
  }

  export type Book_approvalMaxAggregateInputType = {
    id?: true
    id_book?: true
    id_internal?: true
    status?: true
    created_at?: true
  }

  export type Book_approvalCountAggregateInputType = {
    id?: true
    id_book?: true
    id_internal?: true
    comment?: true
    status?: true
    created_at?: true
    _all?: true
  }

  export type Book_approvalAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which book_approval to aggregate.
     */
    where?: book_approvalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of book_approvals to fetch.
     */
    orderBy?: book_approvalOrderByWithRelationInput | book_approvalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: book_approvalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` book_approvals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` book_approvals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned book_approvals
    **/
    _count?: true | Book_approvalCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Book_approvalMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Book_approvalMaxAggregateInputType
  }

  export type GetBook_approvalAggregateType<T extends Book_approvalAggregateArgs> = {
        [P in keyof T & keyof AggregateBook_approval]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBook_approval[P]>
      : GetScalarType<T[P], AggregateBook_approval[P]>
  }




  export type book_approvalGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: book_approvalWhereInput
    orderBy?: book_approvalOrderByWithAggregationInput | book_approvalOrderByWithAggregationInput[]
    by: Book_approvalScalarFieldEnum[] | Book_approvalScalarFieldEnum
    having?: book_approvalScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Book_approvalCountAggregateInputType | true
    _min?: Book_approvalMinAggregateInputType
    _max?: Book_approvalMaxAggregateInputType
  }

  export type Book_approvalGroupByOutputType = {
    id: string
    id_book: string
    id_internal: string | null
    comment: JsonValue | null
    status: string
    created_at: Date
    _count: Book_approvalCountAggregateOutputType | null
    _min: Book_approvalMinAggregateOutputType | null
    _max: Book_approvalMaxAggregateOutputType | null
  }

  type GetBook_approvalGroupByPayload<T extends book_approvalGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Book_approvalGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Book_approvalGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Book_approvalGroupByOutputType[P]>
            : GetScalarType<T[P], Book_approvalGroupByOutputType[P]>
        }
      >
    >


  export type book_approvalSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    id_book?: boolean
    id_internal?: boolean
    comment?: boolean
    status?: boolean
    created_at?: boolean
    book?: boolean | bookDefaultArgs<ExtArgs>
    internal?: boolean | book_approval$internalArgs<ExtArgs>
  }, ExtArgs["result"]["book_approval"]>

  export type book_approvalSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    id_book?: boolean
    id_internal?: boolean
    comment?: boolean
    status?: boolean
    created_at?: boolean
    book?: boolean | bookDefaultArgs<ExtArgs>
    internal?: boolean | book_approval$internalArgs<ExtArgs>
  }, ExtArgs["result"]["book_approval"]>

  export type book_approvalSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    id_book?: boolean
    id_internal?: boolean
    comment?: boolean
    status?: boolean
    created_at?: boolean
    book?: boolean | bookDefaultArgs<ExtArgs>
    internal?: boolean | book_approval$internalArgs<ExtArgs>
  }, ExtArgs["result"]["book_approval"]>

  export type book_approvalSelectScalar = {
    id?: boolean
    id_book?: boolean
    id_internal?: boolean
    comment?: boolean
    status?: boolean
    created_at?: boolean
  }

  export type book_approvalOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "id_book" | "id_internal" | "comment" | "status" | "created_at", ExtArgs["result"]["book_approval"]>
  export type book_approvalInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    book?: boolean | bookDefaultArgs<ExtArgs>
    internal?: boolean | book_approval$internalArgs<ExtArgs>
  }
  export type book_approvalIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    book?: boolean | bookDefaultArgs<ExtArgs>
    internal?: boolean | book_approval$internalArgs<ExtArgs>
  }
  export type book_approvalIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    book?: boolean | bookDefaultArgs<ExtArgs>
    internal?: boolean | book_approval$internalArgs<ExtArgs>
  }

  export type $book_approvalPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "book_approval"
    objects: {
      book: Prisma.$bookPayload<ExtArgs>
      internal: Prisma.$internalPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      id_book: string
      id_internal: string | null
      comment: Prisma.JsonValue | null
      status: string
      created_at: Date
    }, ExtArgs["result"]["book_approval"]>
    composites: {}
  }

  type book_approvalGetPayload<S extends boolean | null | undefined | book_approvalDefaultArgs> = $Result.GetResult<Prisma.$book_approvalPayload, S>

  type book_approvalCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<book_approvalFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Book_approvalCountAggregateInputType | true
    }

  export interface book_approvalDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['book_approval'], meta: { name: 'book_approval' } }
    /**
     * Find zero or one Book_approval that matches the filter.
     * @param {book_approvalFindUniqueArgs} args - Arguments to find a Book_approval
     * @example
     * // Get one Book_approval
     * const book_approval = await prisma.book_approval.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends book_approvalFindUniqueArgs>(args: SelectSubset<T, book_approvalFindUniqueArgs<ExtArgs>>): Prisma__book_approvalClient<$Result.GetResult<Prisma.$book_approvalPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Book_approval that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {book_approvalFindUniqueOrThrowArgs} args - Arguments to find a Book_approval
     * @example
     * // Get one Book_approval
     * const book_approval = await prisma.book_approval.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends book_approvalFindUniqueOrThrowArgs>(args: SelectSubset<T, book_approvalFindUniqueOrThrowArgs<ExtArgs>>): Prisma__book_approvalClient<$Result.GetResult<Prisma.$book_approvalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Book_approval that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {book_approvalFindFirstArgs} args - Arguments to find a Book_approval
     * @example
     * // Get one Book_approval
     * const book_approval = await prisma.book_approval.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends book_approvalFindFirstArgs>(args?: SelectSubset<T, book_approvalFindFirstArgs<ExtArgs>>): Prisma__book_approvalClient<$Result.GetResult<Prisma.$book_approvalPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Book_approval that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {book_approvalFindFirstOrThrowArgs} args - Arguments to find a Book_approval
     * @example
     * // Get one Book_approval
     * const book_approval = await prisma.book_approval.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends book_approvalFindFirstOrThrowArgs>(args?: SelectSubset<T, book_approvalFindFirstOrThrowArgs<ExtArgs>>): Prisma__book_approvalClient<$Result.GetResult<Prisma.$book_approvalPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Book_approvals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {book_approvalFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Book_approvals
     * const book_approvals = await prisma.book_approval.findMany()
     * 
     * // Get first 10 Book_approvals
     * const book_approvals = await prisma.book_approval.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const book_approvalWithIdOnly = await prisma.book_approval.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends book_approvalFindManyArgs>(args?: SelectSubset<T, book_approvalFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$book_approvalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Book_approval.
     * @param {book_approvalCreateArgs} args - Arguments to create a Book_approval.
     * @example
     * // Create one Book_approval
     * const Book_approval = await prisma.book_approval.create({
     *   data: {
     *     // ... data to create a Book_approval
     *   }
     * })
     * 
     */
    create<T extends book_approvalCreateArgs>(args: SelectSubset<T, book_approvalCreateArgs<ExtArgs>>): Prisma__book_approvalClient<$Result.GetResult<Prisma.$book_approvalPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Book_approvals.
     * @param {book_approvalCreateManyArgs} args - Arguments to create many Book_approvals.
     * @example
     * // Create many Book_approvals
     * const book_approval = await prisma.book_approval.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends book_approvalCreateManyArgs>(args?: SelectSubset<T, book_approvalCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Book_approvals and returns the data saved in the database.
     * @param {book_approvalCreateManyAndReturnArgs} args - Arguments to create many Book_approvals.
     * @example
     * // Create many Book_approvals
     * const book_approval = await prisma.book_approval.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Book_approvals and only return the `id`
     * const book_approvalWithIdOnly = await prisma.book_approval.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends book_approvalCreateManyAndReturnArgs>(args?: SelectSubset<T, book_approvalCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$book_approvalPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Book_approval.
     * @param {book_approvalDeleteArgs} args - Arguments to delete one Book_approval.
     * @example
     * // Delete one Book_approval
     * const Book_approval = await prisma.book_approval.delete({
     *   where: {
     *     // ... filter to delete one Book_approval
     *   }
     * })
     * 
     */
    delete<T extends book_approvalDeleteArgs>(args: SelectSubset<T, book_approvalDeleteArgs<ExtArgs>>): Prisma__book_approvalClient<$Result.GetResult<Prisma.$book_approvalPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Book_approval.
     * @param {book_approvalUpdateArgs} args - Arguments to update one Book_approval.
     * @example
     * // Update one Book_approval
     * const book_approval = await prisma.book_approval.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends book_approvalUpdateArgs>(args: SelectSubset<T, book_approvalUpdateArgs<ExtArgs>>): Prisma__book_approvalClient<$Result.GetResult<Prisma.$book_approvalPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Book_approvals.
     * @param {book_approvalDeleteManyArgs} args - Arguments to filter Book_approvals to delete.
     * @example
     * // Delete a few Book_approvals
     * const { count } = await prisma.book_approval.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends book_approvalDeleteManyArgs>(args?: SelectSubset<T, book_approvalDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Book_approvals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {book_approvalUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Book_approvals
     * const book_approval = await prisma.book_approval.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends book_approvalUpdateManyArgs>(args: SelectSubset<T, book_approvalUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Book_approvals and returns the data updated in the database.
     * @param {book_approvalUpdateManyAndReturnArgs} args - Arguments to update many Book_approvals.
     * @example
     * // Update many Book_approvals
     * const book_approval = await prisma.book_approval.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Book_approvals and only return the `id`
     * const book_approvalWithIdOnly = await prisma.book_approval.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends book_approvalUpdateManyAndReturnArgs>(args: SelectSubset<T, book_approvalUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$book_approvalPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Book_approval.
     * @param {book_approvalUpsertArgs} args - Arguments to update or create a Book_approval.
     * @example
     * // Update or create a Book_approval
     * const book_approval = await prisma.book_approval.upsert({
     *   create: {
     *     // ... data to create a Book_approval
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Book_approval we want to update
     *   }
     * })
     */
    upsert<T extends book_approvalUpsertArgs>(args: SelectSubset<T, book_approvalUpsertArgs<ExtArgs>>): Prisma__book_approvalClient<$Result.GetResult<Prisma.$book_approvalPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Book_approvals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {book_approvalCountArgs} args - Arguments to filter Book_approvals to count.
     * @example
     * // Count the number of Book_approvals
     * const count = await prisma.book_approval.count({
     *   where: {
     *     // ... the filter for the Book_approvals we want to count
     *   }
     * })
    **/
    count<T extends book_approvalCountArgs>(
      args?: Subset<T, book_approvalCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Book_approvalCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Book_approval.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Book_approvalAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Book_approvalAggregateArgs>(args: Subset<T, Book_approvalAggregateArgs>): Prisma.PrismaPromise<GetBook_approvalAggregateType<T>>

    /**
     * Group by Book_approval.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {book_approvalGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends book_approvalGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: book_approvalGroupByArgs['orderBy'] }
        : { orderBy?: book_approvalGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, book_approvalGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBook_approvalGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the book_approval model
   */
  readonly fields: book_approvalFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for book_approval.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__book_approvalClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    book<T extends bookDefaultArgs<ExtArgs> = {}>(args?: Subset<T, bookDefaultArgs<ExtArgs>>): Prisma__bookClient<$Result.GetResult<Prisma.$bookPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    internal<T extends book_approval$internalArgs<ExtArgs> = {}>(args?: Subset<T, book_approval$internalArgs<ExtArgs>>): Prisma__internalClient<$Result.GetResult<Prisma.$internalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the book_approval model
   */
  interface book_approvalFieldRefs {
    readonly id: FieldRef<"book_approval", 'String'>
    readonly id_book: FieldRef<"book_approval", 'String'>
    readonly id_internal: FieldRef<"book_approval", 'String'>
    readonly comment: FieldRef<"book_approval", 'Json'>
    readonly status: FieldRef<"book_approval", 'String'>
    readonly created_at: FieldRef<"book_approval", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * book_approval findUnique
   */
  export type book_approvalFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the book_approval
     */
    select?: book_approvalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the book_approval
     */
    omit?: book_approvalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: book_approvalInclude<ExtArgs> | null
    /**
     * Filter, which book_approval to fetch.
     */
    where: book_approvalWhereUniqueInput
  }

  /**
   * book_approval findUniqueOrThrow
   */
  export type book_approvalFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the book_approval
     */
    select?: book_approvalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the book_approval
     */
    omit?: book_approvalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: book_approvalInclude<ExtArgs> | null
    /**
     * Filter, which book_approval to fetch.
     */
    where: book_approvalWhereUniqueInput
  }

  /**
   * book_approval findFirst
   */
  export type book_approvalFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the book_approval
     */
    select?: book_approvalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the book_approval
     */
    omit?: book_approvalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: book_approvalInclude<ExtArgs> | null
    /**
     * Filter, which book_approval to fetch.
     */
    where?: book_approvalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of book_approvals to fetch.
     */
    orderBy?: book_approvalOrderByWithRelationInput | book_approvalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for book_approvals.
     */
    cursor?: book_approvalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` book_approvals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` book_approvals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of book_approvals.
     */
    distinct?: Book_approvalScalarFieldEnum | Book_approvalScalarFieldEnum[]
  }

  /**
   * book_approval findFirstOrThrow
   */
  export type book_approvalFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the book_approval
     */
    select?: book_approvalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the book_approval
     */
    omit?: book_approvalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: book_approvalInclude<ExtArgs> | null
    /**
     * Filter, which book_approval to fetch.
     */
    where?: book_approvalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of book_approvals to fetch.
     */
    orderBy?: book_approvalOrderByWithRelationInput | book_approvalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for book_approvals.
     */
    cursor?: book_approvalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` book_approvals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` book_approvals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of book_approvals.
     */
    distinct?: Book_approvalScalarFieldEnum | Book_approvalScalarFieldEnum[]
  }

  /**
   * book_approval findMany
   */
  export type book_approvalFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the book_approval
     */
    select?: book_approvalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the book_approval
     */
    omit?: book_approvalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: book_approvalInclude<ExtArgs> | null
    /**
     * Filter, which book_approvals to fetch.
     */
    where?: book_approvalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of book_approvals to fetch.
     */
    orderBy?: book_approvalOrderByWithRelationInput | book_approvalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing book_approvals.
     */
    cursor?: book_approvalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` book_approvals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` book_approvals.
     */
    skip?: number
    distinct?: Book_approvalScalarFieldEnum | Book_approvalScalarFieldEnum[]
  }

  /**
   * book_approval create
   */
  export type book_approvalCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the book_approval
     */
    select?: book_approvalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the book_approval
     */
    omit?: book_approvalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: book_approvalInclude<ExtArgs> | null
    /**
     * The data needed to create a book_approval.
     */
    data: XOR<book_approvalCreateInput, book_approvalUncheckedCreateInput>
  }

  /**
   * book_approval createMany
   */
  export type book_approvalCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many book_approvals.
     */
    data: book_approvalCreateManyInput | book_approvalCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * book_approval createManyAndReturn
   */
  export type book_approvalCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the book_approval
     */
    select?: book_approvalSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the book_approval
     */
    omit?: book_approvalOmit<ExtArgs> | null
    /**
     * The data used to create many book_approvals.
     */
    data: book_approvalCreateManyInput | book_approvalCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: book_approvalIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * book_approval update
   */
  export type book_approvalUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the book_approval
     */
    select?: book_approvalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the book_approval
     */
    omit?: book_approvalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: book_approvalInclude<ExtArgs> | null
    /**
     * The data needed to update a book_approval.
     */
    data: XOR<book_approvalUpdateInput, book_approvalUncheckedUpdateInput>
    /**
     * Choose, which book_approval to update.
     */
    where: book_approvalWhereUniqueInput
  }

  /**
   * book_approval updateMany
   */
  export type book_approvalUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update book_approvals.
     */
    data: XOR<book_approvalUpdateManyMutationInput, book_approvalUncheckedUpdateManyInput>
    /**
     * Filter which book_approvals to update
     */
    where?: book_approvalWhereInput
    /**
     * Limit how many book_approvals to update.
     */
    limit?: number
  }

  /**
   * book_approval updateManyAndReturn
   */
  export type book_approvalUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the book_approval
     */
    select?: book_approvalSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the book_approval
     */
    omit?: book_approvalOmit<ExtArgs> | null
    /**
     * The data used to update book_approvals.
     */
    data: XOR<book_approvalUpdateManyMutationInput, book_approvalUncheckedUpdateManyInput>
    /**
     * Filter which book_approvals to update
     */
    where?: book_approvalWhereInput
    /**
     * Limit how many book_approvals to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: book_approvalIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * book_approval upsert
   */
  export type book_approvalUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the book_approval
     */
    select?: book_approvalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the book_approval
     */
    omit?: book_approvalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: book_approvalInclude<ExtArgs> | null
    /**
     * The filter to search for the book_approval to update in case it exists.
     */
    where: book_approvalWhereUniqueInput
    /**
     * In case the book_approval found by the `where` argument doesn't exist, create a new book_approval with this data.
     */
    create: XOR<book_approvalCreateInput, book_approvalUncheckedCreateInput>
    /**
     * In case the book_approval was found with the provided `where` argument, update it with this data.
     */
    update: XOR<book_approvalUpdateInput, book_approvalUncheckedUpdateInput>
  }

  /**
   * book_approval delete
   */
  export type book_approvalDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the book_approval
     */
    select?: book_approvalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the book_approval
     */
    omit?: book_approvalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: book_approvalInclude<ExtArgs> | null
    /**
     * Filter which book_approval to delete.
     */
    where: book_approvalWhereUniqueInput
  }

  /**
   * book_approval deleteMany
   */
  export type book_approvalDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which book_approvals to delete
     */
    where?: book_approvalWhereInput
    /**
     * Limit how many book_approvals to delete.
     */
    limit?: number
  }

  /**
   * book_approval.internal
   */
  export type book_approval$internalArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the internal
     */
    select?: internalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the internal
     */
    omit?: internalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: internalInclude<ExtArgs> | null
    where?: internalWhereInput
  }

  /**
   * book_approval without action
   */
  export type book_approvalDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the book_approval
     */
    select?: book_approvalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the book_approval
     */
    omit?: book_approvalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: book_approvalInclude<ExtArgs> | null
  }


  /**
   * Model book_changes_log
   */

  export type AggregateBook_changes_log = {
    _count: Book_changes_logCountAggregateOutputType | null
    _min: Book_changes_logMinAggregateOutputType | null
    _max: Book_changes_logMaxAggregateOutputType | null
  }

  export type Book_changes_logMinAggregateOutputType = {
    id_book: string | null
    created_at: Date | null
  }

  export type Book_changes_logMaxAggregateOutputType = {
    id_book: string | null
    created_at: Date | null
  }

  export type Book_changes_logCountAggregateOutputType = {
    id_book: number
    created_at: number
    changes: number
    _all: number
  }


  export type Book_changes_logMinAggregateInputType = {
    id_book?: true
    created_at?: true
  }

  export type Book_changes_logMaxAggregateInputType = {
    id_book?: true
    created_at?: true
  }

  export type Book_changes_logCountAggregateInputType = {
    id_book?: true
    created_at?: true
    changes?: true
    _all?: true
  }

  export type Book_changes_logAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which book_changes_log to aggregate.
     */
    where?: book_changes_logWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of book_changes_logs to fetch.
     */
    orderBy?: book_changes_logOrderByWithRelationInput | book_changes_logOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: book_changes_logWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` book_changes_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` book_changes_logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned book_changes_logs
    **/
    _count?: true | Book_changes_logCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Book_changes_logMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Book_changes_logMaxAggregateInputType
  }

  export type GetBook_changes_logAggregateType<T extends Book_changes_logAggregateArgs> = {
        [P in keyof T & keyof AggregateBook_changes_log]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBook_changes_log[P]>
      : GetScalarType<T[P], AggregateBook_changes_log[P]>
  }




  export type book_changes_logGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: book_changes_logWhereInput
    orderBy?: book_changes_logOrderByWithAggregationInput | book_changes_logOrderByWithAggregationInput[]
    by: Book_changes_logScalarFieldEnum[] | Book_changes_logScalarFieldEnum
    having?: book_changes_logScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Book_changes_logCountAggregateInputType | true
    _min?: Book_changes_logMinAggregateInputType
    _max?: Book_changes_logMaxAggregateInputType
  }

  export type Book_changes_logGroupByOutputType = {
    id_book: string
    created_at: Date
    changes: JsonValue | null
    _count: Book_changes_logCountAggregateOutputType | null
    _min: Book_changes_logMinAggregateOutputType | null
    _max: Book_changes_logMaxAggregateOutputType | null
  }

  type GetBook_changes_logGroupByPayload<T extends book_changes_logGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Book_changes_logGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Book_changes_logGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Book_changes_logGroupByOutputType[P]>
            : GetScalarType<T[P], Book_changes_logGroupByOutputType[P]>
        }
      >
    >


  export type book_changes_logSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_book?: boolean
    created_at?: boolean
    changes?: boolean
    book?: boolean | bookDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["book_changes_log"]>

  export type book_changes_logSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_book?: boolean
    created_at?: boolean
    changes?: boolean
    book?: boolean | bookDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["book_changes_log"]>

  export type book_changes_logSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_book?: boolean
    created_at?: boolean
    changes?: boolean
    book?: boolean | bookDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["book_changes_log"]>

  export type book_changes_logSelectScalar = {
    id_book?: boolean
    created_at?: boolean
    changes?: boolean
  }

  export type book_changes_logOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id_book" | "created_at" | "changes", ExtArgs["result"]["book_changes_log"]>
  export type book_changes_logInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    book?: boolean | bookDefaultArgs<ExtArgs>
  }
  export type book_changes_logIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    book?: boolean | bookDefaultArgs<ExtArgs>
  }
  export type book_changes_logIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    book?: boolean | bookDefaultArgs<ExtArgs>
  }

  export type $book_changes_logPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "book_changes_log"
    objects: {
      book: Prisma.$bookPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id_book: string
      created_at: Date
      changes: Prisma.JsonValue | null
    }, ExtArgs["result"]["book_changes_log"]>
    composites: {}
  }

  type book_changes_logGetPayload<S extends boolean | null | undefined | book_changes_logDefaultArgs> = $Result.GetResult<Prisma.$book_changes_logPayload, S>

  type book_changes_logCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<book_changes_logFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Book_changes_logCountAggregateInputType | true
    }

  export interface book_changes_logDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['book_changes_log'], meta: { name: 'book_changes_log' } }
    /**
     * Find zero or one Book_changes_log that matches the filter.
     * @param {book_changes_logFindUniqueArgs} args - Arguments to find a Book_changes_log
     * @example
     * // Get one Book_changes_log
     * const book_changes_log = await prisma.book_changes_log.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends book_changes_logFindUniqueArgs>(args: SelectSubset<T, book_changes_logFindUniqueArgs<ExtArgs>>): Prisma__book_changes_logClient<$Result.GetResult<Prisma.$book_changes_logPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Book_changes_log that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {book_changes_logFindUniqueOrThrowArgs} args - Arguments to find a Book_changes_log
     * @example
     * // Get one Book_changes_log
     * const book_changes_log = await prisma.book_changes_log.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends book_changes_logFindUniqueOrThrowArgs>(args: SelectSubset<T, book_changes_logFindUniqueOrThrowArgs<ExtArgs>>): Prisma__book_changes_logClient<$Result.GetResult<Prisma.$book_changes_logPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Book_changes_log that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {book_changes_logFindFirstArgs} args - Arguments to find a Book_changes_log
     * @example
     * // Get one Book_changes_log
     * const book_changes_log = await prisma.book_changes_log.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends book_changes_logFindFirstArgs>(args?: SelectSubset<T, book_changes_logFindFirstArgs<ExtArgs>>): Prisma__book_changes_logClient<$Result.GetResult<Prisma.$book_changes_logPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Book_changes_log that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {book_changes_logFindFirstOrThrowArgs} args - Arguments to find a Book_changes_log
     * @example
     * // Get one Book_changes_log
     * const book_changes_log = await prisma.book_changes_log.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends book_changes_logFindFirstOrThrowArgs>(args?: SelectSubset<T, book_changes_logFindFirstOrThrowArgs<ExtArgs>>): Prisma__book_changes_logClient<$Result.GetResult<Prisma.$book_changes_logPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Book_changes_logs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {book_changes_logFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Book_changes_logs
     * const book_changes_logs = await prisma.book_changes_log.findMany()
     * 
     * // Get first 10 Book_changes_logs
     * const book_changes_logs = await prisma.book_changes_log.findMany({ take: 10 })
     * 
     * // Only select the `id_book`
     * const book_changes_logWithId_bookOnly = await prisma.book_changes_log.findMany({ select: { id_book: true } })
     * 
     */
    findMany<T extends book_changes_logFindManyArgs>(args?: SelectSubset<T, book_changes_logFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$book_changes_logPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Book_changes_log.
     * @param {book_changes_logCreateArgs} args - Arguments to create a Book_changes_log.
     * @example
     * // Create one Book_changes_log
     * const Book_changes_log = await prisma.book_changes_log.create({
     *   data: {
     *     // ... data to create a Book_changes_log
     *   }
     * })
     * 
     */
    create<T extends book_changes_logCreateArgs>(args: SelectSubset<T, book_changes_logCreateArgs<ExtArgs>>): Prisma__book_changes_logClient<$Result.GetResult<Prisma.$book_changes_logPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Book_changes_logs.
     * @param {book_changes_logCreateManyArgs} args - Arguments to create many Book_changes_logs.
     * @example
     * // Create many Book_changes_logs
     * const book_changes_log = await prisma.book_changes_log.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends book_changes_logCreateManyArgs>(args?: SelectSubset<T, book_changes_logCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Book_changes_logs and returns the data saved in the database.
     * @param {book_changes_logCreateManyAndReturnArgs} args - Arguments to create many Book_changes_logs.
     * @example
     * // Create many Book_changes_logs
     * const book_changes_log = await prisma.book_changes_log.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Book_changes_logs and only return the `id_book`
     * const book_changes_logWithId_bookOnly = await prisma.book_changes_log.createManyAndReturn({
     *   select: { id_book: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends book_changes_logCreateManyAndReturnArgs>(args?: SelectSubset<T, book_changes_logCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$book_changes_logPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Book_changes_log.
     * @param {book_changes_logDeleteArgs} args - Arguments to delete one Book_changes_log.
     * @example
     * // Delete one Book_changes_log
     * const Book_changes_log = await prisma.book_changes_log.delete({
     *   where: {
     *     // ... filter to delete one Book_changes_log
     *   }
     * })
     * 
     */
    delete<T extends book_changes_logDeleteArgs>(args: SelectSubset<T, book_changes_logDeleteArgs<ExtArgs>>): Prisma__book_changes_logClient<$Result.GetResult<Prisma.$book_changes_logPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Book_changes_log.
     * @param {book_changes_logUpdateArgs} args - Arguments to update one Book_changes_log.
     * @example
     * // Update one Book_changes_log
     * const book_changes_log = await prisma.book_changes_log.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends book_changes_logUpdateArgs>(args: SelectSubset<T, book_changes_logUpdateArgs<ExtArgs>>): Prisma__book_changes_logClient<$Result.GetResult<Prisma.$book_changes_logPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Book_changes_logs.
     * @param {book_changes_logDeleteManyArgs} args - Arguments to filter Book_changes_logs to delete.
     * @example
     * // Delete a few Book_changes_logs
     * const { count } = await prisma.book_changes_log.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends book_changes_logDeleteManyArgs>(args?: SelectSubset<T, book_changes_logDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Book_changes_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {book_changes_logUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Book_changes_logs
     * const book_changes_log = await prisma.book_changes_log.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends book_changes_logUpdateManyArgs>(args: SelectSubset<T, book_changes_logUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Book_changes_logs and returns the data updated in the database.
     * @param {book_changes_logUpdateManyAndReturnArgs} args - Arguments to update many Book_changes_logs.
     * @example
     * // Update many Book_changes_logs
     * const book_changes_log = await prisma.book_changes_log.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Book_changes_logs and only return the `id_book`
     * const book_changes_logWithId_bookOnly = await prisma.book_changes_log.updateManyAndReturn({
     *   select: { id_book: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends book_changes_logUpdateManyAndReturnArgs>(args: SelectSubset<T, book_changes_logUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$book_changes_logPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Book_changes_log.
     * @param {book_changes_logUpsertArgs} args - Arguments to update or create a Book_changes_log.
     * @example
     * // Update or create a Book_changes_log
     * const book_changes_log = await prisma.book_changes_log.upsert({
     *   create: {
     *     // ... data to create a Book_changes_log
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Book_changes_log we want to update
     *   }
     * })
     */
    upsert<T extends book_changes_logUpsertArgs>(args: SelectSubset<T, book_changes_logUpsertArgs<ExtArgs>>): Prisma__book_changes_logClient<$Result.GetResult<Prisma.$book_changes_logPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Book_changes_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {book_changes_logCountArgs} args - Arguments to filter Book_changes_logs to count.
     * @example
     * // Count the number of Book_changes_logs
     * const count = await prisma.book_changes_log.count({
     *   where: {
     *     // ... the filter for the Book_changes_logs we want to count
     *   }
     * })
    **/
    count<T extends book_changes_logCountArgs>(
      args?: Subset<T, book_changes_logCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Book_changes_logCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Book_changes_log.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Book_changes_logAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Book_changes_logAggregateArgs>(args: Subset<T, Book_changes_logAggregateArgs>): Prisma.PrismaPromise<GetBook_changes_logAggregateType<T>>

    /**
     * Group by Book_changes_log.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {book_changes_logGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends book_changes_logGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: book_changes_logGroupByArgs['orderBy'] }
        : { orderBy?: book_changes_logGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, book_changes_logGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBook_changes_logGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the book_changes_log model
   */
  readonly fields: book_changes_logFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for book_changes_log.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__book_changes_logClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    book<T extends bookDefaultArgs<ExtArgs> = {}>(args?: Subset<T, bookDefaultArgs<ExtArgs>>): Prisma__bookClient<$Result.GetResult<Prisma.$bookPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the book_changes_log model
   */
  interface book_changes_logFieldRefs {
    readonly id_book: FieldRef<"book_changes_log", 'String'>
    readonly created_at: FieldRef<"book_changes_log", 'DateTime'>
    readonly changes: FieldRef<"book_changes_log", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * book_changes_log findUnique
   */
  export type book_changes_logFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the book_changes_log
     */
    select?: book_changes_logSelect<ExtArgs> | null
    /**
     * Omit specific fields from the book_changes_log
     */
    omit?: book_changes_logOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: book_changes_logInclude<ExtArgs> | null
    /**
     * Filter, which book_changes_log to fetch.
     */
    where: book_changes_logWhereUniqueInput
  }

  /**
   * book_changes_log findUniqueOrThrow
   */
  export type book_changes_logFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the book_changes_log
     */
    select?: book_changes_logSelect<ExtArgs> | null
    /**
     * Omit specific fields from the book_changes_log
     */
    omit?: book_changes_logOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: book_changes_logInclude<ExtArgs> | null
    /**
     * Filter, which book_changes_log to fetch.
     */
    where: book_changes_logWhereUniqueInput
  }

  /**
   * book_changes_log findFirst
   */
  export type book_changes_logFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the book_changes_log
     */
    select?: book_changes_logSelect<ExtArgs> | null
    /**
     * Omit specific fields from the book_changes_log
     */
    omit?: book_changes_logOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: book_changes_logInclude<ExtArgs> | null
    /**
     * Filter, which book_changes_log to fetch.
     */
    where?: book_changes_logWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of book_changes_logs to fetch.
     */
    orderBy?: book_changes_logOrderByWithRelationInput | book_changes_logOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for book_changes_logs.
     */
    cursor?: book_changes_logWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` book_changes_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` book_changes_logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of book_changes_logs.
     */
    distinct?: Book_changes_logScalarFieldEnum | Book_changes_logScalarFieldEnum[]
  }

  /**
   * book_changes_log findFirstOrThrow
   */
  export type book_changes_logFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the book_changes_log
     */
    select?: book_changes_logSelect<ExtArgs> | null
    /**
     * Omit specific fields from the book_changes_log
     */
    omit?: book_changes_logOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: book_changes_logInclude<ExtArgs> | null
    /**
     * Filter, which book_changes_log to fetch.
     */
    where?: book_changes_logWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of book_changes_logs to fetch.
     */
    orderBy?: book_changes_logOrderByWithRelationInput | book_changes_logOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for book_changes_logs.
     */
    cursor?: book_changes_logWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` book_changes_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` book_changes_logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of book_changes_logs.
     */
    distinct?: Book_changes_logScalarFieldEnum | Book_changes_logScalarFieldEnum[]
  }

  /**
   * book_changes_log findMany
   */
  export type book_changes_logFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the book_changes_log
     */
    select?: book_changes_logSelect<ExtArgs> | null
    /**
     * Omit specific fields from the book_changes_log
     */
    omit?: book_changes_logOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: book_changes_logInclude<ExtArgs> | null
    /**
     * Filter, which book_changes_logs to fetch.
     */
    where?: book_changes_logWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of book_changes_logs to fetch.
     */
    orderBy?: book_changes_logOrderByWithRelationInput | book_changes_logOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing book_changes_logs.
     */
    cursor?: book_changes_logWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` book_changes_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` book_changes_logs.
     */
    skip?: number
    distinct?: Book_changes_logScalarFieldEnum | Book_changes_logScalarFieldEnum[]
  }

  /**
   * book_changes_log create
   */
  export type book_changes_logCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the book_changes_log
     */
    select?: book_changes_logSelect<ExtArgs> | null
    /**
     * Omit specific fields from the book_changes_log
     */
    omit?: book_changes_logOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: book_changes_logInclude<ExtArgs> | null
    /**
     * The data needed to create a book_changes_log.
     */
    data: XOR<book_changes_logCreateInput, book_changes_logUncheckedCreateInput>
  }

  /**
   * book_changes_log createMany
   */
  export type book_changes_logCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many book_changes_logs.
     */
    data: book_changes_logCreateManyInput | book_changes_logCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * book_changes_log createManyAndReturn
   */
  export type book_changes_logCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the book_changes_log
     */
    select?: book_changes_logSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the book_changes_log
     */
    omit?: book_changes_logOmit<ExtArgs> | null
    /**
     * The data used to create many book_changes_logs.
     */
    data: book_changes_logCreateManyInput | book_changes_logCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: book_changes_logIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * book_changes_log update
   */
  export type book_changes_logUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the book_changes_log
     */
    select?: book_changes_logSelect<ExtArgs> | null
    /**
     * Omit specific fields from the book_changes_log
     */
    omit?: book_changes_logOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: book_changes_logInclude<ExtArgs> | null
    /**
     * The data needed to update a book_changes_log.
     */
    data: XOR<book_changes_logUpdateInput, book_changes_logUncheckedUpdateInput>
    /**
     * Choose, which book_changes_log to update.
     */
    where: book_changes_logWhereUniqueInput
  }

  /**
   * book_changes_log updateMany
   */
  export type book_changes_logUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update book_changes_logs.
     */
    data: XOR<book_changes_logUpdateManyMutationInput, book_changes_logUncheckedUpdateManyInput>
    /**
     * Filter which book_changes_logs to update
     */
    where?: book_changes_logWhereInput
    /**
     * Limit how many book_changes_logs to update.
     */
    limit?: number
  }

  /**
   * book_changes_log updateManyAndReturn
   */
  export type book_changes_logUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the book_changes_log
     */
    select?: book_changes_logSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the book_changes_log
     */
    omit?: book_changes_logOmit<ExtArgs> | null
    /**
     * The data used to update book_changes_logs.
     */
    data: XOR<book_changes_logUpdateManyMutationInput, book_changes_logUncheckedUpdateManyInput>
    /**
     * Filter which book_changes_logs to update
     */
    where?: book_changes_logWhereInput
    /**
     * Limit how many book_changes_logs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: book_changes_logIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * book_changes_log upsert
   */
  export type book_changes_logUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the book_changes_log
     */
    select?: book_changes_logSelect<ExtArgs> | null
    /**
     * Omit specific fields from the book_changes_log
     */
    omit?: book_changes_logOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: book_changes_logInclude<ExtArgs> | null
    /**
     * The filter to search for the book_changes_log to update in case it exists.
     */
    where: book_changes_logWhereUniqueInput
    /**
     * In case the book_changes_log found by the `where` argument doesn't exist, create a new book_changes_log with this data.
     */
    create: XOR<book_changes_logCreateInput, book_changes_logUncheckedCreateInput>
    /**
     * In case the book_changes_log was found with the provided `where` argument, update it with this data.
     */
    update: XOR<book_changes_logUpdateInput, book_changes_logUncheckedUpdateInput>
  }

  /**
   * book_changes_log delete
   */
  export type book_changes_logDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the book_changes_log
     */
    select?: book_changes_logSelect<ExtArgs> | null
    /**
     * Omit specific fields from the book_changes_log
     */
    omit?: book_changes_logOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: book_changes_logInclude<ExtArgs> | null
    /**
     * Filter which book_changes_log to delete.
     */
    where: book_changes_logWhereUniqueInput
  }

  /**
   * book_changes_log deleteMany
   */
  export type book_changes_logDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which book_changes_logs to delete
     */
    where?: book_changes_logWhereInput
    /**
     * Limit how many book_changes_logs to delete.
     */
    limit?: number
  }

  /**
   * book_changes_log without action
   */
  export type book_changes_logDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the book_changes_log
     */
    select?: book_changes_logSelect<ExtArgs> | null
    /**
     * Omit specific fields from the book_changes_log
     */
    omit?: book_changes_logOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: book_changes_logInclude<ExtArgs> | null
  }


  /**
   * Model book_genre
   */

  export type AggregateBook_genre = {
    _count: Book_genreCountAggregateOutputType | null
    _min: Book_genreMinAggregateOutputType | null
    _max: Book_genreMaxAggregateOutputType | null
  }

  export type Book_genreMinAggregateOutputType = {
    id: string | null
    id_genre: string | null
    id_book: string | null
  }

  export type Book_genreMaxAggregateOutputType = {
    id: string | null
    id_genre: string | null
    id_book: string | null
  }

  export type Book_genreCountAggregateOutputType = {
    id: number
    id_genre: number
    id_book: number
    _all: number
  }


  export type Book_genreMinAggregateInputType = {
    id?: true
    id_genre?: true
    id_book?: true
  }

  export type Book_genreMaxAggregateInputType = {
    id?: true
    id_genre?: true
    id_book?: true
  }

  export type Book_genreCountAggregateInputType = {
    id?: true
    id_genre?: true
    id_book?: true
    _all?: true
  }

  export type Book_genreAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which book_genre to aggregate.
     */
    where?: book_genreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of book_genres to fetch.
     */
    orderBy?: book_genreOrderByWithRelationInput | book_genreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: book_genreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` book_genres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` book_genres.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned book_genres
    **/
    _count?: true | Book_genreCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Book_genreMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Book_genreMaxAggregateInputType
  }

  export type GetBook_genreAggregateType<T extends Book_genreAggregateArgs> = {
        [P in keyof T & keyof AggregateBook_genre]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBook_genre[P]>
      : GetScalarType<T[P], AggregateBook_genre[P]>
  }




  export type book_genreGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: book_genreWhereInput
    orderBy?: book_genreOrderByWithAggregationInput | book_genreOrderByWithAggregationInput[]
    by: Book_genreScalarFieldEnum[] | Book_genreScalarFieldEnum
    having?: book_genreScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Book_genreCountAggregateInputType | true
    _min?: Book_genreMinAggregateInputType
    _max?: Book_genreMaxAggregateInputType
  }

  export type Book_genreGroupByOutputType = {
    id: string
    id_genre: string
    id_book: string
    _count: Book_genreCountAggregateOutputType | null
    _min: Book_genreMinAggregateOutputType | null
    _max: Book_genreMaxAggregateOutputType | null
  }

  type GetBook_genreGroupByPayload<T extends book_genreGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Book_genreGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Book_genreGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Book_genreGroupByOutputType[P]>
            : GetScalarType<T[P], Book_genreGroupByOutputType[P]>
        }
      >
    >


  export type book_genreSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    id_genre?: boolean
    id_book?: boolean
    book?: boolean | bookDefaultArgs<ExtArgs>
    genre?: boolean | genreDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["book_genre"]>

  export type book_genreSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    id_genre?: boolean
    id_book?: boolean
    book?: boolean | bookDefaultArgs<ExtArgs>
    genre?: boolean | genreDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["book_genre"]>

  export type book_genreSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    id_genre?: boolean
    id_book?: boolean
    book?: boolean | bookDefaultArgs<ExtArgs>
    genre?: boolean | genreDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["book_genre"]>

  export type book_genreSelectScalar = {
    id?: boolean
    id_genre?: boolean
    id_book?: boolean
  }

  export type book_genreOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "id_genre" | "id_book", ExtArgs["result"]["book_genre"]>
  export type book_genreInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    book?: boolean | bookDefaultArgs<ExtArgs>
    genre?: boolean | genreDefaultArgs<ExtArgs>
  }
  export type book_genreIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    book?: boolean | bookDefaultArgs<ExtArgs>
    genre?: boolean | genreDefaultArgs<ExtArgs>
  }
  export type book_genreIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    book?: boolean | bookDefaultArgs<ExtArgs>
    genre?: boolean | genreDefaultArgs<ExtArgs>
  }

  export type $book_genrePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "book_genre"
    objects: {
      book: Prisma.$bookPayload<ExtArgs>
      genre: Prisma.$genrePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      id_genre: string
      id_book: string
    }, ExtArgs["result"]["book_genre"]>
    composites: {}
  }

  type book_genreGetPayload<S extends boolean | null | undefined | book_genreDefaultArgs> = $Result.GetResult<Prisma.$book_genrePayload, S>

  type book_genreCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<book_genreFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Book_genreCountAggregateInputType | true
    }

  export interface book_genreDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['book_genre'], meta: { name: 'book_genre' } }
    /**
     * Find zero or one Book_genre that matches the filter.
     * @param {book_genreFindUniqueArgs} args - Arguments to find a Book_genre
     * @example
     * // Get one Book_genre
     * const book_genre = await prisma.book_genre.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends book_genreFindUniqueArgs>(args: SelectSubset<T, book_genreFindUniqueArgs<ExtArgs>>): Prisma__book_genreClient<$Result.GetResult<Prisma.$book_genrePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Book_genre that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {book_genreFindUniqueOrThrowArgs} args - Arguments to find a Book_genre
     * @example
     * // Get one Book_genre
     * const book_genre = await prisma.book_genre.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends book_genreFindUniqueOrThrowArgs>(args: SelectSubset<T, book_genreFindUniqueOrThrowArgs<ExtArgs>>): Prisma__book_genreClient<$Result.GetResult<Prisma.$book_genrePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Book_genre that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {book_genreFindFirstArgs} args - Arguments to find a Book_genre
     * @example
     * // Get one Book_genre
     * const book_genre = await prisma.book_genre.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends book_genreFindFirstArgs>(args?: SelectSubset<T, book_genreFindFirstArgs<ExtArgs>>): Prisma__book_genreClient<$Result.GetResult<Prisma.$book_genrePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Book_genre that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {book_genreFindFirstOrThrowArgs} args - Arguments to find a Book_genre
     * @example
     * // Get one Book_genre
     * const book_genre = await prisma.book_genre.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends book_genreFindFirstOrThrowArgs>(args?: SelectSubset<T, book_genreFindFirstOrThrowArgs<ExtArgs>>): Prisma__book_genreClient<$Result.GetResult<Prisma.$book_genrePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Book_genres that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {book_genreFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Book_genres
     * const book_genres = await prisma.book_genre.findMany()
     * 
     * // Get first 10 Book_genres
     * const book_genres = await prisma.book_genre.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const book_genreWithIdOnly = await prisma.book_genre.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends book_genreFindManyArgs>(args?: SelectSubset<T, book_genreFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$book_genrePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Book_genre.
     * @param {book_genreCreateArgs} args - Arguments to create a Book_genre.
     * @example
     * // Create one Book_genre
     * const Book_genre = await prisma.book_genre.create({
     *   data: {
     *     // ... data to create a Book_genre
     *   }
     * })
     * 
     */
    create<T extends book_genreCreateArgs>(args: SelectSubset<T, book_genreCreateArgs<ExtArgs>>): Prisma__book_genreClient<$Result.GetResult<Prisma.$book_genrePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Book_genres.
     * @param {book_genreCreateManyArgs} args - Arguments to create many Book_genres.
     * @example
     * // Create many Book_genres
     * const book_genre = await prisma.book_genre.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends book_genreCreateManyArgs>(args?: SelectSubset<T, book_genreCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Book_genres and returns the data saved in the database.
     * @param {book_genreCreateManyAndReturnArgs} args - Arguments to create many Book_genres.
     * @example
     * // Create many Book_genres
     * const book_genre = await prisma.book_genre.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Book_genres and only return the `id`
     * const book_genreWithIdOnly = await prisma.book_genre.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends book_genreCreateManyAndReturnArgs>(args?: SelectSubset<T, book_genreCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$book_genrePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Book_genre.
     * @param {book_genreDeleteArgs} args - Arguments to delete one Book_genre.
     * @example
     * // Delete one Book_genre
     * const Book_genre = await prisma.book_genre.delete({
     *   where: {
     *     // ... filter to delete one Book_genre
     *   }
     * })
     * 
     */
    delete<T extends book_genreDeleteArgs>(args: SelectSubset<T, book_genreDeleteArgs<ExtArgs>>): Prisma__book_genreClient<$Result.GetResult<Prisma.$book_genrePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Book_genre.
     * @param {book_genreUpdateArgs} args - Arguments to update one Book_genre.
     * @example
     * // Update one Book_genre
     * const book_genre = await prisma.book_genre.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends book_genreUpdateArgs>(args: SelectSubset<T, book_genreUpdateArgs<ExtArgs>>): Prisma__book_genreClient<$Result.GetResult<Prisma.$book_genrePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Book_genres.
     * @param {book_genreDeleteManyArgs} args - Arguments to filter Book_genres to delete.
     * @example
     * // Delete a few Book_genres
     * const { count } = await prisma.book_genre.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends book_genreDeleteManyArgs>(args?: SelectSubset<T, book_genreDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Book_genres.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {book_genreUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Book_genres
     * const book_genre = await prisma.book_genre.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends book_genreUpdateManyArgs>(args: SelectSubset<T, book_genreUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Book_genres and returns the data updated in the database.
     * @param {book_genreUpdateManyAndReturnArgs} args - Arguments to update many Book_genres.
     * @example
     * // Update many Book_genres
     * const book_genre = await prisma.book_genre.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Book_genres and only return the `id`
     * const book_genreWithIdOnly = await prisma.book_genre.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends book_genreUpdateManyAndReturnArgs>(args: SelectSubset<T, book_genreUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$book_genrePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Book_genre.
     * @param {book_genreUpsertArgs} args - Arguments to update or create a Book_genre.
     * @example
     * // Update or create a Book_genre
     * const book_genre = await prisma.book_genre.upsert({
     *   create: {
     *     // ... data to create a Book_genre
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Book_genre we want to update
     *   }
     * })
     */
    upsert<T extends book_genreUpsertArgs>(args: SelectSubset<T, book_genreUpsertArgs<ExtArgs>>): Prisma__book_genreClient<$Result.GetResult<Prisma.$book_genrePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Book_genres.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {book_genreCountArgs} args - Arguments to filter Book_genres to count.
     * @example
     * // Count the number of Book_genres
     * const count = await prisma.book_genre.count({
     *   where: {
     *     // ... the filter for the Book_genres we want to count
     *   }
     * })
    **/
    count<T extends book_genreCountArgs>(
      args?: Subset<T, book_genreCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Book_genreCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Book_genre.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Book_genreAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Book_genreAggregateArgs>(args: Subset<T, Book_genreAggregateArgs>): Prisma.PrismaPromise<GetBook_genreAggregateType<T>>

    /**
     * Group by Book_genre.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {book_genreGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends book_genreGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: book_genreGroupByArgs['orderBy'] }
        : { orderBy?: book_genreGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, book_genreGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBook_genreGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the book_genre model
   */
  readonly fields: book_genreFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for book_genre.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__book_genreClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    book<T extends bookDefaultArgs<ExtArgs> = {}>(args?: Subset<T, bookDefaultArgs<ExtArgs>>): Prisma__bookClient<$Result.GetResult<Prisma.$bookPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    genre<T extends genreDefaultArgs<ExtArgs> = {}>(args?: Subset<T, genreDefaultArgs<ExtArgs>>): Prisma__genreClient<$Result.GetResult<Prisma.$genrePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the book_genre model
   */
  interface book_genreFieldRefs {
    readonly id: FieldRef<"book_genre", 'String'>
    readonly id_genre: FieldRef<"book_genre", 'String'>
    readonly id_book: FieldRef<"book_genre", 'String'>
  }
    

  // Custom InputTypes
  /**
   * book_genre findUnique
   */
  export type book_genreFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the book_genre
     */
    select?: book_genreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the book_genre
     */
    omit?: book_genreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: book_genreInclude<ExtArgs> | null
    /**
     * Filter, which book_genre to fetch.
     */
    where: book_genreWhereUniqueInput
  }

  /**
   * book_genre findUniqueOrThrow
   */
  export type book_genreFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the book_genre
     */
    select?: book_genreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the book_genre
     */
    omit?: book_genreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: book_genreInclude<ExtArgs> | null
    /**
     * Filter, which book_genre to fetch.
     */
    where: book_genreWhereUniqueInput
  }

  /**
   * book_genre findFirst
   */
  export type book_genreFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the book_genre
     */
    select?: book_genreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the book_genre
     */
    omit?: book_genreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: book_genreInclude<ExtArgs> | null
    /**
     * Filter, which book_genre to fetch.
     */
    where?: book_genreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of book_genres to fetch.
     */
    orderBy?: book_genreOrderByWithRelationInput | book_genreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for book_genres.
     */
    cursor?: book_genreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` book_genres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` book_genres.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of book_genres.
     */
    distinct?: Book_genreScalarFieldEnum | Book_genreScalarFieldEnum[]
  }

  /**
   * book_genre findFirstOrThrow
   */
  export type book_genreFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the book_genre
     */
    select?: book_genreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the book_genre
     */
    omit?: book_genreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: book_genreInclude<ExtArgs> | null
    /**
     * Filter, which book_genre to fetch.
     */
    where?: book_genreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of book_genres to fetch.
     */
    orderBy?: book_genreOrderByWithRelationInput | book_genreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for book_genres.
     */
    cursor?: book_genreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` book_genres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` book_genres.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of book_genres.
     */
    distinct?: Book_genreScalarFieldEnum | Book_genreScalarFieldEnum[]
  }

  /**
   * book_genre findMany
   */
  export type book_genreFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the book_genre
     */
    select?: book_genreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the book_genre
     */
    omit?: book_genreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: book_genreInclude<ExtArgs> | null
    /**
     * Filter, which book_genres to fetch.
     */
    where?: book_genreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of book_genres to fetch.
     */
    orderBy?: book_genreOrderByWithRelationInput | book_genreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing book_genres.
     */
    cursor?: book_genreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` book_genres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` book_genres.
     */
    skip?: number
    distinct?: Book_genreScalarFieldEnum | Book_genreScalarFieldEnum[]
  }

  /**
   * book_genre create
   */
  export type book_genreCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the book_genre
     */
    select?: book_genreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the book_genre
     */
    omit?: book_genreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: book_genreInclude<ExtArgs> | null
    /**
     * The data needed to create a book_genre.
     */
    data: XOR<book_genreCreateInput, book_genreUncheckedCreateInput>
  }

  /**
   * book_genre createMany
   */
  export type book_genreCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many book_genres.
     */
    data: book_genreCreateManyInput | book_genreCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * book_genre createManyAndReturn
   */
  export type book_genreCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the book_genre
     */
    select?: book_genreSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the book_genre
     */
    omit?: book_genreOmit<ExtArgs> | null
    /**
     * The data used to create many book_genres.
     */
    data: book_genreCreateManyInput | book_genreCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: book_genreIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * book_genre update
   */
  export type book_genreUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the book_genre
     */
    select?: book_genreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the book_genre
     */
    omit?: book_genreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: book_genreInclude<ExtArgs> | null
    /**
     * The data needed to update a book_genre.
     */
    data: XOR<book_genreUpdateInput, book_genreUncheckedUpdateInput>
    /**
     * Choose, which book_genre to update.
     */
    where: book_genreWhereUniqueInput
  }

  /**
   * book_genre updateMany
   */
  export type book_genreUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update book_genres.
     */
    data: XOR<book_genreUpdateManyMutationInput, book_genreUncheckedUpdateManyInput>
    /**
     * Filter which book_genres to update
     */
    where?: book_genreWhereInput
    /**
     * Limit how many book_genres to update.
     */
    limit?: number
  }

  /**
   * book_genre updateManyAndReturn
   */
  export type book_genreUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the book_genre
     */
    select?: book_genreSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the book_genre
     */
    omit?: book_genreOmit<ExtArgs> | null
    /**
     * The data used to update book_genres.
     */
    data: XOR<book_genreUpdateManyMutationInput, book_genreUncheckedUpdateManyInput>
    /**
     * Filter which book_genres to update
     */
    where?: book_genreWhereInput
    /**
     * Limit how many book_genres to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: book_genreIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * book_genre upsert
   */
  export type book_genreUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the book_genre
     */
    select?: book_genreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the book_genre
     */
    omit?: book_genreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: book_genreInclude<ExtArgs> | null
    /**
     * The filter to search for the book_genre to update in case it exists.
     */
    where: book_genreWhereUniqueInput
    /**
     * In case the book_genre found by the `where` argument doesn't exist, create a new book_genre with this data.
     */
    create: XOR<book_genreCreateInput, book_genreUncheckedCreateInput>
    /**
     * In case the book_genre was found with the provided `where` argument, update it with this data.
     */
    update: XOR<book_genreUpdateInput, book_genreUncheckedUpdateInput>
  }

  /**
   * book_genre delete
   */
  export type book_genreDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the book_genre
     */
    select?: book_genreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the book_genre
     */
    omit?: book_genreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: book_genreInclude<ExtArgs> | null
    /**
     * Filter which book_genre to delete.
     */
    where: book_genreWhereUniqueInput
  }

  /**
   * book_genre deleteMany
   */
  export type book_genreDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which book_genres to delete
     */
    where?: book_genreWhereInput
    /**
     * Limit how many book_genres to delete.
     */
    limit?: number
  }

  /**
   * book_genre without action
   */
  export type book_genreDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the book_genre
     */
    select?: book_genreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the book_genre
     */
    omit?: book_genreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: book_genreInclude<ExtArgs> | null
  }


  /**
   * Model book_tags
   */

  export type AggregateBook_tags = {
    _count: Book_tagsCountAggregateOutputType | null
    _min: Book_tagsMinAggregateOutputType | null
    _max: Book_tagsMaxAggregateOutputType | null
  }

  export type Book_tagsMinAggregateOutputType = {
    id: string | null
    id_tags: string | null
    id_book: string | null
  }

  export type Book_tagsMaxAggregateOutputType = {
    id: string | null
    id_tags: string | null
    id_book: string | null
  }

  export type Book_tagsCountAggregateOutputType = {
    id: number
    id_tags: number
    id_book: number
    _all: number
  }


  export type Book_tagsMinAggregateInputType = {
    id?: true
    id_tags?: true
    id_book?: true
  }

  export type Book_tagsMaxAggregateInputType = {
    id?: true
    id_tags?: true
    id_book?: true
  }

  export type Book_tagsCountAggregateInputType = {
    id?: true
    id_tags?: true
    id_book?: true
    _all?: true
  }

  export type Book_tagsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which book_tags to aggregate.
     */
    where?: book_tagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of book_tags to fetch.
     */
    orderBy?: book_tagsOrderByWithRelationInput | book_tagsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: book_tagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` book_tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` book_tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned book_tags
    **/
    _count?: true | Book_tagsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Book_tagsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Book_tagsMaxAggregateInputType
  }

  export type GetBook_tagsAggregateType<T extends Book_tagsAggregateArgs> = {
        [P in keyof T & keyof AggregateBook_tags]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBook_tags[P]>
      : GetScalarType<T[P], AggregateBook_tags[P]>
  }




  export type book_tagsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: book_tagsWhereInput
    orderBy?: book_tagsOrderByWithAggregationInput | book_tagsOrderByWithAggregationInput[]
    by: Book_tagsScalarFieldEnum[] | Book_tagsScalarFieldEnum
    having?: book_tagsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Book_tagsCountAggregateInputType | true
    _min?: Book_tagsMinAggregateInputType
    _max?: Book_tagsMaxAggregateInputType
  }

  export type Book_tagsGroupByOutputType = {
    id: string
    id_tags: string
    id_book: string
    _count: Book_tagsCountAggregateOutputType | null
    _min: Book_tagsMinAggregateOutputType | null
    _max: Book_tagsMaxAggregateOutputType | null
  }

  type GetBook_tagsGroupByPayload<T extends book_tagsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Book_tagsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Book_tagsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Book_tagsGroupByOutputType[P]>
            : GetScalarType<T[P], Book_tagsGroupByOutputType[P]>
        }
      >
    >


  export type book_tagsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    id_tags?: boolean
    id_book?: boolean
    book?: boolean | bookDefaultArgs<ExtArgs>
    tags?: boolean | tagsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["book_tags"]>

  export type book_tagsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    id_tags?: boolean
    id_book?: boolean
    book?: boolean | bookDefaultArgs<ExtArgs>
    tags?: boolean | tagsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["book_tags"]>

  export type book_tagsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    id_tags?: boolean
    id_book?: boolean
    book?: boolean | bookDefaultArgs<ExtArgs>
    tags?: boolean | tagsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["book_tags"]>

  export type book_tagsSelectScalar = {
    id?: boolean
    id_tags?: boolean
    id_book?: boolean
  }

  export type book_tagsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "id_tags" | "id_book", ExtArgs["result"]["book_tags"]>
  export type book_tagsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    book?: boolean | bookDefaultArgs<ExtArgs>
    tags?: boolean | tagsDefaultArgs<ExtArgs>
  }
  export type book_tagsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    book?: boolean | bookDefaultArgs<ExtArgs>
    tags?: boolean | tagsDefaultArgs<ExtArgs>
  }
  export type book_tagsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    book?: boolean | bookDefaultArgs<ExtArgs>
    tags?: boolean | tagsDefaultArgs<ExtArgs>
  }

  export type $book_tagsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "book_tags"
    objects: {
      book: Prisma.$bookPayload<ExtArgs>
      tags: Prisma.$tagsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      id_tags: string
      id_book: string
    }, ExtArgs["result"]["book_tags"]>
    composites: {}
  }

  type book_tagsGetPayload<S extends boolean | null | undefined | book_tagsDefaultArgs> = $Result.GetResult<Prisma.$book_tagsPayload, S>

  type book_tagsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<book_tagsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Book_tagsCountAggregateInputType | true
    }

  export interface book_tagsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['book_tags'], meta: { name: 'book_tags' } }
    /**
     * Find zero or one Book_tags that matches the filter.
     * @param {book_tagsFindUniqueArgs} args - Arguments to find a Book_tags
     * @example
     * // Get one Book_tags
     * const book_tags = await prisma.book_tags.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends book_tagsFindUniqueArgs>(args: SelectSubset<T, book_tagsFindUniqueArgs<ExtArgs>>): Prisma__book_tagsClient<$Result.GetResult<Prisma.$book_tagsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Book_tags that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {book_tagsFindUniqueOrThrowArgs} args - Arguments to find a Book_tags
     * @example
     * // Get one Book_tags
     * const book_tags = await prisma.book_tags.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends book_tagsFindUniqueOrThrowArgs>(args: SelectSubset<T, book_tagsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__book_tagsClient<$Result.GetResult<Prisma.$book_tagsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Book_tags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {book_tagsFindFirstArgs} args - Arguments to find a Book_tags
     * @example
     * // Get one Book_tags
     * const book_tags = await prisma.book_tags.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends book_tagsFindFirstArgs>(args?: SelectSubset<T, book_tagsFindFirstArgs<ExtArgs>>): Prisma__book_tagsClient<$Result.GetResult<Prisma.$book_tagsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Book_tags that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {book_tagsFindFirstOrThrowArgs} args - Arguments to find a Book_tags
     * @example
     * // Get one Book_tags
     * const book_tags = await prisma.book_tags.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends book_tagsFindFirstOrThrowArgs>(args?: SelectSubset<T, book_tagsFindFirstOrThrowArgs<ExtArgs>>): Prisma__book_tagsClient<$Result.GetResult<Prisma.$book_tagsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Book_tags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {book_tagsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Book_tags
     * const book_tags = await prisma.book_tags.findMany()
     * 
     * // Get first 10 Book_tags
     * const book_tags = await prisma.book_tags.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const book_tagsWithIdOnly = await prisma.book_tags.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends book_tagsFindManyArgs>(args?: SelectSubset<T, book_tagsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$book_tagsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Book_tags.
     * @param {book_tagsCreateArgs} args - Arguments to create a Book_tags.
     * @example
     * // Create one Book_tags
     * const Book_tags = await prisma.book_tags.create({
     *   data: {
     *     // ... data to create a Book_tags
     *   }
     * })
     * 
     */
    create<T extends book_tagsCreateArgs>(args: SelectSubset<T, book_tagsCreateArgs<ExtArgs>>): Prisma__book_tagsClient<$Result.GetResult<Prisma.$book_tagsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Book_tags.
     * @param {book_tagsCreateManyArgs} args - Arguments to create many Book_tags.
     * @example
     * // Create many Book_tags
     * const book_tags = await prisma.book_tags.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends book_tagsCreateManyArgs>(args?: SelectSubset<T, book_tagsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Book_tags and returns the data saved in the database.
     * @param {book_tagsCreateManyAndReturnArgs} args - Arguments to create many Book_tags.
     * @example
     * // Create many Book_tags
     * const book_tags = await prisma.book_tags.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Book_tags and only return the `id`
     * const book_tagsWithIdOnly = await prisma.book_tags.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends book_tagsCreateManyAndReturnArgs>(args?: SelectSubset<T, book_tagsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$book_tagsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Book_tags.
     * @param {book_tagsDeleteArgs} args - Arguments to delete one Book_tags.
     * @example
     * // Delete one Book_tags
     * const Book_tags = await prisma.book_tags.delete({
     *   where: {
     *     // ... filter to delete one Book_tags
     *   }
     * })
     * 
     */
    delete<T extends book_tagsDeleteArgs>(args: SelectSubset<T, book_tagsDeleteArgs<ExtArgs>>): Prisma__book_tagsClient<$Result.GetResult<Prisma.$book_tagsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Book_tags.
     * @param {book_tagsUpdateArgs} args - Arguments to update one Book_tags.
     * @example
     * // Update one Book_tags
     * const book_tags = await prisma.book_tags.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends book_tagsUpdateArgs>(args: SelectSubset<T, book_tagsUpdateArgs<ExtArgs>>): Prisma__book_tagsClient<$Result.GetResult<Prisma.$book_tagsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Book_tags.
     * @param {book_tagsDeleteManyArgs} args - Arguments to filter Book_tags to delete.
     * @example
     * // Delete a few Book_tags
     * const { count } = await prisma.book_tags.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends book_tagsDeleteManyArgs>(args?: SelectSubset<T, book_tagsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Book_tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {book_tagsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Book_tags
     * const book_tags = await prisma.book_tags.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends book_tagsUpdateManyArgs>(args: SelectSubset<T, book_tagsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Book_tags and returns the data updated in the database.
     * @param {book_tagsUpdateManyAndReturnArgs} args - Arguments to update many Book_tags.
     * @example
     * // Update many Book_tags
     * const book_tags = await prisma.book_tags.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Book_tags and only return the `id`
     * const book_tagsWithIdOnly = await prisma.book_tags.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends book_tagsUpdateManyAndReturnArgs>(args: SelectSubset<T, book_tagsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$book_tagsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Book_tags.
     * @param {book_tagsUpsertArgs} args - Arguments to update or create a Book_tags.
     * @example
     * // Update or create a Book_tags
     * const book_tags = await prisma.book_tags.upsert({
     *   create: {
     *     // ... data to create a Book_tags
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Book_tags we want to update
     *   }
     * })
     */
    upsert<T extends book_tagsUpsertArgs>(args: SelectSubset<T, book_tagsUpsertArgs<ExtArgs>>): Prisma__book_tagsClient<$Result.GetResult<Prisma.$book_tagsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Book_tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {book_tagsCountArgs} args - Arguments to filter Book_tags to count.
     * @example
     * // Count the number of Book_tags
     * const count = await prisma.book_tags.count({
     *   where: {
     *     // ... the filter for the Book_tags we want to count
     *   }
     * })
    **/
    count<T extends book_tagsCountArgs>(
      args?: Subset<T, book_tagsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Book_tagsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Book_tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Book_tagsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Book_tagsAggregateArgs>(args: Subset<T, Book_tagsAggregateArgs>): Prisma.PrismaPromise<GetBook_tagsAggregateType<T>>

    /**
     * Group by Book_tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {book_tagsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends book_tagsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: book_tagsGroupByArgs['orderBy'] }
        : { orderBy?: book_tagsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, book_tagsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBook_tagsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the book_tags model
   */
  readonly fields: book_tagsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for book_tags.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__book_tagsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    book<T extends bookDefaultArgs<ExtArgs> = {}>(args?: Subset<T, bookDefaultArgs<ExtArgs>>): Prisma__bookClient<$Result.GetResult<Prisma.$bookPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    tags<T extends tagsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, tagsDefaultArgs<ExtArgs>>): Prisma__tagsClient<$Result.GetResult<Prisma.$tagsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the book_tags model
   */
  interface book_tagsFieldRefs {
    readonly id: FieldRef<"book_tags", 'String'>
    readonly id_tags: FieldRef<"book_tags", 'String'>
    readonly id_book: FieldRef<"book_tags", 'String'>
  }
    

  // Custom InputTypes
  /**
   * book_tags findUnique
   */
  export type book_tagsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the book_tags
     */
    select?: book_tagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the book_tags
     */
    omit?: book_tagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: book_tagsInclude<ExtArgs> | null
    /**
     * Filter, which book_tags to fetch.
     */
    where: book_tagsWhereUniqueInput
  }

  /**
   * book_tags findUniqueOrThrow
   */
  export type book_tagsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the book_tags
     */
    select?: book_tagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the book_tags
     */
    omit?: book_tagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: book_tagsInclude<ExtArgs> | null
    /**
     * Filter, which book_tags to fetch.
     */
    where: book_tagsWhereUniqueInput
  }

  /**
   * book_tags findFirst
   */
  export type book_tagsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the book_tags
     */
    select?: book_tagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the book_tags
     */
    omit?: book_tagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: book_tagsInclude<ExtArgs> | null
    /**
     * Filter, which book_tags to fetch.
     */
    where?: book_tagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of book_tags to fetch.
     */
    orderBy?: book_tagsOrderByWithRelationInput | book_tagsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for book_tags.
     */
    cursor?: book_tagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` book_tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` book_tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of book_tags.
     */
    distinct?: Book_tagsScalarFieldEnum | Book_tagsScalarFieldEnum[]
  }

  /**
   * book_tags findFirstOrThrow
   */
  export type book_tagsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the book_tags
     */
    select?: book_tagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the book_tags
     */
    omit?: book_tagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: book_tagsInclude<ExtArgs> | null
    /**
     * Filter, which book_tags to fetch.
     */
    where?: book_tagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of book_tags to fetch.
     */
    orderBy?: book_tagsOrderByWithRelationInput | book_tagsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for book_tags.
     */
    cursor?: book_tagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` book_tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` book_tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of book_tags.
     */
    distinct?: Book_tagsScalarFieldEnum | Book_tagsScalarFieldEnum[]
  }

  /**
   * book_tags findMany
   */
  export type book_tagsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the book_tags
     */
    select?: book_tagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the book_tags
     */
    omit?: book_tagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: book_tagsInclude<ExtArgs> | null
    /**
     * Filter, which book_tags to fetch.
     */
    where?: book_tagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of book_tags to fetch.
     */
    orderBy?: book_tagsOrderByWithRelationInput | book_tagsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing book_tags.
     */
    cursor?: book_tagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` book_tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` book_tags.
     */
    skip?: number
    distinct?: Book_tagsScalarFieldEnum | Book_tagsScalarFieldEnum[]
  }

  /**
   * book_tags create
   */
  export type book_tagsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the book_tags
     */
    select?: book_tagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the book_tags
     */
    omit?: book_tagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: book_tagsInclude<ExtArgs> | null
    /**
     * The data needed to create a book_tags.
     */
    data: XOR<book_tagsCreateInput, book_tagsUncheckedCreateInput>
  }

  /**
   * book_tags createMany
   */
  export type book_tagsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many book_tags.
     */
    data: book_tagsCreateManyInput | book_tagsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * book_tags createManyAndReturn
   */
  export type book_tagsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the book_tags
     */
    select?: book_tagsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the book_tags
     */
    omit?: book_tagsOmit<ExtArgs> | null
    /**
     * The data used to create many book_tags.
     */
    data: book_tagsCreateManyInput | book_tagsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: book_tagsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * book_tags update
   */
  export type book_tagsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the book_tags
     */
    select?: book_tagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the book_tags
     */
    omit?: book_tagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: book_tagsInclude<ExtArgs> | null
    /**
     * The data needed to update a book_tags.
     */
    data: XOR<book_tagsUpdateInput, book_tagsUncheckedUpdateInput>
    /**
     * Choose, which book_tags to update.
     */
    where: book_tagsWhereUniqueInput
  }

  /**
   * book_tags updateMany
   */
  export type book_tagsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update book_tags.
     */
    data: XOR<book_tagsUpdateManyMutationInput, book_tagsUncheckedUpdateManyInput>
    /**
     * Filter which book_tags to update
     */
    where?: book_tagsWhereInput
    /**
     * Limit how many book_tags to update.
     */
    limit?: number
  }

  /**
   * book_tags updateManyAndReturn
   */
  export type book_tagsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the book_tags
     */
    select?: book_tagsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the book_tags
     */
    omit?: book_tagsOmit<ExtArgs> | null
    /**
     * The data used to update book_tags.
     */
    data: XOR<book_tagsUpdateManyMutationInput, book_tagsUncheckedUpdateManyInput>
    /**
     * Filter which book_tags to update
     */
    where?: book_tagsWhereInput
    /**
     * Limit how many book_tags to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: book_tagsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * book_tags upsert
   */
  export type book_tagsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the book_tags
     */
    select?: book_tagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the book_tags
     */
    omit?: book_tagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: book_tagsInclude<ExtArgs> | null
    /**
     * The filter to search for the book_tags to update in case it exists.
     */
    where: book_tagsWhereUniqueInput
    /**
     * In case the book_tags found by the `where` argument doesn't exist, create a new book_tags with this data.
     */
    create: XOR<book_tagsCreateInput, book_tagsUncheckedCreateInput>
    /**
     * In case the book_tags was found with the provided `where` argument, update it with this data.
     */
    update: XOR<book_tagsUpdateInput, book_tagsUncheckedUpdateInput>
  }

  /**
   * book_tags delete
   */
  export type book_tagsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the book_tags
     */
    select?: book_tagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the book_tags
     */
    omit?: book_tagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: book_tagsInclude<ExtArgs> | null
    /**
     * Filter which book_tags to delete.
     */
    where: book_tagsWhereUniqueInput
  }

  /**
   * book_tags deleteMany
   */
  export type book_tagsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which book_tags to delete
     */
    where?: book_tagsWhereInput
    /**
     * Limit how many book_tags to delete.
     */
    limit?: number
  }

  /**
   * book_tags without action
   */
  export type book_tagsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the book_tags
     */
    select?: book_tagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the book_tags
     */
    omit?: book_tagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: book_tagsInclude<ExtArgs> | null
  }


  /**
   * Model bundle
   */

  export type AggregateBundle = {
    _count: BundleCountAggregateOutputType | null
    _avg: BundleAvgAggregateOutputType | null
    _sum: BundleSumAggregateOutputType | null
    _min: BundleMinAggregateOutputType | null
    _max: BundleMaxAggregateOutputType | null
  }

  export type BundleAvgAggregateOutputType = {
    strike_price: Decimal | null
    real_price: Decimal | null
  }

  export type BundleSumAggregateOutputType = {
    strike_price: Decimal | null
    real_price: Decimal | null
  }

  export type BundleMinAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    strike_price: Decimal | null
    real_price: Decimal | null
    currency: string | null
    desc: string | null
    deleted_at: Date | null
    status: string | null
    img_file: string | null
    cover: string | null
    sku: string | null
  }

  export type BundleMaxAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    strike_price: Decimal | null
    real_price: Decimal | null
    currency: string | null
    desc: string | null
    deleted_at: Date | null
    status: string | null
    img_file: string | null
    cover: string | null
    sku: string | null
  }

  export type BundleCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    strike_price: number
    real_price: number
    currency: number
    desc: number
    info: number
    deleted_at: number
    status: number
    img_file: number
    cover: number
    sku: number
    _all: number
  }


  export type BundleAvgAggregateInputType = {
    strike_price?: true
    real_price?: true
  }

  export type BundleSumAggregateInputType = {
    strike_price?: true
    real_price?: true
  }

  export type BundleMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    strike_price?: true
    real_price?: true
    currency?: true
    desc?: true
    deleted_at?: true
    status?: true
    img_file?: true
    cover?: true
    sku?: true
  }

  export type BundleMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    strike_price?: true
    real_price?: true
    currency?: true
    desc?: true
    deleted_at?: true
    status?: true
    img_file?: true
    cover?: true
    sku?: true
  }

  export type BundleCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    strike_price?: true
    real_price?: true
    currency?: true
    desc?: true
    info?: true
    deleted_at?: true
    status?: true
    img_file?: true
    cover?: true
    sku?: true
    _all?: true
  }

  export type BundleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which bundle to aggregate.
     */
    where?: bundleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bundles to fetch.
     */
    orderBy?: bundleOrderByWithRelationInput | bundleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: bundleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bundles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bundles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned bundles
    **/
    _count?: true | BundleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BundleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BundleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BundleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BundleMaxAggregateInputType
  }

  export type GetBundleAggregateType<T extends BundleAggregateArgs> = {
        [P in keyof T & keyof AggregateBundle]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBundle[P]>
      : GetScalarType<T[P], AggregateBundle[P]>
  }




  export type bundleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: bundleWhereInput
    orderBy?: bundleOrderByWithAggregationInput | bundleOrderByWithAggregationInput[]
    by: BundleScalarFieldEnum[] | BundleScalarFieldEnum
    having?: bundleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BundleCountAggregateInputType | true
    _avg?: BundleAvgAggregateInputType
    _sum?: BundleSumAggregateInputType
    _min?: BundleMinAggregateInputType
    _max?: BundleMaxAggregateInputType
  }

  export type BundleGroupByOutputType = {
    id: string
    name: string
    slug: string
    strike_price: Decimal | null
    real_price: Decimal
    currency: string
    desc: string
    info: JsonValue
    deleted_at: Date | null
    status: string
    img_file: string
    cover: string
    sku: string
    _count: BundleCountAggregateOutputType | null
    _avg: BundleAvgAggregateOutputType | null
    _sum: BundleSumAggregateOutputType | null
    _min: BundleMinAggregateOutputType | null
    _max: BundleMaxAggregateOutputType | null
  }

  type GetBundleGroupByPayload<T extends bundleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BundleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BundleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BundleGroupByOutputType[P]>
            : GetScalarType<T[P], BundleGroupByOutputType[P]>
        }
      >
    >


  export type bundleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    strike_price?: boolean
    real_price?: boolean
    currency?: boolean
    desc?: boolean
    info?: boolean
    deleted_at?: boolean
    status?: boolean
    img_file?: boolean
    cover?: boolean
    sku?: boolean
    bundle_category?: boolean | bundle$bundle_categoryArgs<ExtArgs>
    bundle_product?: boolean | bundle$bundle_productArgs<ExtArgs>
    t_sales_line?: boolean | bundle$t_sales_lineArgs<ExtArgs>
    _count?: boolean | BundleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bundle"]>

  export type bundleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    strike_price?: boolean
    real_price?: boolean
    currency?: boolean
    desc?: boolean
    info?: boolean
    deleted_at?: boolean
    status?: boolean
    img_file?: boolean
    cover?: boolean
    sku?: boolean
  }, ExtArgs["result"]["bundle"]>

  export type bundleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    strike_price?: boolean
    real_price?: boolean
    currency?: boolean
    desc?: boolean
    info?: boolean
    deleted_at?: boolean
    status?: boolean
    img_file?: boolean
    cover?: boolean
    sku?: boolean
  }, ExtArgs["result"]["bundle"]>

  export type bundleSelectScalar = {
    id?: boolean
    name?: boolean
    slug?: boolean
    strike_price?: boolean
    real_price?: boolean
    currency?: boolean
    desc?: boolean
    info?: boolean
    deleted_at?: boolean
    status?: boolean
    img_file?: boolean
    cover?: boolean
    sku?: boolean
  }

  export type bundleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "slug" | "strike_price" | "real_price" | "currency" | "desc" | "info" | "deleted_at" | "status" | "img_file" | "cover" | "sku", ExtArgs["result"]["bundle"]>
  export type bundleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bundle_category?: boolean | bundle$bundle_categoryArgs<ExtArgs>
    bundle_product?: boolean | bundle$bundle_productArgs<ExtArgs>
    t_sales_line?: boolean | bundle$t_sales_lineArgs<ExtArgs>
    _count?: boolean | BundleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type bundleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type bundleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $bundlePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "bundle"
    objects: {
      bundle_category: Prisma.$bundle_categoryPayload<ExtArgs>[]
      bundle_product: Prisma.$bundle_productPayload<ExtArgs>[]
      t_sales_line: Prisma.$t_sales_linePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      slug: string
      strike_price: Prisma.Decimal | null
      real_price: Prisma.Decimal
      currency: string
      desc: string
      info: Prisma.JsonValue
      deleted_at: Date | null
      status: string
      img_file: string
      cover: string
      sku: string
    }, ExtArgs["result"]["bundle"]>
    composites: {}
  }

  type bundleGetPayload<S extends boolean | null | undefined | bundleDefaultArgs> = $Result.GetResult<Prisma.$bundlePayload, S>

  type bundleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<bundleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BundleCountAggregateInputType | true
    }

  export interface bundleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['bundle'], meta: { name: 'bundle' } }
    /**
     * Find zero or one Bundle that matches the filter.
     * @param {bundleFindUniqueArgs} args - Arguments to find a Bundle
     * @example
     * // Get one Bundle
     * const bundle = await prisma.bundle.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends bundleFindUniqueArgs>(args: SelectSubset<T, bundleFindUniqueArgs<ExtArgs>>): Prisma__bundleClient<$Result.GetResult<Prisma.$bundlePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Bundle that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {bundleFindUniqueOrThrowArgs} args - Arguments to find a Bundle
     * @example
     * // Get one Bundle
     * const bundle = await prisma.bundle.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends bundleFindUniqueOrThrowArgs>(args: SelectSubset<T, bundleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__bundleClient<$Result.GetResult<Prisma.$bundlePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Bundle that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bundleFindFirstArgs} args - Arguments to find a Bundle
     * @example
     * // Get one Bundle
     * const bundle = await prisma.bundle.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends bundleFindFirstArgs>(args?: SelectSubset<T, bundleFindFirstArgs<ExtArgs>>): Prisma__bundleClient<$Result.GetResult<Prisma.$bundlePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Bundle that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bundleFindFirstOrThrowArgs} args - Arguments to find a Bundle
     * @example
     * // Get one Bundle
     * const bundle = await prisma.bundle.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends bundleFindFirstOrThrowArgs>(args?: SelectSubset<T, bundleFindFirstOrThrowArgs<ExtArgs>>): Prisma__bundleClient<$Result.GetResult<Prisma.$bundlePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Bundles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bundleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Bundles
     * const bundles = await prisma.bundle.findMany()
     * 
     * // Get first 10 Bundles
     * const bundles = await prisma.bundle.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bundleWithIdOnly = await prisma.bundle.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends bundleFindManyArgs>(args?: SelectSubset<T, bundleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$bundlePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Bundle.
     * @param {bundleCreateArgs} args - Arguments to create a Bundle.
     * @example
     * // Create one Bundle
     * const Bundle = await prisma.bundle.create({
     *   data: {
     *     // ... data to create a Bundle
     *   }
     * })
     * 
     */
    create<T extends bundleCreateArgs>(args: SelectSubset<T, bundleCreateArgs<ExtArgs>>): Prisma__bundleClient<$Result.GetResult<Prisma.$bundlePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Bundles.
     * @param {bundleCreateManyArgs} args - Arguments to create many Bundles.
     * @example
     * // Create many Bundles
     * const bundle = await prisma.bundle.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends bundleCreateManyArgs>(args?: SelectSubset<T, bundleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Bundles and returns the data saved in the database.
     * @param {bundleCreateManyAndReturnArgs} args - Arguments to create many Bundles.
     * @example
     * // Create many Bundles
     * const bundle = await prisma.bundle.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Bundles and only return the `id`
     * const bundleWithIdOnly = await prisma.bundle.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends bundleCreateManyAndReturnArgs>(args?: SelectSubset<T, bundleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$bundlePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Bundle.
     * @param {bundleDeleteArgs} args - Arguments to delete one Bundle.
     * @example
     * // Delete one Bundle
     * const Bundle = await prisma.bundle.delete({
     *   where: {
     *     // ... filter to delete one Bundle
     *   }
     * })
     * 
     */
    delete<T extends bundleDeleteArgs>(args: SelectSubset<T, bundleDeleteArgs<ExtArgs>>): Prisma__bundleClient<$Result.GetResult<Prisma.$bundlePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Bundle.
     * @param {bundleUpdateArgs} args - Arguments to update one Bundle.
     * @example
     * // Update one Bundle
     * const bundle = await prisma.bundle.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends bundleUpdateArgs>(args: SelectSubset<T, bundleUpdateArgs<ExtArgs>>): Prisma__bundleClient<$Result.GetResult<Prisma.$bundlePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Bundles.
     * @param {bundleDeleteManyArgs} args - Arguments to filter Bundles to delete.
     * @example
     * // Delete a few Bundles
     * const { count } = await prisma.bundle.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends bundleDeleteManyArgs>(args?: SelectSubset<T, bundleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bundles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bundleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Bundles
     * const bundle = await prisma.bundle.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends bundleUpdateManyArgs>(args: SelectSubset<T, bundleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bundles and returns the data updated in the database.
     * @param {bundleUpdateManyAndReturnArgs} args - Arguments to update many Bundles.
     * @example
     * // Update many Bundles
     * const bundle = await prisma.bundle.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Bundles and only return the `id`
     * const bundleWithIdOnly = await prisma.bundle.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends bundleUpdateManyAndReturnArgs>(args: SelectSubset<T, bundleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$bundlePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Bundle.
     * @param {bundleUpsertArgs} args - Arguments to update or create a Bundle.
     * @example
     * // Update or create a Bundle
     * const bundle = await prisma.bundle.upsert({
     *   create: {
     *     // ... data to create a Bundle
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Bundle we want to update
     *   }
     * })
     */
    upsert<T extends bundleUpsertArgs>(args: SelectSubset<T, bundleUpsertArgs<ExtArgs>>): Prisma__bundleClient<$Result.GetResult<Prisma.$bundlePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Bundles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bundleCountArgs} args - Arguments to filter Bundles to count.
     * @example
     * // Count the number of Bundles
     * const count = await prisma.bundle.count({
     *   where: {
     *     // ... the filter for the Bundles we want to count
     *   }
     * })
    **/
    count<T extends bundleCountArgs>(
      args?: Subset<T, bundleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BundleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Bundle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BundleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BundleAggregateArgs>(args: Subset<T, BundleAggregateArgs>): Prisma.PrismaPromise<GetBundleAggregateType<T>>

    /**
     * Group by Bundle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bundleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends bundleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: bundleGroupByArgs['orderBy'] }
        : { orderBy?: bundleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, bundleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBundleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the bundle model
   */
  readonly fields: bundleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for bundle.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__bundleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bundle_category<T extends bundle$bundle_categoryArgs<ExtArgs> = {}>(args?: Subset<T, bundle$bundle_categoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$bundle_categoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    bundle_product<T extends bundle$bundle_productArgs<ExtArgs> = {}>(args?: Subset<T, bundle$bundle_productArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$bundle_productPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    t_sales_line<T extends bundle$t_sales_lineArgs<ExtArgs> = {}>(args?: Subset<T, bundle$t_sales_lineArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$t_sales_linePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the bundle model
   */
  interface bundleFieldRefs {
    readonly id: FieldRef<"bundle", 'String'>
    readonly name: FieldRef<"bundle", 'String'>
    readonly slug: FieldRef<"bundle", 'String'>
    readonly strike_price: FieldRef<"bundle", 'Decimal'>
    readonly real_price: FieldRef<"bundle", 'Decimal'>
    readonly currency: FieldRef<"bundle", 'String'>
    readonly desc: FieldRef<"bundle", 'String'>
    readonly info: FieldRef<"bundle", 'Json'>
    readonly deleted_at: FieldRef<"bundle", 'DateTime'>
    readonly status: FieldRef<"bundle", 'String'>
    readonly img_file: FieldRef<"bundle", 'String'>
    readonly cover: FieldRef<"bundle", 'String'>
    readonly sku: FieldRef<"bundle", 'String'>
  }
    

  // Custom InputTypes
  /**
   * bundle findUnique
   */
  export type bundleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bundle
     */
    select?: bundleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bundle
     */
    omit?: bundleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bundleInclude<ExtArgs> | null
    /**
     * Filter, which bundle to fetch.
     */
    where: bundleWhereUniqueInput
  }

  /**
   * bundle findUniqueOrThrow
   */
  export type bundleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bundle
     */
    select?: bundleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bundle
     */
    omit?: bundleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bundleInclude<ExtArgs> | null
    /**
     * Filter, which bundle to fetch.
     */
    where: bundleWhereUniqueInput
  }

  /**
   * bundle findFirst
   */
  export type bundleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bundle
     */
    select?: bundleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bundle
     */
    omit?: bundleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bundleInclude<ExtArgs> | null
    /**
     * Filter, which bundle to fetch.
     */
    where?: bundleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bundles to fetch.
     */
    orderBy?: bundleOrderByWithRelationInput | bundleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for bundles.
     */
    cursor?: bundleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bundles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bundles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of bundles.
     */
    distinct?: BundleScalarFieldEnum | BundleScalarFieldEnum[]
  }

  /**
   * bundle findFirstOrThrow
   */
  export type bundleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bundle
     */
    select?: bundleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bundle
     */
    omit?: bundleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bundleInclude<ExtArgs> | null
    /**
     * Filter, which bundle to fetch.
     */
    where?: bundleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bundles to fetch.
     */
    orderBy?: bundleOrderByWithRelationInput | bundleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for bundles.
     */
    cursor?: bundleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bundles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bundles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of bundles.
     */
    distinct?: BundleScalarFieldEnum | BundleScalarFieldEnum[]
  }

  /**
   * bundle findMany
   */
  export type bundleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bundle
     */
    select?: bundleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bundle
     */
    omit?: bundleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bundleInclude<ExtArgs> | null
    /**
     * Filter, which bundles to fetch.
     */
    where?: bundleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bundles to fetch.
     */
    orderBy?: bundleOrderByWithRelationInput | bundleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing bundles.
     */
    cursor?: bundleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bundles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bundles.
     */
    skip?: number
    distinct?: BundleScalarFieldEnum | BundleScalarFieldEnum[]
  }

  /**
   * bundle create
   */
  export type bundleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bundle
     */
    select?: bundleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bundle
     */
    omit?: bundleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bundleInclude<ExtArgs> | null
    /**
     * The data needed to create a bundle.
     */
    data: XOR<bundleCreateInput, bundleUncheckedCreateInput>
  }

  /**
   * bundle createMany
   */
  export type bundleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many bundles.
     */
    data: bundleCreateManyInput | bundleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * bundle createManyAndReturn
   */
  export type bundleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bundle
     */
    select?: bundleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the bundle
     */
    omit?: bundleOmit<ExtArgs> | null
    /**
     * The data used to create many bundles.
     */
    data: bundleCreateManyInput | bundleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * bundle update
   */
  export type bundleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bundle
     */
    select?: bundleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bundle
     */
    omit?: bundleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bundleInclude<ExtArgs> | null
    /**
     * The data needed to update a bundle.
     */
    data: XOR<bundleUpdateInput, bundleUncheckedUpdateInput>
    /**
     * Choose, which bundle to update.
     */
    where: bundleWhereUniqueInput
  }

  /**
   * bundle updateMany
   */
  export type bundleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update bundles.
     */
    data: XOR<bundleUpdateManyMutationInput, bundleUncheckedUpdateManyInput>
    /**
     * Filter which bundles to update
     */
    where?: bundleWhereInput
    /**
     * Limit how many bundles to update.
     */
    limit?: number
  }

  /**
   * bundle updateManyAndReturn
   */
  export type bundleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bundle
     */
    select?: bundleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the bundle
     */
    omit?: bundleOmit<ExtArgs> | null
    /**
     * The data used to update bundles.
     */
    data: XOR<bundleUpdateManyMutationInput, bundleUncheckedUpdateManyInput>
    /**
     * Filter which bundles to update
     */
    where?: bundleWhereInput
    /**
     * Limit how many bundles to update.
     */
    limit?: number
  }

  /**
   * bundle upsert
   */
  export type bundleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bundle
     */
    select?: bundleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bundle
     */
    omit?: bundleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bundleInclude<ExtArgs> | null
    /**
     * The filter to search for the bundle to update in case it exists.
     */
    where: bundleWhereUniqueInput
    /**
     * In case the bundle found by the `where` argument doesn't exist, create a new bundle with this data.
     */
    create: XOR<bundleCreateInput, bundleUncheckedCreateInput>
    /**
     * In case the bundle was found with the provided `where` argument, update it with this data.
     */
    update: XOR<bundleUpdateInput, bundleUncheckedUpdateInput>
  }

  /**
   * bundle delete
   */
  export type bundleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bundle
     */
    select?: bundleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bundle
     */
    omit?: bundleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bundleInclude<ExtArgs> | null
    /**
     * Filter which bundle to delete.
     */
    where: bundleWhereUniqueInput
  }

  /**
   * bundle deleteMany
   */
  export type bundleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which bundles to delete
     */
    where?: bundleWhereInput
    /**
     * Limit how many bundles to delete.
     */
    limit?: number
  }

  /**
   * bundle.bundle_category
   */
  export type bundle$bundle_categoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bundle_category
     */
    select?: bundle_categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the bundle_category
     */
    omit?: bundle_categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bundle_categoryInclude<ExtArgs> | null
    where?: bundle_categoryWhereInput
    orderBy?: bundle_categoryOrderByWithRelationInput | bundle_categoryOrderByWithRelationInput[]
    cursor?: bundle_categoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Bundle_categoryScalarFieldEnum | Bundle_categoryScalarFieldEnum[]
  }

  /**
   * bundle.bundle_product
   */
  export type bundle$bundle_productArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bundle_product
     */
    select?: bundle_productSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bundle_product
     */
    omit?: bundle_productOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bundle_productInclude<ExtArgs> | null
    where?: bundle_productWhereInput
    orderBy?: bundle_productOrderByWithRelationInput | bundle_productOrderByWithRelationInput[]
    cursor?: bundle_productWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Bundle_productScalarFieldEnum | Bundle_productScalarFieldEnum[]
  }

  /**
   * bundle.t_sales_line
   */
  export type bundle$t_sales_lineArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the t_sales_line
     */
    select?: t_sales_lineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the t_sales_line
     */
    omit?: t_sales_lineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: t_sales_lineInclude<ExtArgs> | null
    where?: t_sales_lineWhereInput
    orderBy?: t_sales_lineOrderByWithRelationInput | t_sales_lineOrderByWithRelationInput[]
    cursor?: t_sales_lineWhereUniqueInput
    take?: number
    skip?: number
    distinct?: T_sales_lineScalarFieldEnum | T_sales_lineScalarFieldEnum[]
  }

  /**
   * bundle without action
   */
  export type bundleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bundle
     */
    select?: bundleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bundle
     */
    omit?: bundleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bundleInclude<ExtArgs> | null
  }


  /**
   * Model bundle_category
   */

  export type AggregateBundle_category = {
    _count: Bundle_categoryCountAggregateOutputType | null
    _min: Bundle_categoryMinAggregateOutputType | null
    _max: Bundle_categoryMaxAggregateOutputType | null
  }

  export type Bundle_categoryMinAggregateOutputType = {
    id: string | null
    id_category: string | null
    id_bundle: string | null
  }

  export type Bundle_categoryMaxAggregateOutputType = {
    id: string | null
    id_category: string | null
    id_bundle: string | null
  }

  export type Bundle_categoryCountAggregateOutputType = {
    id: number
    id_category: number
    id_bundle: number
    _all: number
  }


  export type Bundle_categoryMinAggregateInputType = {
    id?: true
    id_category?: true
    id_bundle?: true
  }

  export type Bundle_categoryMaxAggregateInputType = {
    id?: true
    id_category?: true
    id_bundle?: true
  }

  export type Bundle_categoryCountAggregateInputType = {
    id?: true
    id_category?: true
    id_bundle?: true
    _all?: true
  }

  export type Bundle_categoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which bundle_category to aggregate.
     */
    where?: bundle_categoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bundle_categories to fetch.
     */
    orderBy?: bundle_categoryOrderByWithRelationInput | bundle_categoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: bundle_categoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bundle_categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bundle_categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned bundle_categories
    **/
    _count?: true | Bundle_categoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Bundle_categoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Bundle_categoryMaxAggregateInputType
  }

  export type GetBundle_categoryAggregateType<T extends Bundle_categoryAggregateArgs> = {
        [P in keyof T & keyof AggregateBundle_category]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBundle_category[P]>
      : GetScalarType<T[P], AggregateBundle_category[P]>
  }




  export type bundle_categoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: bundle_categoryWhereInput
    orderBy?: bundle_categoryOrderByWithAggregationInput | bundle_categoryOrderByWithAggregationInput[]
    by: Bundle_categoryScalarFieldEnum[] | Bundle_categoryScalarFieldEnum
    having?: bundle_categoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Bundle_categoryCountAggregateInputType | true
    _min?: Bundle_categoryMinAggregateInputType
    _max?: Bundle_categoryMaxAggregateInputType
  }

  export type Bundle_categoryGroupByOutputType = {
    id: string
    id_category: string
    id_bundle: string
    _count: Bundle_categoryCountAggregateOutputType | null
    _min: Bundle_categoryMinAggregateOutputType | null
    _max: Bundle_categoryMaxAggregateOutputType | null
  }

  type GetBundle_categoryGroupByPayload<T extends bundle_categoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Bundle_categoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Bundle_categoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Bundle_categoryGroupByOutputType[P]>
            : GetScalarType<T[P], Bundle_categoryGroupByOutputType[P]>
        }
      >
    >


  export type bundle_categorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    id_category?: boolean
    id_bundle?: boolean
    bundle?: boolean | bundleDefaultArgs<ExtArgs>
    category?: boolean | categoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bundle_category"]>

  export type bundle_categorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    id_category?: boolean
    id_bundle?: boolean
    bundle?: boolean | bundleDefaultArgs<ExtArgs>
    category?: boolean | categoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bundle_category"]>

  export type bundle_categorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    id_category?: boolean
    id_bundle?: boolean
    bundle?: boolean | bundleDefaultArgs<ExtArgs>
    category?: boolean | categoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bundle_category"]>

  export type bundle_categorySelectScalar = {
    id?: boolean
    id_category?: boolean
    id_bundle?: boolean
  }

  export type bundle_categoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "id_category" | "id_bundle", ExtArgs["result"]["bundle_category"]>
  export type bundle_categoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bundle?: boolean | bundleDefaultArgs<ExtArgs>
    category?: boolean | categoryDefaultArgs<ExtArgs>
  }
  export type bundle_categoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bundle?: boolean | bundleDefaultArgs<ExtArgs>
    category?: boolean | categoryDefaultArgs<ExtArgs>
  }
  export type bundle_categoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bundle?: boolean | bundleDefaultArgs<ExtArgs>
    category?: boolean | categoryDefaultArgs<ExtArgs>
  }

  export type $bundle_categoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "bundle_category"
    objects: {
      bundle: Prisma.$bundlePayload<ExtArgs>
      category: Prisma.$categoryPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      id_category: string
      id_bundle: string
    }, ExtArgs["result"]["bundle_category"]>
    composites: {}
  }

  type bundle_categoryGetPayload<S extends boolean | null | undefined | bundle_categoryDefaultArgs> = $Result.GetResult<Prisma.$bundle_categoryPayload, S>

  type bundle_categoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<bundle_categoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Bundle_categoryCountAggregateInputType | true
    }

  export interface bundle_categoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['bundle_category'], meta: { name: 'bundle_category' } }
    /**
     * Find zero or one Bundle_category that matches the filter.
     * @param {bundle_categoryFindUniqueArgs} args - Arguments to find a Bundle_category
     * @example
     * // Get one Bundle_category
     * const bundle_category = await prisma.bundle_category.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends bundle_categoryFindUniqueArgs>(args: SelectSubset<T, bundle_categoryFindUniqueArgs<ExtArgs>>): Prisma__bundle_categoryClient<$Result.GetResult<Prisma.$bundle_categoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Bundle_category that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {bundle_categoryFindUniqueOrThrowArgs} args - Arguments to find a Bundle_category
     * @example
     * // Get one Bundle_category
     * const bundle_category = await prisma.bundle_category.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends bundle_categoryFindUniqueOrThrowArgs>(args: SelectSubset<T, bundle_categoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__bundle_categoryClient<$Result.GetResult<Prisma.$bundle_categoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Bundle_category that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bundle_categoryFindFirstArgs} args - Arguments to find a Bundle_category
     * @example
     * // Get one Bundle_category
     * const bundle_category = await prisma.bundle_category.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends bundle_categoryFindFirstArgs>(args?: SelectSubset<T, bundle_categoryFindFirstArgs<ExtArgs>>): Prisma__bundle_categoryClient<$Result.GetResult<Prisma.$bundle_categoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Bundle_category that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bundle_categoryFindFirstOrThrowArgs} args - Arguments to find a Bundle_category
     * @example
     * // Get one Bundle_category
     * const bundle_category = await prisma.bundle_category.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends bundle_categoryFindFirstOrThrowArgs>(args?: SelectSubset<T, bundle_categoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__bundle_categoryClient<$Result.GetResult<Prisma.$bundle_categoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Bundle_categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bundle_categoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Bundle_categories
     * const bundle_categories = await prisma.bundle_category.findMany()
     * 
     * // Get first 10 Bundle_categories
     * const bundle_categories = await prisma.bundle_category.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bundle_categoryWithIdOnly = await prisma.bundle_category.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends bundle_categoryFindManyArgs>(args?: SelectSubset<T, bundle_categoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$bundle_categoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Bundle_category.
     * @param {bundle_categoryCreateArgs} args - Arguments to create a Bundle_category.
     * @example
     * // Create one Bundle_category
     * const Bundle_category = await prisma.bundle_category.create({
     *   data: {
     *     // ... data to create a Bundle_category
     *   }
     * })
     * 
     */
    create<T extends bundle_categoryCreateArgs>(args: SelectSubset<T, bundle_categoryCreateArgs<ExtArgs>>): Prisma__bundle_categoryClient<$Result.GetResult<Prisma.$bundle_categoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Bundle_categories.
     * @param {bundle_categoryCreateManyArgs} args - Arguments to create many Bundle_categories.
     * @example
     * // Create many Bundle_categories
     * const bundle_category = await prisma.bundle_category.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends bundle_categoryCreateManyArgs>(args?: SelectSubset<T, bundle_categoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Bundle_categories and returns the data saved in the database.
     * @param {bundle_categoryCreateManyAndReturnArgs} args - Arguments to create many Bundle_categories.
     * @example
     * // Create many Bundle_categories
     * const bundle_category = await prisma.bundle_category.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Bundle_categories and only return the `id`
     * const bundle_categoryWithIdOnly = await prisma.bundle_category.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends bundle_categoryCreateManyAndReturnArgs>(args?: SelectSubset<T, bundle_categoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$bundle_categoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Bundle_category.
     * @param {bundle_categoryDeleteArgs} args - Arguments to delete one Bundle_category.
     * @example
     * // Delete one Bundle_category
     * const Bundle_category = await prisma.bundle_category.delete({
     *   where: {
     *     // ... filter to delete one Bundle_category
     *   }
     * })
     * 
     */
    delete<T extends bundle_categoryDeleteArgs>(args: SelectSubset<T, bundle_categoryDeleteArgs<ExtArgs>>): Prisma__bundle_categoryClient<$Result.GetResult<Prisma.$bundle_categoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Bundle_category.
     * @param {bundle_categoryUpdateArgs} args - Arguments to update one Bundle_category.
     * @example
     * // Update one Bundle_category
     * const bundle_category = await prisma.bundle_category.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends bundle_categoryUpdateArgs>(args: SelectSubset<T, bundle_categoryUpdateArgs<ExtArgs>>): Prisma__bundle_categoryClient<$Result.GetResult<Prisma.$bundle_categoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Bundle_categories.
     * @param {bundle_categoryDeleteManyArgs} args - Arguments to filter Bundle_categories to delete.
     * @example
     * // Delete a few Bundle_categories
     * const { count } = await prisma.bundle_category.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends bundle_categoryDeleteManyArgs>(args?: SelectSubset<T, bundle_categoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bundle_categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bundle_categoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Bundle_categories
     * const bundle_category = await prisma.bundle_category.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends bundle_categoryUpdateManyArgs>(args: SelectSubset<T, bundle_categoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bundle_categories and returns the data updated in the database.
     * @param {bundle_categoryUpdateManyAndReturnArgs} args - Arguments to update many Bundle_categories.
     * @example
     * // Update many Bundle_categories
     * const bundle_category = await prisma.bundle_category.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Bundle_categories and only return the `id`
     * const bundle_categoryWithIdOnly = await prisma.bundle_category.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends bundle_categoryUpdateManyAndReturnArgs>(args: SelectSubset<T, bundle_categoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$bundle_categoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Bundle_category.
     * @param {bundle_categoryUpsertArgs} args - Arguments to update or create a Bundle_category.
     * @example
     * // Update or create a Bundle_category
     * const bundle_category = await prisma.bundle_category.upsert({
     *   create: {
     *     // ... data to create a Bundle_category
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Bundle_category we want to update
     *   }
     * })
     */
    upsert<T extends bundle_categoryUpsertArgs>(args: SelectSubset<T, bundle_categoryUpsertArgs<ExtArgs>>): Prisma__bundle_categoryClient<$Result.GetResult<Prisma.$bundle_categoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Bundle_categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bundle_categoryCountArgs} args - Arguments to filter Bundle_categories to count.
     * @example
     * // Count the number of Bundle_categories
     * const count = await prisma.bundle_category.count({
     *   where: {
     *     // ... the filter for the Bundle_categories we want to count
     *   }
     * })
    **/
    count<T extends bundle_categoryCountArgs>(
      args?: Subset<T, bundle_categoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Bundle_categoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Bundle_category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Bundle_categoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Bundle_categoryAggregateArgs>(args: Subset<T, Bundle_categoryAggregateArgs>): Prisma.PrismaPromise<GetBundle_categoryAggregateType<T>>

    /**
     * Group by Bundle_category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bundle_categoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends bundle_categoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: bundle_categoryGroupByArgs['orderBy'] }
        : { orderBy?: bundle_categoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, bundle_categoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBundle_categoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the bundle_category model
   */
  readonly fields: bundle_categoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for bundle_category.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__bundle_categoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bundle<T extends bundleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, bundleDefaultArgs<ExtArgs>>): Prisma__bundleClient<$Result.GetResult<Prisma.$bundlePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    category<T extends categoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, categoryDefaultArgs<ExtArgs>>): Prisma__categoryClient<$Result.GetResult<Prisma.$categoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the bundle_category model
   */
  interface bundle_categoryFieldRefs {
    readonly id: FieldRef<"bundle_category", 'String'>
    readonly id_category: FieldRef<"bundle_category", 'String'>
    readonly id_bundle: FieldRef<"bundle_category", 'String'>
  }
    

  // Custom InputTypes
  /**
   * bundle_category findUnique
   */
  export type bundle_categoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bundle_category
     */
    select?: bundle_categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the bundle_category
     */
    omit?: bundle_categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bundle_categoryInclude<ExtArgs> | null
    /**
     * Filter, which bundle_category to fetch.
     */
    where: bundle_categoryWhereUniqueInput
  }

  /**
   * bundle_category findUniqueOrThrow
   */
  export type bundle_categoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bundle_category
     */
    select?: bundle_categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the bundle_category
     */
    omit?: bundle_categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bundle_categoryInclude<ExtArgs> | null
    /**
     * Filter, which bundle_category to fetch.
     */
    where: bundle_categoryWhereUniqueInput
  }

  /**
   * bundle_category findFirst
   */
  export type bundle_categoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bundle_category
     */
    select?: bundle_categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the bundle_category
     */
    omit?: bundle_categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bundle_categoryInclude<ExtArgs> | null
    /**
     * Filter, which bundle_category to fetch.
     */
    where?: bundle_categoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bundle_categories to fetch.
     */
    orderBy?: bundle_categoryOrderByWithRelationInput | bundle_categoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for bundle_categories.
     */
    cursor?: bundle_categoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bundle_categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bundle_categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of bundle_categories.
     */
    distinct?: Bundle_categoryScalarFieldEnum | Bundle_categoryScalarFieldEnum[]
  }

  /**
   * bundle_category findFirstOrThrow
   */
  export type bundle_categoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bundle_category
     */
    select?: bundle_categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the bundle_category
     */
    omit?: bundle_categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bundle_categoryInclude<ExtArgs> | null
    /**
     * Filter, which bundle_category to fetch.
     */
    where?: bundle_categoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bundle_categories to fetch.
     */
    orderBy?: bundle_categoryOrderByWithRelationInput | bundle_categoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for bundle_categories.
     */
    cursor?: bundle_categoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bundle_categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bundle_categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of bundle_categories.
     */
    distinct?: Bundle_categoryScalarFieldEnum | Bundle_categoryScalarFieldEnum[]
  }

  /**
   * bundle_category findMany
   */
  export type bundle_categoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bundle_category
     */
    select?: bundle_categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the bundle_category
     */
    omit?: bundle_categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bundle_categoryInclude<ExtArgs> | null
    /**
     * Filter, which bundle_categories to fetch.
     */
    where?: bundle_categoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bundle_categories to fetch.
     */
    orderBy?: bundle_categoryOrderByWithRelationInput | bundle_categoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing bundle_categories.
     */
    cursor?: bundle_categoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bundle_categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bundle_categories.
     */
    skip?: number
    distinct?: Bundle_categoryScalarFieldEnum | Bundle_categoryScalarFieldEnum[]
  }

  /**
   * bundle_category create
   */
  export type bundle_categoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bundle_category
     */
    select?: bundle_categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the bundle_category
     */
    omit?: bundle_categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bundle_categoryInclude<ExtArgs> | null
    /**
     * The data needed to create a bundle_category.
     */
    data: XOR<bundle_categoryCreateInput, bundle_categoryUncheckedCreateInput>
  }

  /**
   * bundle_category createMany
   */
  export type bundle_categoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many bundle_categories.
     */
    data: bundle_categoryCreateManyInput | bundle_categoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * bundle_category createManyAndReturn
   */
  export type bundle_categoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bundle_category
     */
    select?: bundle_categorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the bundle_category
     */
    omit?: bundle_categoryOmit<ExtArgs> | null
    /**
     * The data used to create many bundle_categories.
     */
    data: bundle_categoryCreateManyInput | bundle_categoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bundle_categoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * bundle_category update
   */
  export type bundle_categoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bundle_category
     */
    select?: bundle_categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the bundle_category
     */
    omit?: bundle_categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bundle_categoryInclude<ExtArgs> | null
    /**
     * The data needed to update a bundle_category.
     */
    data: XOR<bundle_categoryUpdateInput, bundle_categoryUncheckedUpdateInput>
    /**
     * Choose, which bundle_category to update.
     */
    where: bundle_categoryWhereUniqueInput
  }

  /**
   * bundle_category updateMany
   */
  export type bundle_categoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update bundle_categories.
     */
    data: XOR<bundle_categoryUpdateManyMutationInput, bundle_categoryUncheckedUpdateManyInput>
    /**
     * Filter which bundle_categories to update
     */
    where?: bundle_categoryWhereInput
    /**
     * Limit how many bundle_categories to update.
     */
    limit?: number
  }

  /**
   * bundle_category updateManyAndReturn
   */
  export type bundle_categoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bundle_category
     */
    select?: bundle_categorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the bundle_category
     */
    omit?: bundle_categoryOmit<ExtArgs> | null
    /**
     * The data used to update bundle_categories.
     */
    data: XOR<bundle_categoryUpdateManyMutationInput, bundle_categoryUncheckedUpdateManyInput>
    /**
     * Filter which bundle_categories to update
     */
    where?: bundle_categoryWhereInput
    /**
     * Limit how many bundle_categories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bundle_categoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * bundle_category upsert
   */
  export type bundle_categoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bundle_category
     */
    select?: bundle_categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the bundle_category
     */
    omit?: bundle_categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bundle_categoryInclude<ExtArgs> | null
    /**
     * The filter to search for the bundle_category to update in case it exists.
     */
    where: bundle_categoryWhereUniqueInput
    /**
     * In case the bundle_category found by the `where` argument doesn't exist, create a new bundle_category with this data.
     */
    create: XOR<bundle_categoryCreateInput, bundle_categoryUncheckedCreateInput>
    /**
     * In case the bundle_category was found with the provided `where` argument, update it with this data.
     */
    update: XOR<bundle_categoryUpdateInput, bundle_categoryUncheckedUpdateInput>
  }

  /**
   * bundle_category delete
   */
  export type bundle_categoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bundle_category
     */
    select?: bundle_categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the bundle_category
     */
    omit?: bundle_categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bundle_categoryInclude<ExtArgs> | null
    /**
     * Filter which bundle_category to delete.
     */
    where: bundle_categoryWhereUniqueInput
  }

  /**
   * bundle_category deleteMany
   */
  export type bundle_categoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which bundle_categories to delete
     */
    where?: bundle_categoryWhereInput
    /**
     * Limit how many bundle_categories to delete.
     */
    limit?: number
  }

  /**
   * bundle_category without action
   */
  export type bundle_categoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bundle_category
     */
    select?: bundle_categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the bundle_category
     */
    omit?: bundle_categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bundle_categoryInclude<ExtArgs> | null
  }


  /**
   * Model bundle_product
   */

  export type AggregateBundle_product = {
    _count: Bundle_productCountAggregateOutputType | null
    _avg: Bundle_productAvgAggregateOutputType | null
    _sum: Bundle_productSumAggregateOutputType | null
    _min: Bundle_productMinAggregateOutputType | null
    _max: Bundle_productMaxAggregateOutputType | null
  }

  export type Bundle_productAvgAggregateOutputType = {
    qty: number | null
  }

  export type Bundle_productSumAggregateOutputType = {
    qty: number | null
  }

  export type Bundle_productMinAggregateOutputType = {
    id_bundle: string | null
    id_product: string | null
    id: string | null
    qty: number | null
  }

  export type Bundle_productMaxAggregateOutputType = {
    id_bundle: string | null
    id_product: string | null
    id: string | null
    qty: number | null
  }

  export type Bundle_productCountAggregateOutputType = {
    id_bundle: number
    id_product: number
    id: number
    qty: number
    _all: number
  }


  export type Bundle_productAvgAggregateInputType = {
    qty?: true
  }

  export type Bundle_productSumAggregateInputType = {
    qty?: true
  }

  export type Bundle_productMinAggregateInputType = {
    id_bundle?: true
    id_product?: true
    id?: true
    qty?: true
  }

  export type Bundle_productMaxAggregateInputType = {
    id_bundle?: true
    id_product?: true
    id?: true
    qty?: true
  }

  export type Bundle_productCountAggregateInputType = {
    id_bundle?: true
    id_product?: true
    id?: true
    qty?: true
    _all?: true
  }

  export type Bundle_productAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which bundle_product to aggregate.
     */
    where?: bundle_productWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bundle_products to fetch.
     */
    orderBy?: bundle_productOrderByWithRelationInput | bundle_productOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: bundle_productWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bundle_products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bundle_products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned bundle_products
    **/
    _count?: true | Bundle_productCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Bundle_productAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Bundle_productSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Bundle_productMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Bundle_productMaxAggregateInputType
  }

  export type GetBundle_productAggregateType<T extends Bundle_productAggregateArgs> = {
        [P in keyof T & keyof AggregateBundle_product]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBundle_product[P]>
      : GetScalarType<T[P], AggregateBundle_product[P]>
  }




  export type bundle_productGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: bundle_productWhereInput
    orderBy?: bundle_productOrderByWithAggregationInput | bundle_productOrderByWithAggregationInput[]
    by: Bundle_productScalarFieldEnum[] | Bundle_productScalarFieldEnum
    having?: bundle_productScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Bundle_productCountAggregateInputType | true
    _avg?: Bundle_productAvgAggregateInputType
    _sum?: Bundle_productSumAggregateInputType
    _min?: Bundle_productMinAggregateInputType
    _max?: Bundle_productMaxAggregateInputType
  }

  export type Bundle_productGroupByOutputType = {
    id_bundle: string
    id_product: string
    id: string
    qty: number | null
    _count: Bundle_productCountAggregateOutputType | null
    _avg: Bundle_productAvgAggregateOutputType | null
    _sum: Bundle_productSumAggregateOutputType | null
    _min: Bundle_productMinAggregateOutputType | null
    _max: Bundle_productMaxAggregateOutputType | null
  }

  type GetBundle_productGroupByPayload<T extends bundle_productGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Bundle_productGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Bundle_productGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Bundle_productGroupByOutputType[P]>
            : GetScalarType<T[P], Bundle_productGroupByOutputType[P]>
        }
      >
    >


  export type bundle_productSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_bundle?: boolean
    id_product?: boolean
    id?: boolean
    qty?: boolean
    bundle?: boolean | bundleDefaultArgs<ExtArgs>
    product?: boolean | productDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bundle_product"]>

  export type bundle_productSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_bundle?: boolean
    id_product?: boolean
    id?: boolean
    qty?: boolean
    bundle?: boolean | bundleDefaultArgs<ExtArgs>
    product?: boolean | productDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bundle_product"]>

  export type bundle_productSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_bundle?: boolean
    id_product?: boolean
    id?: boolean
    qty?: boolean
    bundle?: boolean | bundleDefaultArgs<ExtArgs>
    product?: boolean | productDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bundle_product"]>

  export type bundle_productSelectScalar = {
    id_bundle?: boolean
    id_product?: boolean
    id?: boolean
    qty?: boolean
  }

  export type bundle_productOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id_bundle" | "id_product" | "id" | "qty", ExtArgs["result"]["bundle_product"]>
  export type bundle_productInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bundle?: boolean | bundleDefaultArgs<ExtArgs>
    product?: boolean | productDefaultArgs<ExtArgs>
  }
  export type bundle_productIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bundle?: boolean | bundleDefaultArgs<ExtArgs>
    product?: boolean | productDefaultArgs<ExtArgs>
  }
  export type bundle_productIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bundle?: boolean | bundleDefaultArgs<ExtArgs>
    product?: boolean | productDefaultArgs<ExtArgs>
  }

  export type $bundle_productPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "bundle_product"
    objects: {
      bundle: Prisma.$bundlePayload<ExtArgs>
      product: Prisma.$productPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id_bundle: string
      id_product: string
      id: string
      qty: number | null
    }, ExtArgs["result"]["bundle_product"]>
    composites: {}
  }

  type bundle_productGetPayload<S extends boolean | null | undefined | bundle_productDefaultArgs> = $Result.GetResult<Prisma.$bundle_productPayload, S>

  type bundle_productCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<bundle_productFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Bundle_productCountAggregateInputType | true
    }

  export interface bundle_productDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['bundle_product'], meta: { name: 'bundle_product' } }
    /**
     * Find zero or one Bundle_product that matches the filter.
     * @param {bundle_productFindUniqueArgs} args - Arguments to find a Bundle_product
     * @example
     * // Get one Bundle_product
     * const bundle_product = await prisma.bundle_product.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends bundle_productFindUniqueArgs>(args: SelectSubset<T, bundle_productFindUniqueArgs<ExtArgs>>): Prisma__bundle_productClient<$Result.GetResult<Prisma.$bundle_productPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Bundle_product that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {bundle_productFindUniqueOrThrowArgs} args - Arguments to find a Bundle_product
     * @example
     * // Get one Bundle_product
     * const bundle_product = await prisma.bundle_product.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends bundle_productFindUniqueOrThrowArgs>(args: SelectSubset<T, bundle_productFindUniqueOrThrowArgs<ExtArgs>>): Prisma__bundle_productClient<$Result.GetResult<Prisma.$bundle_productPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Bundle_product that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bundle_productFindFirstArgs} args - Arguments to find a Bundle_product
     * @example
     * // Get one Bundle_product
     * const bundle_product = await prisma.bundle_product.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends bundle_productFindFirstArgs>(args?: SelectSubset<T, bundle_productFindFirstArgs<ExtArgs>>): Prisma__bundle_productClient<$Result.GetResult<Prisma.$bundle_productPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Bundle_product that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bundle_productFindFirstOrThrowArgs} args - Arguments to find a Bundle_product
     * @example
     * // Get one Bundle_product
     * const bundle_product = await prisma.bundle_product.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends bundle_productFindFirstOrThrowArgs>(args?: SelectSubset<T, bundle_productFindFirstOrThrowArgs<ExtArgs>>): Prisma__bundle_productClient<$Result.GetResult<Prisma.$bundle_productPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Bundle_products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bundle_productFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Bundle_products
     * const bundle_products = await prisma.bundle_product.findMany()
     * 
     * // Get first 10 Bundle_products
     * const bundle_products = await prisma.bundle_product.findMany({ take: 10 })
     * 
     * // Only select the `id_bundle`
     * const bundle_productWithId_bundleOnly = await prisma.bundle_product.findMany({ select: { id_bundle: true } })
     * 
     */
    findMany<T extends bundle_productFindManyArgs>(args?: SelectSubset<T, bundle_productFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$bundle_productPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Bundle_product.
     * @param {bundle_productCreateArgs} args - Arguments to create a Bundle_product.
     * @example
     * // Create one Bundle_product
     * const Bundle_product = await prisma.bundle_product.create({
     *   data: {
     *     // ... data to create a Bundle_product
     *   }
     * })
     * 
     */
    create<T extends bundle_productCreateArgs>(args: SelectSubset<T, bundle_productCreateArgs<ExtArgs>>): Prisma__bundle_productClient<$Result.GetResult<Prisma.$bundle_productPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Bundle_products.
     * @param {bundle_productCreateManyArgs} args - Arguments to create many Bundle_products.
     * @example
     * // Create many Bundle_products
     * const bundle_product = await prisma.bundle_product.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends bundle_productCreateManyArgs>(args?: SelectSubset<T, bundle_productCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Bundle_products and returns the data saved in the database.
     * @param {bundle_productCreateManyAndReturnArgs} args - Arguments to create many Bundle_products.
     * @example
     * // Create many Bundle_products
     * const bundle_product = await prisma.bundle_product.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Bundle_products and only return the `id_bundle`
     * const bundle_productWithId_bundleOnly = await prisma.bundle_product.createManyAndReturn({
     *   select: { id_bundle: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends bundle_productCreateManyAndReturnArgs>(args?: SelectSubset<T, bundle_productCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$bundle_productPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Bundle_product.
     * @param {bundle_productDeleteArgs} args - Arguments to delete one Bundle_product.
     * @example
     * // Delete one Bundle_product
     * const Bundle_product = await prisma.bundle_product.delete({
     *   where: {
     *     // ... filter to delete one Bundle_product
     *   }
     * })
     * 
     */
    delete<T extends bundle_productDeleteArgs>(args: SelectSubset<T, bundle_productDeleteArgs<ExtArgs>>): Prisma__bundle_productClient<$Result.GetResult<Prisma.$bundle_productPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Bundle_product.
     * @param {bundle_productUpdateArgs} args - Arguments to update one Bundle_product.
     * @example
     * // Update one Bundle_product
     * const bundle_product = await prisma.bundle_product.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends bundle_productUpdateArgs>(args: SelectSubset<T, bundle_productUpdateArgs<ExtArgs>>): Prisma__bundle_productClient<$Result.GetResult<Prisma.$bundle_productPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Bundle_products.
     * @param {bundle_productDeleteManyArgs} args - Arguments to filter Bundle_products to delete.
     * @example
     * // Delete a few Bundle_products
     * const { count } = await prisma.bundle_product.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends bundle_productDeleteManyArgs>(args?: SelectSubset<T, bundle_productDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bundle_products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bundle_productUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Bundle_products
     * const bundle_product = await prisma.bundle_product.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends bundle_productUpdateManyArgs>(args: SelectSubset<T, bundle_productUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bundle_products and returns the data updated in the database.
     * @param {bundle_productUpdateManyAndReturnArgs} args - Arguments to update many Bundle_products.
     * @example
     * // Update many Bundle_products
     * const bundle_product = await prisma.bundle_product.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Bundle_products and only return the `id_bundle`
     * const bundle_productWithId_bundleOnly = await prisma.bundle_product.updateManyAndReturn({
     *   select: { id_bundle: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends bundle_productUpdateManyAndReturnArgs>(args: SelectSubset<T, bundle_productUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$bundle_productPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Bundle_product.
     * @param {bundle_productUpsertArgs} args - Arguments to update or create a Bundle_product.
     * @example
     * // Update or create a Bundle_product
     * const bundle_product = await prisma.bundle_product.upsert({
     *   create: {
     *     // ... data to create a Bundle_product
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Bundle_product we want to update
     *   }
     * })
     */
    upsert<T extends bundle_productUpsertArgs>(args: SelectSubset<T, bundle_productUpsertArgs<ExtArgs>>): Prisma__bundle_productClient<$Result.GetResult<Prisma.$bundle_productPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Bundle_products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bundle_productCountArgs} args - Arguments to filter Bundle_products to count.
     * @example
     * // Count the number of Bundle_products
     * const count = await prisma.bundle_product.count({
     *   where: {
     *     // ... the filter for the Bundle_products we want to count
     *   }
     * })
    **/
    count<T extends bundle_productCountArgs>(
      args?: Subset<T, bundle_productCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Bundle_productCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Bundle_product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Bundle_productAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Bundle_productAggregateArgs>(args: Subset<T, Bundle_productAggregateArgs>): Prisma.PrismaPromise<GetBundle_productAggregateType<T>>

    /**
     * Group by Bundle_product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bundle_productGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends bundle_productGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: bundle_productGroupByArgs['orderBy'] }
        : { orderBy?: bundle_productGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, bundle_productGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBundle_productGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the bundle_product model
   */
  readonly fields: bundle_productFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for bundle_product.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__bundle_productClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bundle<T extends bundleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, bundleDefaultArgs<ExtArgs>>): Prisma__bundleClient<$Result.GetResult<Prisma.$bundlePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    product<T extends productDefaultArgs<ExtArgs> = {}>(args?: Subset<T, productDefaultArgs<ExtArgs>>): Prisma__productClient<$Result.GetResult<Prisma.$productPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the bundle_product model
   */
  interface bundle_productFieldRefs {
    readonly id_bundle: FieldRef<"bundle_product", 'String'>
    readonly id_product: FieldRef<"bundle_product", 'String'>
    readonly id: FieldRef<"bundle_product", 'String'>
    readonly qty: FieldRef<"bundle_product", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * bundle_product findUnique
   */
  export type bundle_productFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bundle_product
     */
    select?: bundle_productSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bundle_product
     */
    omit?: bundle_productOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bundle_productInclude<ExtArgs> | null
    /**
     * Filter, which bundle_product to fetch.
     */
    where: bundle_productWhereUniqueInput
  }

  /**
   * bundle_product findUniqueOrThrow
   */
  export type bundle_productFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bundle_product
     */
    select?: bundle_productSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bundle_product
     */
    omit?: bundle_productOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bundle_productInclude<ExtArgs> | null
    /**
     * Filter, which bundle_product to fetch.
     */
    where: bundle_productWhereUniqueInput
  }

  /**
   * bundle_product findFirst
   */
  export type bundle_productFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bundle_product
     */
    select?: bundle_productSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bundle_product
     */
    omit?: bundle_productOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bundle_productInclude<ExtArgs> | null
    /**
     * Filter, which bundle_product to fetch.
     */
    where?: bundle_productWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bundle_products to fetch.
     */
    orderBy?: bundle_productOrderByWithRelationInput | bundle_productOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for bundle_products.
     */
    cursor?: bundle_productWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bundle_products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bundle_products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of bundle_products.
     */
    distinct?: Bundle_productScalarFieldEnum | Bundle_productScalarFieldEnum[]
  }

  /**
   * bundle_product findFirstOrThrow
   */
  export type bundle_productFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bundle_product
     */
    select?: bundle_productSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bundle_product
     */
    omit?: bundle_productOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bundle_productInclude<ExtArgs> | null
    /**
     * Filter, which bundle_product to fetch.
     */
    where?: bundle_productWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bundle_products to fetch.
     */
    orderBy?: bundle_productOrderByWithRelationInput | bundle_productOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for bundle_products.
     */
    cursor?: bundle_productWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bundle_products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bundle_products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of bundle_products.
     */
    distinct?: Bundle_productScalarFieldEnum | Bundle_productScalarFieldEnum[]
  }

  /**
   * bundle_product findMany
   */
  export type bundle_productFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bundle_product
     */
    select?: bundle_productSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bundle_product
     */
    omit?: bundle_productOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bundle_productInclude<ExtArgs> | null
    /**
     * Filter, which bundle_products to fetch.
     */
    where?: bundle_productWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bundle_products to fetch.
     */
    orderBy?: bundle_productOrderByWithRelationInput | bundle_productOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing bundle_products.
     */
    cursor?: bundle_productWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bundle_products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bundle_products.
     */
    skip?: number
    distinct?: Bundle_productScalarFieldEnum | Bundle_productScalarFieldEnum[]
  }

  /**
   * bundle_product create
   */
  export type bundle_productCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bundle_product
     */
    select?: bundle_productSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bundle_product
     */
    omit?: bundle_productOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bundle_productInclude<ExtArgs> | null
    /**
     * The data needed to create a bundle_product.
     */
    data: XOR<bundle_productCreateInput, bundle_productUncheckedCreateInput>
  }

  /**
   * bundle_product createMany
   */
  export type bundle_productCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many bundle_products.
     */
    data: bundle_productCreateManyInput | bundle_productCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * bundle_product createManyAndReturn
   */
  export type bundle_productCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bundle_product
     */
    select?: bundle_productSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the bundle_product
     */
    omit?: bundle_productOmit<ExtArgs> | null
    /**
     * The data used to create many bundle_products.
     */
    data: bundle_productCreateManyInput | bundle_productCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bundle_productIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * bundle_product update
   */
  export type bundle_productUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bundle_product
     */
    select?: bundle_productSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bundle_product
     */
    omit?: bundle_productOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bundle_productInclude<ExtArgs> | null
    /**
     * The data needed to update a bundle_product.
     */
    data: XOR<bundle_productUpdateInput, bundle_productUncheckedUpdateInput>
    /**
     * Choose, which bundle_product to update.
     */
    where: bundle_productWhereUniqueInput
  }

  /**
   * bundle_product updateMany
   */
  export type bundle_productUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update bundle_products.
     */
    data: XOR<bundle_productUpdateManyMutationInput, bundle_productUncheckedUpdateManyInput>
    /**
     * Filter which bundle_products to update
     */
    where?: bundle_productWhereInput
    /**
     * Limit how many bundle_products to update.
     */
    limit?: number
  }

  /**
   * bundle_product updateManyAndReturn
   */
  export type bundle_productUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bundle_product
     */
    select?: bundle_productSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the bundle_product
     */
    omit?: bundle_productOmit<ExtArgs> | null
    /**
     * The data used to update bundle_products.
     */
    data: XOR<bundle_productUpdateManyMutationInput, bundle_productUncheckedUpdateManyInput>
    /**
     * Filter which bundle_products to update
     */
    where?: bundle_productWhereInput
    /**
     * Limit how many bundle_products to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bundle_productIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * bundle_product upsert
   */
  export type bundle_productUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bundle_product
     */
    select?: bundle_productSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bundle_product
     */
    omit?: bundle_productOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bundle_productInclude<ExtArgs> | null
    /**
     * The filter to search for the bundle_product to update in case it exists.
     */
    where: bundle_productWhereUniqueInput
    /**
     * In case the bundle_product found by the `where` argument doesn't exist, create a new bundle_product with this data.
     */
    create: XOR<bundle_productCreateInput, bundle_productUncheckedCreateInput>
    /**
     * In case the bundle_product was found with the provided `where` argument, update it with this data.
     */
    update: XOR<bundle_productUpdateInput, bundle_productUncheckedUpdateInput>
  }

  /**
   * bundle_product delete
   */
  export type bundle_productDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bundle_product
     */
    select?: bundle_productSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bundle_product
     */
    omit?: bundle_productOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bundle_productInclude<ExtArgs> | null
    /**
     * Filter which bundle_product to delete.
     */
    where: bundle_productWhereUniqueInput
  }

  /**
   * bundle_product deleteMany
   */
  export type bundle_productDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which bundle_products to delete
     */
    where?: bundle_productWhereInput
    /**
     * Limit how many bundle_products to delete.
     */
    limit?: number
  }

  /**
   * bundle_product without action
   */
  export type bundle_productDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bundle_product
     */
    select?: bundle_productSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bundle_product
     */
    omit?: bundle_productOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bundle_productInclude<ExtArgs> | null
  }


  /**
   * Model category
   */

  export type AggregateCategory = {
    _count: CategoryCountAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  export type CategoryMinAggregateOutputType = {
    id: string | null
    name: string | null
    id_parent: string | null
    deleted_at: Date | null
    slug: string | null
    img: string | null
  }

  export type CategoryMaxAggregateOutputType = {
    id: string | null
    name: string | null
    id_parent: string | null
    deleted_at: Date | null
    slug: string | null
    img: string | null
  }

  export type CategoryCountAggregateOutputType = {
    id: number
    name: number
    id_parent: number
    deleted_at: number
    slug: number
    img: number
    _all: number
  }


  export type CategoryMinAggregateInputType = {
    id?: true
    name?: true
    id_parent?: true
    deleted_at?: true
    slug?: true
    img?: true
  }

  export type CategoryMaxAggregateInputType = {
    id?: true
    name?: true
    id_parent?: true
    deleted_at?: true
    slug?: true
    img?: true
  }

  export type CategoryCountAggregateInputType = {
    id?: true
    name?: true
    id_parent?: true
    deleted_at?: true
    slug?: true
    img?: true
    _all?: true
  }

  export type CategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which category to aggregate.
     */
    where?: categoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of categories to fetch.
     */
    orderBy?: categoryOrderByWithRelationInput | categoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: categoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned categories
    **/
    _count?: true | CategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CategoryMaxAggregateInputType
  }

  export type GetCategoryAggregateType<T extends CategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategory[P]>
      : GetScalarType<T[P], AggregateCategory[P]>
  }




  export type categoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: categoryWhereInput
    orderBy?: categoryOrderByWithAggregationInput | categoryOrderByWithAggregationInput[]
    by: CategoryScalarFieldEnum[] | CategoryScalarFieldEnum
    having?: categoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CategoryCountAggregateInputType | true
    _min?: CategoryMinAggregateInputType
    _max?: CategoryMaxAggregateInputType
  }

  export type CategoryGroupByOutputType = {
    id: string
    name: string
    id_parent: string | null
    deleted_at: Date | null
    slug: string | null
    img: string | null
    _count: CategoryCountAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  type GetCategoryGroupByPayload<T extends categoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CategoryGroupByOutputType[P]>
            : GetScalarType<T[P], CategoryGroupByOutputType[P]>
        }
      >
    >


  export type categorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    id_parent?: boolean
    deleted_at?: boolean
    slug?: boolean
    img?: boolean
    bundle_category?: boolean | category$bundle_categoryArgs<ExtArgs>
    category?: boolean | category$categoryArgs<ExtArgs>
    other_category?: boolean | category$other_categoryArgs<ExtArgs>
    product_category?: boolean | category$product_categoryArgs<ExtArgs>
    _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["category"]>

  export type categorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    id_parent?: boolean
    deleted_at?: boolean
    slug?: boolean
    img?: boolean
    category?: boolean | category$categoryArgs<ExtArgs>
  }, ExtArgs["result"]["category"]>

  export type categorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    id_parent?: boolean
    deleted_at?: boolean
    slug?: boolean
    img?: boolean
    category?: boolean | category$categoryArgs<ExtArgs>
  }, ExtArgs["result"]["category"]>

  export type categorySelectScalar = {
    id?: boolean
    name?: boolean
    id_parent?: boolean
    deleted_at?: boolean
    slug?: boolean
    img?: boolean
  }

  export type categoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "id_parent" | "deleted_at" | "slug" | "img", ExtArgs["result"]["category"]>
  export type categoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bundle_category?: boolean | category$bundle_categoryArgs<ExtArgs>
    category?: boolean | category$categoryArgs<ExtArgs>
    other_category?: boolean | category$other_categoryArgs<ExtArgs>
    product_category?: boolean | category$product_categoryArgs<ExtArgs>
    _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type categoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | category$categoryArgs<ExtArgs>
  }
  export type categoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | category$categoryArgs<ExtArgs>
  }

  export type $categoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "category"
    objects: {
      bundle_category: Prisma.$bundle_categoryPayload<ExtArgs>[]
      category: Prisma.$categoryPayload<ExtArgs> | null
      other_category: Prisma.$categoryPayload<ExtArgs>[]
      product_category: Prisma.$product_categoryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      id_parent: string | null
      deleted_at: Date | null
      slug: string | null
      img: string | null
    }, ExtArgs["result"]["category"]>
    composites: {}
  }

  type categoryGetPayload<S extends boolean | null | undefined | categoryDefaultArgs> = $Result.GetResult<Prisma.$categoryPayload, S>

  type categoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<categoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CategoryCountAggregateInputType | true
    }

  export interface categoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['category'], meta: { name: 'category' } }
    /**
     * Find zero or one Category that matches the filter.
     * @param {categoryFindUniqueArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends categoryFindUniqueArgs>(args: SelectSubset<T, categoryFindUniqueArgs<ExtArgs>>): Prisma__categoryClient<$Result.GetResult<Prisma.$categoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Category that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {categoryFindUniqueOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends categoryFindUniqueOrThrowArgs>(args: SelectSubset<T, categoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__categoryClient<$Result.GetResult<Prisma.$categoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Category that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoryFindFirstArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends categoryFindFirstArgs>(args?: SelectSubset<T, categoryFindFirstArgs<ExtArgs>>): Prisma__categoryClient<$Result.GetResult<Prisma.$categoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Category that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoryFindFirstOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends categoryFindFirstOrThrowArgs>(args?: SelectSubset<T, categoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__categoryClient<$Result.GetResult<Prisma.$categoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Categories
     * const categories = await prisma.category.findMany()
     * 
     * // Get first 10 Categories
     * const categories = await prisma.category.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const categoryWithIdOnly = await prisma.category.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends categoryFindManyArgs>(args?: SelectSubset<T, categoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$categoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Category.
     * @param {categoryCreateArgs} args - Arguments to create a Category.
     * @example
     * // Create one Category
     * const Category = await prisma.category.create({
     *   data: {
     *     // ... data to create a Category
     *   }
     * })
     * 
     */
    create<T extends categoryCreateArgs>(args: SelectSubset<T, categoryCreateArgs<ExtArgs>>): Prisma__categoryClient<$Result.GetResult<Prisma.$categoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Categories.
     * @param {categoryCreateManyArgs} args - Arguments to create many Categories.
     * @example
     * // Create many Categories
     * const category = await prisma.category.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends categoryCreateManyArgs>(args?: SelectSubset<T, categoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Categories and returns the data saved in the database.
     * @param {categoryCreateManyAndReturnArgs} args - Arguments to create many Categories.
     * @example
     * // Create many Categories
     * const category = await prisma.category.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Categories and only return the `id`
     * const categoryWithIdOnly = await prisma.category.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends categoryCreateManyAndReturnArgs>(args?: SelectSubset<T, categoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$categoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Category.
     * @param {categoryDeleteArgs} args - Arguments to delete one Category.
     * @example
     * // Delete one Category
     * const Category = await prisma.category.delete({
     *   where: {
     *     // ... filter to delete one Category
     *   }
     * })
     * 
     */
    delete<T extends categoryDeleteArgs>(args: SelectSubset<T, categoryDeleteArgs<ExtArgs>>): Prisma__categoryClient<$Result.GetResult<Prisma.$categoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Category.
     * @param {categoryUpdateArgs} args - Arguments to update one Category.
     * @example
     * // Update one Category
     * const category = await prisma.category.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends categoryUpdateArgs>(args: SelectSubset<T, categoryUpdateArgs<ExtArgs>>): Prisma__categoryClient<$Result.GetResult<Prisma.$categoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Categories.
     * @param {categoryDeleteManyArgs} args - Arguments to filter Categories to delete.
     * @example
     * // Delete a few Categories
     * const { count } = await prisma.category.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends categoryDeleteManyArgs>(args?: SelectSubset<T, categoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Categories
     * const category = await prisma.category.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends categoryUpdateManyArgs>(args: SelectSubset<T, categoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories and returns the data updated in the database.
     * @param {categoryUpdateManyAndReturnArgs} args - Arguments to update many Categories.
     * @example
     * // Update many Categories
     * const category = await prisma.category.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Categories and only return the `id`
     * const categoryWithIdOnly = await prisma.category.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends categoryUpdateManyAndReturnArgs>(args: SelectSubset<T, categoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$categoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Category.
     * @param {categoryUpsertArgs} args - Arguments to update or create a Category.
     * @example
     * // Update or create a Category
     * const category = await prisma.category.upsert({
     *   create: {
     *     // ... data to create a Category
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Category we want to update
     *   }
     * })
     */
    upsert<T extends categoryUpsertArgs>(args: SelectSubset<T, categoryUpsertArgs<ExtArgs>>): Prisma__categoryClient<$Result.GetResult<Prisma.$categoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoryCountArgs} args - Arguments to filter Categories to count.
     * @example
     * // Count the number of Categories
     * const count = await prisma.category.count({
     *   where: {
     *     // ... the filter for the Categories we want to count
     *   }
     * })
    **/
    count<T extends categoryCountArgs>(
      args?: Subset<T, categoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CategoryAggregateArgs>(args: Subset<T, CategoryAggregateArgs>): Prisma.PrismaPromise<GetCategoryAggregateType<T>>

    /**
     * Group by Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends categoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: categoryGroupByArgs['orderBy'] }
        : { orderBy?: categoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, categoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the category model
   */
  readonly fields: categoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for category.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__categoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bundle_category<T extends category$bundle_categoryArgs<ExtArgs> = {}>(args?: Subset<T, category$bundle_categoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$bundle_categoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    category<T extends category$categoryArgs<ExtArgs> = {}>(args?: Subset<T, category$categoryArgs<ExtArgs>>): Prisma__categoryClient<$Result.GetResult<Prisma.$categoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    other_category<T extends category$other_categoryArgs<ExtArgs> = {}>(args?: Subset<T, category$other_categoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$categoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    product_category<T extends category$product_categoryArgs<ExtArgs> = {}>(args?: Subset<T, category$product_categoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$product_categoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the category model
   */
  interface categoryFieldRefs {
    readonly id: FieldRef<"category", 'String'>
    readonly name: FieldRef<"category", 'String'>
    readonly id_parent: FieldRef<"category", 'String'>
    readonly deleted_at: FieldRef<"category", 'DateTime'>
    readonly slug: FieldRef<"category", 'String'>
    readonly img: FieldRef<"category", 'String'>
  }
    

  // Custom InputTypes
  /**
   * category findUnique
   */
  export type categoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the category
     */
    select?: categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the category
     */
    omit?: categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoryInclude<ExtArgs> | null
    /**
     * Filter, which category to fetch.
     */
    where: categoryWhereUniqueInput
  }

  /**
   * category findUniqueOrThrow
   */
  export type categoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the category
     */
    select?: categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the category
     */
    omit?: categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoryInclude<ExtArgs> | null
    /**
     * Filter, which category to fetch.
     */
    where: categoryWhereUniqueInput
  }

  /**
   * category findFirst
   */
  export type categoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the category
     */
    select?: categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the category
     */
    omit?: categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoryInclude<ExtArgs> | null
    /**
     * Filter, which category to fetch.
     */
    where?: categoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of categories to fetch.
     */
    orderBy?: categoryOrderByWithRelationInput | categoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for categories.
     */
    cursor?: categoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * category findFirstOrThrow
   */
  export type categoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the category
     */
    select?: categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the category
     */
    omit?: categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoryInclude<ExtArgs> | null
    /**
     * Filter, which category to fetch.
     */
    where?: categoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of categories to fetch.
     */
    orderBy?: categoryOrderByWithRelationInput | categoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for categories.
     */
    cursor?: categoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * category findMany
   */
  export type categoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the category
     */
    select?: categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the category
     */
    omit?: categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoryInclude<ExtArgs> | null
    /**
     * Filter, which categories to fetch.
     */
    where?: categoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of categories to fetch.
     */
    orderBy?: categoryOrderByWithRelationInput | categoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing categories.
     */
    cursor?: categoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` categories.
     */
    skip?: number
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * category create
   */
  export type categoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the category
     */
    select?: categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the category
     */
    omit?: categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoryInclude<ExtArgs> | null
    /**
     * The data needed to create a category.
     */
    data: XOR<categoryCreateInput, categoryUncheckedCreateInput>
  }

  /**
   * category createMany
   */
  export type categoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many categories.
     */
    data: categoryCreateManyInput | categoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * category createManyAndReturn
   */
  export type categoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the category
     */
    select?: categorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the category
     */
    omit?: categoryOmit<ExtArgs> | null
    /**
     * The data used to create many categories.
     */
    data: categoryCreateManyInput | categoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * category update
   */
  export type categoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the category
     */
    select?: categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the category
     */
    omit?: categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoryInclude<ExtArgs> | null
    /**
     * The data needed to update a category.
     */
    data: XOR<categoryUpdateInput, categoryUncheckedUpdateInput>
    /**
     * Choose, which category to update.
     */
    where: categoryWhereUniqueInput
  }

  /**
   * category updateMany
   */
  export type categoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update categories.
     */
    data: XOR<categoryUpdateManyMutationInput, categoryUncheckedUpdateManyInput>
    /**
     * Filter which categories to update
     */
    where?: categoryWhereInput
    /**
     * Limit how many categories to update.
     */
    limit?: number
  }

  /**
   * category updateManyAndReturn
   */
  export type categoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the category
     */
    select?: categorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the category
     */
    omit?: categoryOmit<ExtArgs> | null
    /**
     * The data used to update categories.
     */
    data: XOR<categoryUpdateManyMutationInput, categoryUncheckedUpdateManyInput>
    /**
     * Filter which categories to update
     */
    where?: categoryWhereInput
    /**
     * Limit how many categories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * category upsert
   */
  export type categoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the category
     */
    select?: categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the category
     */
    omit?: categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoryInclude<ExtArgs> | null
    /**
     * The filter to search for the category to update in case it exists.
     */
    where: categoryWhereUniqueInput
    /**
     * In case the category found by the `where` argument doesn't exist, create a new category with this data.
     */
    create: XOR<categoryCreateInput, categoryUncheckedCreateInput>
    /**
     * In case the category was found with the provided `where` argument, update it with this data.
     */
    update: XOR<categoryUpdateInput, categoryUncheckedUpdateInput>
  }

  /**
   * category delete
   */
  export type categoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the category
     */
    select?: categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the category
     */
    omit?: categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoryInclude<ExtArgs> | null
    /**
     * Filter which category to delete.
     */
    where: categoryWhereUniqueInput
  }

  /**
   * category deleteMany
   */
  export type categoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which categories to delete
     */
    where?: categoryWhereInput
    /**
     * Limit how many categories to delete.
     */
    limit?: number
  }

  /**
   * category.bundle_category
   */
  export type category$bundle_categoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bundle_category
     */
    select?: bundle_categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the bundle_category
     */
    omit?: bundle_categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bundle_categoryInclude<ExtArgs> | null
    where?: bundle_categoryWhereInput
    orderBy?: bundle_categoryOrderByWithRelationInput | bundle_categoryOrderByWithRelationInput[]
    cursor?: bundle_categoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Bundle_categoryScalarFieldEnum | Bundle_categoryScalarFieldEnum[]
  }

  /**
   * category.category
   */
  export type category$categoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the category
     */
    select?: categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the category
     */
    omit?: categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoryInclude<ExtArgs> | null
    where?: categoryWhereInput
  }

  /**
   * category.other_category
   */
  export type category$other_categoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the category
     */
    select?: categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the category
     */
    omit?: categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoryInclude<ExtArgs> | null
    where?: categoryWhereInput
    orderBy?: categoryOrderByWithRelationInput | categoryOrderByWithRelationInput[]
    cursor?: categoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * category.product_category
   */
  export type category$product_categoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product_category
     */
    select?: product_categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the product_category
     */
    omit?: product_categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: product_categoryInclude<ExtArgs> | null
    where?: product_categoryWhereInput
    orderBy?: product_categoryOrderByWithRelationInput | product_categoryOrderByWithRelationInput[]
    cursor?: product_categoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Product_categoryScalarFieldEnum | Product_categoryScalarFieldEnum[]
  }

  /**
   * category without action
   */
  export type categoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the category
     */
    select?: categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the category
     */
    omit?: categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoryInclude<ExtArgs> | null
  }


  /**
   * Model chapter
   */

  export type AggregateChapter = {
    _count: ChapterCountAggregateOutputType | null
    _avg: ChapterAvgAggregateOutputType | null
    _sum: ChapterSumAggregateOutputType | null
    _min: ChapterMinAggregateOutputType | null
    _max: ChapterMaxAggregateOutputType | null
  }

  export type ChapterAvgAggregateOutputType = {
    number: number | null
  }

  export type ChapterSumAggregateOutputType = {
    number: number | null
  }

  export type ChapterMinAggregateOutputType = {
    id: string | null
    id_product: string | null
    id_book: string | null
    number: number | null
    name: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ChapterMaxAggregateOutputType = {
    id: string | null
    id_product: string | null
    id_book: string | null
    number: number | null
    name: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ChapterCountAggregateOutputType = {
    id: number
    id_product: number
    id_book: number
    number: number
    name: number
    content: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type ChapterAvgAggregateInputType = {
    number?: true
  }

  export type ChapterSumAggregateInputType = {
    number?: true
  }

  export type ChapterMinAggregateInputType = {
    id?: true
    id_product?: true
    id_book?: true
    number?: true
    name?: true
    created_at?: true
    updated_at?: true
  }

  export type ChapterMaxAggregateInputType = {
    id?: true
    id_product?: true
    id_book?: true
    number?: true
    name?: true
    created_at?: true
    updated_at?: true
  }

  export type ChapterCountAggregateInputType = {
    id?: true
    id_product?: true
    id_book?: true
    number?: true
    name?: true
    content?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type ChapterAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which chapter to aggregate.
     */
    where?: chapterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chapters to fetch.
     */
    orderBy?: chapterOrderByWithRelationInput | chapterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: chapterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chapters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chapters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned chapters
    **/
    _count?: true | ChapterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ChapterAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ChapterSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChapterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChapterMaxAggregateInputType
  }

  export type GetChapterAggregateType<T extends ChapterAggregateArgs> = {
        [P in keyof T & keyof AggregateChapter]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChapter[P]>
      : GetScalarType<T[P], AggregateChapter[P]>
  }




  export type chapterGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: chapterWhereInput
    orderBy?: chapterOrderByWithAggregationInput | chapterOrderByWithAggregationInput[]
    by: ChapterScalarFieldEnum[] | ChapterScalarFieldEnum
    having?: chapterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChapterCountAggregateInputType | true
    _avg?: ChapterAvgAggregateInputType
    _sum?: ChapterSumAggregateInputType
    _min?: ChapterMinAggregateInputType
    _max?: ChapterMaxAggregateInputType
  }

  export type ChapterGroupByOutputType = {
    id: string
    id_product: string | null
    id_book: string | null
    number: number
    name: string
    content: JsonValue
    created_at: Date
    updated_at: Date | null
    _count: ChapterCountAggregateOutputType | null
    _avg: ChapterAvgAggregateOutputType | null
    _sum: ChapterSumAggregateOutputType | null
    _min: ChapterMinAggregateOutputType | null
    _max: ChapterMaxAggregateOutputType | null
  }

  type GetChapterGroupByPayload<T extends chapterGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChapterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChapterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChapterGroupByOutputType[P]>
            : GetScalarType<T[P], ChapterGroupByOutputType[P]>
        }
      >
    >


  export type chapterSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    id_product?: boolean
    id_book?: boolean
    number?: boolean
    name?: boolean
    content?: boolean
    created_at?: boolean
    updated_at?: boolean
    book?: boolean | chapter$bookArgs<ExtArgs>
    product?: boolean | chapter$productArgs<ExtArgs>
  }, ExtArgs["result"]["chapter"]>

  export type chapterSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    id_product?: boolean
    id_book?: boolean
    number?: boolean
    name?: boolean
    content?: boolean
    created_at?: boolean
    updated_at?: boolean
    book?: boolean | chapter$bookArgs<ExtArgs>
    product?: boolean | chapter$productArgs<ExtArgs>
  }, ExtArgs["result"]["chapter"]>

  export type chapterSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    id_product?: boolean
    id_book?: boolean
    number?: boolean
    name?: boolean
    content?: boolean
    created_at?: boolean
    updated_at?: boolean
    book?: boolean | chapter$bookArgs<ExtArgs>
    product?: boolean | chapter$productArgs<ExtArgs>
  }, ExtArgs["result"]["chapter"]>

  export type chapterSelectScalar = {
    id?: boolean
    id_product?: boolean
    id_book?: boolean
    number?: boolean
    name?: boolean
    content?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type chapterOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "id_product" | "id_book" | "number" | "name" | "content" | "created_at" | "updated_at", ExtArgs["result"]["chapter"]>
  export type chapterInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    book?: boolean | chapter$bookArgs<ExtArgs>
    product?: boolean | chapter$productArgs<ExtArgs>
  }
  export type chapterIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    book?: boolean | chapter$bookArgs<ExtArgs>
    product?: boolean | chapter$productArgs<ExtArgs>
  }
  export type chapterIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    book?: boolean | chapter$bookArgs<ExtArgs>
    product?: boolean | chapter$productArgs<ExtArgs>
  }

  export type $chapterPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "chapter"
    objects: {
      book: Prisma.$bookPayload<ExtArgs> | null
      product: Prisma.$productPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      id_product: string | null
      id_book: string | null
      number: number
      name: string
      content: Prisma.JsonValue
      created_at: Date
      updated_at: Date | null
    }, ExtArgs["result"]["chapter"]>
    composites: {}
  }

  type chapterGetPayload<S extends boolean | null | undefined | chapterDefaultArgs> = $Result.GetResult<Prisma.$chapterPayload, S>

  type chapterCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<chapterFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ChapterCountAggregateInputType | true
    }

  export interface chapterDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['chapter'], meta: { name: 'chapter' } }
    /**
     * Find zero or one Chapter that matches the filter.
     * @param {chapterFindUniqueArgs} args - Arguments to find a Chapter
     * @example
     * // Get one Chapter
     * const chapter = await prisma.chapter.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends chapterFindUniqueArgs>(args: SelectSubset<T, chapterFindUniqueArgs<ExtArgs>>): Prisma__chapterClient<$Result.GetResult<Prisma.$chapterPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Chapter that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {chapterFindUniqueOrThrowArgs} args - Arguments to find a Chapter
     * @example
     * // Get one Chapter
     * const chapter = await prisma.chapter.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends chapterFindUniqueOrThrowArgs>(args: SelectSubset<T, chapterFindUniqueOrThrowArgs<ExtArgs>>): Prisma__chapterClient<$Result.GetResult<Prisma.$chapterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Chapter that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chapterFindFirstArgs} args - Arguments to find a Chapter
     * @example
     * // Get one Chapter
     * const chapter = await prisma.chapter.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends chapterFindFirstArgs>(args?: SelectSubset<T, chapterFindFirstArgs<ExtArgs>>): Prisma__chapterClient<$Result.GetResult<Prisma.$chapterPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Chapter that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chapterFindFirstOrThrowArgs} args - Arguments to find a Chapter
     * @example
     * // Get one Chapter
     * const chapter = await prisma.chapter.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends chapterFindFirstOrThrowArgs>(args?: SelectSubset<T, chapterFindFirstOrThrowArgs<ExtArgs>>): Prisma__chapterClient<$Result.GetResult<Prisma.$chapterPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Chapters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chapterFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Chapters
     * const chapters = await prisma.chapter.findMany()
     * 
     * // Get first 10 Chapters
     * const chapters = await prisma.chapter.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const chapterWithIdOnly = await prisma.chapter.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends chapterFindManyArgs>(args?: SelectSubset<T, chapterFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$chapterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Chapter.
     * @param {chapterCreateArgs} args - Arguments to create a Chapter.
     * @example
     * // Create one Chapter
     * const Chapter = await prisma.chapter.create({
     *   data: {
     *     // ... data to create a Chapter
     *   }
     * })
     * 
     */
    create<T extends chapterCreateArgs>(args: SelectSubset<T, chapterCreateArgs<ExtArgs>>): Prisma__chapterClient<$Result.GetResult<Prisma.$chapterPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Chapters.
     * @param {chapterCreateManyArgs} args - Arguments to create many Chapters.
     * @example
     * // Create many Chapters
     * const chapter = await prisma.chapter.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends chapterCreateManyArgs>(args?: SelectSubset<T, chapterCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Chapters and returns the data saved in the database.
     * @param {chapterCreateManyAndReturnArgs} args - Arguments to create many Chapters.
     * @example
     * // Create many Chapters
     * const chapter = await prisma.chapter.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Chapters and only return the `id`
     * const chapterWithIdOnly = await prisma.chapter.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends chapterCreateManyAndReturnArgs>(args?: SelectSubset<T, chapterCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$chapterPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Chapter.
     * @param {chapterDeleteArgs} args - Arguments to delete one Chapter.
     * @example
     * // Delete one Chapter
     * const Chapter = await prisma.chapter.delete({
     *   where: {
     *     // ... filter to delete one Chapter
     *   }
     * })
     * 
     */
    delete<T extends chapterDeleteArgs>(args: SelectSubset<T, chapterDeleteArgs<ExtArgs>>): Prisma__chapterClient<$Result.GetResult<Prisma.$chapterPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Chapter.
     * @param {chapterUpdateArgs} args - Arguments to update one Chapter.
     * @example
     * // Update one Chapter
     * const chapter = await prisma.chapter.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends chapterUpdateArgs>(args: SelectSubset<T, chapterUpdateArgs<ExtArgs>>): Prisma__chapterClient<$Result.GetResult<Prisma.$chapterPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Chapters.
     * @param {chapterDeleteManyArgs} args - Arguments to filter Chapters to delete.
     * @example
     * // Delete a few Chapters
     * const { count } = await prisma.chapter.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends chapterDeleteManyArgs>(args?: SelectSubset<T, chapterDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Chapters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chapterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Chapters
     * const chapter = await prisma.chapter.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends chapterUpdateManyArgs>(args: SelectSubset<T, chapterUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Chapters and returns the data updated in the database.
     * @param {chapterUpdateManyAndReturnArgs} args - Arguments to update many Chapters.
     * @example
     * // Update many Chapters
     * const chapter = await prisma.chapter.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Chapters and only return the `id`
     * const chapterWithIdOnly = await prisma.chapter.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends chapterUpdateManyAndReturnArgs>(args: SelectSubset<T, chapterUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$chapterPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Chapter.
     * @param {chapterUpsertArgs} args - Arguments to update or create a Chapter.
     * @example
     * // Update or create a Chapter
     * const chapter = await prisma.chapter.upsert({
     *   create: {
     *     // ... data to create a Chapter
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Chapter we want to update
     *   }
     * })
     */
    upsert<T extends chapterUpsertArgs>(args: SelectSubset<T, chapterUpsertArgs<ExtArgs>>): Prisma__chapterClient<$Result.GetResult<Prisma.$chapterPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Chapters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chapterCountArgs} args - Arguments to filter Chapters to count.
     * @example
     * // Count the number of Chapters
     * const count = await prisma.chapter.count({
     *   where: {
     *     // ... the filter for the Chapters we want to count
     *   }
     * })
    **/
    count<T extends chapterCountArgs>(
      args?: Subset<T, chapterCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChapterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Chapter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChapterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChapterAggregateArgs>(args: Subset<T, ChapterAggregateArgs>): Prisma.PrismaPromise<GetChapterAggregateType<T>>

    /**
     * Group by Chapter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chapterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends chapterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: chapterGroupByArgs['orderBy'] }
        : { orderBy?: chapterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, chapterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChapterGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the chapter model
   */
  readonly fields: chapterFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for chapter.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__chapterClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    book<T extends chapter$bookArgs<ExtArgs> = {}>(args?: Subset<T, chapter$bookArgs<ExtArgs>>): Prisma__bookClient<$Result.GetResult<Prisma.$bookPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    product<T extends chapter$productArgs<ExtArgs> = {}>(args?: Subset<T, chapter$productArgs<ExtArgs>>): Prisma__productClient<$Result.GetResult<Prisma.$productPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the chapter model
   */
  interface chapterFieldRefs {
    readonly id: FieldRef<"chapter", 'String'>
    readonly id_product: FieldRef<"chapter", 'String'>
    readonly id_book: FieldRef<"chapter", 'String'>
    readonly number: FieldRef<"chapter", 'Int'>
    readonly name: FieldRef<"chapter", 'String'>
    readonly content: FieldRef<"chapter", 'Json'>
    readonly created_at: FieldRef<"chapter", 'DateTime'>
    readonly updated_at: FieldRef<"chapter", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * chapter findUnique
   */
  export type chapterFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chapter
     */
    select?: chapterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chapter
     */
    omit?: chapterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chapterInclude<ExtArgs> | null
    /**
     * Filter, which chapter to fetch.
     */
    where: chapterWhereUniqueInput
  }

  /**
   * chapter findUniqueOrThrow
   */
  export type chapterFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chapter
     */
    select?: chapterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chapter
     */
    omit?: chapterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chapterInclude<ExtArgs> | null
    /**
     * Filter, which chapter to fetch.
     */
    where: chapterWhereUniqueInput
  }

  /**
   * chapter findFirst
   */
  export type chapterFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chapter
     */
    select?: chapterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chapter
     */
    omit?: chapterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chapterInclude<ExtArgs> | null
    /**
     * Filter, which chapter to fetch.
     */
    where?: chapterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chapters to fetch.
     */
    orderBy?: chapterOrderByWithRelationInput | chapterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for chapters.
     */
    cursor?: chapterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chapters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chapters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of chapters.
     */
    distinct?: ChapterScalarFieldEnum | ChapterScalarFieldEnum[]
  }

  /**
   * chapter findFirstOrThrow
   */
  export type chapterFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chapter
     */
    select?: chapterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chapter
     */
    omit?: chapterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chapterInclude<ExtArgs> | null
    /**
     * Filter, which chapter to fetch.
     */
    where?: chapterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chapters to fetch.
     */
    orderBy?: chapterOrderByWithRelationInput | chapterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for chapters.
     */
    cursor?: chapterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chapters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chapters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of chapters.
     */
    distinct?: ChapterScalarFieldEnum | ChapterScalarFieldEnum[]
  }

  /**
   * chapter findMany
   */
  export type chapterFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chapter
     */
    select?: chapterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chapter
     */
    omit?: chapterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chapterInclude<ExtArgs> | null
    /**
     * Filter, which chapters to fetch.
     */
    where?: chapterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chapters to fetch.
     */
    orderBy?: chapterOrderByWithRelationInput | chapterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing chapters.
     */
    cursor?: chapterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chapters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chapters.
     */
    skip?: number
    distinct?: ChapterScalarFieldEnum | ChapterScalarFieldEnum[]
  }

  /**
   * chapter create
   */
  export type chapterCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chapter
     */
    select?: chapterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chapter
     */
    omit?: chapterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chapterInclude<ExtArgs> | null
    /**
     * The data needed to create a chapter.
     */
    data: XOR<chapterCreateInput, chapterUncheckedCreateInput>
  }

  /**
   * chapter createMany
   */
  export type chapterCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many chapters.
     */
    data: chapterCreateManyInput | chapterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * chapter createManyAndReturn
   */
  export type chapterCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chapter
     */
    select?: chapterSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the chapter
     */
    omit?: chapterOmit<ExtArgs> | null
    /**
     * The data used to create many chapters.
     */
    data: chapterCreateManyInput | chapterCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chapterIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * chapter update
   */
  export type chapterUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chapter
     */
    select?: chapterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chapter
     */
    omit?: chapterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chapterInclude<ExtArgs> | null
    /**
     * The data needed to update a chapter.
     */
    data: XOR<chapterUpdateInput, chapterUncheckedUpdateInput>
    /**
     * Choose, which chapter to update.
     */
    where: chapterWhereUniqueInput
  }

  /**
   * chapter updateMany
   */
  export type chapterUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update chapters.
     */
    data: XOR<chapterUpdateManyMutationInput, chapterUncheckedUpdateManyInput>
    /**
     * Filter which chapters to update
     */
    where?: chapterWhereInput
    /**
     * Limit how many chapters to update.
     */
    limit?: number
  }

  /**
   * chapter updateManyAndReturn
   */
  export type chapterUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chapter
     */
    select?: chapterSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the chapter
     */
    omit?: chapterOmit<ExtArgs> | null
    /**
     * The data used to update chapters.
     */
    data: XOR<chapterUpdateManyMutationInput, chapterUncheckedUpdateManyInput>
    /**
     * Filter which chapters to update
     */
    where?: chapterWhereInput
    /**
     * Limit how many chapters to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chapterIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * chapter upsert
   */
  export type chapterUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chapter
     */
    select?: chapterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chapter
     */
    omit?: chapterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chapterInclude<ExtArgs> | null
    /**
     * The filter to search for the chapter to update in case it exists.
     */
    where: chapterWhereUniqueInput
    /**
     * In case the chapter found by the `where` argument doesn't exist, create a new chapter with this data.
     */
    create: XOR<chapterCreateInput, chapterUncheckedCreateInput>
    /**
     * In case the chapter was found with the provided `where` argument, update it with this data.
     */
    update: XOR<chapterUpdateInput, chapterUncheckedUpdateInput>
  }

  /**
   * chapter delete
   */
  export type chapterDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chapter
     */
    select?: chapterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chapter
     */
    omit?: chapterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chapterInclude<ExtArgs> | null
    /**
     * Filter which chapter to delete.
     */
    where: chapterWhereUniqueInput
  }

  /**
   * chapter deleteMany
   */
  export type chapterDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which chapters to delete
     */
    where?: chapterWhereInput
    /**
     * Limit how many chapters to delete.
     */
    limit?: number
  }

  /**
   * chapter.book
   */
  export type chapter$bookArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the book
     */
    select?: bookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the book
     */
    omit?: bookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bookInclude<ExtArgs> | null
    where?: bookWhereInput
  }

  /**
   * chapter.product
   */
  export type chapter$productArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product
     */
    select?: productSelect<ExtArgs> | null
    /**
     * Omit specific fields from the product
     */
    omit?: productOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productInclude<ExtArgs> | null
    where?: productWhereInput
  }

  /**
   * chapter without action
   */
  export type chapterDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chapter
     */
    select?: chapterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chapter
     */
    omit?: chapterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chapterInclude<ExtArgs> | null
  }


  /**
   * Model customer
   */

  export type AggregateCustomer = {
    _count: CustomerCountAggregateOutputType | null
    _avg: CustomerAvgAggregateOutputType | null
    _sum: CustomerSumAggregateOutputType | null
    _min: CustomerMinAggregateOutputType | null
    _max: CustomerMaxAggregateOutputType | null
  }

  export type CustomerAvgAggregateOutputType = {
    otp: number | null
  }

  export type CustomerSumAggregateOutputType = {
    otp: number | null
  }

  export type CustomerMinAggregateOutputType = {
    id: string | null
    whatsapp: string | null
    deleted_at: Date | null
    otp: number | null
    id_account: string | null
    name: string | null
    email: string | null
  }

  export type CustomerMaxAggregateOutputType = {
    id: string | null
    whatsapp: string | null
    deleted_at: Date | null
    otp: number | null
    id_account: string | null
    name: string | null
    email: string | null
  }

  export type CustomerCountAggregateOutputType = {
    id: number
    whatsapp: number
    deleted_at: number
    otp: number
    id_account: number
    name: number
    email: number
    _all: number
  }


  export type CustomerAvgAggregateInputType = {
    otp?: true
  }

  export type CustomerSumAggregateInputType = {
    otp?: true
  }

  export type CustomerMinAggregateInputType = {
    id?: true
    whatsapp?: true
    deleted_at?: true
    otp?: true
    id_account?: true
    name?: true
    email?: true
  }

  export type CustomerMaxAggregateInputType = {
    id?: true
    whatsapp?: true
    deleted_at?: true
    otp?: true
    id_account?: true
    name?: true
    email?: true
  }

  export type CustomerCountAggregateInputType = {
    id?: true
    whatsapp?: true
    deleted_at?: true
    otp?: true
    id_account?: true
    name?: true
    email?: true
    _all?: true
  }

  export type CustomerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which customer to aggregate.
     */
    where?: customerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of customers to fetch.
     */
    orderBy?: customerOrderByWithRelationInput | customerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: customerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned customers
    **/
    _count?: true | CustomerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CustomerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CustomerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomerMaxAggregateInputType
  }

  export type GetCustomerAggregateType<T extends CustomerAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomer[P]>
      : GetScalarType<T[P], AggregateCustomer[P]>
  }




  export type customerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: customerWhereInput
    orderBy?: customerOrderByWithAggregationInput | customerOrderByWithAggregationInput[]
    by: CustomerScalarFieldEnum[] | CustomerScalarFieldEnum
    having?: customerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomerCountAggregateInputType | true
    _avg?: CustomerAvgAggregateInputType
    _sum?: CustomerSumAggregateInputType
    _min?: CustomerMinAggregateInputType
    _max?: CustomerMaxAggregateInputType
  }

  export type CustomerGroupByOutputType = {
    id: string
    whatsapp: string
    deleted_at: Date | null
    otp: number | null
    id_account: string | null
    name: string
    email: string
    _count: CustomerCountAggregateOutputType | null
    _avg: CustomerAvgAggregateOutputType | null
    _sum: CustomerSumAggregateOutputType | null
    _min: CustomerMinAggregateOutputType | null
    _max: CustomerMaxAggregateOutputType | null
  }

  type GetCustomerGroupByPayload<T extends customerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomerGroupByOutputType[P]>
            : GetScalarType<T[P], CustomerGroupByOutputType[P]>
        }
      >
    >


  export type customerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    whatsapp?: boolean
    deleted_at?: boolean
    otp?: boolean
    id_account?: boolean
    name?: boolean
    email?: boolean
    auth_user?: boolean | customer$auth_userArgs<ExtArgs>
    auth_account?: boolean | customer$auth_accountArgs<ExtArgs>
    customer_reader?: boolean | customer$customer_readerArgs<ExtArgs>
    customer_track?: boolean | customer$customer_trackArgs<ExtArgs>
    t_sales?: boolean | customer$t_salesArgs<ExtArgs>
    t_sales_download?: boolean | customer$t_sales_downloadArgs<ExtArgs>
    _count?: boolean | CustomerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customer"]>

  export type customerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    whatsapp?: boolean
    deleted_at?: boolean
    otp?: boolean
    id_account?: boolean
    name?: boolean
    email?: boolean
    auth_account?: boolean | customer$auth_accountArgs<ExtArgs>
  }, ExtArgs["result"]["customer"]>

  export type customerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    whatsapp?: boolean
    deleted_at?: boolean
    otp?: boolean
    id_account?: boolean
    name?: boolean
    email?: boolean
    auth_account?: boolean | customer$auth_accountArgs<ExtArgs>
  }, ExtArgs["result"]["customer"]>

  export type customerSelectScalar = {
    id?: boolean
    whatsapp?: boolean
    deleted_at?: boolean
    otp?: boolean
    id_account?: boolean
    name?: boolean
    email?: boolean
  }

  export type customerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "whatsapp" | "deleted_at" | "otp" | "id_account" | "name" | "email", ExtArgs["result"]["customer"]>
  export type customerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    auth_user?: boolean | customer$auth_userArgs<ExtArgs>
    auth_account?: boolean | customer$auth_accountArgs<ExtArgs>
    customer_reader?: boolean | customer$customer_readerArgs<ExtArgs>
    customer_track?: boolean | customer$customer_trackArgs<ExtArgs>
    t_sales?: boolean | customer$t_salesArgs<ExtArgs>
    t_sales_download?: boolean | customer$t_sales_downloadArgs<ExtArgs>
    _count?: boolean | CustomerCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type customerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    auth_account?: boolean | customer$auth_accountArgs<ExtArgs>
  }
  export type customerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    auth_account?: boolean | customer$auth_accountArgs<ExtArgs>
  }

  export type $customerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "customer"
    objects: {
      auth_user: Prisma.$auth_userPayload<ExtArgs>[]
      auth_account: Prisma.$auth_accountPayload<ExtArgs> | null
      customer_reader: Prisma.$customer_readerPayload<ExtArgs>[]
      customer_track: Prisma.$customer_trackPayload<ExtArgs>[]
      t_sales: Prisma.$t_salesPayload<ExtArgs>[]
      t_sales_download: Prisma.$t_sales_downloadPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      whatsapp: string
      deleted_at: Date | null
      otp: number | null
      id_account: string | null
      name: string
      email: string
    }, ExtArgs["result"]["customer"]>
    composites: {}
  }

  type customerGetPayload<S extends boolean | null | undefined | customerDefaultArgs> = $Result.GetResult<Prisma.$customerPayload, S>

  type customerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<customerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CustomerCountAggregateInputType | true
    }

  export interface customerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['customer'], meta: { name: 'customer' } }
    /**
     * Find zero or one Customer that matches the filter.
     * @param {customerFindUniqueArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends customerFindUniqueArgs>(args: SelectSubset<T, customerFindUniqueArgs<ExtArgs>>): Prisma__customerClient<$Result.GetResult<Prisma.$customerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Customer that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {customerFindUniqueOrThrowArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends customerFindUniqueOrThrowArgs>(args: SelectSubset<T, customerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__customerClient<$Result.GetResult<Prisma.$customerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Customer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {customerFindFirstArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends customerFindFirstArgs>(args?: SelectSubset<T, customerFindFirstArgs<ExtArgs>>): Prisma__customerClient<$Result.GetResult<Prisma.$customerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Customer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {customerFindFirstOrThrowArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends customerFindFirstOrThrowArgs>(args?: SelectSubset<T, customerFindFirstOrThrowArgs<ExtArgs>>): Prisma__customerClient<$Result.GetResult<Prisma.$customerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Customers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {customerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Customers
     * const customers = await prisma.customer.findMany()
     * 
     * // Get first 10 Customers
     * const customers = await prisma.customer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customerWithIdOnly = await prisma.customer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends customerFindManyArgs>(args?: SelectSubset<T, customerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$customerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Customer.
     * @param {customerCreateArgs} args - Arguments to create a Customer.
     * @example
     * // Create one Customer
     * const Customer = await prisma.customer.create({
     *   data: {
     *     // ... data to create a Customer
     *   }
     * })
     * 
     */
    create<T extends customerCreateArgs>(args: SelectSubset<T, customerCreateArgs<ExtArgs>>): Prisma__customerClient<$Result.GetResult<Prisma.$customerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Customers.
     * @param {customerCreateManyArgs} args - Arguments to create many Customers.
     * @example
     * // Create many Customers
     * const customer = await prisma.customer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends customerCreateManyArgs>(args?: SelectSubset<T, customerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Customers and returns the data saved in the database.
     * @param {customerCreateManyAndReturnArgs} args - Arguments to create many Customers.
     * @example
     * // Create many Customers
     * const customer = await prisma.customer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Customers and only return the `id`
     * const customerWithIdOnly = await prisma.customer.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends customerCreateManyAndReturnArgs>(args?: SelectSubset<T, customerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$customerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Customer.
     * @param {customerDeleteArgs} args - Arguments to delete one Customer.
     * @example
     * // Delete one Customer
     * const Customer = await prisma.customer.delete({
     *   where: {
     *     // ... filter to delete one Customer
     *   }
     * })
     * 
     */
    delete<T extends customerDeleteArgs>(args: SelectSubset<T, customerDeleteArgs<ExtArgs>>): Prisma__customerClient<$Result.GetResult<Prisma.$customerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Customer.
     * @param {customerUpdateArgs} args - Arguments to update one Customer.
     * @example
     * // Update one Customer
     * const customer = await prisma.customer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends customerUpdateArgs>(args: SelectSubset<T, customerUpdateArgs<ExtArgs>>): Prisma__customerClient<$Result.GetResult<Prisma.$customerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Customers.
     * @param {customerDeleteManyArgs} args - Arguments to filter Customers to delete.
     * @example
     * // Delete a few Customers
     * const { count } = await prisma.customer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends customerDeleteManyArgs>(args?: SelectSubset<T, customerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {customerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Customers
     * const customer = await prisma.customer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends customerUpdateManyArgs>(args: SelectSubset<T, customerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Customers and returns the data updated in the database.
     * @param {customerUpdateManyAndReturnArgs} args - Arguments to update many Customers.
     * @example
     * // Update many Customers
     * const customer = await prisma.customer.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Customers and only return the `id`
     * const customerWithIdOnly = await prisma.customer.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends customerUpdateManyAndReturnArgs>(args: SelectSubset<T, customerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$customerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Customer.
     * @param {customerUpsertArgs} args - Arguments to update or create a Customer.
     * @example
     * // Update or create a Customer
     * const customer = await prisma.customer.upsert({
     *   create: {
     *     // ... data to create a Customer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Customer we want to update
     *   }
     * })
     */
    upsert<T extends customerUpsertArgs>(args: SelectSubset<T, customerUpsertArgs<ExtArgs>>): Prisma__customerClient<$Result.GetResult<Prisma.$customerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {customerCountArgs} args - Arguments to filter Customers to count.
     * @example
     * // Count the number of Customers
     * const count = await prisma.customer.count({
     *   where: {
     *     // ... the filter for the Customers we want to count
     *   }
     * })
    **/
    count<T extends customerCountArgs>(
      args?: Subset<T, customerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Customer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomerAggregateArgs>(args: Subset<T, CustomerAggregateArgs>): Prisma.PrismaPromise<GetCustomerAggregateType<T>>

    /**
     * Group by Customer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {customerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends customerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: customerGroupByArgs['orderBy'] }
        : { orderBy?: customerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, customerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the customer model
   */
  readonly fields: customerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for customer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__customerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    auth_user<T extends customer$auth_userArgs<ExtArgs> = {}>(args?: Subset<T, customer$auth_userArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$auth_userPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    auth_account<T extends customer$auth_accountArgs<ExtArgs> = {}>(args?: Subset<T, customer$auth_accountArgs<ExtArgs>>): Prisma__auth_accountClient<$Result.GetResult<Prisma.$auth_accountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    customer_reader<T extends customer$customer_readerArgs<ExtArgs> = {}>(args?: Subset<T, customer$customer_readerArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$customer_readerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    customer_track<T extends customer$customer_trackArgs<ExtArgs> = {}>(args?: Subset<T, customer$customer_trackArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$customer_trackPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    t_sales<T extends customer$t_salesArgs<ExtArgs> = {}>(args?: Subset<T, customer$t_salesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$t_salesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    t_sales_download<T extends customer$t_sales_downloadArgs<ExtArgs> = {}>(args?: Subset<T, customer$t_sales_downloadArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$t_sales_downloadPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the customer model
   */
  interface customerFieldRefs {
    readonly id: FieldRef<"customer", 'String'>
    readonly whatsapp: FieldRef<"customer", 'String'>
    readonly deleted_at: FieldRef<"customer", 'DateTime'>
    readonly otp: FieldRef<"customer", 'Int'>
    readonly id_account: FieldRef<"customer", 'String'>
    readonly name: FieldRef<"customer", 'String'>
    readonly email: FieldRef<"customer", 'String'>
  }
    

  // Custom InputTypes
  /**
   * customer findUnique
   */
  export type customerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer
     */
    select?: customerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customer
     */
    omit?: customerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customerInclude<ExtArgs> | null
    /**
     * Filter, which customer to fetch.
     */
    where: customerWhereUniqueInput
  }

  /**
   * customer findUniqueOrThrow
   */
  export type customerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer
     */
    select?: customerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customer
     */
    omit?: customerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customerInclude<ExtArgs> | null
    /**
     * Filter, which customer to fetch.
     */
    where: customerWhereUniqueInput
  }

  /**
   * customer findFirst
   */
  export type customerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer
     */
    select?: customerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customer
     */
    omit?: customerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customerInclude<ExtArgs> | null
    /**
     * Filter, which customer to fetch.
     */
    where?: customerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of customers to fetch.
     */
    orderBy?: customerOrderByWithRelationInput | customerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for customers.
     */
    cursor?: customerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of customers.
     */
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * customer findFirstOrThrow
   */
  export type customerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer
     */
    select?: customerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customer
     */
    omit?: customerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customerInclude<ExtArgs> | null
    /**
     * Filter, which customer to fetch.
     */
    where?: customerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of customers to fetch.
     */
    orderBy?: customerOrderByWithRelationInput | customerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for customers.
     */
    cursor?: customerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of customers.
     */
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * customer findMany
   */
  export type customerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer
     */
    select?: customerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customer
     */
    omit?: customerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customerInclude<ExtArgs> | null
    /**
     * Filter, which customers to fetch.
     */
    where?: customerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of customers to fetch.
     */
    orderBy?: customerOrderByWithRelationInput | customerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing customers.
     */
    cursor?: customerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` customers.
     */
    skip?: number
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * customer create
   */
  export type customerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer
     */
    select?: customerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customer
     */
    omit?: customerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customerInclude<ExtArgs> | null
    /**
     * The data needed to create a customer.
     */
    data: XOR<customerCreateInput, customerUncheckedCreateInput>
  }

  /**
   * customer createMany
   */
  export type customerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many customers.
     */
    data: customerCreateManyInput | customerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * customer createManyAndReturn
   */
  export type customerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer
     */
    select?: customerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the customer
     */
    omit?: customerOmit<ExtArgs> | null
    /**
     * The data used to create many customers.
     */
    data: customerCreateManyInput | customerCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * customer update
   */
  export type customerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer
     */
    select?: customerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customer
     */
    omit?: customerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customerInclude<ExtArgs> | null
    /**
     * The data needed to update a customer.
     */
    data: XOR<customerUpdateInput, customerUncheckedUpdateInput>
    /**
     * Choose, which customer to update.
     */
    where: customerWhereUniqueInput
  }

  /**
   * customer updateMany
   */
  export type customerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update customers.
     */
    data: XOR<customerUpdateManyMutationInput, customerUncheckedUpdateManyInput>
    /**
     * Filter which customers to update
     */
    where?: customerWhereInput
    /**
     * Limit how many customers to update.
     */
    limit?: number
  }

  /**
   * customer updateManyAndReturn
   */
  export type customerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer
     */
    select?: customerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the customer
     */
    omit?: customerOmit<ExtArgs> | null
    /**
     * The data used to update customers.
     */
    data: XOR<customerUpdateManyMutationInput, customerUncheckedUpdateManyInput>
    /**
     * Filter which customers to update
     */
    where?: customerWhereInput
    /**
     * Limit how many customers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customerIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * customer upsert
   */
  export type customerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer
     */
    select?: customerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customer
     */
    omit?: customerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customerInclude<ExtArgs> | null
    /**
     * The filter to search for the customer to update in case it exists.
     */
    where: customerWhereUniqueInput
    /**
     * In case the customer found by the `where` argument doesn't exist, create a new customer with this data.
     */
    create: XOR<customerCreateInput, customerUncheckedCreateInput>
    /**
     * In case the customer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<customerUpdateInput, customerUncheckedUpdateInput>
  }

  /**
   * customer delete
   */
  export type customerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer
     */
    select?: customerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customer
     */
    omit?: customerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customerInclude<ExtArgs> | null
    /**
     * Filter which customer to delete.
     */
    where: customerWhereUniqueInput
  }

  /**
   * customer deleteMany
   */
  export type customerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which customers to delete
     */
    where?: customerWhereInput
    /**
     * Limit how many customers to delete.
     */
    limit?: number
  }

  /**
   * customer.auth_user
   */
  export type customer$auth_userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auth_user
     */
    select?: auth_userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the auth_user
     */
    omit?: auth_userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auth_userInclude<ExtArgs> | null
    where?: auth_userWhereInput
    orderBy?: auth_userOrderByWithRelationInput | auth_userOrderByWithRelationInput[]
    cursor?: auth_userWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Auth_userScalarFieldEnum | Auth_userScalarFieldEnum[]
  }

  /**
   * customer.auth_account
   */
  export type customer$auth_accountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auth_account
     */
    select?: auth_accountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the auth_account
     */
    omit?: auth_accountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auth_accountInclude<ExtArgs> | null
    where?: auth_accountWhereInput
  }

  /**
   * customer.customer_reader
   */
  export type customer$customer_readerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer_reader
     */
    select?: customer_readerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customer_reader
     */
    omit?: customer_readerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customer_readerInclude<ExtArgs> | null
    where?: customer_readerWhereInput
    orderBy?: customer_readerOrderByWithRelationInput | customer_readerOrderByWithRelationInput[]
    cursor?: customer_readerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Customer_readerScalarFieldEnum | Customer_readerScalarFieldEnum[]
  }

  /**
   * customer.customer_track
   */
  export type customer$customer_trackArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer_track
     */
    select?: customer_trackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customer_track
     */
    omit?: customer_trackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customer_trackInclude<ExtArgs> | null
    where?: customer_trackWhereInput
    orderBy?: customer_trackOrderByWithRelationInput | customer_trackOrderByWithRelationInput[]
    cursor?: customer_trackWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Customer_trackScalarFieldEnum | Customer_trackScalarFieldEnum[]
  }

  /**
   * customer.t_sales
   */
  export type customer$t_salesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the t_sales
     */
    select?: t_salesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the t_sales
     */
    omit?: t_salesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: t_salesInclude<ExtArgs> | null
    where?: t_salesWhereInput
    orderBy?: t_salesOrderByWithRelationInput | t_salesOrderByWithRelationInput[]
    cursor?: t_salesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: T_salesScalarFieldEnum | T_salesScalarFieldEnum[]
  }

  /**
   * customer.t_sales_download
   */
  export type customer$t_sales_downloadArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the t_sales_download
     */
    select?: t_sales_downloadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the t_sales_download
     */
    omit?: t_sales_downloadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: t_sales_downloadInclude<ExtArgs> | null
    where?: t_sales_downloadWhereInput
    orderBy?: t_sales_downloadOrderByWithRelationInput | t_sales_downloadOrderByWithRelationInput[]
    cursor?: t_sales_downloadWhereUniqueInput
    take?: number
    skip?: number
    distinct?: T_sales_downloadScalarFieldEnum | T_sales_downloadScalarFieldEnum[]
  }

  /**
   * customer without action
   */
  export type customerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer
     */
    select?: customerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customer
     */
    omit?: customerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customerInclude<ExtArgs> | null
  }


  /**
   * Model customer_reader
   */

  export type AggregateCustomer_reader = {
    _count: Customer_readerCountAggregateOutputType | null
    _avg: Customer_readerAvgAggregateOutputType | null
    _sum: Customer_readerSumAggregateOutputType | null
    _min: Customer_readerMinAggregateOutputType | null
    _max: Customer_readerMaxAggregateOutputType | null
  }

  export type Customer_readerAvgAggregateOutputType = {
    last_page: number | null
    percent: number | null
  }

  export type Customer_readerSumAggregateOutputType = {
    last_page: number | null
    percent: number | null
  }

  export type Customer_readerMinAggregateOutputType = {
    id: string | null
    id_customer: string | null
    id_product: string | null
    last_page: number | null
    percent: number | null
  }

  export type Customer_readerMaxAggregateOutputType = {
    id: string | null
    id_customer: string | null
    id_product: string | null
    last_page: number | null
    percent: number | null
  }

  export type Customer_readerCountAggregateOutputType = {
    id: number
    id_customer: number
    id_product: number
    last_page: number
    percent: number
    _all: number
  }


  export type Customer_readerAvgAggregateInputType = {
    last_page?: true
    percent?: true
  }

  export type Customer_readerSumAggregateInputType = {
    last_page?: true
    percent?: true
  }

  export type Customer_readerMinAggregateInputType = {
    id?: true
    id_customer?: true
    id_product?: true
    last_page?: true
    percent?: true
  }

  export type Customer_readerMaxAggregateInputType = {
    id?: true
    id_customer?: true
    id_product?: true
    last_page?: true
    percent?: true
  }

  export type Customer_readerCountAggregateInputType = {
    id?: true
    id_customer?: true
    id_product?: true
    last_page?: true
    percent?: true
    _all?: true
  }

  export type Customer_readerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which customer_reader to aggregate.
     */
    where?: customer_readerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of customer_readers to fetch.
     */
    orderBy?: customer_readerOrderByWithRelationInput | customer_readerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: customer_readerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` customer_readers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` customer_readers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned customer_readers
    **/
    _count?: true | Customer_readerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Customer_readerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Customer_readerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Customer_readerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Customer_readerMaxAggregateInputType
  }

  export type GetCustomer_readerAggregateType<T extends Customer_readerAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomer_reader]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomer_reader[P]>
      : GetScalarType<T[P], AggregateCustomer_reader[P]>
  }




  export type customer_readerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: customer_readerWhereInput
    orderBy?: customer_readerOrderByWithAggregationInput | customer_readerOrderByWithAggregationInput[]
    by: Customer_readerScalarFieldEnum[] | Customer_readerScalarFieldEnum
    having?: customer_readerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Customer_readerCountAggregateInputType | true
    _avg?: Customer_readerAvgAggregateInputType
    _sum?: Customer_readerSumAggregateInputType
    _min?: Customer_readerMinAggregateInputType
    _max?: Customer_readerMaxAggregateInputType
  }

  export type Customer_readerGroupByOutputType = {
    id: string
    id_customer: string
    id_product: string
    last_page: number
    percent: number
    _count: Customer_readerCountAggregateOutputType | null
    _avg: Customer_readerAvgAggregateOutputType | null
    _sum: Customer_readerSumAggregateOutputType | null
    _min: Customer_readerMinAggregateOutputType | null
    _max: Customer_readerMaxAggregateOutputType | null
  }

  type GetCustomer_readerGroupByPayload<T extends customer_readerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Customer_readerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Customer_readerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Customer_readerGroupByOutputType[P]>
            : GetScalarType<T[P], Customer_readerGroupByOutputType[P]>
        }
      >
    >


  export type customer_readerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    id_customer?: boolean
    id_product?: boolean
    last_page?: boolean
    percent?: boolean
    customer?: boolean | customerDefaultArgs<ExtArgs>
    product?: boolean | productDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customer_reader"]>

  export type customer_readerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    id_customer?: boolean
    id_product?: boolean
    last_page?: boolean
    percent?: boolean
    customer?: boolean | customerDefaultArgs<ExtArgs>
    product?: boolean | productDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customer_reader"]>

  export type customer_readerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    id_customer?: boolean
    id_product?: boolean
    last_page?: boolean
    percent?: boolean
    customer?: boolean | customerDefaultArgs<ExtArgs>
    product?: boolean | productDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customer_reader"]>

  export type customer_readerSelectScalar = {
    id?: boolean
    id_customer?: boolean
    id_product?: boolean
    last_page?: boolean
    percent?: boolean
  }

  export type customer_readerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "id_customer" | "id_product" | "last_page" | "percent", ExtArgs["result"]["customer_reader"]>
  export type customer_readerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | customerDefaultArgs<ExtArgs>
    product?: boolean | productDefaultArgs<ExtArgs>
  }
  export type customer_readerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | customerDefaultArgs<ExtArgs>
    product?: boolean | productDefaultArgs<ExtArgs>
  }
  export type customer_readerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | customerDefaultArgs<ExtArgs>
    product?: boolean | productDefaultArgs<ExtArgs>
  }

  export type $customer_readerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "customer_reader"
    objects: {
      customer: Prisma.$customerPayload<ExtArgs>
      product: Prisma.$productPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      id_customer: string
      id_product: string
      last_page: number
      percent: number
    }, ExtArgs["result"]["customer_reader"]>
    composites: {}
  }

  type customer_readerGetPayload<S extends boolean | null | undefined | customer_readerDefaultArgs> = $Result.GetResult<Prisma.$customer_readerPayload, S>

  type customer_readerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<customer_readerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Customer_readerCountAggregateInputType | true
    }

  export interface customer_readerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['customer_reader'], meta: { name: 'customer_reader' } }
    /**
     * Find zero or one Customer_reader that matches the filter.
     * @param {customer_readerFindUniqueArgs} args - Arguments to find a Customer_reader
     * @example
     * // Get one Customer_reader
     * const customer_reader = await prisma.customer_reader.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends customer_readerFindUniqueArgs>(args: SelectSubset<T, customer_readerFindUniqueArgs<ExtArgs>>): Prisma__customer_readerClient<$Result.GetResult<Prisma.$customer_readerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Customer_reader that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {customer_readerFindUniqueOrThrowArgs} args - Arguments to find a Customer_reader
     * @example
     * // Get one Customer_reader
     * const customer_reader = await prisma.customer_reader.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends customer_readerFindUniqueOrThrowArgs>(args: SelectSubset<T, customer_readerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__customer_readerClient<$Result.GetResult<Prisma.$customer_readerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Customer_reader that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {customer_readerFindFirstArgs} args - Arguments to find a Customer_reader
     * @example
     * // Get one Customer_reader
     * const customer_reader = await prisma.customer_reader.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends customer_readerFindFirstArgs>(args?: SelectSubset<T, customer_readerFindFirstArgs<ExtArgs>>): Prisma__customer_readerClient<$Result.GetResult<Prisma.$customer_readerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Customer_reader that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {customer_readerFindFirstOrThrowArgs} args - Arguments to find a Customer_reader
     * @example
     * // Get one Customer_reader
     * const customer_reader = await prisma.customer_reader.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends customer_readerFindFirstOrThrowArgs>(args?: SelectSubset<T, customer_readerFindFirstOrThrowArgs<ExtArgs>>): Prisma__customer_readerClient<$Result.GetResult<Prisma.$customer_readerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Customer_readers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {customer_readerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Customer_readers
     * const customer_readers = await prisma.customer_reader.findMany()
     * 
     * // Get first 10 Customer_readers
     * const customer_readers = await prisma.customer_reader.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customer_readerWithIdOnly = await prisma.customer_reader.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends customer_readerFindManyArgs>(args?: SelectSubset<T, customer_readerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$customer_readerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Customer_reader.
     * @param {customer_readerCreateArgs} args - Arguments to create a Customer_reader.
     * @example
     * // Create one Customer_reader
     * const Customer_reader = await prisma.customer_reader.create({
     *   data: {
     *     // ... data to create a Customer_reader
     *   }
     * })
     * 
     */
    create<T extends customer_readerCreateArgs>(args: SelectSubset<T, customer_readerCreateArgs<ExtArgs>>): Prisma__customer_readerClient<$Result.GetResult<Prisma.$customer_readerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Customer_readers.
     * @param {customer_readerCreateManyArgs} args - Arguments to create many Customer_readers.
     * @example
     * // Create many Customer_readers
     * const customer_reader = await prisma.customer_reader.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends customer_readerCreateManyArgs>(args?: SelectSubset<T, customer_readerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Customer_readers and returns the data saved in the database.
     * @param {customer_readerCreateManyAndReturnArgs} args - Arguments to create many Customer_readers.
     * @example
     * // Create many Customer_readers
     * const customer_reader = await prisma.customer_reader.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Customer_readers and only return the `id`
     * const customer_readerWithIdOnly = await prisma.customer_reader.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends customer_readerCreateManyAndReturnArgs>(args?: SelectSubset<T, customer_readerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$customer_readerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Customer_reader.
     * @param {customer_readerDeleteArgs} args - Arguments to delete one Customer_reader.
     * @example
     * // Delete one Customer_reader
     * const Customer_reader = await prisma.customer_reader.delete({
     *   where: {
     *     // ... filter to delete one Customer_reader
     *   }
     * })
     * 
     */
    delete<T extends customer_readerDeleteArgs>(args: SelectSubset<T, customer_readerDeleteArgs<ExtArgs>>): Prisma__customer_readerClient<$Result.GetResult<Prisma.$customer_readerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Customer_reader.
     * @param {customer_readerUpdateArgs} args - Arguments to update one Customer_reader.
     * @example
     * // Update one Customer_reader
     * const customer_reader = await prisma.customer_reader.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends customer_readerUpdateArgs>(args: SelectSubset<T, customer_readerUpdateArgs<ExtArgs>>): Prisma__customer_readerClient<$Result.GetResult<Prisma.$customer_readerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Customer_readers.
     * @param {customer_readerDeleteManyArgs} args - Arguments to filter Customer_readers to delete.
     * @example
     * // Delete a few Customer_readers
     * const { count } = await prisma.customer_reader.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends customer_readerDeleteManyArgs>(args?: SelectSubset<T, customer_readerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Customer_readers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {customer_readerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Customer_readers
     * const customer_reader = await prisma.customer_reader.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends customer_readerUpdateManyArgs>(args: SelectSubset<T, customer_readerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Customer_readers and returns the data updated in the database.
     * @param {customer_readerUpdateManyAndReturnArgs} args - Arguments to update many Customer_readers.
     * @example
     * // Update many Customer_readers
     * const customer_reader = await prisma.customer_reader.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Customer_readers and only return the `id`
     * const customer_readerWithIdOnly = await prisma.customer_reader.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends customer_readerUpdateManyAndReturnArgs>(args: SelectSubset<T, customer_readerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$customer_readerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Customer_reader.
     * @param {customer_readerUpsertArgs} args - Arguments to update or create a Customer_reader.
     * @example
     * // Update or create a Customer_reader
     * const customer_reader = await prisma.customer_reader.upsert({
     *   create: {
     *     // ... data to create a Customer_reader
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Customer_reader we want to update
     *   }
     * })
     */
    upsert<T extends customer_readerUpsertArgs>(args: SelectSubset<T, customer_readerUpsertArgs<ExtArgs>>): Prisma__customer_readerClient<$Result.GetResult<Prisma.$customer_readerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Customer_readers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {customer_readerCountArgs} args - Arguments to filter Customer_readers to count.
     * @example
     * // Count the number of Customer_readers
     * const count = await prisma.customer_reader.count({
     *   where: {
     *     // ... the filter for the Customer_readers we want to count
     *   }
     * })
    **/
    count<T extends customer_readerCountArgs>(
      args?: Subset<T, customer_readerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Customer_readerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Customer_reader.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Customer_readerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Customer_readerAggregateArgs>(args: Subset<T, Customer_readerAggregateArgs>): Prisma.PrismaPromise<GetCustomer_readerAggregateType<T>>

    /**
     * Group by Customer_reader.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {customer_readerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends customer_readerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: customer_readerGroupByArgs['orderBy'] }
        : { orderBy?: customer_readerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, customer_readerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomer_readerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the customer_reader model
   */
  readonly fields: customer_readerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for customer_reader.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__customer_readerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    customer<T extends customerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, customerDefaultArgs<ExtArgs>>): Prisma__customerClient<$Result.GetResult<Prisma.$customerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    product<T extends productDefaultArgs<ExtArgs> = {}>(args?: Subset<T, productDefaultArgs<ExtArgs>>): Prisma__productClient<$Result.GetResult<Prisma.$productPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the customer_reader model
   */
  interface customer_readerFieldRefs {
    readonly id: FieldRef<"customer_reader", 'String'>
    readonly id_customer: FieldRef<"customer_reader", 'String'>
    readonly id_product: FieldRef<"customer_reader", 'String'>
    readonly last_page: FieldRef<"customer_reader", 'Int'>
    readonly percent: FieldRef<"customer_reader", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * customer_reader findUnique
   */
  export type customer_readerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer_reader
     */
    select?: customer_readerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customer_reader
     */
    omit?: customer_readerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customer_readerInclude<ExtArgs> | null
    /**
     * Filter, which customer_reader to fetch.
     */
    where: customer_readerWhereUniqueInput
  }

  /**
   * customer_reader findUniqueOrThrow
   */
  export type customer_readerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer_reader
     */
    select?: customer_readerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customer_reader
     */
    omit?: customer_readerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customer_readerInclude<ExtArgs> | null
    /**
     * Filter, which customer_reader to fetch.
     */
    where: customer_readerWhereUniqueInput
  }

  /**
   * customer_reader findFirst
   */
  export type customer_readerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer_reader
     */
    select?: customer_readerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customer_reader
     */
    omit?: customer_readerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customer_readerInclude<ExtArgs> | null
    /**
     * Filter, which customer_reader to fetch.
     */
    where?: customer_readerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of customer_readers to fetch.
     */
    orderBy?: customer_readerOrderByWithRelationInput | customer_readerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for customer_readers.
     */
    cursor?: customer_readerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` customer_readers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` customer_readers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of customer_readers.
     */
    distinct?: Customer_readerScalarFieldEnum | Customer_readerScalarFieldEnum[]
  }

  /**
   * customer_reader findFirstOrThrow
   */
  export type customer_readerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer_reader
     */
    select?: customer_readerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customer_reader
     */
    omit?: customer_readerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customer_readerInclude<ExtArgs> | null
    /**
     * Filter, which customer_reader to fetch.
     */
    where?: customer_readerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of customer_readers to fetch.
     */
    orderBy?: customer_readerOrderByWithRelationInput | customer_readerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for customer_readers.
     */
    cursor?: customer_readerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` customer_readers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` customer_readers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of customer_readers.
     */
    distinct?: Customer_readerScalarFieldEnum | Customer_readerScalarFieldEnum[]
  }

  /**
   * customer_reader findMany
   */
  export type customer_readerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer_reader
     */
    select?: customer_readerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customer_reader
     */
    omit?: customer_readerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customer_readerInclude<ExtArgs> | null
    /**
     * Filter, which customer_readers to fetch.
     */
    where?: customer_readerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of customer_readers to fetch.
     */
    orderBy?: customer_readerOrderByWithRelationInput | customer_readerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing customer_readers.
     */
    cursor?: customer_readerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` customer_readers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` customer_readers.
     */
    skip?: number
    distinct?: Customer_readerScalarFieldEnum | Customer_readerScalarFieldEnum[]
  }

  /**
   * customer_reader create
   */
  export type customer_readerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer_reader
     */
    select?: customer_readerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customer_reader
     */
    omit?: customer_readerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customer_readerInclude<ExtArgs> | null
    /**
     * The data needed to create a customer_reader.
     */
    data: XOR<customer_readerCreateInput, customer_readerUncheckedCreateInput>
  }

  /**
   * customer_reader createMany
   */
  export type customer_readerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many customer_readers.
     */
    data: customer_readerCreateManyInput | customer_readerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * customer_reader createManyAndReturn
   */
  export type customer_readerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer_reader
     */
    select?: customer_readerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the customer_reader
     */
    omit?: customer_readerOmit<ExtArgs> | null
    /**
     * The data used to create many customer_readers.
     */
    data: customer_readerCreateManyInput | customer_readerCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customer_readerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * customer_reader update
   */
  export type customer_readerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer_reader
     */
    select?: customer_readerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customer_reader
     */
    omit?: customer_readerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customer_readerInclude<ExtArgs> | null
    /**
     * The data needed to update a customer_reader.
     */
    data: XOR<customer_readerUpdateInput, customer_readerUncheckedUpdateInput>
    /**
     * Choose, which customer_reader to update.
     */
    where: customer_readerWhereUniqueInput
  }

  /**
   * customer_reader updateMany
   */
  export type customer_readerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update customer_readers.
     */
    data: XOR<customer_readerUpdateManyMutationInput, customer_readerUncheckedUpdateManyInput>
    /**
     * Filter which customer_readers to update
     */
    where?: customer_readerWhereInput
    /**
     * Limit how many customer_readers to update.
     */
    limit?: number
  }

  /**
   * customer_reader updateManyAndReturn
   */
  export type customer_readerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer_reader
     */
    select?: customer_readerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the customer_reader
     */
    omit?: customer_readerOmit<ExtArgs> | null
    /**
     * The data used to update customer_readers.
     */
    data: XOR<customer_readerUpdateManyMutationInput, customer_readerUncheckedUpdateManyInput>
    /**
     * Filter which customer_readers to update
     */
    where?: customer_readerWhereInput
    /**
     * Limit how many customer_readers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customer_readerIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * customer_reader upsert
   */
  export type customer_readerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer_reader
     */
    select?: customer_readerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customer_reader
     */
    omit?: customer_readerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customer_readerInclude<ExtArgs> | null
    /**
     * The filter to search for the customer_reader to update in case it exists.
     */
    where: customer_readerWhereUniqueInput
    /**
     * In case the customer_reader found by the `where` argument doesn't exist, create a new customer_reader with this data.
     */
    create: XOR<customer_readerCreateInput, customer_readerUncheckedCreateInput>
    /**
     * In case the customer_reader was found with the provided `where` argument, update it with this data.
     */
    update: XOR<customer_readerUpdateInput, customer_readerUncheckedUpdateInput>
  }

  /**
   * customer_reader delete
   */
  export type customer_readerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer_reader
     */
    select?: customer_readerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customer_reader
     */
    omit?: customer_readerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customer_readerInclude<ExtArgs> | null
    /**
     * Filter which customer_reader to delete.
     */
    where: customer_readerWhereUniqueInput
  }

  /**
   * customer_reader deleteMany
   */
  export type customer_readerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which customer_readers to delete
     */
    where?: customer_readerWhereInput
    /**
     * Limit how many customer_readers to delete.
     */
    limit?: number
  }

  /**
   * customer_reader without action
   */
  export type customer_readerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer_reader
     */
    select?: customer_readerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customer_reader
     */
    omit?: customer_readerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customer_readerInclude<ExtArgs> | null
  }


  /**
   * Model customer_track
   */

  export type AggregateCustomer_track = {
    _count: Customer_trackCountAggregateOutputType | null
    _min: Customer_trackMinAggregateOutputType | null
    _max: Customer_trackMaxAggregateOutputType | null
  }

  export type Customer_trackMinAggregateOutputType = {
    id: string | null
    ts: Date | null
    id_customer: string | null
    path: string | null
    referrer: string | null
    ip: string | null
  }

  export type Customer_trackMaxAggregateOutputType = {
    id: string | null
    ts: Date | null
    id_customer: string | null
    path: string | null
    referrer: string | null
    ip: string | null
  }

  export type Customer_trackCountAggregateOutputType = {
    id: number
    ts: number
    id_customer: number
    path: number
    referrer: number
    info: number
    ip: number
    _all: number
  }


  export type Customer_trackMinAggregateInputType = {
    id?: true
    ts?: true
    id_customer?: true
    path?: true
    referrer?: true
    ip?: true
  }

  export type Customer_trackMaxAggregateInputType = {
    id?: true
    ts?: true
    id_customer?: true
    path?: true
    referrer?: true
    ip?: true
  }

  export type Customer_trackCountAggregateInputType = {
    id?: true
    ts?: true
    id_customer?: true
    path?: true
    referrer?: true
    info?: true
    ip?: true
    _all?: true
  }

  export type Customer_trackAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which customer_track to aggregate.
     */
    where?: customer_trackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of customer_tracks to fetch.
     */
    orderBy?: customer_trackOrderByWithRelationInput | customer_trackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: customer_trackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` customer_tracks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` customer_tracks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned customer_tracks
    **/
    _count?: true | Customer_trackCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Customer_trackMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Customer_trackMaxAggregateInputType
  }

  export type GetCustomer_trackAggregateType<T extends Customer_trackAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomer_track]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomer_track[P]>
      : GetScalarType<T[P], AggregateCustomer_track[P]>
  }




  export type customer_trackGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: customer_trackWhereInput
    orderBy?: customer_trackOrderByWithAggregationInput | customer_trackOrderByWithAggregationInput[]
    by: Customer_trackScalarFieldEnum[] | Customer_trackScalarFieldEnum
    having?: customer_trackScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Customer_trackCountAggregateInputType | true
    _min?: Customer_trackMinAggregateInputType
    _max?: Customer_trackMaxAggregateInputType
  }

  export type Customer_trackGroupByOutputType = {
    id: string
    ts: Date
    id_customer: string
    path: string
    referrer: string
    info: JsonValue
    ip: string
    _count: Customer_trackCountAggregateOutputType | null
    _min: Customer_trackMinAggregateOutputType | null
    _max: Customer_trackMaxAggregateOutputType | null
  }

  type GetCustomer_trackGroupByPayload<T extends customer_trackGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Customer_trackGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Customer_trackGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Customer_trackGroupByOutputType[P]>
            : GetScalarType<T[P], Customer_trackGroupByOutputType[P]>
        }
      >
    >


  export type customer_trackSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ts?: boolean
    id_customer?: boolean
    path?: boolean
    referrer?: boolean
    info?: boolean
    ip?: boolean
    customer?: boolean | customerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customer_track"]>

  export type customer_trackSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ts?: boolean
    id_customer?: boolean
    path?: boolean
    referrer?: boolean
    info?: boolean
    ip?: boolean
    customer?: boolean | customerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customer_track"]>

  export type customer_trackSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ts?: boolean
    id_customer?: boolean
    path?: boolean
    referrer?: boolean
    info?: boolean
    ip?: boolean
    customer?: boolean | customerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customer_track"]>

  export type customer_trackSelectScalar = {
    id?: boolean
    ts?: boolean
    id_customer?: boolean
    path?: boolean
    referrer?: boolean
    info?: boolean
    ip?: boolean
  }

  export type customer_trackOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "ts" | "id_customer" | "path" | "referrer" | "info" | "ip", ExtArgs["result"]["customer_track"]>
  export type customer_trackInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | customerDefaultArgs<ExtArgs>
  }
  export type customer_trackIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | customerDefaultArgs<ExtArgs>
  }
  export type customer_trackIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | customerDefaultArgs<ExtArgs>
  }

  export type $customer_trackPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "customer_track"
    objects: {
      customer: Prisma.$customerPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      ts: Date
      id_customer: string
      path: string
      referrer: string
      info: Prisma.JsonValue
      ip: string
    }, ExtArgs["result"]["customer_track"]>
    composites: {}
  }

  type customer_trackGetPayload<S extends boolean | null | undefined | customer_trackDefaultArgs> = $Result.GetResult<Prisma.$customer_trackPayload, S>

  type customer_trackCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<customer_trackFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Customer_trackCountAggregateInputType | true
    }

  export interface customer_trackDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['customer_track'], meta: { name: 'customer_track' } }
    /**
     * Find zero or one Customer_track that matches the filter.
     * @param {customer_trackFindUniqueArgs} args - Arguments to find a Customer_track
     * @example
     * // Get one Customer_track
     * const customer_track = await prisma.customer_track.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends customer_trackFindUniqueArgs>(args: SelectSubset<T, customer_trackFindUniqueArgs<ExtArgs>>): Prisma__customer_trackClient<$Result.GetResult<Prisma.$customer_trackPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Customer_track that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {customer_trackFindUniqueOrThrowArgs} args - Arguments to find a Customer_track
     * @example
     * // Get one Customer_track
     * const customer_track = await prisma.customer_track.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends customer_trackFindUniqueOrThrowArgs>(args: SelectSubset<T, customer_trackFindUniqueOrThrowArgs<ExtArgs>>): Prisma__customer_trackClient<$Result.GetResult<Prisma.$customer_trackPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Customer_track that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {customer_trackFindFirstArgs} args - Arguments to find a Customer_track
     * @example
     * // Get one Customer_track
     * const customer_track = await prisma.customer_track.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends customer_trackFindFirstArgs>(args?: SelectSubset<T, customer_trackFindFirstArgs<ExtArgs>>): Prisma__customer_trackClient<$Result.GetResult<Prisma.$customer_trackPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Customer_track that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {customer_trackFindFirstOrThrowArgs} args - Arguments to find a Customer_track
     * @example
     * // Get one Customer_track
     * const customer_track = await prisma.customer_track.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends customer_trackFindFirstOrThrowArgs>(args?: SelectSubset<T, customer_trackFindFirstOrThrowArgs<ExtArgs>>): Prisma__customer_trackClient<$Result.GetResult<Prisma.$customer_trackPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Customer_tracks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {customer_trackFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Customer_tracks
     * const customer_tracks = await prisma.customer_track.findMany()
     * 
     * // Get first 10 Customer_tracks
     * const customer_tracks = await prisma.customer_track.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customer_trackWithIdOnly = await prisma.customer_track.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends customer_trackFindManyArgs>(args?: SelectSubset<T, customer_trackFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$customer_trackPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Customer_track.
     * @param {customer_trackCreateArgs} args - Arguments to create a Customer_track.
     * @example
     * // Create one Customer_track
     * const Customer_track = await prisma.customer_track.create({
     *   data: {
     *     // ... data to create a Customer_track
     *   }
     * })
     * 
     */
    create<T extends customer_trackCreateArgs>(args: SelectSubset<T, customer_trackCreateArgs<ExtArgs>>): Prisma__customer_trackClient<$Result.GetResult<Prisma.$customer_trackPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Customer_tracks.
     * @param {customer_trackCreateManyArgs} args - Arguments to create many Customer_tracks.
     * @example
     * // Create many Customer_tracks
     * const customer_track = await prisma.customer_track.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends customer_trackCreateManyArgs>(args?: SelectSubset<T, customer_trackCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Customer_tracks and returns the data saved in the database.
     * @param {customer_trackCreateManyAndReturnArgs} args - Arguments to create many Customer_tracks.
     * @example
     * // Create many Customer_tracks
     * const customer_track = await prisma.customer_track.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Customer_tracks and only return the `id`
     * const customer_trackWithIdOnly = await prisma.customer_track.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends customer_trackCreateManyAndReturnArgs>(args?: SelectSubset<T, customer_trackCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$customer_trackPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Customer_track.
     * @param {customer_trackDeleteArgs} args - Arguments to delete one Customer_track.
     * @example
     * // Delete one Customer_track
     * const Customer_track = await prisma.customer_track.delete({
     *   where: {
     *     // ... filter to delete one Customer_track
     *   }
     * })
     * 
     */
    delete<T extends customer_trackDeleteArgs>(args: SelectSubset<T, customer_trackDeleteArgs<ExtArgs>>): Prisma__customer_trackClient<$Result.GetResult<Prisma.$customer_trackPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Customer_track.
     * @param {customer_trackUpdateArgs} args - Arguments to update one Customer_track.
     * @example
     * // Update one Customer_track
     * const customer_track = await prisma.customer_track.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends customer_trackUpdateArgs>(args: SelectSubset<T, customer_trackUpdateArgs<ExtArgs>>): Prisma__customer_trackClient<$Result.GetResult<Prisma.$customer_trackPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Customer_tracks.
     * @param {customer_trackDeleteManyArgs} args - Arguments to filter Customer_tracks to delete.
     * @example
     * // Delete a few Customer_tracks
     * const { count } = await prisma.customer_track.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends customer_trackDeleteManyArgs>(args?: SelectSubset<T, customer_trackDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Customer_tracks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {customer_trackUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Customer_tracks
     * const customer_track = await prisma.customer_track.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends customer_trackUpdateManyArgs>(args: SelectSubset<T, customer_trackUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Customer_tracks and returns the data updated in the database.
     * @param {customer_trackUpdateManyAndReturnArgs} args - Arguments to update many Customer_tracks.
     * @example
     * // Update many Customer_tracks
     * const customer_track = await prisma.customer_track.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Customer_tracks and only return the `id`
     * const customer_trackWithIdOnly = await prisma.customer_track.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends customer_trackUpdateManyAndReturnArgs>(args: SelectSubset<T, customer_trackUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$customer_trackPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Customer_track.
     * @param {customer_trackUpsertArgs} args - Arguments to update or create a Customer_track.
     * @example
     * // Update or create a Customer_track
     * const customer_track = await prisma.customer_track.upsert({
     *   create: {
     *     // ... data to create a Customer_track
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Customer_track we want to update
     *   }
     * })
     */
    upsert<T extends customer_trackUpsertArgs>(args: SelectSubset<T, customer_trackUpsertArgs<ExtArgs>>): Prisma__customer_trackClient<$Result.GetResult<Prisma.$customer_trackPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Customer_tracks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {customer_trackCountArgs} args - Arguments to filter Customer_tracks to count.
     * @example
     * // Count the number of Customer_tracks
     * const count = await prisma.customer_track.count({
     *   where: {
     *     // ... the filter for the Customer_tracks we want to count
     *   }
     * })
    **/
    count<T extends customer_trackCountArgs>(
      args?: Subset<T, customer_trackCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Customer_trackCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Customer_track.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Customer_trackAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Customer_trackAggregateArgs>(args: Subset<T, Customer_trackAggregateArgs>): Prisma.PrismaPromise<GetCustomer_trackAggregateType<T>>

    /**
     * Group by Customer_track.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {customer_trackGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends customer_trackGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: customer_trackGroupByArgs['orderBy'] }
        : { orderBy?: customer_trackGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, customer_trackGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomer_trackGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the customer_track model
   */
  readonly fields: customer_trackFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for customer_track.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__customer_trackClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    customer<T extends customerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, customerDefaultArgs<ExtArgs>>): Prisma__customerClient<$Result.GetResult<Prisma.$customerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the customer_track model
   */
  interface customer_trackFieldRefs {
    readonly id: FieldRef<"customer_track", 'String'>
    readonly ts: FieldRef<"customer_track", 'DateTime'>
    readonly id_customer: FieldRef<"customer_track", 'String'>
    readonly path: FieldRef<"customer_track", 'String'>
    readonly referrer: FieldRef<"customer_track", 'String'>
    readonly info: FieldRef<"customer_track", 'Json'>
    readonly ip: FieldRef<"customer_track", 'String'>
  }
    

  // Custom InputTypes
  /**
   * customer_track findUnique
   */
  export type customer_trackFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer_track
     */
    select?: customer_trackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customer_track
     */
    omit?: customer_trackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customer_trackInclude<ExtArgs> | null
    /**
     * Filter, which customer_track to fetch.
     */
    where: customer_trackWhereUniqueInput
  }

  /**
   * customer_track findUniqueOrThrow
   */
  export type customer_trackFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer_track
     */
    select?: customer_trackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customer_track
     */
    omit?: customer_trackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customer_trackInclude<ExtArgs> | null
    /**
     * Filter, which customer_track to fetch.
     */
    where: customer_trackWhereUniqueInput
  }

  /**
   * customer_track findFirst
   */
  export type customer_trackFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer_track
     */
    select?: customer_trackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customer_track
     */
    omit?: customer_trackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customer_trackInclude<ExtArgs> | null
    /**
     * Filter, which customer_track to fetch.
     */
    where?: customer_trackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of customer_tracks to fetch.
     */
    orderBy?: customer_trackOrderByWithRelationInput | customer_trackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for customer_tracks.
     */
    cursor?: customer_trackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` customer_tracks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` customer_tracks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of customer_tracks.
     */
    distinct?: Customer_trackScalarFieldEnum | Customer_trackScalarFieldEnum[]
  }

  /**
   * customer_track findFirstOrThrow
   */
  export type customer_trackFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer_track
     */
    select?: customer_trackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customer_track
     */
    omit?: customer_trackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customer_trackInclude<ExtArgs> | null
    /**
     * Filter, which customer_track to fetch.
     */
    where?: customer_trackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of customer_tracks to fetch.
     */
    orderBy?: customer_trackOrderByWithRelationInput | customer_trackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for customer_tracks.
     */
    cursor?: customer_trackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` customer_tracks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` customer_tracks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of customer_tracks.
     */
    distinct?: Customer_trackScalarFieldEnum | Customer_trackScalarFieldEnum[]
  }

  /**
   * customer_track findMany
   */
  export type customer_trackFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer_track
     */
    select?: customer_trackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customer_track
     */
    omit?: customer_trackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customer_trackInclude<ExtArgs> | null
    /**
     * Filter, which customer_tracks to fetch.
     */
    where?: customer_trackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of customer_tracks to fetch.
     */
    orderBy?: customer_trackOrderByWithRelationInput | customer_trackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing customer_tracks.
     */
    cursor?: customer_trackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` customer_tracks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` customer_tracks.
     */
    skip?: number
    distinct?: Customer_trackScalarFieldEnum | Customer_trackScalarFieldEnum[]
  }

  /**
   * customer_track create
   */
  export type customer_trackCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer_track
     */
    select?: customer_trackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customer_track
     */
    omit?: customer_trackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customer_trackInclude<ExtArgs> | null
    /**
     * The data needed to create a customer_track.
     */
    data: XOR<customer_trackCreateInput, customer_trackUncheckedCreateInput>
  }

  /**
   * customer_track createMany
   */
  export type customer_trackCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many customer_tracks.
     */
    data: customer_trackCreateManyInput | customer_trackCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * customer_track createManyAndReturn
   */
  export type customer_trackCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer_track
     */
    select?: customer_trackSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the customer_track
     */
    omit?: customer_trackOmit<ExtArgs> | null
    /**
     * The data used to create many customer_tracks.
     */
    data: customer_trackCreateManyInput | customer_trackCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customer_trackIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * customer_track update
   */
  export type customer_trackUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer_track
     */
    select?: customer_trackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customer_track
     */
    omit?: customer_trackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customer_trackInclude<ExtArgs> | null
    /**
     * The data needed to update a customer_track.
     */
    data: XOR<customer_trackUpdateInput, customer_trackUncheckedUpdateInput>
    /**
     * Choose, which customer_track to update.
     */
    where: customer_trackWhereUniqueInput
  }

  /**
   * customer_track updateMany
   */
  export type customer_trackUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update customer_tracks.
     */
    data: XOR<customer_trackUpdateManyMutationInput, customer_trackUncheckedUpdateManyInput>
    /**
     * Filter which customer_tracks to update
     */
    where?: customer_trackWhereInput
    /**
     * Limit how many customer_tracks to update.
     */
    limit?: number
  }

  /**
   * customer_track updateManyAndReturn
   */
  export type customer_trackUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer_track
     */
    select?: customer_trackSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the customer_track
     */
    omit?: customer_trackOmit<ExtArgs> | null
    /**
     * The data used to update customer_tracks.
     */
    data: XOR<customer_trackUpdateManyMutationInput, customer_trackUncheckedUpdateManyInput>
    /**
     * Filter which customer_tracks to update
     */
    where?: customer_trackWhereInput
    /**
     * Limit how many customer_tracks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customer_trackIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * customer_track upsert
   */
  export type customer_trackUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer_track
     */
    select?: customer_trackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customer_track
     */
    omit?: customer_trackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customer_trackInclude<ExtArgs> | null
    /**
     * The filter to search for the customer_track to update in case it exists.
     */
    where: customer_trackWhereUniqueInput
    /**
     * In case the customer_track found by the `where` argument doesn't exist, create a new customer_track with this data.
     */
    create: XOR<customer_trackCreateInput, customer_trackUncheckedCreateInput>
    /**
     * In case the customer_track was found with the provided `where` argument, update it with this data.
     */
    update: XOR<customer_trackUpdateInput, customer_trackUncheckedUpdateInput>
  }

  /**
   * customer_track delete
   */
  export type customer_trackDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer_track
     */
    select?: customer_trackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customer_track
     */
    omit?: customer_trackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customer_trackInclude<ExtArgs> | null
    /**
     * Filter which customer_track to delete.
     */
    where: customer_trackWhereUniqueInput
  }

  /**
   * customer_track deleteMany
   */
  export type customer_trackDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which customer_tracks to delete
     */
    where?: customer_trackWhereInput
    /**
     * Limit how many customer_tracks to delete.
     */
    limit?: number
  }

  /**
   * customer_track without action
   */
  export type customer_trackDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer_track
     */
    select?: customer_trackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customer_track
     */
    omit?: customer_trackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customer_trackInclude<ExtArgs> | null
  }


  /**
   * Model genre
   */

  export type AggregateGenre = {
    _count: GenreCountAggregateOutputType | null
    _min: GenreMinAggregateOutputType | null
    _max: GenreMaxAggregateOutputType | null
  }

  export type GenreMinAggregateOutputType = {
    id: string | null
    name: string | null
    id_parent: string | null
    slug: string | null
    img: string | null
    deleted_at: Date | null
  }

  export type GenreMaxAggregateOutputType = {
    id: string | null
    name: string | null
    id_parent: string | null
    slug: string | null
    img: string | null
    deleted_at: Date | null
  }

  export type GenreCountAggregateOutputType = {
    id: number
    name: number
    id_parent: number
    slug: number
    img: number
    deleted_at: number
    _all: number
  }


  export type GenreMinAggregateInputType = {
    id?: true
    name?: true
    id_parent?: true
    slug?: true
    img?: true
    deleted_at?: true
  }

  export type GenreMaxAggregateInputType = {
    id?: true
    name?: true
    id_parent?: true
    slug?: true
    img?: true
    deleted_at?: true
  }

  export type GenreCountAggregateInputType = {
    id?: true
    name?: true
    id_parent?: true
    slug?: true
    img?: true
    deleted_at?: true
    _all?: true
  }

  export type GenreAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which genre to aggregate.
     */
    where?: genreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of genres to fetch.
     */
    orderBy?: genreOrderByWithRelationInput | genreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: genreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` genres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` genres.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned genres
    **/
    _count?: true | GenreCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GenreMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GenreMaxAggregateInputType
  }

  export type GetGenreAggregateType<T extends GenreAggregateArgs> = {
        [P in keyof T & keyof AggregateGenre]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGenre[P]>
      : GetScalarType<T[P], AggregateGenre[P]>
  }




  export type genreGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: genreWhereInput
    orderBy?: genreOrderByWithAggregationInput | genreOrderByWithAggregationInput[]
    by: GenreScalarFieldEnum[] | GenreScalarFieldEnum
    having?: genreScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GenreCountAggregateInputType | true
    _min?: GenreMinAggregateInputType
    _max?: GenreMaxAggregateInputType
  }

  export type GenreGroupByOutputType = {
    id: string
    name: string
    id_parent: string | null
    slug: string | null
    img: string | null
    deleted_at: Date | null
    _count: GenreCountAggregateOutputType | null
    _min: GenreMinAggregateOutputType | null
    _max: GenreMaxAggregateOutputType | null
  }

  type GetGenreGroupByPayload<T extends genreGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GenreGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GenreGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GenreGroupByOutputType[P]>
            : GetScalarType<T[P], GenreGroupByOutputType[P]>
        }
      >
    >


  export type genreSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    id_parent?: boolean
    slug?: boolean
    img?: boolean
    deleted_at?: boolean
    book_genre?: boolean | genre$book_genreArgs<ExtArgs>
    genre?: boolean | genre$genreArgs<ExtArgs>
    other_genre?: boolean | genre$other_genreArgs<ExtArgs>
    _count?: boolean | GenreCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["genre"]>

  export type genreSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    id_parent?: boolean
    slug?: boolean
    img?: boolean
    deleted_at?: boolean
    genre?: boolean | genre$genreArgs<ExtArgs>
  }, ExtArgs["result"]["genre"]>

  export type genreSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    id_parent?: boolean
    slug?: boolean
    img?: boolean
    deleted_at?: boolean
    genre?: boolean | genre$genreArgs<ExtArgs>
  }, ExtArgs["result"]["genre"]>

  export type genreSelectScalar = {
    id?: boolean
    name?: boolean
    id_parent?: boolean
    slug?: boolean
    img?: boolean
    deleted_at?: boolean
  }

  export type genreOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "id_parent" | "slug" | "img" | "deleted_at", ExtArgs["result"]["genre"]>
  export type genreInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    book_genre?: boolean | genre$book_genreArgs<ExtArgs>
    genre?: boolean | genre$genreArgs<ExtArgs>
    other_genre?: boolean | genre$other_genreArgs<ExtArgs>
    _count?: boolean | GenreCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type genreIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    genre?: boolean | genre$genreArgs<ExtArgs>
  }
  export type genreIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    genre?: boolean | genre$genreArgs<ExtArgs>
  }

  export type $genrePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "genre"
    objects: {
      book_genre: Prisma.$book_genrePayload<ExtArgs>[]
      genre: Prisma.$genrePayload<ExtArgs> | null
      other_genre: Prisma.$genrePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      id_parent: string | null
      slug: string | null
      img: string | null
      deleted_at: Date | null
    }, ExtArgs["result"]["genre"]>
    composites: {}
  }

  type genreGetPayload<S extends boolean | null | undefined | genreDefaultArgs> = $Result.GetResult<Prisma.$genrePayload, S>

  type genreCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<genreFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GenreCountAggregateInputType | true
    }

  export interface genreDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['genre'], meta: { name: 'genre' } }
    /**
     * Find zero or one Genre that matches the filter.
     * @param {genreFindUniqueArgs} args - Arguments to find a Genre
     * @example
     * // Get one Genre
     * const genre = await prisma.genre.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends genreFindUniqueArgs>(args: SelectSubset<T, genreFindUniqueArgs<ExtArgs>>): Prisma__genreClient<$Result.GetResult<Prisma.$genrePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Genre that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {genreFindUniqueOrThrowArgs} args - Arguments to find a Genre
     * @example
     * // Get one Genre
     * const genre = await prisma.genre.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends genreFindUniqueOrThrowArgs>(args: SelectSubset<T, genreFindUniqueOrThrowArgs<ExtArgs>>): Prisma__genreClient<$Result.GetResult<Prisma.$genrePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Genre that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {genreFindFirstArgs} args - Arguments to find a Genre
     * @example
     * // Get one Genre
     * const genre = await prisma.genre.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends genreFindFirstArgs>(args?: SelectSubset<T, genreFindFirstArgs<ExtArgs>>): Prisma__genreClient<$Result.GetResult<Prisma.$genrePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Genre that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {genreFindFirstOrThrowArgs} args - Arguments to find a Genre
     * @example
     * // Get one Genre
     * const genre = await prisma.genre.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends genreFindFirstOrThrowArgs>(args?: SelectSubset<T, genreFindFirstOrThrowArgs<ExtArgs>>): Prisma__genreClient<$Result.GetResult<Prisma.$genrePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Genres that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {genreFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Genres
     * const genres = await prisma.genre.findMany()
     * 
     * // Get first 10 Genres
     * const genres = await prisma.genre.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const genreWithIdOnly = await prisma.genre.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends genreFindManyArgs>(args?: SelectSubset<T, genreFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$genrePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Genre.
     * @param {genreCreateArgs} args - Arguments to create a Genre.
     * @example
     * // Create one Genre
     * const Genre = await prisma.genre.create({
     *   data: {
     *     // ... data to create a Genre
     *   }
     * })
     * 
     */
    create<T extends genreCreateArgs>(args: SelectSubset<T, genreCreateArgs<ExtArgs>>): Prisma__genreClient<$Result.GetResult<Prisma.$genrePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Genres.
     * @param {genreCreateManyArgs} args - Arguments to create many Genres.
     * @example
     * // Create many Genres
     * const genre = await prisma.genre.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends genreCreateManyArgs>(args?: SelectSubset<T, genreCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Genres and returns the data saved in the database.
     * @param {genreCreateManyAndReturnArgs} args - Arguments to create many Genres.
     * @example
     * // Create many Genres
     * const genre = await prisma.genre.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Genres and only return the `id`
     * const genreWithIdOnly = await prisma.genre.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends genreCreateManyAndReturnArgs>(args?: SelectSubset<T, genreCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$genrePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Genre.
     * @param {genreDeleteArgs} args - Arguments to delete one Genre.
     * @example
     * // Delete one Genre
     * const Genre = await prisma.genre.delete({
     *   where: {
     *     // ... filter to delete one Genre
     *   }
     * })
     * 
     */
    delete<T extends genreDeleteArgs>(args: SelectSubset<T, genreDeleteArgs<ExtArgs>>): Prisma__genreClient<$Result.GetResult<Prisma.$genrePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Genre.
     * @param {genreUpdateArgs} args - Arguments to update one Genre.
     * @example
     * // Update one Genre
     * const genre = await prisma.genre.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends genreUpdateArgs>(args: SelectSubset<T, genreUpdateArgs<ExtArgs>>): Prisma__genreClient<$Result.GetResult<Prisma.$genrePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Genres.
     * @param {genreDeleteManyArgs} args - Arguments to filter Genres to delete.
     * @example
     * // Delete a few Genres
     * const { count } = await prisma.genre.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends genreDeleteManyArgs>(args?: SelectSubset<T, genreDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Genres.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {genreUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Genres
     * const genre = await prisma.genre.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends genreUpdateManyArgs>(args: SelectSubset<T, genreUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Genres and returns the data updated in the database.
     * @param {genreUpdateManyAndReturnArgs} args - Arguments to update many Genres.
     * @example
     * // Update many Genres
     * const genre = await prisma.genre.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Genres and only return the `id`
     * const genreWithIdOnly = await prisma.genre.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends genreUpdateManyAndReturnArgs>(args: SelectSubset<T, genreUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$genrePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Genre.
     * @param {genreUpsertArgs} args - Arguments to update or create a Genre.
     * @example
     * // Update or create a Genre
     * const genre = await prisma.genre.upsert({
     *   create: {
     *     // ... data to create a Genre
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Genre we want to update
     *   }
     * })
     */
    upsert<T extends genreUpsertArgs>(args: SelectSubset<T, genreUpsertArgs<ExtArgs>>): Prisma__genreClient<$Result.GetResult<Prisma.$genrePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Genres.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {genreCountArgs} args - Arguments to filter Genres to count.
     * @example
     * // Count the number of Genres
     * const count = await prisma.genre.count({
     *   where: {
     *     // ... the filter for the Genres we want to count
     *   }
     * })
    **/
    count<T extends genreCountArgs>(
      args?: Subset<T, genreCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GenreCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Genre.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenreAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GenreAggregateArgs>(args: Subset<T, GenreAggregateArgs>): Prisma.PrismaPromise<GetGenreAggregateType<T>>

    /**
     * Group by Genre.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {genreGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends genreGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: genreGroupByArgs['orderBy'] }
        : { orderBy?: genreGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, genreGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGenreGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the genre model
   */
  readonly fields: genreFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for genre.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__genreClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    book_genre<T extends genre$book_genreArgs<ExtArgs> = {}>(args?: Subset<T, genre$book_genreArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$book_genrePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    genre<T extends genre$genreArgs<ExtArgs> = {}>(args?: Subset<T, genre$genreArgs<ExtArgs>>): Prisma__genreClient<$Result.GetResult<Prisma.$genrePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    other_genre<T extends genre$other_genreArgs<ExtArgs> = {}>(args?: Subset<T, genre$other_genreArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$genrePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the genre model
   */
  interface genreFieldRefs {
    readonly id: FieldRef<"genre", 'String'>
    readonly name: FieldRef<"genre", 'String'>
    readonly id_parent: FieldRef<"genre", 'String'>
    readonly slug: FieldRef<"genre", 'String'>
    readonly img: FieldRef<"genre", 'String'>
    readonly deleted_at: FieldRef<"genre", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * genre findUnique
   */
  export type genreFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the genre
     */
    select?: genreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the genre
     */
    omit?: genreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: genreInclude<ExtArgs> | null
    /**
     * Filter, which genre to fetch.
     */
    where: genreWhereUniqueInput
  }

  /**
   * genre findUniqueOrThrow
   */
  export type genreFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the genre
     */
    select?: genreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the genre
     */
    omit?: genreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: genreInclude<ExtArgs> | null
    /**
     * Filter, which genre to fetch.
     */
    where: genreWhereUniqueInput
  }

  /**
   * genre findFirst
   */
  export type genreFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the genre
     */
    select?: genreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the genre
     */
    omit?: genreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: genreInclude<ExtArgs> | null
    /**
     * Filter, which genre to fetch.
     */
    where?: genreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of genres to fetch.
     */
    orderBy?: genreOrderByWithRelationInput | genreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for genres.
     */
    cursor?: genreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` genres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` genres.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of genres.
     */
    distinct?: GenreScalarFieldEnum | GenreScalarFieldEnum[]
  }

  /**
   * genre findFirstOrThrow
   */
  export type genreFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the genre
     */
    select?: genreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the genre
     */
    omit?: genreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: genreInclude<ExtArgs> | null
    /**
     * Filter, which genre to fetch.
     */
    where?: genreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of genres to fetch.
     */
    orderBy?: genreOrderByWithRelationInput | genreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for genres.
     */
    cursor?: genreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` genres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` genres.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of genres.
     */
    distinct?: GenreScalarFieldEnum | GenreScalarFieldEnum[]
  }

  /**
   * genre findMany
   */
  export type genreFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the genre
     */
    select?: genreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the genre
     */
    omit?: genreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: genreInclude<ExtArgs> | null
    /**
     * Filter, which genres to fetch.
     */
    where?: genreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of genres to fetch.
     */
    orderBy?: genreOrderByWithRelationInput | genreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing genres.
     */
    cursor?: genreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` genres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` genres.
     */
    skip?: number
    distinct?: GenreScalarFieldEnum | GenreScalarFieldEnum[]
  }

  /**
   * genre create
   */
  export type genreCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the genre
     */
    select?: genreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the genre
     */
    omit?: genreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: genreInclude<ExtArgs> | null
    /**
     * The data needed to create a genre.
     */
    data: XOR<genreCreateInput, genreUncheckedCreateInput>
  }

  /**
   * genre createMany
   */
  export type genreCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many genres.
     */
    data: genreCreateManyInput | genreCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * genre createManyAndReturn
   */
  export type genreCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the genre
     */
    select?: genreSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the genre
     */
    omit?: genreOmit<ExtArgs> | null
    /**
     * The data used to create many genres.
     */
    data: genreCreateManyInput | genreCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: genreIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * genre update
   */
  export type genreUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the genre
     */
    select?: genreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the genre
     */
    omit?: genreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: genreInclude<ExtArgs> | null
    /**
     * The data needed to update a genre.
     */
    data: XOR<genreUpdateInput, genreUncheckedUpdateInput>
    /**
     * Choose, which genre to update.
     */
    where: genreWhereUniqueInput
  }

  /**
   * genre updateMany
   */
  export type genreUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update genres.
     */
    data: XOR<genreUpdateManyMutationInput, genreUncheckedUpdateManyInput>
    /**
     * Filter which genres to update
     */
    where?: genreWhereInput
    /**
     * Limit how many genres to update.
     */
    limit?: number
  }

  /**
   * genre updateManyAndReturn
   */
  export type genreUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the genre
     */
    select?: genreSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the genre
     */
    omit?: genreOmit<ExtArgs> | null
    /**
     * The data used to update genres.
     */
    data: XOR<genreUpdateManyMutationInput, genreUncheckedUpdateManyInput>
    /**
     * Filter which genres to update
     */
    where?: genreWhereInput
    /**
     * Limit how many genres to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: genreIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * genre upsert
   */
  export type genreUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the genre
     */
    select?: genreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the genre
     */
    omit?: genreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: genreInclude<ExtArgs> | null
    /**
     * The filter to search for the genre to update in case it exists.
     */
    where: genreWhereUniqueInput
    /**
     * In case the genre found by the `where` argument doesn't exist, create a new genre with this data.
     */
    create: XOR<genreCreateInput, genreUncheckedCreateInput>
    /**
     * In case the genre was found with the provided `where` argument, update it with this data.
     */
    update: XOR<genreUpdateInput, genreUncheckedUpdateInput>
  }

  /**
   * genre delete
   */
  export type genreDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the genre
     */
    select?: genreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the genre
     */
    omit?: genreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: genreInclude<ExtArgs> | null
    /**
     * Filter which genre to delete.
     */
    where: genreWhereUniqueInput
  }

  /**
   * genre deleteMany
   */
  export type genreDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which genres to delete
     */
    where?: genreWhereInput
    /**
     * Limit how many genres to delete.
     */
    limit?: number
  }

  /**
   * genre.book_genre
   */
  export type genre$book_genreArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the book_genre
     */
    select?: book_genreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the book_genre
     */
    omit?: book_genreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: book_genreInclude<ExtArgs> | null
    where?: book_genreWhereInput
    orderBy?: book_genreOrderByWithRelationInput | book_genreOrderByWithRelationInput[]
    cursor?: book_genreWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Book_genreScalarFieldEnum | Book_genreScalarFieldEnum[]
  }

  /**
   * genre.genre
   */
  export type genre$genreArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the genre
     */
    select?: genreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the genre
     */
    omit?: genreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: genreInclude<ExtArgs> | null
    where?: genreWhereInput
  }

  /**
   * genre.other_genre
   */
  export type genre$other_genreArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the genre
     */
    select?: genreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the genre
     */
    omit?: genreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: genreInclude<ExtArgs> | null
    where?: genreWhereInput
    orderBy?: genreOrderByWithRelationInput | genreOrderByWithRelationInput[]
    cursor?: genreWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GenreScalarFieldEnum | GenreScalarFieldEnum[]
  }

  /**
   * genre without action
   */
  export type genreDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the genre
     */
    select?: genreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the genre
     */
    omit?: genreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: genreInclude<ExtArgs> | null
  }


  /**
   * Model internal
   */

  export type AggregateInternal = {
    _count: InternalCountAggregateOutputType | null
    _min: InternalMinAggregateOutputType | null
    _max: InternalMaxAggregateOutputType | null
  }

  export type InternalMinAggregateOutputType = {
    id: string | null
    id_account: string | null
    name: string | null
    is_sales_and_marketing: boolean | null
    is_support: boolean | null
    is_management: boolean | null
    is_it: boolean | null
  }

  export type InternalMaxAggregateOutputType = {
    id: string | null
    id_account: string | null
    name: string | null
    is_sales_and_marketing: boolean | null
    is_support: boolean | null
    is_management: boolean | null
    is_it: boolean | null
  }

  export type InternalCountAggregateOutputType = {
    id: number
    id_account: number
    name: number
    is_sales_and_marketing: number
    is_support: number
    is_management: number
    is_it: number
    _all: number
  }


  export type InternalMinAggregateInputType = {
    id?: true
    id_account?: true
    name?: true
    is_sales_and_marketing?: true
    is_support?: true
    is_management?: true
    is_it?: true
  }

  export type InternalMaxAggregateInputType = {
    id?: true
    id_account?: true
    name?: true
    is_sales_and_marketing?: true
    is_support?: true
    is_management?: true
    is_it?: true
  }

  export type InternalCountAggregateInputType = {
    id?: true
    id_account?: true
    name?: true
    is_sales_and_marketing?: true
    is_support?: true
    is_management?: true
    is_it?: true
    _all?: true
  }

  export type InternalAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which internal to aggregate.
     */
    where?: internalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of internals to fetch.
     */
    orderBy?: internalOrderByWithRelationInput | internalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: internalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` internals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` internals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned internals
    **/
    _count?: true | InternalCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InternalMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InternalMaxAggregateInputType
  }

  export type GetInternalAggregateType<T extends InternalAggregateArgs> = {
        [P in keyof T & keyof AggregateInternal]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInternal[P]>
      : GetScalarType<T[P], AggregateInternal[P]>
  }




  export type internalGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: internalWhereInput
    orderBy?: internalOrderByWithAggregationInput | internalOrderByWithAggregationInput[]
    by: InternalScalarFieldEnum[] | InternalScalarFieldEnum
    having?: internalScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InternalCountAggregateInputType | true
    _min?: InternalMinAggregateInputType
    _max?: InternalMaxAggregateInputType
  }

  export type InternalGroupByOutputType = {
    id: string
    id_account: string | null
    name: string
    is_sales_and_marketing: boolean
    is_support: boolean
    is_management: boolean
    is_it: boolean
    _count: InternalCountAggregateOutputType | null
    _min: InternalMinAggregateOutputType | null
    _max: InternalMaxAggregateOutputType | null
  }

  type GetInternalGroupByPayload<T extends internalGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InternalGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InternalGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InternalGroupByOutputType[P]>
            : GetScalarType<T[P], InternalGroupByOutputType[P]>
        }
      >
    >


  export type internalSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    id_account?: boolean
    name?: boolean
    is_sales_and_marketing?: boolean
    is_support?: boolean
    is_management?: boolean
    is_it?: boolean
    auth_user?: boolean | internal$auth_userArgs<ExtArgs>
    book_approval?: boolean | internal$book_approvalArgs<ExtArgs>
    auth_account?: boolean | internal$auth_accountArgs<ExtArgs>
    _count?: boolean | InternalCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["internal"]>

  export type internalSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    id_account?: boolean
    name?: boolean
    is_sales_and_marketing?: boolean
    is_support?: boolean
    is_management?: boolean
    is_it?: boolean
    auth_account?: boolean | internal$auth_accountArgs<ExtArgs>
  }, ExtArgs["result"]["internal"]>

  export type internalSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    id_account?: boolean
    name?: boolean
    is_sales_and_marketing?: boolean
    is_support?: boolean
    is_management?: boolean
    is_it?: boolean
    auth_account?: boolean | internal$auth_accountArgs<ExtArgs>
  }, ExtArgs["result"]["internal"]>

  export type internalSelectScalar = {
    id?: boolean
    id_account?: boolean
    name?: boolean
    is_sales_and_marketing?: boolean
    is_support?: boolean
    is_management?: boolean
    is_it?: boolean
  }

  export type internalOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "id_account" | "name" | "is_sales_and_marketing" | "is_support" | "is_management" | "is_it", ExtArgs["result"]["internal"]>
  export type internalInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    auth_user?: boolean | internal$auth_userArgs<ExtArgs>
    book_approval?: boolean | internal$book_approvalArgs<ExtArgs>
    auth_account?: boolean | internal$auth_accountArgs<ExtArgs>
    _count?: boolean | InternalCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type internalIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    auth_account?: boolean | internal$auth_accountArgs<ExtArgs>
  }
  export type internalIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    auth_account?: boolean | internal$auth_accountArgs<ExtArgs>
  }

  export type $internalPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "internal"
    objects: {
      auth_user: Prisma.$auth_userPayload<ExtArgs>[]
      book_approval: Prisma.$book_approvalPayload<ExtArgs>[]
      auth_account: Prisma.$auth_accountPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      id_account: string | null
      name: string
      is_sales_and_marketing: boolean
      is_support: boolean
      is_management: boolean
      is_it: boolean
    }, ExtArgs["result"]["internal"]>
    composites: {}
  }

  type internalGetPayload<S extends boolean | null | undefined | internalDefaultArgs> = $Result.GetResult<Prisma.$internalPayload, S>

  type internalCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<internalFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InternalCountAggregateInputType | true
    }

  export interface internalDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['internal'], meta: { name: 'internal' } }
    /**
     * Find zero or one Internal that matches the filter.
     * @param {internalFindUniqueArgs} args - Arguments to find a Internal
     * @example
     * // Get one Internal
     * const internal = await prisma.internal.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends internalFindUniqueArgs>(args: SelectSubset<T, internalFindUniqueArgs<ExtArgs>>): Prisma__internalClient<$Result.GetResult<Prisma.$internalPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Internal that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {internalFindUniqueOrThrowArgs} args - Arguments to find a Internal
     * @example
     * // Get one Internal
     * const internal = await prisma.internal.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends internalFindUniqueOrThrowArgs>(args: SelectSubset<T, internalFindUniqueOrThrowArgs<ExtArgs>>): Prisma__internalClient<$Result.GetResult<Prisma.$internalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Internal that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {internalFindFirstArgs} args - Arguments to find a Internal
     * @example
     * // Get one Internal
     * const internal = await prisma.internal.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends internalFindFirstArgs>(args?: SelectSubset<T, internalFindFirstArgs<ExtArgs>>): Prisma__internalClient<$Result.GetResult<Prisma.$internalPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Internal that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {internalFindFirstOrThrowArgs} args - Arguments to find a Internal
     * @example
     * // Get one Internal
     * const internal = await prisma.internal.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends internalFindFirstOrThrowArgs>(args?: SelectSubset<T, internalFindFirstOrThrowArgs<ExtArgs>>): Prisma__internalClient<$Result.GetResult<Prisma.$internalPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Internals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {internalFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Internals
     * const internals = await prisma.internal.findMany()
     * 
     * // Get first 10 Internals
     * const internals = await prisma.internal.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const internalWithIdOnly = await prisma.internal.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends internalFindManyArgs>(args?: SelectSubset<T, internalFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$internalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Internal.
     * @param {internalCreateArgs} args - Arguments to create a Internal.
     * @example
     * // Create one Internal
     * const Internal = await prisma.internal.create({
     *   data: {
     *     // ... data to create a Internal
     *   }
     * })
     * 
     */
    create<T extends internalCreateArgs>(args: SelectSubset<T, internalCreateArgs<ExtArgs>>): Prisma__internalClient<$Result.GetResult<Prisma.$internalPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Internals.
     * @param {internalCreateManyArgs} args - Arguments to create many Internals.
     * @example
     * // Create many Internals
     * const internal = await prisma.internal.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends internalCreateManyArgs>(args?: SelectSubset<T, internalCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Internals and returns the data saved in the database.
     * @param {internalCreateManyAndReturnArgs} args - Arguments to create many Internals.
     * @example
     * // Create many Internals
     * const internal = await prisma.internal.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Internals and only return the `id`
     * const internalWithIdOnly = await prisma.internal.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends internalCreateManyAndReturnArgs>(args?: SelectSubset<T, internalCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$internalPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Internal.
     * @param {internalDeleteArgs} args - Arguments to delete one Internal.
     * @example
     * // Delete one Internal
     * const Internal = await prisma.internal.delete({
     *   where: {
     *     // ... filter to delete one Internal
     *   }
     * })
     * 
     */
    delete<T extends internalDeleteArgs>(args: SelectSubset<T, internalDeleteArgs<ExtArgs>>): Prisma__internalClient<$Result.GetResult<Prisma.$internalPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Internal.
     * @param {internalUpdateArgs} args - Arguments to update one Internal.
     * @example
     * // Update one Internal
     * const internal = await prisma.internal.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends internalUpdateArgs>(args: SelectSubset<T, internalUpdateArgs<ExtArgs>>): Prisma__internalClient<$Result.GetResult<Prisma.$internalPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Internals.
     * @param {internalDeleteManyArgs} args - Arguments to filter Internals to delete.
     * @example
     * // Delete a few Internals
     * const { count } = await prisma.internal.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends internalDeleteManyArgs>(args?: SelectSubset<T, internalDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Internals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {internalUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Internals
     * const internal = await prisma.internal.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends internalUpdateManyArgs>(args: SelectSubset<T, internalUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Internals and returns the data updated in the database.
     * @param {internalUpdateManyAndReturnArgs} args - Arguments to update many Internals.
     * @example
     * // Update many Internals
     * const internal = await prisma.internal.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Internals and only return the `id`
     * const internalWithIdOnly = await prisma.internal.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends internalUpdateManyAndReturnArgs>(args: SelectSubset<T, internalUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$internalPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Internal.
     * @param {internalUpsertArgs} args - Arguments to update or create a Internal.
     * @example
     * // Update or create a Internal
     * const internal = await prisma.internal.upsert({
     *   create: {
     *     // ... data to create a Internal
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Internal we want to update
     *   }
     * })
     */
    upsert<T extends internalUpsertArgs>(args: SelectSubset<T, internalUpsertArgs<ExtArgs>>): Prisma__internalClient<$Result.GetResult<Prisma.$internalPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Internals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {internalCountArgs} args - Arguments to filter Internals to count.
     * @example
     * // Count the number of Internals
     * const count = await prisma.internal.count({
     *   where: {
     *     // ... the filter for the Internals we want to count
     *   }
     * })
    **/
    count<T extends internalCountArgs>(
      args?: Subset<T, internalCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InternalCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Internal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InternalAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InternalAggregateArgs>(args: Subset<T, InternalAggregateArgs>): Prisma.PrismaPromise<GetInternalAggregateType<T>>

    /**
     * Group by Internal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {internalGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends internalGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: internalGroupByArgs['orderBy'] }
        : { orderBy?: internalGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, internalGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInternalGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the internal model
   */
  readonly fields: internalFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for internal.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__internalClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    auth_user<T extends internal$auth_userArgs<ExtArgs> = {}>(args?: Subset<T, internal$auth_userArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$auth_userPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    book_approval<T extends internal$book_approvalArgs<ExtArgs> = {}>(args?: Subset<T, internal$book_approvalArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$book_approvalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    auth_account<T extends internal$auth_accountArgs<ExtArgs> = {}>(args?: Subset<T, internal$auth_accountArgs<ExtArgs>>): Prisma__auth_accountClient<$Result.GetResult<Prisma.$auth_accountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the internal model
   */
  interface internalFieldRefs {
    readonly id: FieldRef<"internal", 'String'>
    readonly id_account: FieldRef<"internal", 'String'>
    readonly name: FieldRef<"internal", 'String'>
    readonly is_sales_and_marketing: FieldRef<"internal", 'Boolean'>
    readonly is_support: FieldRef<"internal", 'Boolean'>
    readonly is_management: FieldRef<"internal", 'Boolean'>
    readonly is_it: FieldRef<"internal", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * internal findUnique
   */
  export type internalFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the internal
     */
    select?: internalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the internal
     */
    omit?: internalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: internalInclude<ExtArgs> | null
    /**
     * Filter, which internal to fetch.
     */
    where: internalWhereUniqueInput
  }

  /**
   * internal findUniqueOrThrow
   */
  export type internalFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the internal
     */
    select?: internalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the internal
     */
    omit?: internalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: internalInclude<ExtArgs> | null
    /**
     * Filter, which internal to fetch.
     */
    where: internalWhereUniqueInput
  }

  /**
   * internal findFirst
   */
  export type internalFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the internal
     */
    select?: internalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the internal
     */
    omit?: internalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: internalInclude<ExtArgs> | null
    /**
     * Filter, which internal to fetch.
     */
    where?: internalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of internals to fetch.
     */
    orderBy?: internalOrderByWithRelationInput | internalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for internals.
     */
    cursor?: internalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` internals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` internals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of internals.
     */
    distinct?: InternalScalarFieldEnum | InternalScalarFieldEnum[]
  }

  /**
   * internal findFirstOrThrow
   */
  export type internalFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the internal
     */
    select?: internalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the internal
     */
    omit?: internalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: internalInclude<ExtArgs> | null
    /**
     * Filter, which internal to fetch.
     */
    where?: internalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of internals to fetch.
     */
    orderBy?: internalOrderByWithRelationInput | internalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for internals.
     */
    cursor?: internalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` internals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` internals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of internals.
     */
    distinct?: InternalScalarFieldEnum | InternalScalarFieldEnum[]
  }

  /**
   * internal findMany
   */
  export type internalFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the internal
     */
    select?: internalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the internal
     */
    omit?: internalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: internalInclude<ExtArgs> | null
    /**
     * Filter, which internals to fetch.
     */
    where?: internalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of internals to fetch.
     */
    orderBy?: internalOrderByWithRelationInput | internalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing internals.
     */
    cursor?: internalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` internals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` internals.
     */
    skip?: number
    distinct?: InternalScalarFieldEnum | InternalScalarFieldEnum[]
  }

  /**
   * internal create
   */
  export type internalCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the internal
     */
    select?: internalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the internal
     */
    omit?: internalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: internalInclude<ExtArgs> | null
    /**
     * The data needed to create a internal.
     */
    data: XOR<internalCreateInput, internalUncheckedCreateInput>
  }

  /**
   * internal createMany
   */
  export type internalCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many internals.
     */
    data: internalCreateManyInput | internalCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * internal createManyAndReturn
   */
  export type internalCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the internal
     */
    select?: internalSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the internal
     */
    omit?: internalOmit<ExtArgs> | null
    /**
     * The data used to create many internals.
     */
    data: internalCreateManyInput | internalCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: internalIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * internal update
   */
  export type internalUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the internal
     */
    select?: internalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the internal
     */
    omit?: internalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: internalInclude<ExtArgs> | null
    /**
     * The data needed to update a internal.
     */
    data: XOR<internalUpdateInput, internalUncheckedUpdateInput>
    /**
     * Choose, which internal to update.
     */
    where: internalWhereUniqueInput
  }

  /**
   * internal updateMany
   */
  export type internalUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update internals.
     */
    data: XOR<internalUpdateManyMutationInput, internalUncheckedUpdateManyInput>
    /**
     * Filter which internals to update
     */
    where?: internalWhereInput
    /**
     * Limit how many internals to update.
     */
    limit?: number
  }

  /**
   * internal updateManyAndReturn
   */
  export type internalUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the internal
     */
    select?: internalSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the internal
     */
    omit?: internalOmit<ExtArgs> | null
    /**
     * The data used to update internals.
     */
    data: XOR<internalUpdateManyMutationInput, internalUncheckedUpdateManyInput>
    /**
     * Filter which internals to update
     */
    where?: internalWhereInput
    /**
     * Limit how many internals to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: internalIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * internal upsert
   */
  export type internalUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the internal
     */
    select?: internalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the internal
     */
    omit?: internalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: internalInclude<ExtArgs> | null
    /**
     * The filter to search for the internal to update in case it exists.
     */
    where: internalWhereUniqueInput
    /**
     * In case the internal found by the `where` argument doesn't exist, create a new internal with this data.
     */
    create: XOR<internalCreateInput, internalUncheckedCreateInput>
    /**
     * In case the internal was found with the provided `where` argument, update it with this data.
     */
    update: XOR<internalUpdateInput, internalUncheckedUpdateInput>
  }

  /**
   * internal delete
   */
  export type internalDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the internal
     */
    select?: internalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the internal
     */
    omit?: internalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: internalInclude<ExtArgs> | null
    /**
     * Filter which internal to delete.
     */
    where: internalWhereUniqueInput
  }

  /**
   * internal deleteMany
   */
  export type internalDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which internals to delete
     */
    where?: internalWhereInput
    /**
     * Limit how many internals to delete.
     */
    limit?: number
  }

  /**
   * internal.auth_user
   */
  export type internal$auth_userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auth_user
     */
    select?: auth_userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the auth_user
     */
    omit?: auth_userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auth_userInclude<ExtArgs> | null
    where?: auth_userWhereInput
    orderBy?: auth_userOrderByWithRelationInput | auth_userOrderByWithRelationInput[]
    cursor?: auth_userWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Auth_userScalarFieldEnum | Auth_userScalarFieldEnum[]
  }

  /**
   * internal.book_approval
   */
  export type internal$book_approvalArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the book_approval
     */
    select?: book_approvalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the book_approval
     */
    omit?: book_approvalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: book_approvalInclude<ExtArgs> | null
    where?: book_approvalWhereInput
    orderBy?: book_approvalOrderByWithRelationInput | book_approvalOrderByWithRelationInput[]
    cursor?: book_approvalWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Book_approvalScalarFieldEnum | Book_approvalScalarFieldEnum[]
  }

  /**
   * internal.auth_account
   */
  export type internal$auth_accountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auth_account
     */
    select?: auth_accountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the auth_account
     */
    omit?: auth_accountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auth_accountInclude<ExtArgs> | null
    where?: auth_accountWhereInput
  }

  /**
   * internal without action
   */
  export type internalDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the internal
     */
    select?: internalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the internal
     */
    omit?: internalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: internalInclude<ExtArgs> | null
  }


  /**
   * Model landing
   */

  export type AggregateLanding = {
    _count: LandingCountAggregateOutputType | null
    _avg: LandingAvgAggregateOutputType | null
    _sum: LandingSumAggregateOutputType | null
    _min: LandingMinAggregateOutputType | null
    _max: LandingMaxAggregateOutputType | null
  }

  export type LandingAvgAggregateOutputType = {
    views: number | null
  }

  export type LandingSumAggregateOutputType = {
    views: number | null
  }

  export type LandingMinAggregateOutputType = {
    id: string | null
    slug: string | null
    views: number | null
    deleted_at: Date | null
    status: string | null
    title: string | null
  }

  export type LandingMaxAggregateOutputType = {
    id: string | null
    slug: string | null
    views: number | null
    deleted_at: Date | null
    status: string | null
    title: string | null
  }

  export type LandingCountAggregateOutputType = {
    id: number
    slug: number
    views: number
    deleted_at: number
    status: number
    title: number
    _all: number
  }


  export type LandingAvgAggregateInputType = {
    views?: true
  }

  export type LandingSumAggregateInputType = {
    views?: true
  }

  export type LandingMinAggregateInputType = {
    id?: true
    slug?: true
    views?: true
    deleted_at?: true
    status?: true
    title?: true
  }

  export type LandingMaxAggregateInputType = {
    id?: true
    slug?: true
    views?: true
    deleted_at?: true
    status?: true
    title?: true
  }

  export type LandingCountAggregateInputType = {
    id?: true
    slug?: true
    views?: true
    deleted_at?: true
    status?: true
    title?: true
    _all?: true
  }

  export type LandingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which landing to aggregate.
     */
    where?: landingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of landings to fetch.
     */
    orderBy?: landingOrderByWithRelationInput | landingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: landingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` landings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` landings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned landings
    **/
    _count?: true | LandingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LandingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LandingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LandingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LandingMaxAggregateInputType
  }

  export type GetLandingAggregateType<T extends LandingAggregateArgs> = {
        [P in keyof T & keyof AggregateLanding]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLanding[P]>
      : GetScalarType<T[P], AggregateLanding[P]>
  }




  export type landingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: landingWhereInput
    orderBy?: landingOrderByWithAggregationInput | landingOrderByWithAggregationInput[]
    by: LandingScalarFieldEnum[] | LandingScalarFieldEnum
    having?: landingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LandingCountAggregateInputType | true
    _avg?: LandingAvgAggregateInputType
    _sum?: LandingSumAggregateInputType
    _min?: LandingMinAggregateInputType
    _max?: LandingMaxAggregateInputType
  }

  export type LandingGroupByOutputType = {
    id: string
    slug: string
    views: number
    deleted_at: Date | null
    status: string
    title: string
    _count: LandingCountAggregateOutputType | null
    _avg: LandingAvgAggregateOutputType | null
    _sum: LandingSumAggregateOutputType | null
    _min: LandingMinAggregateOutputType | null
    _max: LandingMaxAggregateOutputType | null
  }

  type GetLandingGroupByPayload<T extends landingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LandingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LandingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LandingGroupByOutputType[P]>
            : GetScalarType<T[P], LandingGroupByOutputType[P]>
        }
      >
    >


  export type landingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    slug?: boolean
    views?: boolean
    deleted_at?: boolean
    status?: boolean
    title?: boolean
    landing_items?: boolean | landing$landing_itemsArgs<ExtArgs>
    _count?: boolean | LandingCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["landing"]>

  export type landingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    slug?: boolean
    views?: boolean
    deleted_at?: boolean
    status?: boolean
    title?: boolean
  }, ExtArgs["result"]["landing"]>

  export type landingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    slug?: boolean
    views?: boolean
    deleted_at?: boolean
    status?: boolean
    title?: boolean
  }, ExtArgs["result"]["landing"]>

  export type landingSelectScalar = {
    id?: boolean
    slug?: boolean
    views?: boolean
    deleted_at?: boolean
    status?: boolean
    title?: boolean
  }

  export type landingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "slug" | "views" | "deleted_at" | "status" | "title", ExtArgs["result"]["landing"]>
  export type landingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    landing_items?: boolean | landing$landing_itemsArgs<ExtArgs>
    _count?: boolean | LandingCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type landingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type landingIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $landingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "landing"
    objects: {
      landing_items: Prisma.$landing_itemsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      slug: string
      views: number
      deleted_at: Date | null
      status: string
      title: string
    }, ExtArgs["result"]["landing"]>
    composites: {}
  }

  type landingGetPayload<S extends boolean | null | undefined | landingDefaultArgs> = $Result.GetResult<Prisma.$landingPayload, S>

  type landingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<landingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LandingCountAggregateInputType | true
    }

  export interface landingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['landing'], meta: { name: 'landing' } }
    /**
     * Find zero or one Landing that matches the filter.
     * @param {landingFindUniqueArgs} args - Arguments to find a Landing
     * @example
     * // Get one Landing
     * const landing = await prisma.landing.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends landingFindUniqueArgs>(args: SelectSubset<T, landingFindUniqueArgs<ExtArgs>>): Prisma__landingClient<$Result.GetResult<Prisma.$landingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Landing that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {landingFindUniqueOrThrowArgs} args - Arguments to find a Landing
     * @example
     * // Get one Landing
     * const landing = await prisma.landing.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends landingFindUniqueOrThrowArgs>(args: SelectSubset<T, landingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__landingClient<$Result.GetResult<Prisma.$landingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Landing that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {landingFindFirstArgs} args - Arguments to find a Landing
     * @example
     * // Get one Landing
     * const landing = await prisma.landing.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends landingFindFirstArgs>(args?: SelectSubset<T, landingFindFirstArgs<ExtArgs>>): Prisma__landingClient<$Result.GetResult<Prisma.$landingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Landing that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {landingFindFirstOrThrowArgs} args - Arguments to find a Landing
     * @example
     * // Get one Landing
     * const landing = await prisma.landing.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends landingFindFirstOrThrowArgs>(args?: SelectSubset<T, landingFindFirstOrThrowArgs<ExtArgs>>): Prisma__landingClient<$Result.GetResult<Prisma.$landingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Landings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {landingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Landings
     * const landings = await prisma.landing.findMany()
     * 
     * // Get first 10 Landings
     * const landings = await prisma.landing.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const landingWithIdOnly = await prisma.landing.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends landingFindManyArgs>(args?: SelectSubset<T, landingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$landingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Landing.
     * @param {landingCreateArgs} args - Arguments to create a Landing.
     * @example
     * // Create one Landing
     * const Landing = await prisma.landing.create({
     *   data: {
     *     // ... data to create a Landing
     *   }
     * })
     * 
     */
    create<T extends landingCreateArgs>(args: SelectSubset<T, landingCreateArgs<ExtArgs>>): Prisma__landingClient<$Result.GetResult<Prisma.$landingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Landings.
     * @param {landingCreateManyArgs} args - Arguments to create many Landings.
     * @example
     * // Create many Landings
     * const landing = await prisma.landing.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends landingCreateManyArgs>(args?: SelectSubset<T, landingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Landings and returns the data saved in the database.
     * @param {landingCreateManyAndReturnArgs} args - Arguments to create many Landings.
     * @example
     * // Create many Landings
     * const landing = await prisma.landing.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Landings and only return the `id`
     * const landingWithIdOnly = await prisma.landing.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends landingCreateManyAndReturnArgs>(args?: SelectSubset<T, landingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$landingPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Landing.
     * @param {landingDeleteArgs} args - Arguments to delete one Landing.
     * @example
     * // Delete one Landing
     * const Landing = await prisma.landing.delete({
     *   where: {
     *     // ... filter to delete one Landing
     *   }
     * })
     * 
     */
    delete<T extends landingDeleteArgs>(args: SelectSubset<T, landingDeleteArgs<ExtArgs>>): Prisma__landingClient<$Result.GetResult<Prisma.$landingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Landing.
     * @param {landingUpdateArgs} args - Arguments to update one Landing.
     * @example
     * // Update one Landing
     * const landing = await prisma.landing.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends landingUpdateArgs>(args: SelectSubset<T, landingUpdateArgs<ExtArgs>>): Prisma__landingClient<$Result.GetResult<Prisma.$landingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Landings.
     * @param {landingDeleteManyArgs} args - Arguments to filter Landings to delete.
     * @example
     * // Delete a few Landings
     * const { count } = await prisma.landing.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends landingDeleteManyArgs>(args?: SelectSubset<T, landingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Landings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {landingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Landings
     * const landing = await prisma.landing.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends landingUpdateManyArgs>(args: SelectSubset<T, landingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Landings and returns the data updated in the database.
     * @param {landingUpdateManyAndReturnArgs} args - Arguments to update many Landings.
     * @example
     * // Update many Landings
     * const landing = await prisma.landing.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Landings and only return the `id`
     * const landingWithIdOnly = await prisma.landing.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends landingUpdateManyAndReturnArgs>(args: SelectSubset<T, landingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$landingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Landing.
     * @param {landingUpsertArgs} args - Arguments to update or create a Landing.
     * @example
     * // Update or create a Landing
     * const landing = await prisma.landing.upsert({
     *   create: {
     *     // ... data to create a Landing
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Landing we want to update
     *   }
     * })
     */
    upsert<T extends landingUpsertArgs>(args: SelectSubset<T, landingUpsertArgs<ExtArgs>>): Prisma__landingClient<$Result.GetResult<Prisma.$landingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Landings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {landingCountArgs} args - Arguments to filter Landings to count.
     * @example
     * // Count the number of Landings
     * const count = await prisma.landing.count({
     *   where: {
     *     // ... the filter for the Landings we want to count
     *   }
     * })
    **/
    count<T extends landingCountArgs>(
      args?: Subset<T, landingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LandingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Landing.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LandingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LandingAggregateArgs>(args: Subset<T, LandingAggregateArgs>): Prisma.PrismaPromise<GetLandingAggregateType<T>>

    /**
     * Group by Landing.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {landingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends landingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: landingGroupByArgs['orderBy'] }
        : { orderBy?: landingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, landingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLandingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the landing model
   */
  readonly fields: landingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for landing.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__landingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    landing_items<T extends landing$landing_itemsArgs<ExtArgs> = {}>(args?: Subset<T, landing$landing_itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$landing_itemsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the landing model
   */
  interface landingFieldRefs {
    readonly id: FieldRef<"landing", 'String'>
    readonly slug: FieldRef<"landing", 'String'>
    readonly views: FieldRef<"landing", 'Int'>
    readonly deleted_at: FieldRef<"landing", 'DateTime'>
    readonly status: FieldRef<"landing", 'String'>
    readonly title: FieldRef<"landing", 'String'>
  }
    

  // Custom InputTypes
  /**
   * landing findUnique
   */
  export type landingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the landing
     */
    select?: landingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the landing
     */
    omit?: landingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: landingInclude<ExtArgs> | null
    /**
     * Filter, which landing to fetch.
     */
    where: landingWhereUniqueInput
  }

  /**
   * landing findUniqueOrThrow
   */
  export type landingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the landing
     */
    select?: landingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the landing
     */
    omit?: landingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: landingInclude<ExtArgs> | null
    /**
     * Filter, which landing to fetch.
     */
    where: landingWhereUniqueInput
  }

  /**
   * landing findFirst
   */
  export type landingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the landing
     */
    select?: landingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the landing
     */
    omit?: landingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: landingInclude<ExtArgs> | null
    /**
     * Filter, which landing to fetch.
     */
    where?: landingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of landings to fetch.
     */
    orderBy?: landingOrderByWithRelationInput | landingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for landings.
     */
    cursor?: landingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` landings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` landings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of landings.
     */
    distinct?: LandingScalarFieldEnum | LandingScalarFieldEnum[]
  }

  /**
   * landing findFirstOrThrow
   */
  export type landingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the landing
     */
    select?: landingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the landing
     */
    omit?: landingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: landingInclude<ExtArgs> | null
    /**
     * Filter, which landing to fetch.
     */
    where?: landingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of landings to fetch.
     */
    orderBy?: landingOrderByWithRelationInput | landingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for landings.
     */
    cursor?: landingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` landings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` landings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of landings.
     */
    distinct?: LandingScalarFieldEnum | LandingScalarFieldEnum[]
  }

  /**
   * landing findMany
   */
  export type landingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the landing
     */
    select?: landingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the landing
     */
    omit?: landingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: landingInclude<ExtArgs> | null
    /**
     * Filter, which landings to fetch.
     */
    where?: landingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of landings to fetch.
     */
    orderBy?: landingOrderByWithRelationInput | landingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing landings.
     */
    cursor?: landingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` landings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` landings.
     */
    skip?: number
    distinct?: LandingScalarFieldEnum | LandingScalarFieldEnum[]
  }

  /**
   * landing create
   */
  export type landingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the landing
     */
    select?: landingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the landing
     */
    omit?: landingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: landingInclude<ExtArgs> | null
    /**
     * The data needed to create a landing.
     */
    data: XOR<landingCreateInput, landingUncheckedCreateInput>
  }

  /**
   * landing createMany
   */
  export type landingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many landings.
     */
    data: landingCreateManyInput | landingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * landing createManyAndReturn
   */
  export type landingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the landing
     */
    select?: landingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the landing
     */
    omit?: landingOmit<ExtArgs> | null
    /**
     * The data used to create many landings.
     */
    data: landingCreateManyInput | landingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * landing update
   */
  export type landingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the landing
     */
    select?: landingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the landing
     */
    omit?: landingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: landingInclude<ExtArgs> | null
    /**
     * The data needed to update a landing.
     */
    data: XOR<landingUpdateInput, landingUncheckedUpdateInput>
    /**
     * Choose, which landing to update.
     */
    where: landingWhereUniqueInput
  }

  /**
   * landing updateMany
   */
  export type landingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update landings.
     */
    data: XOR<landingUpdateManyMutationInput, landingUncheckedUpdateManyInput>
    /**
     * Filter which landings to update
     */
    where?: landingWhereInput
    /**
     * Limit how many landings to update.
     */
    limit?: number
  }

  /**
   * landing updateManyAndReturn
   */
  export type landingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the landing
     */
    select?: landingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the landing
     */
    omit?: landingOmit<ExtArgs> | null
    /**
     * The data used to update landings.
     */
    data: XOR<landingUpdateManyMutationInput, landingUncheckedUpdateManyInput>
    /**
     * Filter which landings to update
     */
    where?: landingWhereInput
    /**
     * Limit how many landings to update.
     */
    limit?: number
  }

  /**
   * landing upsert
   */
  export type landingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the landing
     */
    select?: landingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the landing
     */
    omit?: landingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: landingInclude<ExtArgs> | null
    /**
     * The filter to search for the landing to update in case it exists.
     */
    where: landingWhereUniqueInput
    /**
     * In case the landing found by the `where` argument doesn't exist, create a new landing with this data.
     */
    create: XOR<landingCreateInput, landingUncheckedCreateInput>
    /**
     * In case the landing was found with the provided `where` argument, update it with this data.
     */
    update: XOR<landingUpdateInput, landingUncheckedUpdateInput>
  }

  /**
   * landing delete
   */
  export type landingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the landing
     */
    select?: landingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the landing
     */
    omit?: landingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: landingInclude<ExtArgs> | null
    /**
     * Filter which landing to delete.
     */
    where: landingWhereUniqueInput
  }

  /**
   * landing deleteMany
   */
  export type landingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which landings to delete
     */
    where?: landingWhereInput
    /**
     * Limit how many landings to delete.
     */
    limit?: number
  }

  /**
   * landing.landing_items
   */
  export type landing$landing_itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the landing_items
     */
    select?: landing_itemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the landing_items
     */
    omit?: landing_itemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: landing_itemsInclude<ExtArgs> | null
    where?: landing_itemsWhereInput
    orderBy?: landing_itemsOrderByWithRelationInput | landing_itemsOrderByWithRelationInput[]
    cursor?: landing_itemsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Landing_itemsScalarFieldEnum | Landing_itemsScalarFieldEnum[]
  }

  /**
   * landing without action
   */
  export type landingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the landing
     */
    select?: landingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the landing
     */
    omit?: landingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: landingInclude<ExtArgs> | null
  }


  /**
   * Model landing_items
   */

  export type AggregateLanding_items = {
    _count: Landing_itemsCountAggregateOutputType | null
    _avg: Landing_itemsAvgAggregateOutputType | null
    _sum: Landing_itemsSumAggregateOutputType | null
    _min: Landing_itemsMinAggregateOutputType | null
    _max: Landing_itemsMaxAggregateOutputType | null
  }

  export type Landing_itemsAvgAggregateOutputType = {
    idx: number | null
  }

  export type Landing_itemsSumAggregateOutputType = {
    idx: number | null
  }

  export type Landing_itemsMinAggregateOutputType = {
    id: string | null
    desc: string | null
    img_file: string | null
    tag: string | null
    link_to: string | null
    landing_id: string | null
    idx: number | null
    color: string | null
  }

  export type Landing_itemsMaxAggregateOutputType = {
    id: string | null
    desc: string | null
    img_file: string | null
    tag: string | null
    link_to: string | null
    landing_id: string | null
    idx: number | null
    color: string | null
  }

  export type Landing_itemsCountAggregateOutputType = {
    id: number
    desc: number
    img_file: number
    tag: number
    link_to: number
    landing_id: number
    idx: number
    color: number
    _all: number
  }


  export type Landing_itemsAvgAggregateInputType = {
    idx?: true
  }

  export type Landing_itemsSumAggregateInputType = {
    idx?: true
  }

  export type Landing_itemsMinAggregateInputType = {
    id?: true
    desc?: true
    img_file?: true
    tag?: true
    link_to?: true
    landing_id?: true
    idx?: true
    color?: true
  }

  export type Landing_itemsMaxAggregateInputType = {
    id?: true
    desc?: true
    img_file?: true
    tag?: true
    link_to?: true
    landing_id?: true
    idx?: true
    color?: true
  }

  export type Landing_itemsCountAggregateInputType = {
    id?: true
    desc?: true
    img_file?: true
    tag?: true
    link_to?: true
    landing_id?: true
    idx?: true
    color?: true
    _all?: true
  }

  export type Landing_itemsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which landing_items to aggregate.
     */
    where?: landing_itemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of landing_items to fetch.
     */
    orderBy?: landing_itemsOrderByWithRelationInput | landing_itemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: landing_itemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` landing_items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` landing_items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned landing_items
    **/
    _count?: true | Landing_itemsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Landing_itemsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Landing_itemsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Landing_itemsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Landing_itemsMaxAggregateInputType
  }

  export type GetLanding_itemsAggregateType<T extends Landing_itemsAggregateArgs> = {
        [P in keyof T & keyof AggregateLanding_items]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLanding_items[P]>
      : GetScalarType<T[P], AggregateLanding_items[P]>
  }




  export type landing_itemsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: landing_itemsWhereInput
    orderBy?: landing_itemsOrderByWithAggregationInput | landing_itemsOrderByWithAggregationInput[]
    by: Landing_itemsScalarFieldEnum[] | Landing_itemsScalarFieldEnum
    having?: landing_itemsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Landing_itemsCountAggregateInputType | true
    _avg?: Landing_itemsAvgAggregateInputType
    _sum?: Landing_itemsSumAggregateInputType
    _min?: Landing_itemsMinAggregateInputType
    _max?: Landing_itemsMaxAggregateInputType
  }

  export type Landing_itemsGroupByOutputType = {
    id: string
    desc: string
    img_file: string
    tag: string
    link_to: string
    landing_id: string
    idx: number
    color: string
    _count: Landing_itemsCountAggregateOutputType | null
    _avg: Landing_itemsAvgAggregateOutputType | null
    _sum: Landing_itemsSumAggregateOutputType | null
    _min: Landing_itemsMinAggregateOutputType | null
    _max: Landing_itemsMaxAggregateOutputType | null
  }

  type GetLanding_itemsGroupByPayload<T extends landing_itemsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Landing_itemsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Landing_itemsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Landing_itemsGroupByOutputType[P]>
            : GetScalarType<T[P], Landing_itemsGroupByOutputType[P]>
        }
      >
    >


  export type landing_itemsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    desc?: boolean
    img_file?: boolean
    tag?: boolean
    link_to?: boolean
    landing_id?: boolean
    idx?: boolean
    color?: boolean
    landing?: boolean | landingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["landing_items"]>

  export type landing_itemsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    desc?: boolean
    img_file?: boolean
    tag?: boolean
    link_to?: boolean
    landing_id?: boolean
    idx?: boolean
    color?: boolean
    landing?: boolean | landingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["landing_items"]>

  export type landing_itemsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    desc?: boolean
    img_file?: boolean
    tag?: boolean
    link_to?: boolean
    landing_id?: boolean
    idx?: boolean
    color?: boolean
    landing?: boolean | landingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["landing_items"]>

  export type landing_itemsSelectScalar = {
    id?: boolean
    desc?: boolean
    img_file?: boolean
    tag?: boolean
    link_to?: boolean
    landing_id?: boolean
    idx?: boolean
    color?: boolean
  }

  export type landing_itemsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "desc" | "img_file" | "tag" | "link_to" | "landing_id" | "idx" | "color", ExtArgs["result"]["landing_items"]>
  export type landing_itemsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    landing?: boolean | landingDefaultArgs<ExtArgs>
  }
  export type landing_itemsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    landing?: boolean | landingDefaultArgs<ExtArgs>
  }
  export type landing_itemsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    landing?: boolean | landingDefaultArgs<ExtArgs>
  }

  export type $landing_itemsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "landing_items"
    objects: {
      landing: Prisma.$landingPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      desc: string
      img_file: string
      tag: string
      link_to: string
      landing_id: string
      idx: number
      color: string
    }, ExtArgs["result"]["landing_items"]>
    composites: {}
  }

  type landing_itemsGetPayload<S extends boolean | null | undefined | landing_itemsDefaultArgs> = $Result.GetResult<Prisma.$landing_itemsPayload, S>

  type landing_itemsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<landing_itemsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Landing_itemsCountAggregateInputType | true
    }

  export interface landing_itemsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['landing_items'], meta: { name: 'landing_items' } }
    /**
     * Find zero or one Landing_items that matches the filter.
     * @param {landing_itemsFindUniqueArgs} args - Arguments to find a Landing_items
     * @example
     * // Get one Landing_items
     * const landing_items = await prisma.landing_items.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends landing_itemsFindUniqueArgs>(args: SelectSubset<T, landing_itemsFindUniqueArgs<ExtArgs>>): Prisma__landing_itemsClient<$Result.GetResult<Prisma.$landing_itemsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Landing_items that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {landing_itemsFindUniqueOrThrowArgs} args - Arguments to find a Landing_items
     * @example
     * // Get one Landing_items
     * const landing_items = await prisma.landing_items.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends landing_itemsFindUniqueOrThrowArgs>(args: SelectSubset<T, landing_itemsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__landing_itemsClient<$Result.GetResult<Prisma.$landing_itemsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Landing_items that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {landing_itemsFindFirstArgs} args - Arguments to find a Landing_items
     * @example
     * // Get one Landing_items
     * const landing_items = await prisma.landing_items.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends landing_itemsFindFirstArgs>(args?: SelectSubset<T, landing_itemsFindFirstArgs<ExtArgs>>): Prisma__landing_itemsClient<$Result.GetResult<Prisma.$landing_itemsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Landing_items that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {landing_itemsFindFirstOrThrowArgs} args - Arguments to find a Landing_items
     * @example
     * // Get one Landing_items
     * const landing_items = await prisma.landing_items.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends landing_itemsFindFirstOrThrowArgs>(args?: SelectSubset<T, landing_itemsFindFirstOrThrowArgs<ExtArgs>>): Prisma__landing_itemsClient<$Result.GetResult<Prisma.$landing_itemsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Landing_items that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {landing_itemsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Landing_items
     * const landing_items = await prisma.landing_items.findMany()
     * 
     * // Get first 10 Landing_items
     * const landing_items = await prisma.landing_items.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const landing_itemsWithIdOnly = await prisma.landing_items.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends landing_itemsFindManyArgs>(args?: SelectSubset<T, landing_itemsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$landing_itemsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Landing_items.
     * @param {landing_itemsCreateArgs} args - Arguments to create a Landing_items.
     * @example
     * // Create one Landing_items
     * const Landing_items = await prisma.landing_items.create({
     *   data: {
     *     // ... data to create a Landing_items
     *   }
     * })
     * 
     */
    create<T extends landing_itemsCreateArgs>(args: SelectSubset<T, landing_itemsCreateArgs<ExtArgs>>): Prisma__landing_itemsClient<$Result.GetResult<Prisma.$landing_itemsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Landing_items.
     * @param {landing_itemsCreateManyArgs} args - Arguments to create many Landing_items.
     * @example
     * // Create many Landing_items
     * const landing_items = await prisma.landing_items.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends landing_itemsCreateManyArgs>(args?: SelectSubset<T, landing_itemsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Landing_items and returns the data saved in the database.
     * @param {landing_itemsCreateManyAndReturnArgs} args - Arguments to create many Landing_items.
     * @example
     * // Create many Landing_items
     * const landing_items = await prisma.landing_items.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Landing_items and only return the `id`
     * const landing_itemsWithIdOnly = await prisma.landing_items.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends landing_itemsCreateManyAndReturnArgs>(args?: SelectSubset<T, landing_itemsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$landing_itemsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Landing_items.
     * @param {landing_itemsDeleteArgs} args - Arguments to delete one Landing_items.
     * @example
     * // Delete one Landing_items
     * const Landing_items = await prisma.landing_items.delete({
     *   where: {
     *     // ... filter to delete one Landing_items
     *   }
     * })
     * 
     */
    delete<T extends landing_itemsDeleteArgs>(args: SelectSubset<T, landing_itemsDeleteArgs<ExtArgs>>): Prisma__landing_itemsClient<$Result.GetResult<Prisma.$landing_itemsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Landing_items.
     * @param {landing_itemsUpdateArgs} args - Arguments to update one Landing_items.
     * @example
     * // Update one Landing_items
     * const landing_items = await prisma.landing_items.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends landing_itemsUpdateArgs>(args: SelectSubset<T, landing_itemsUpdateArgs<ExtArgs>>): Prisma__landing_itemsClient<$Result.GetResult<Prisma.$landing_itemsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Landing_items.
     * @param {landing_itemsDeleteManyArgs} args - Arguments to filter Landing_items to delete.
     * @example
     * // Delete a few Landing_items
     * const { count } = await prisma.landing_items.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends landing_itemsDeleteManyArgs>(args?: SelectSubset<T, landing_itemsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Landing_items.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {landing_itemsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Landing_items
     * const landing_items = await prisma.landing_items.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends landing_itemsUpdateManyArgs>(args: SelectSubset<T, landing_itemsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Landing_items and returns the data updated in the database.
     * @param {landing_itemsUpdateManyAndReturnArgs} args - Arguments to update many Landing_items.
     * @example
     * // Update many Landing_items
     * const landing_items = await prisma.landing_items.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Landing_items and only return the `id`
     * const landing_itemsWithIdOnly = await prisma.landing_items.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends landing_itemsUpdateManyAndReturnArgs>(args: SelectSubset<T, landing_itemsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$landing_itemsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Landing_items.
     * @param {landing_itemsUpsertArgs} args - Arguments to update or create a Landing_items.
     * @example
     * // Update or create a Landing_items
     * const landing_items = await prisma.landing_items.upsert({
     *   create: {
     *     // ... data to create a Landing_items
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Landing_items we want to update
     *   }
     * })
     */
    upsert<T extends landing_itemsUpsertArgs>(args: SelectSubset<T, landing_itemsUpsertArgs<ExtArgs>>): Prisma__landing_itemsClient<$Result.GetResult<Prisma.$landing_itemsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Landing_items.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {landing_itemsCountArgs} args - Arguments to filter Landing_items to count.
     * @example
     * // Count the number of Landing_items
     * const count = await prisma.landing_items.count({
     *   where: {
     *     // ... the filter for the Landing_items we want to count
     *   }
     * })
    **/
    count<T extends landing_itemsCountArgs>(
      args?: Subset<T, landing_itemsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Landing_itemsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Landing_items.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Landing_itemsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Landing_itemsAggregateArgs>(args: Subset<T, Landing_itemsAggregateArgs>): Prisma.PrismaPromise<GetLanding_itemsAggregateType<T>>

    /**
     * Group by Landing_items.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {landing_itemsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends landing_itemsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: landing_itemsGroupByArgs['orderBy'] }
        : { orderBy?: landing_itemsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, landing_itemsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLanding_itemsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the landing_items model
   */
  readonly fields: landing_itemsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for landing_items.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__landing_itemsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    landing<T extends landingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, landingDefaultArgs<ExtArgs>>): Prisma__landingClient<$Result.GetResult<Prisma.$landingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the landing_items model
   */
  interface landing_itemsFieldRefs {
    readonly id: FieldRef<"landing_items", 'String'>
    readonly desc: FieldRef<"landing_items", 'String'>
    readonly img_file: FieldRef<"landing_items", 'String'>
    readonly tag: FieldRef<"landing_items", 'String'>
    readonly link_to: FieldRef<"landing_items", 'String'>
    readonly landing_id: FieldRef<"landing_items", 'String'>
    readonly idx: FieldRef<"landing_items", 'Int'>
    readonly color: FieldRef<"landing_items", 'String'>
  }
    

  // Custom InputTypes
  /**
   * landing_items findUnique
   */
  export type landing_itemsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the landing_items
     */
    select?: landing_itemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the landing_items
     */
    omit?: landing_itemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: landing_itemsInclude<ExtArgs> | null
    /**
     * Filter, which landing_items to fetch.
     */
    where: landing_itemsWhereUniqueInput
  }

  /**
   * landing_items findUniqueOrThrow
   */
  export type landing_itemsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the landing_items
     */
    select?: landing_itemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the landing_items
     */
    omit?: landing_itemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: landing_itemsInclude<ExtArgs> | null
    /**
     * Filter, which landing_items to fetch.
     */
    where: landing_itemsWhereUniqueInput
  }

  /**
   * landing_items findFirst
   */
  export type landing_itemsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the landing_items
     */
    select?: landing_itemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the landing_items
     */
    omit?: landing_itemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: landing_itemsInclude<ExtArgs> | null
    /**
     * Filter, which landing_items to fetch.
     */
    where?: landing_itemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of landing_items to fetch.
     */
    orderBy?: landing_itemsOrderByWithRelationInput | landing_itemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for landing_items.
     */
    cursor?: landing_itemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` landing_items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` landing_items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of landing_items.
     */
    distinct?: Landing_itemsScalarFieldEnum | Landing_itemsScalarFieldEnum[]
  }

  /**
   * landing_items findFirstOrThrow
   */
  export type landing_itemsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the landing_items
     */
    select?: landing_itemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the landing_items
     */
    omit?: landing_itemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: landing_itemsInclude<ExtArgs> | null
    /**
     * Filter, which landing_items to fetch.
     */
    where?: landing_itemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of landing_items to fetch.
     */
    orderBy?: landing_itemsOrderByWithRelationInput | landing_itemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for landing_items.
     */
    cursor?: landing_itemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` landing_items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` landing_items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of landing_items.
     */
    distinct?: Landing_itemsScalarFieldEnum | Landing_itemsScalarFieldEnum[]
  }

  /**
   * landing_items findMany
   */
  export type landing_itemsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the landing_items
     */
    select?: landing_itemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the landing_items
     */
    omit?: landing_itemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: landing_itemsInclude<ExtArgs> | null
    /**
     * Filter, which landing_items to fetch.
     */
    where?: landing_itemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of landing_items to fetch.
     */
    orderBy?: landing_itemsOrderByWithRelationInput | landing_itemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing landing_items.
     */
    cursor?: landing_itemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` landing_items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` landing_items.
     */
    skip?: number
    distinct?: Landing_itemsScalarFieldEnum | Landing_itemsScalarFieldEnum[]
  }

  /**
   * landing_items create
   */
  export type landing_itemsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the landing_items
     */
    select?: landing_itemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the landing_items
     */
    omit?: landing_itemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: landing_itemsInclude<ExtArgs> | null
    /**
     * The data needed to create a landing_items.
     */
    data: XOR<landing_itemsCreateInput, landing_itemsUncheckedCreateInput>
  }

  /**
   * landing_items createMany
   */
  export type landing_itemsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many landing_items.
     */
    data: landing_itemsCreateManyInput | landing_itemsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * landing_items createManyAndReturn
   */
  export type landing_itemsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the landing_items
     */
    select?: landing_itemsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the landing_items
     */
    omit?: landing_itemsOmit<ExtArgs> | null
    /**
     * The data used to create many landing_items.
     */
    data: landing_itemsCreateManyInput | landing_itemsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: landing_itemsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * landing_items update
   */
  export type landing_itemsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the landing_items
     */
    select?: landing_itemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the landing_items
     */
    omit?: landing_itemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: landing_itemsInclude<ExtArgs> | null
    /**
     * The data needed to update a landing_items.
     */
    data: XOR<landing_itemsUpdateInput, landing_itemsUncheckedUpdateInput>
    /**
     * Choose, which landing_items to update.
     */
    where: landing_itemsWhereUniqueInput
  }

  /**
   * landing_items updateMany
   */
  export type landing_itemsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update landing_items.
     */
    data: XOR<landing_itemsUpdateManyMutationInput, landing_itemsUncheckedUpdateManyInput>
    /**
     * Filter which landing_items to update
     */
    where?: landing_itemsWhereInput
    /**
     * Limit how many landing_items to update.
     */
    limit?: number
  }

  /**
   * landing_items updateManyAndReturn
   */
  export type landing_itemsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the landing_items
     */
    select?: landing_itemsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the landing_items
     */
    omit?: landing_itemsOmit<ExtArgs> | null
    /**
     * The data used to update landing_items.
     */
    data: XOR<landing_itemsUpdateManyMutationInput, landing_itemsUncheckedUpdateManyInput>
    /**
     * Filter which landing_items to update
     */
    where?: landing_itemsWhereInput
    /**
     * Limit how many landing_items to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: landing_itemsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * landing_items upsert
   */
  export type landing_itemsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the landing_items
     */
    select?: landing_itemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the landing_items
     */
    omit?: landing_itemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: landing_itemsInclude<ExtArgs> | null
    /**
     * The filter to search for the landing_items to update in case it exists.
     */
    where: landing_itemsWhereUniqueInput
    /**
     * In case the landing_items found by the `where` argument doesn't exist, create a new landing_items with this data.
     */
    create: XOR<landing_itemsCreateInput, landing_itemsUncheckedCreateInput>
    /**
     * In case the landing_items was found with the provided `where` argument, update it with this data.
     */
    update: XOR<landing_itemsUpdateInput, landing_itemsUncheckedUpdateInput>
  }

  /**
   * landing_items delete
   */
  export type landing_itemsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the landing_items
     */
    select?: landing_itemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the landing_items
     */
    omit?: landing_itemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: landing_itemsInclude<ExtArgs> | null
    /**
     * Filter which landing_items to delete.
     */
    where: landing_itemsWhereUniqueInput
  }

  /**
   * landing_items deleteMany
   */
  export type landing_itemsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which landing_items to delete
     */
    where?: landing_itemsWhereInput
    /**
     * Limit how many landing_items to delete.
     */
    limit?: number
  }

  /**
   * landing_items without action
   */
  export type landing_itemsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the landing_items
     */
    select?: landing_itemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the landing_items
     */
    omit?: landing_itemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: landing_itemsInclude<ExtArgs> | null
  }


  /**
   * Model midtrx
   */

  export type AggregateMidtrx = {
    _count: MidtrxCountAggregateOutputType | null
    _min: MidtrxMinAggregateOutputType | null
    _max: MidtrxMaxAggregateOutputType | null
  }

  export type MidtrxMinAggregateOutputType = {
    id: string | null
    tz: Date | null
    type: string | null
  }

  export type MidtrxMaxAggregateOutputType = {
    id: string | null
    tz: Date | null
    type: string | null
  }

  export type MidtrxCountAggregateOutputType = {
    id: number
    tz: number
    type: number
    payload: number
    _all: number
  }


  export type MidtrxMinAggregateInputType = {
    id?: true
    tz?: true
    type?: true
  }

  export type MidtrxMaxAggregateInputType = {
    id?: true
    tz?: true
    type?: true
  }

  export type MidtrxCountAggregateInputType = {
    id?: true
    tz?: true
    type?: true
    payload?: true
    _all?: true
  }

  export type MidtrxAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which midtrx to aggregate.
     */
    where?: midtrxWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of midtrxes to fetch.
     */
    orderBy?: midtrxOrderByWithRelationInput | midtrxOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: midtrxWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` midtrxes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` midtrxes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned midtrxes
    **/
    _count?: true | MidtrxCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MidtrxMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MidtrxMaxAggregateInputType
  }

  export type GetMidtrxAggregateType<T extends MidtrxAggregateArgs> = {
        [P in keyof T & keyof AggregateMidtrx]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMidtrx[P]>
      : GetScalarType<T[P], AggregateMidtrx[P]>
  }




  export type midtrxGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: midtrxWhereInput
    orderBy?: midtrxOrderByWithAggregationInput | midtrxOrderByWithAggregationInput[]
    by: MidtrxScalarFieldEnum[] | MidtrxScalarFieldEnum
    having?: midtrxScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MidtrxCountAggregateInputType | true
    _min?: MidtrxMinAggregateInputType
    _max?: MidtrxMaxAggregateInputType
  }

  export type MidtrxGroupByOutputType = {
    id: string
    tz: Date
    type: string
    payload: JsonValue
    _count: MidtrxCountAggregateOutputType | null
    _min: MidtrxMinAggregateOutputType | null
    _max: MidtrxMaxAggregateOutputType | null
  }

  type GetMidtrxGroupByPayload<T extends midtrxGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MidtrxGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MidtrxGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MidtrxGroupByOutputType[P]>
            : GetScalarType<T[P], MidtrxGroupByOutputType[P]>
        }
      >
    >


  export type midtrxSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tz?: boolean
    type?: boolean
    payload?: boolean
  }, ExtArgs["result"]["midtrx"]>

  export type midtrxSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tz?: boolean
    type?: boolean
    payload?: boolean
  }, ExtArgs["result"]["midtrx"]>

  export type midtrxSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tz?: boolean
    type?: boolean
    payload?: boolean
  }, ExtArgs["result"]["midtrx"]>

  export type midtrxSelectScalar = {
    id?: boolean
    tz?: boolean
    type?: boolean
    payload?: boolean
  }

  export type midtrxOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tz" | "type" | "payload", ExtArgs["result"]["midtrx"]>

  export type $midtrxPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "midtrx"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tz: Date
      type: string
      payload: Prisma.JsonValue
    }, ExtArgs["result"]["midtrx"]>
    composites: {}
  }

  type midtrxGetPayload<S extends boolean | null | undefined | midtrxDefaultArgs> = $Result.GetResult<Prisma.$midtrxPayload, S>

  type midtrxCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<midtrxFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MidtrxCountAggregateInputType | true
    }

  export interface midtrxDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['midtrx'], meta: { name: 'midtrx' } }
    /**
     * Find zero or one Midtrx that matches the filter.
     * @param {midtrxFindUniqueArgs} args - Arguments to find a Midtrx
     * @example
     * // Get one Midtrx
     * const midtrx = await prisma.midtrx.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends midtrxFindUniqueArgs>(args: SelectSubset<T, midtrxFindUniqueArgs<ExtArgs>>): Prisma__midtrxClient<$Result.GetResult<Prisma.$midtrxPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Midtrx that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {midtrxFindUniqueOrThrowArgs} args - Arguments to find a Midtrx
     * @example
     * // Get one Midtrx
     * const midtrx = await prisma.midtrx.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends midtrxFindUniqueOrThrowArgs>(args: SelectSubset<T, midtrxFindUniqueOrThrowArgs<ExtArgs>>): Prisma__midtrxClient<$Result.GetResult<Prisma.$midtrxPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Midtrx that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {midtrxFindFirstArgs} args - Arguments to find a Midtrx
     * @example
     * // Get one Midtrx
     * const midtrx = await prisma.midtrx.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends midtrxFindFirstArgs>(args?: SelectSubset<T, midtrxFindFirstArgs<ExtArgs>>): Prisma__midtrxClient<$Result.GetResult<Prisma.$midtrxPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Midtrx that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {midtrxFindFirstOrThrowArgs} args - Arguments to find a Midtrx
     * @example
     * // Get one Midtrx
     * const midtrx = await prisma.midtrx.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends midtrxFindFirstOrThrowArgs>(args?: SelectSubset<T, midtrxFindFirstOrThrowArgs<ExtArgs>>): Prisma__midtrxClient<$Result.GetResult<Prisma.$midtrxPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Midtrxes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {midtrxFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Midtrxes
     * const midtrxes = await prisma.midtrx.findMany()
     * 
     * // Get first 10 Midtrxes
     * const midtrxes = await prisma.midtrx.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const midtrxWithIdOnly = await prisma.midtrx.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends midtrxFindManyArgs>(args?: SelectSubset<T, midtrxFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$midtrxPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Midtrx.
     * @param {midtrxCreateArgs} args - Arguments to create a Midtrx.
     * @example
     * // Create one Midtrx
     * const Midtrx = await prisma.midtrx.create({
     *   data: {
     *     // ... data to create a Midtrx
     *   }
     * })
     * 
     */
    create<T extends midtrxCreateArgs>(args: SelectSubset<T, midtrxCreateArgs<ExtArgs>>): Prisma__midtrxClient<$Result.GetResult<Prisma.$midtrxPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Midtrxes.
     * @param {midtrxCreateManyArgs} args - Arguments to create many Midtrxes.
     * @example
     * // Create many Midtrxes
     * const midtrx = await prisma.midtrx.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends midtrxCreateManyArgs>(args?: SelectSubset<T, midtrxCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Midtrxes and returns the data saved in the database.
     * @param {midtrxCreateManyAndReturnArgs} args - Arguments to create many Midtrxes.
     * @example
     * // Create many Midtrxes
     * const midtrx = await prisma.midtrx.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Midtrxes and only return the `id`
     * const midtrxWithIdOnly = await prisma.midtrx.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends midtrxCreateManyAndReturnArgs>(args?: SelectSubset<T, midtrxCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$midtrxPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Midtrx.
     * @param {midtrxDeleteArgs} args - Arguments to delete one Midtrx.
     * @example
     * // Delete one Midtrx
     * const Midtrx = await prisma.midtrx.delete({
     *   where: {
     *     // ... filter to delete one Midtrx
     *   }
     * })
     * 
     */
    delete<T extends midtrxDeleteArgs>(args: SelectSubset<T, midtrxDeleteArgs<ExtArgs>>): Prisma__midtrxClient<$Result.GetResult<Prisma.$midtrxPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Midtrx.
     * @param {midtrxUpdateArgs} args - Arguments to update one Midtrx.
     * @example
     * // Update one Midtrx
     * const midtrx = await prisma.midtrx.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends midtrxUpdateArgs>(args: SelectSubset<T, midtrxUpdateArgs<ExtArgs>>): Prisma__midtrxClient<$Result.GetResult<Prisma.$midtrxPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Midtrxes.
     * @param {midtrxDeleteManyArgs} args - Arguments to filter Midtrxes to delete.
     * @example
     * // Delete a few Midtrxes
     * const { count } = await prisma.midtrx.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends midtrxDeleteManyArgs>(args?: SelectSubset<T, midtrxDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Midtrxes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {midtrxUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Midtrxes
     * const midtrx = await prisma.midtrx.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends midtrxUpdateManyArgs>(args: SelectSubset<T, midtrxUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Midtrxes and returns the data updated in the database.
     * @param {midtrxUpdateManyAndReturnArgs} args - Arguments to update many Midtrxes.
     * @example
     * // Update many Midtrxes
     * const midtrx = await prisma.midtrx.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Midtrxes and only return the `id`
     * const midtrxWithIdOnly = await prisma.midtrx.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends midtrxUpdateManyAndReturnArgs>(args: SelectSubset<T, midtrxUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$midtrxPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Midtrx.
     * @param {midtrxUpsertArgs} args - Arguments to update or create a Midtrx.
     * @example
     * // Update or create a Midtrx
     * const midtrx = await prisma.midtrx.upsert({
     *   create: {
     *     // ... data to create a Midtrx
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Midtrx we want to update
     *   }
     * })
     */
    upsert<T extends midtrxUpsertArgs>(args: SelectSubset<T, midtrxUpsertArgs<ExtArgs>>): Prisma__midtrxClient<$Result.GetResult<Prisma.$midtrxPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Midtrxes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {midtrxCountArgs} args - Arguments to filter Midtrxes to count.
     * @example
     * // Count the number of Midtrxes
     * const count = await prisma.midtrx.count({
     *   where: {
     *     // ... the filter for the Midtrxes we want to count
     *   }
     * })
    **/
    count<T extends midtrxCountArgs>(
      args?: Subset<T, midtrxCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MidtrxCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Midtrx.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MidtrxAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MidtrxAggregateArgs>(args: Subset<T, MidtrxAggregateArgs>): Prisma.PrismaPromise<GetMidtrxAggregateType<T>>

    /**
     * Group by Midtrx.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {midtrxGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends midtrxGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: midtrxGroupByArgs['orderBy'] }
        : { orderBy?: midtrxGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, midtrxGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMidtrxGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the midtrx model
   */
  readonly fields: midtrxFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for midtrx.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__midtrxClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the midtrx model
   */
  interface midtrxFieldRefs {
    readonly id: FieldRef<"midtrx", 'String'>
    readonly tz: FieldRef<"midtrx", 'DateTime'>
    readonly type: FieldRef<"midtrx", 'String'>
    readonly payload: FieldRef<"midtrx", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * midtrx findUnique
   */
  export type midtrxFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the midtrx
     */
    select?: midtrxSelect<ExtArgs> | null
    /**
     * Omit specific fields from the midtrx
     */
    omit?: midtrxOmit<ExtArgs> | null
    /**
     * Filter, which midtrx to fetch.
     */
    where: midtrxWhereUniqueInput
  }

  /**
   * midtrx findUniqueOrThrow
   */
  export type midtrxFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the midtrx
     */
    select?: midtrxSelect<ExtArgs> | null
    /**
     * Omit specific fields from the midtrx
     */
    omit?: midtrxOmit<ExtArgs> | null
    /**
     * Filter, which midtrx to fetch.
     */
    where: midtrxWhereUniqueInput
  }

  /**
   * midtrx findFirst
   */
  export type midtrxFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the midtrx
     */
    select?: midtrxSelect<ExtArgs> | null
    /**
     * Omit specific fields from the midtrx
     */
    omit?: midtrxOmit<ExtArgs> | null
    /**
     * Filter, which midtrx to fetch.
     */
    where?: midtrxWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of midtrxes to fetch.
     */
    orderBy?: midtrxOrderByWithRelationInput | midtrxOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for midtrxes.
     */
    cursor?: midtrxWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` midtrxes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` midtrxes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of midtrxes.
     */
    distinct?: MidtrxScalarFieldEnum | MidtrxScalarFieldEnum[]
  }

  /**
   * midtrx findFirstOrThrow
   */
  export type midtrxFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the midtrx
     */
    select?: midtrxSelect<ExtArgs> | null
    /**
     * Omit specific fields from the midtrx
     */
    omit?: midtrxOmit<ExtArgs> | null
    /**
     * Filter, which midtrx to fetch.
     */
    where?: midtrxWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of midtrxes to fetch.
     */
    orderBy?: midtrxOrderByWithRelationInput | midtrxOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for midtrxes.
     */
    cursor?: midtrxWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` midtrxes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` midtrxes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of midtrxes.
     */
    distinct?: MidtrxScalarFieldEnum | MidtrxScalarFieldEnum[]
  }

  /**
   * midtrx findMany
   */
  export type midtrxFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the midtrx
     */
    select?: midtrxSelect<ExtArgs> | null
    /**
     * Omit specific fields from the midtrx
     */
    omit?: midtrxOmit<ExtArgs> | null
    /**
     * Filter, which midtrxes to fetch.
     */
    where?: midtrxWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of midtrxes to fetch.
     */
    orderBy?: midtrxOrderByWithRelationInput | midtrxOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing midtrxes.
     */
    cursor?: midtrxWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` midtrxes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` midtrxes.
     */
    skip?: number
    distinct?: MidtrxScalarFieldEnum | MidtrxScalarFieldEnum[]
  }

  /**
   * midtrx create
   */
  export type midtrxCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the midtrx
     */
    select?: midtrxSelect<ExtArgs> | null
    /**
     * Omit specific fields from the midtrx
     */
    omit?: midtrxOmit<ExtArgs> | null
    /**
     * The data needed to create a midtrx.
     */
    data: XOR<midtrxCreateInput, midtrxUncheckedCreateInput>
  }

  /**
   * midtrx createMany
   */
  export type midtrxCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many midtrxes.
     */
    data: midtrxCreateManyInput | midtrxCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * midtrx createManyAndReturn
   */
  export type midtrxCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the midtrx
     */
    select?: midtrxSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the midtrx
     */
    omit?: midtrxOmit<ExtArgs> | null
    /**
     * The data used to create many midtrxes.
     */
    data: midtrxCreateManyInput | midtrxCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * midtrx update
   */
  export type midtrxUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the midtrx
     */
    select?: midtrxSelect<ExtArgs> | null
    /**
     * Omit specific fields from the midtrx
     */
    omit?: midtrxOmit<ExtArgs> | null
    /**
     * The data needed to update a midtrx.
     */
    data: XOR<midtrxUpdateInput, midtrxUncheckedUpdateInput>
    /**
     * Choose, which midtrx to update.
     */
    where: midtrxWhereUniqueInput
  }

  /**
   * midtrx updateMany
   */
  export type midtrxUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update midtrxes.
     */
    data: XOR<midtrxUpdateManyMutationInput, midtrxUncheckedUpdateManyInput>
    /**
     * Filter which midtrxes to update
     */
    where?: midtrxWhereInput
    /**
     * Limit how many midtrxes to update.
     */
    limit?: number
  }

  /**
   * midtrx updateManyAndReturn
   */
  export type midtrxUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the midtrx
     */
    select?: midtrxSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the midtrx
     */
    omit?: midtrxOmit<ExtArgs> | null
    /**
     * The data used to update midtrxes.
     */
    data: XOR<midtrxUpdateManyMutationInput, midtrxUncheckedUpdateManyInput>
    /**
     * Filter which midtrxes to update
     */
    where?: midtrxWhereInput
    /**
     * Limit how many midtrxes to update.
     */
    limit?: number
  }

  /**
   * midtrx upsert
   */
  export type midtrxUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the midtrx
     */
    select?: midtrxSelect<ExtArgs> | null
    /**
     * Omit specific fields from the midtrx
     */
    omit?: midtrxOmit<ExtArgs> | null
    /**
     * The filter to search for the midtrx to update in case it exists.
     */
    where: midtrxWhereUniqueInput
    /**
     * In case the midtrx found by the `where` argument doesn't exist, create a new midtrx with this data.
     */
    create: XOR<midtrxCreateInput, midtrxUncheckedCreateInput>
    /**
     * In case the midtrx was found with the provided `where` argument, update it with this data.
     */
    update: XOR<midtrxUpdateInput, midtrxUncheckedUpdateInput>
  }

  /**
   * midtrx delete
   */
  export type midtrxDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the midtrx
     */
    select?: midtrxSelect<ExtArgs> | null
    /**
     * Omit specific fields from the midtrx
     */
    omit?: midtrxOmit<ExtArgs> | null
    /**
     * Filter which midtrx to delete.
     */
    where: midtrxWhereUniqueInput
  }

  /**
   * midtrx deleteMany
   */
  export type midtrxDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which midtrxes to delete
     */
    where?: midtrxWhereInput
    /**
     * Limit how many midtrxes to delete.
     */
    limit?: number
  }

  /**
   * midtrx without action
   */
  export type midtrxDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the midtrx
     */
    select?: midtrxSelect<ExtArgs> | null
    /**
     * Omit specific fields from the midtrx
     */
    omit?: midtrxOmit<ExtArgs> | null
  }


  /**
   * Model preorder
   */

  export type AggregatePreorder = {
    _count: PreorderCountAggregateOutputType | null
    _avg: PreorderAvgAggregateOutputType | null
    _sum: PreorderSumAggregateOutputType | null
    _min: PreorderMinAggregateOutputType | null
    _max: PreorderMaxAggregateOutputType | null
  }

  export type PreorderAvgAggregateOutputType = {
    min_qty: number | null
    current_qty: number | null
  }

  export type PreorderSumAggregateOutputType = {
    min_qty: number | null
    current_qty: number | null
  }

  export type PreorderMinAggregateOutputType = {
    id: string | null
    id_product: string | null
    min_qty: number | null
    current_qty: number | null
    status: string | null
    deadline: Date | null
  }

  export type PreorderMaxAggregateOutputType = {
    id: string | null
    id_product: string | null
    min_qty: number | null
    current_qty: number | null
    status: string | null
    deadline: Date | null
  }

  export type PreorderCountAggregateOutputType = {
    id: number
    id_product: number
    min_qty: number
    current_qty: number
    status: number
    deadline: number
    _all: number
  }


  export type PreorderAvgAggregateInputType = {
    min_qty?: true
    current_qty?: true
  }

  export type PreorderSumAggregateInputType = {
    min_qty?: true
    current_qty?: true
  }

  export type PreorderMinAggregateInputType = {
    id?: true
    id_product?: true
    min_qty?: true
    current_qty?: true
    status?: true
    deadline?: true
  }

  export type PreorderMaxAggregateInputType = {
    id?: true
    id_product?: true
    min_qty?: true
    current_qty?: true
    status?: true
    deadline?: true
  }

  export type PreorderCountAggregateInputType = {
    id?: true
    id_product?: true
    min_qty?: true
    current_qty?: true
    status?: true
    deadline?: true
    _all?: true
  }

  export type PreorderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which preorder to aggregate.
     */
    where?: preorderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of preorders to fetch.
     */
    orderBy?: preorderOrderByWithRelationInput | preorderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: preorderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` preorders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` preorders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned preorders
    **/
    _count?: true | PreorderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PreorderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PreorderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PreorderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PreorderMaxAggregateInputType
  }

  export type GetPreorderAggregateType<T extends PreorderAggregateArgs> = {
        [P in keyof T & keyof AggregatePreorder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePreorder[P]>
      : GetScalarType<T[P], AggregatePreorder[P]>
  }




  export type preorderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: preorderWhereInput
    orderBy?: preorderOrderByWithAggregationInput | preorderOrderByWithAggregationInput[]
    by: PreorderScalarFieldEnum[] | PreorderScalarFieldEnum
    having?: preorderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PreorderCountAggregateInputType | true
    _avg?: PreorderAvgAggregateInputType
    _sum?: PreorderSumAggregateInputType
    _min?: PreorderMinAggregateInputType
    _max?: PreorderMaxAggregateInputType
  }

  export type PreorderGroupByOutputType = {
    id: string
    id_product: string
    min_qty: number
    current_qty: number
    status: string
    deadline: Date
    _count: PreorderCountAggregateOutputType | null
    _avg: PreorderAvgAggregateOutputType | null
    _sum: PreorderSumAggregateOutputType | null
    _min: PreorderMinAggregateOutputType | null
    _max: PreorderMaxAggregateOutputType | null
  }

  type GetPreorderGroupByPayload<T extends preorderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PreorderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PreorderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PreorderGroupByOutputType[P]>
            : GetScalarType<T[P], PreorderGroupByOutputType[P]>
        }
      >
    >


  export type preorderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    id_product?: boolean
    min_qty?: boolean
    current_qty?: boolean
    status?: boolean
    deadline?: boolean
    product?: boolean | productDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["preorder"]>

  export type preorderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    id_product?: boolean
    min_qty?: boolean
    current_qty?: boolean
    status?: boolean
    deadline?: boolean
    product?: boolean | productDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["preorder"]>

  export type preorderSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    id_product?: boolean
    min_qty?: boolean
    current_qty?: boolean
    status?: boolean
    deadline?: boolean
    product?: boolean | productDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["preorder"]>

  export type preorderSelectScalar = {
    id?: boolean
    id_product?: boolean
    min_qty?: boolean
    current_qty?: boolean
    status?: boolean
    deadline?: boolean
  }

  export type preorderOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "id_product" | "min_qty" | "current_qty" | "status" | "deadline", ExtArgs["result"]["preorder"]>
  export type preorderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | productDefaultArgs<ExtArgs>
  }
  export type preorderIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | productDefaultArgs<ExtArgs>
  }
  export type preorderIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | productDefaultArgs<ExtArgs>
  }

  export type $preorderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "preorder"
    objects: {
      product: Prisma.$productPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      id_product: string
      min_qty: number
      current_qty: number
      status: string
      deadline: Date
    }, ExtArgs["result"]["preorder"]>
    composites: {}
  }

  type preorderGetPayload<S extends boolean | null | undefined | preorderDefaultArgs> = $Result.GetResult<Prisma.$preorderPayload, S>

  type preorderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<preorderFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PreorderCountAggregateInputType | true
    }

  export interface preorderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['preorder'], meta: { name: 'preorder' } }
    /**
     * Find zero or one Preorder that matches the filter.
     * @param {preorderFindUniqueArgs} args - Arguments to find a Preorder
     * @example
     * // Get one Preorder
     * const preorder = await prisma.preorder.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends preorderFindUniqueArgs>(args: SelectSubset<T, preorderFindUniqueArgs<ExtArgs>>): Prisma__preorderClient<$Result.GetResult<Prisma.$preorderPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Preorder that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {preorderFindUniqueOrThrowArgs} args - Arguments to find a Preorder
     * @example
     * // Get one Preorder
     * const preorder = await prisma.preorder.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends preorderFindUniqueOrThrowArgs>(args: SelectSubset<T, preorderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__preorderClient<$Result.GetResult<Prisma.$preorderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Preorder that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {preorderFindFirstArgs} args - Arguments to find a Preorder
     * @example
     * // Get one Preorder
     * const preorder = await prisma.preorder.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends preorderFindFirstArgs>(args?: SelectSubset<T, preorderFindFirstArgs<ExtArgs>>): Prisma__preorderClient<$Result.GetResult<Prisma.$preorderPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Preorder that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {preorderFindFirstOrThrowArgs} args - Arguments to find a Preorder
     * @example
     * // Get one Preorder
     * const preorder = await prisma.preorder.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends preorderFindFirstOrThrowArgs>(args?: SelectSubset<T, preorderFindFirstOrThrowArgs<ExtArgs>>): Prisma__preorderClient<$Result.GetResult<Prisma.$preorderPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Preorders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {preorderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Preorders
     * const preorders = await prisma.preorder.findMany()
     * 
     * // Get first 10 Preorders
     * const preorders = await prisma.preorder.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const preorderWithIdOnly = await prisma.preorder.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends preorderFindManyArgs>(args?: SelectSubset<T, preorderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$preorderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Preorder.
     * @param {preorderCreateArgs} args - Arguments to create a Preorder.
     * @example
     * // Create one Preorder
     * const Preorder = await prisma.preorder.create({
     *   data: {
     *     // ... data to create a Preorder
     *   }
     * })
     * 
     */
    create<T extends preorderCreateArgs>(args: SelectSubset<T, preorderCreateArgs<ExtArgs>>): Prisma__preorderClient<$Result.GetResult<Prisma.$preorderPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Preorders.
     * @param {preorderCreateManyArgs} args - Arguments to create many Preorders.
     * @example
     * // Create many Preorders
     * const preorder = await prisma.preorder.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends preorderCreateManyArgs>(args?: SelectSubset<T, preorderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Preorders and returns the data saved in the database.
     * @param {preorderCreateManyAndReturnArgs} args - Arguments to create many Preorders.
     * @example
     * // Create many Preorders
     * const preorder = await prisma.preorder.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Preorders and only return the `id`
     * const preorderWithIdOnly = await prisma.preorder.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends preorderCreateManyAndReturnArgs>(args?: SelectSubset<T, preorderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$preorderPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Preorder.
     * @param {preorderDeleteArgs} args - Arguments to delete one Preorder.
     * @example
     * // Delete one Preorder
     * const Preorder = await prisma.preorder.delete({
     *   where: {
     *     // ... filter to delete one Preorder
     *   }
     * })
     * 
     */
    delete<T extends preorderDeleteArgs>(args: SelectSubset<T, preorderDeleteArgs<ExtArgs>>): Prisma__preorderClient<$Result.GetResult<Prisma.$preorderPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Preorder.
     * @param {preorderUpdateArgs} args - Arguments to update one Preorder.
     * @example
     * // Update one Preorder
     * const preorder = await prisma.preorder.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends preorderUpdateArgs>(args: SelectSubset<T, preorderUpdateArgs<ExtArgs>>): Prisma__preorderClient<$Result.GetResult<Prisma.$preorderPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Preorders.
     * @param {preorderDeleteManyArgs} args - Arguments to filter Preorders to delete.
     * @example
     * // Delete a few Preorders
     * const { count } = await prisma.preorder.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends preorderDeleteManyArgs>(args?: SelectSubset<T, preorderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Preorders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {preorderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Preorders
     * const preorder = await prisma.preorder.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends preorderUpdateManyArgs>(args: SelectSubset<T, preorderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Preorders and returns the data updated in the database.
     * @param {preorderUpdateManyAndReturnArgs} args - Arguments to update many Preorders.
     * @example
     * // Update many Preorders
     * const preorder = await prisma.preorder.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Preorders and only return the `id`
     * const preorderWithIdOnly = await prisma.preorder.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends preorderUpdateManyAndReturnArgs>(args: SelectSubset<T, preorderUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$preorderPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Preorder.
     * @param {preorderUpsertArgs} args - Arguments to update or create a Preorder.
     * @example
     * // Update or create a Preorder
     * const preorder = await prisma.preorder.upsert({
     *   create: {
     *     // ... data to create a Preorder
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Preorder we want to update
     *   }
     * })
     */
    upsert<T extends preorderUpsertArgs>(args: SelectSubset<T, preorderUpsertArgs<ExtArgs>>): Prisma__preorderClient<$Result.GetResult<Prisma.$preorderPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Preorders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {preorderCountArgs} args - Arguments to filter Preorders to count.
     * @example
     * // Count the number of Preorders
     * const count = await prisma.preorder.count({
     *   where: {
     *     // ... the filter for the Preorders we want to count
     *   }
     * })
    **/
    count<T extends preorderCountArgs>(
      args?: Subset<T, preorderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PreorderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Preorder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PreorderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PreorderAggregateArgs>(args: Subset<T, PreorderAggregateArgs>): Prisma.PrismaPromise<GetPreorderAggregateType<T>>

    /**
     * Group by Preorder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {preorderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends preorderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: preorderGroupByArgs['orderBy'] }
        : { orderBy?: preorderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, preorderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPreorderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the preorder model
   */
  readonly fields: preorderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for preorder.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__preorderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    product<T extends productDefaultArgs<ExtArgs> = {}>(args?: Subset<T, productDefaultArgs<ExtArgs>>): Prisma__productClient<$Result.GetResult<Prisma.$productPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the preorder model
   */
  interface preorderFieldRefs {
    readonly id: FieldRef<"preorder", 'String'>
    readonly id_product: FieldRef<"preorder", 'String'>
    readonly min_qty: FieldRef<"preorder", 'Int'>
    readonly current_qty: FieldRef<"preorder", 'Int'>
    readonly status: FieldRef<"preorder", 'String'>
    readonly deadline: FieldRef<"preorder", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * preorder findUnique
   */
  export type preorderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the preorder
     */
    select?: preorderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the preorder
     */
    omit?: preorderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: preorderInclude<ExtArgs> | null
    /**
     * Filter, which preorder to fetch.
     */
    where: preorderWhereUniqueInput
  }

  /**
   * preorder findUniqueOrThrow
   */
  export type preorderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the preorder
     */
    select?: preorderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the preorder
     */
    omit?: preorderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: preorderInclude<ExtArgs> | null
    /**
     * Filter, which preorder to fetch.
     */
    where: preorderWhereUniqueInput
  }

  /**
   * preorder findFirst
   */
  export type preorderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the preorder
     */
    select?: preorderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the preorder
     */
    omit?: preorderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: preorderInclude<ExtArgs> | null
    /**
     * Filter, which preorder to fetch.
     */
    where?: preorderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of preorders to fetch.
     */
    orderBy?: preorderOrderByWithRelationInput | preorderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for preorders.
     */
    cursor?: preorderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` preorders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` preorders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of preorders.
     */
    distinct?: PreorderScalarFieldEnum | PreorderScalarFieldEnum[]
  }

  /**
   * preorder findFirstOrThrow
   */
  export type preorderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the preorder
     */
    select?: preorderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the preorder
     */
    omit?: preorderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: preorderInclude<ExtArgs> | null
    /**
     * Filter, which preorder to fetch.
     */
    where?: preorderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of preorders to fetch.
     */
    orderBy?: preorderOrderByWithRelationInput | preorderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for preorders.
     */
    cursor?: preorderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` preorders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` preorders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of preorders.
     */
    distinct?: PreorderScalarFieldEnum | PreorderScalarFieldEnum[]
  }

  /**
   * preorder findMany
   */
  export type preorderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the preorder
     */
    select?: preorderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the preorder
     */
    omit?: preorderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: preorderInclude<ExtArgs> | null
    /**
     * Filter, which preorders to fetch.
     */
    where?: preorderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of preorders to fetch.
     */
    orderBy?: preorderOrderByWithRelationInput | preorderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing preorders.
     */
    cursor?: preorderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` preorders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` preorders.
     */
    skip?: number
    distinct?: PreorderScalarFieldEnum | PreorderScalarFieldEnum[]
  }

  /**
   * preorder create
   */
  export type preorderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the preorder
     */
    select?: preorderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the preorder
     */
    omit?: preorderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: preorderInclude<ExtArgs> | null
    /**
     * The data needed to create a preorder.
     */
    data: XOR<preorderCreateInput, preorderUncheckedCreateInput>
  }

  /**
   * preorder createMany
   */
  export type preorderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many preorders.
     */
    data: preorderCreateManyInput | preorderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * preorder createManyAndReturn
   */
  export type preorderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the preorder
     */
    select?: preorderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the preorder
     */
    omit?: preorderOmit<ExtArgs> | null
    /**
     * The data used to create many preorders.
     */
    data: preorderCreateManyInput | preorderCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: preorderIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * preorder update
   */
  export type preorderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the preorder
     */
    select?: preorderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the preorder
     */
    omit?: preorderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: preorderInclude<ExtArgs> | null
    /**
     * The data needed to update a preorder.
     */
    data: XOR<preorderUpdateInput, preorderUncheckedUpdateInput>
    /**
     * Choose, which preorder to update.
     */
    where: preorderWhereUniqueInput
  }

  /**
   * preorder updateMany
   */
  export type preorderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update preorders.
     */
    data: XOR<preorderUpdateManyMutationInput, preorderUncheckedUpdateManyInput>
    /**
     * Filter which preorders to update
     */
    where?: preorderWhereInput
    /**
     * Limit how many preorders to update.
     */
    limit?: number
  }

  /**
   * preorder updateManyAndReturn
   */
  export type preorderUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the preorder
     */
    select?: preorderSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the preorder
     */
    omit?: preorderOmit<ExtArgs> | null
    /**
     * The data used to update preorders.
     */
    data: XOR<preorderUpdateManyMutationInput, preorderUncheckedUpdateManyInput>
    /**
     * Filter which preorders to update
     */
    where?: preorderWhereInput
    /**
     * Limit how many preorders to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: preorderIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * preorder upsert
   */
  export type preorderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the preorder
     */
    select?: preorderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the preorder
     */
    omit?: preorderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: preorderInclude<ExtArgs> | null
    /**
     * The filter to search for the preorder to update in case it exists.
     */
    where: preorderWhereUniqueInput
    /**
     * In case the preorder found by the `where` argument doesn't exist, create a new preorder with this data.
     */
    create: XOR<preorderCreateInput, preorderUncheckedCreateInput>
    /**
     * In case the preorder was found with the provided `where` argument, update it with this data.
     */
    update: XOR<preorderUpdateInput, preorderUncheckedUpdateInput>
  }

  /**
   * preorder delete
   */
  export type preorderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the preorder
     */
    select?: preorderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the preorder
     */
    omit?: preorderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: preorderInclude<ExtArgs> | null
    /**
     * Filter which preorder to delete.
     */
    where: preorderWhereUniqueInput
  }

  /**
   * preorder deleteMany
   */
  export type preorderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which preorders to delete
     */
    where?: preorderWhereInput
    /**
     * Limit how many preorders to delete.
     */
    limit?: number
  }

  /**
   * preorder without action
   */
  export type preorderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the preorder
     */
    select?: preorderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the preorder
     */
    omit?: preorderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: preorderInclude<ExtArgs> | null
  }


  /**
   * Model product
   */

  export type AggregateProduct = {
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  export type ProductAvgAggregateOutputType = {
    strike_price: Decimal | null
    real_price: Decimal | null
    preorder_min_qty: number | null
  }

  export type ProductSumAggregateOutputType = {
    strike_price: Decimal | null
    real_price: Decimal | null
    preorder_min_qty: number | null
  }

  export type ProductMinAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    alias: string | null
    strike_price: Decimal | null
    real_price: Decimal | null
    desc: string | null
    status: string | null
    currency: string | null
    deleted_at: Date | null
    img_file: string | null
    cover: string | null
    product_file: string | null
    sku: string | null
    id_author: string | null
    published_date: Date | null
    is_physical: boolean | null
    preorder_min_qty: number | null
    content_type: string | null
    is_chapter: boolean | null
  }

  export type ProductMaxAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    alias: string | null
    strike_price: Decimal | null
    real_price: Decimal | null
    desc: string | null
    status: string | null
    currency: string | null
    deleted_at: Date | null
    img_file: string | null
    cover: string | null
    product_file: string | null
    sku: string | null
    id_author: string | null
    published_date: Date | null
    is_physical: boolean | null
    preorder_min_qty: number | null
    content_type: string | null
    is_chapter: boolean | null
  }

  export type ProductCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    alias: number
    strike_price: number
    real_price: number
    desc: number
    info: number
    status: number
    currency: number
    deleted_at: number
    img_file: number
    cover: number
    product_file: number
    sku: number
    id_author: number
    published_date: number
    is_physical: number
    preorder_min_qty: number
    content_type: number
    is_chapter: number
    _all: number
  }


  export type ProductAvgAggregateInputType = {
    strike_price?: true
    real_price?: true
    preorder_min_qty?: true
  }

  export type ProductSumAggregateInputType = {
    strike_price?: true
    real_price?: true
    preorder_min_qty?: true
  }

  export type ProductMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    alias?: true
    strike_price?: true
    real_price?: true
    desc?: true
    status?: true
    currency?: true
    deleted_at?: true
    img_file?: true
    cover?: true
    product_file?: true
    sku?: true
    id_author?: true
    published_date?: true
    is_physical?: true
    preorder_min_qty?: true
    content_type?: true
    is_chapter?: true
  }

  export type ProductMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    alias?: true
    strike_price?: true
    real_price?: true
    desc?: true
    status?: true
    currency?: true
    deleted_at?: true
    img_file?: true
    cover?: true
    product_file?: true
    sku?: true
    id_author?: true
    published_date?: true
    is_physical?: true
    preorder_min_qty?: true
    content_type?: true
    is_chapter?: true
  }

  export type ProductCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    alias?: true
    strike_price?: true
    real_price?: true
    desc?: true
    info?: true
    status?: true
    currency?: true
    deleted_at?: true
    img_file?: true
    cover?: true
    product_file?: true
    sku?: true
    id_author?: true
    published_date?: true
    is_physical?: true
    preorder_min_qty?: true
    content_type?: true
    is_chapter?: true
    _all?: true
  }

  export type ProductAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which product to aggregate.
     */
    where?: productWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of products to fetch.
     */
    orderBy?: productOrderByWithRelationInput | productOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: productWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned products
    **/
    _count?: true | ProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductMaxAggregateInputType
  }

  export type GetProductAggregateType<T extends ProductAggregateArgs> = {
        [P in keyof T & keyof AggregateProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProduct[P]>
      : GetScalarType<T[P], AggregateProduct[P]>
  }




  export type productGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: productWhereInput
    orderBy?: productOrderByWithAggregationInput | productOrderByWithAggregationInput[]
    by: ProductScalarFieldEnum[] | ProductScalarFieldEnum
    having?: productScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductCountAggregateInputType | true
    _avg?: ProductAvgAggregateInputType
    _sum?: ProductSumAggregateInputType
    _min?: ProductMinAggregateInputType
    _max?: ProductMaxAggregateInputType
  }

  export type ProductGroupByOutputType = {
    id: string
    name: string
    slug: string
    alias: string
    strike_price: Decimal | null
    real_price: Decimal
    desc: string
    info: JsonValue | null
    status: string
    currency: string
    deleted_at: Date | null
    img_file: string
    cover: string
    product_file: string
    sku: string
    id_author: string | null
    published_date: Date
    is_physical: boolean
    preorder_min_qty: number | null
    content_type: string | null
    is_chapter: boolean
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  type GetProductGroupByPayload<T extends productGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductGroupByOutputType[P]>
            : GetScalarType<T[P], ProductGroupByOutputType[P]>
        }
      >
    >


  export type productSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    alias?: boolean
    strike_price?: boolean
    real_price?: boolean
    desc?: boolean
    info?: boolean
    status?: boolean
    currency?: boolean
    deleted_at?: boolean
    img_file?: boolean
    cover?: boolean
    product_file?: boolean
    sku?: boolean
    id_author?: boolean
    published_date?: boolean
    is_physical?: boolean
    preorder_min_qty?: boolean
    content_type?: boolean
    is_chapter?: boolean
    book?: boolean | product$bookArgs<ExtArgs>
    bundle_product?: boolean | product$bundle_productArgs<ExtArgs>
    chapter?: boolean | product$chapterArgs<ExtArgs>
    customer_reader?: boolean | product$customer_readerArgs<ExtArgs>
    preorder?: boolean | product$preorderArgs<ExtArgs>
    author?: boolean | product$authorArgs<ExtArgs>
    product_category?: boolean | product$product_categoryArgs<ExtArgs>
    t_sales_download?: boolean | product$t_sales_downloadArgs<ExtArgs>
    t_sales_line?: boolean | product$t_sales_lineArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type productSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    alias?: boolean
    strike_price?: boolean
    real_price?: boolean
    desc?: boolean
    info?: boolean
    status?: boolean
    currency?: boolean
    deleted_at?: boolean
    img_file?: boolean
    cover?: boolean
    product_file?: boolean
    sku?: boolean
    id_author?: boolean
    published_date?: boolean
    is_physical?: boolean
    preorder_min_qty?: boolean
    content_type?: boolean
    is_chapter?: boolean
    author?: boolean | product$authorArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type productSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    alias?: boolean
    strike_price?: boolean
    real_price?: boolean
    desc?: boolean
    info?: boolean
    status?: boolean
    currency?: boolean
    deleted_at?: boolean
    img_file?: boolean
    cover?: boolean
    product_file?: boolean
    sku?: boolean
    id_author?: boolean
    published_date?: boolean
    is_physical?: boolean
    preorder_min_qty?: boolean
    content_type?: boolean
    is_chapter?: boolean
    author?: boolean | product$authorArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type productSelectScalar = {
    id?: boolean
    name?: boolean
    slug?: boolean
    alias?: boolean
    strike_price?: boolean
    real_price?: boolean
    desc?: boolean
    info?: boolean
    status?: boolean
    currency?: boolean
    deleted_at?: boolean
    img_file?: boolean
    cover?: boolean
    product_file?: boolean
    sku?: boolean
    id_author?: boolean
    published_date?: boolean
    is_physical?: boolean
    preorder_min_qty?: boolean
    content_type?: boolean
    is_chapter?: boolean
  }

  export type productOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "slug" | "alias" | "strike_price" | "real_price" | "desc" | "info" | "status" | "currency" | "deleted_at" | "img_file" | "cover" | "product_file" | "sku" | "id_author" | "published_date" | "is_physical" | "preorder_min_qty" | "content_type" | "is_chapter", ExtArgs["result"]["product"]>
  export type productInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    book?: boolean | product$bookArgs<ExtArgs>
    bundle_product?: boolean | product$bundle_productArgs<ExtArgs>
    chapter?: boolean | product$chapterArgs<ExtArgs>
    customer_reader?: boolean | product$customer_readerArgs<ExtArgs>
    preorder?: boolean | product$preorderArgs<ExtArgs>
    author?: boolean | product$authorArgs<ExtArgs>
    product_category?: boolean | product$product_categoryArgs<ExtArgs>
    t_sales_download?: boolean | product$t_sales_downloadArgs<ExtArgs>
    t_sales_line?: boolean | product$t_sales_lineArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type productIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    author?: boolean | product$authorArgs<ExtArgs>
  }
  export type productIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    author?: boolean | product$authorArgs<ExtArgs>
  }

  export type $productPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "product"
    objects: {
      book: Prisma.$bookPayload<ExtArgs>[]
      bundle_product: Prisma.$bundle_productPayload<ExtArgs>[]
      chapter: Prisma.$chapterPayload<ExtArgs>[]
      customer_reader: Prisma.$customer_readerPayload<ExtArgs>[]
      preorder: Prisma.$preorderPayload<ExtArgs>[]
      author: Prisma.$authorPayload<ExtArgs> | null
      product_category: Prisma.$product_categoryPayload<ExtArgs>[]
      t_sales_download: Prisma.$t_sales_downloadPayload<ExtArgs>[]
      t_sales_line: Prisma.$t_sales_linePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      slug: string
      alias: string
      strike_price: Prisma.Decimal | null
      real_price: Prisma.Decimal
      desc: string
      info: Prisma.JsonValue | null
      status: string
      currency: string
      deleted_at: Date | null
      img_file: string
      cover: string
      product_file: string
      sku: string
      id_author: string | null
      published_date: Date
      is_physical: boolean
      preorder_min_qty: number | null
      content_type: string | null
      is_chapter: boolean
    }, ExtArgs["result"]["product"]>
    composites: {}
  }

  type productGetPayload<S extends boolean | null | undefined | productDefaultArgs> = $Result.GetResult<Prisma.$productPayload, S>

  type productCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<productFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductCountAggregateInputType | true
    }

  export interface productDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['product'], meta: { name: 'product' } }
    /**
     * Find zero or one Product that matches the filter.
     * @param {productFindUniqueArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends productFindUniqueArgs>(args: SelectSubset<T, productFindUniqueArgs<ExtArgs>>): Prisma__productClient<$Result.GetResult<Prisma.$productPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Product that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {productFindUniqueOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends productFindUniqueOrThrowArgs>(args: SelectSubset<T, productFindUniqueOrThrowArgs<ExtArgs>>): Prisma__productClient<$Result.GetResult<Prisma.$productPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Product that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {productFindFirstArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends productFindFirstArgs>(args?: SelectSubset<T, productFindFirstArgs<ExtArgs>>): Prisma__productClient<$Result.GetResult<Prisma.$productPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Product that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {productFindFirstOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends productFindFirstOrThrowArgs>(args?: SelectSubset<T, productFindFirstOrThrowArgs<ExtArgs>>): Prisma__productClient<$Result.GetResult<Prisma.$productPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {productFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Products
     * const products = await prisma.product.findMany()
     * 
     * // Get first 10 Products
     * const products = await prisma.product.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productWithIdOnly = await prisma.product.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends productFindManyArgs>(args?: SelectSubset<T, productFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$productPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Product.
     * @param {productCreateArgs} args - Arguments to create a Product.
     * @example
     * // Create one Product
     * const Product = await prisma.product.create({
     *   data: {
     *     // ... data to create a Product
     *   }
     * })
     * 
     */
    create<T extends productCreateArgs>(args: SelectSubset<T, productCreateArgs<ExtArgs>>): Prisma__productClient<$Result.GetResult<Prisma.$productPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Products.
     * @param {productCreateManyArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends productCreateManyArgs>(args?: SelectSubset<T, productCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Products and returns the data saved in the database.
     * @param {productCreateManyAndReturnArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Products and only return the `id`
     * const productWithIdOnly = await prisma.product.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends productCreateManyAndReturnArgs>(args?: SelectSubset<T, productCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$productPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Product.
     * @param {productDeleteArgs} args - Arguments to delete one Product.
     * @example
     * // Delete one Product
     * const Product = await prisma.product.delete({
     *   where: {
     *     // ... filter to delete one Product
     *   }
     * })
     * 
     */
    delete<T extends productDeleteArgs>(args: SelectSubset<T, productDeleteArgs<ExtArgs>>): Prisma__productClient<$Result.GetResult<Prisma.$productPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Product.
     * @param {productUpdateArgs} args - Arguments to update one Product.
     * @example
     * // Update one Product
     * const product = await prisma.product.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends productUpdateArgs>(args: SelectSubset<T, productUpdateArgs<ExtArgs>>): Prisma__productClient<$Result.GetResult<Prisma.$productPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Products.
     * @param {productDeleteManyArgs} args - Arguments to filter Products to delete.
     * @example
     * // Delete a few Products
     * const { count } = await prisma.product.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends productDeleteManyArgs>(args?: SelectSubset<T, productDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {productUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends productUpdateManyArgs>(args: SelectSubset<T, productUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products and returns the data updated in the database.
     * @param {productUpdateManyAndReturnArgs} args - Arguments to update many Products.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Products and only return the `id`
     * const productWithIdOnly = await prisma.product.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends productUpdateManyAndReturnArgs>(args: SelectSubset<T, productUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$productPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Product.
     * @param {productUpsertArgs} args - Arguments to update or create a Product.
     * @example
     * // Update or create a Product
     * const product = await prisma.product.upsert({
     *   create: {
     *     // ... data to create a Product
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Product we want to update
     *   }
     * })
     */
    upsert<T extends productUpsertArgs>(args: SelectSubset<T, productUpsertArgs<ExtArgs>>): Prisma__productClient<$Result.GetResult<Prisma.$productPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {productCountArgs} args - Arguments to filter Products to count.
     * @example
     * // Count the number of Products
     * const count = await prisma.product.count({
     *   where: {
     *     // ... the filter for the Products we want to count
     *   }
     * })
    **/
    count<T extends productCountArgs>(
      args?: Subset<T, productCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductAggregateArgs>(args: Subset<T, ProductAggregateArgs>): Prisma.PrismaPromise<GetProductAggregateType<T>>

    /**
     * Group by Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {productGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends productGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: productGroupByArgs['orderBy'] }
        : { orderBy?: productGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, productGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the product model
   */
  readonly fields: productFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for product.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__productClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    book<T extends product$bookArgs<ExtArgs> = {}>(args?: Subset<T, product$bookArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$bookPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    bundle_product<T extends product$bundle_productArgs<ExtArgs> = {}>(args?: Subset<T, product$bundle_productArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$bundle_productPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    chapter<T extends product$chapterArgs<ExtArgs> = {}>(args?: Subset<T, product$chapterArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$chapterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    customer_reader<T extends product$customer_readerArgs<ExtArgs> = {}>(args?: Subset<T, product$customer_readerArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$customer_readerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    preorder<T extends product$preorderArgs<ExtArgs> = {}>(args?: Subset<T, product$preorderArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$preorderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    author<T extends product$authorArgs<ExtArgs> = {}>(args?: Subset<T, product$authorArgs<ExtArgs>>): Prisma__authorClient<$Result.GetResult<Prisma.$authorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    product_category<T extends product$product_categoryArgs<ExtArgs> = {}>(args?: Subset<T, product$product_categoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$product_categoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    t_sales_download<T extends product$t_sales_downloadArgs<ExtArgs> = {}>(args?: Subset<T, product$t_sales_downloadArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$t_sales_downloadPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    t_sales_line<T extends product$t_sales_lineArgs<ExtArgs> = {}>(args?: Subset<T, product$t_sales_lineArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$t_sales_linePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the product model
   */
  interface productFieldRefs {
    readonly id: FieldRef<"product", 'String'>
    readonly name: FieldRef<"product", 'String'>
    readonly slug: FieldRef<"product", 'String'>
    readonly alias: FieldRef<"product", 'String'>
    readonly strike_price: FieldRef<"product", 'Decimal'>
    readonly real_price: FieldRef<"product", 'Decimal'>
    readonly desc: FieldRef<"product", 'String'>
    readonly info: FieldRef<"product", 'Json'>
    readonly status: FieldRef<"product", 'String'>
    readonly currency: FieldRef<"product", 'String'>
    readonly deleted_at: FieldRef<"product", 'DateTime'>
    readonly img_file: FieldRef<"product", 'String'>
    readonly cover: FieldRef<"product", 'String'>
    readonly product_file: FieldRef<"product", 'String'>
    readonly sku: FieldRef<"product", 'String'>
    readonly id_author: FieldRef<"product", 'String'>
    readonly published_date: FieldRef<"product", 'DateTime'>
    readonly is_physical: FieldRef<"product", 'Boolean'>
    readonly preorder_min_qty: FieldRef<"product", 'Int'>
    readonly content_type: FieldRef<"product", 'String'>
    readonly is_chapter: FieldRef<"product", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * product findUnique
   */
  export type productFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product
     */
    select?: productSelect<ExtArgs> | null
    /**
     * Omit specific fields from the product
     */
    omit?: productOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productInclude<ExtArgs> | null
    /**
     * Filter, which product to fetch.
     */
    where: productWhereUniqueInput
  }

  /**
   * product findUniqueOrThrow
   */
  export type productFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product
     */
    select?: productSelect<ExtArgs> | null
    /**
     * Omit specific fields from the product
     */
    omit?: productOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productInclude<ExtArgs> | null
    /**
     * Filter, which product to fetch.
     */
    where: productWhereUniqueInput
  }

  /**
   * product findFirst
   */
  export type productFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product
     */
    select?: productSelect<ExtArgs> | null
    /**
     * Omit specific fields from the product
     */
    omit?: productOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productInclude<ExtArgs> | null
    /**
     * Filter, which product to fetch.
     */
    where?: productWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of products to fetch.
     */
    orderBy?: productOrderByWithRelationInput | productOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for products.
     */
    cursor?: productWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * product findFirstOrThrow
   */
  export type productFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product
     */
    select?: productSelect<ExtArgs> | null
    /**
     * Omit specific fields from the product
     */
    omit?: productOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productInclude<ExtArgs> | null
    /**
     * Filter, which product to fetch.
     */
    where?: productWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of products to fetch.
     */
    orderBy?: productOrderByWithRelationInput | productOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for products.
     */
    cursor?: productWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * product findMany
   */
  export type productFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product
     */
    select?: productSelect<ExtArgs> | null
    /**
     * Omit specific fields from the product
     */
    omit?: productOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productInclude<ExtArgs> | null
    /**
     * Filter, which products to fetch.
     */
    where?: productWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of products to fetch.
     */
    orderBy?: productOrderByWithRelationInput | productOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing products.
     */
    cursor?: productWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` products.
     */
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * product create
   */
  export type productCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product
     */
    select?: productSelect<ExtArgs> | null
    /**
     * Omit specific fields from the product
     */
    omit?: productOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productInclude<ExtArgs> | null
    /**
     * The data needed to create a product.
     */
    data: XOR<productCreateInput, productUncheckedCreateInput>
  }

  /**
   * product createMany
   */
  export type productCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many products.
     */
    data: productCreateManyInput | productCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * product createManyAndReturn
   */
  export type productCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product
     */
    select?: productSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the product
     */
    omit?: productOmit<ExtArgs> | null
    /**
     * The data used to create many products.
     */
    data: productCreateManyInput | productCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * product update
   */
  export type productUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product
     */
    select?: productSelect<ExtArgs> | null
    /**
     * Omit specific fields from the product
     */
    omit?: productOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productInclude<ExtArgs> | null
    /**
     * The data needed to update a product.
     */
    data: XOR<productUpdateInput, productUncheckedUpdateInput>
    /**
     * Choose, which product to update.
     */
    where: productWhereUniqueInput
  }

  /**
   * product updateMany
   */
  export type productUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update products.
     */
    data: XOR<productUpdateManyMutationInput, productUncheckedUpdateManyInput>
    /**
     * Filter which products to update
     */
    where?: productWhereInput
    /**
     * Limit how many products to update.
     */
    limit?: number
  }

  /**
   * product updateManyAndReturn
   */
  export type productUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product
     */
    select?: productSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the product
     */
    omit?: productOmit<ExtArgs> | null
    /**
     * The data used to update products.
     */
    data: XOR<productUpdateManyMutationInput, productUncheckedUpdateManyInput>
    /**
     * Filter which products to update
     */
    where?: productWhereInput
    /**
     * Limit how many products to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * product upsert
   */
  export type productUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product
     */
    select?: productSelect<ExtArgs> | null
    /**
     * Omit specific fields from the product
     */
    omit?: productOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productInclude<ExtArgs> | null
    /**
     * The filter to search for the product to update in case it exists.
     */
    where: productWhereUniqueInput
    /**
     * In case the product found by the `where` argument doesn't exist, create a new product with this data.
     */
    create: XOR<productCreateInput, productUncheckedCreateInput>
    /**
     * In case the product was found with the provided `where` argument, update it with this data.
     */
    update: XOR<productUpdateInput, productUncheckedUpdateInput>
  }

  /**
   * product delete
   */
  export type productDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product
     */
    select?: productSelect<ExtArgs> | null
    /**
     * Omit specific fields from the product
     */
    omit?: productOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productInclude<ExtArgs> | null
    /**
     * Filter which product to delete.
     */
    where: productWhereUniqueInput
  }

  /**
   * product deleteMany
   */
  export type productDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which products to delete
     */
    where?: productWhereInput
    /**
     * Limit how many products to delete.
     */
    limit?: number
  }

  /**
   * product.book
   */
  export type product$bookArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the book
     */
    select?: bookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the book
     */
    omit?: bookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bookInclude<ExtArgs> | null
    where?: bookWhereInput
    orderBy?: bookOrderByWithRelationInput | bookOrderByWithRelationInput[]
    cursor?: bookWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookScalarFieldEnum | BookScalarFieldEnum[]
  }

  /**
   * product.bundle_product
   */
  export type product$bundle_productArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bundle_product
     */
    select?: bundle_productSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bundle_product
     */
    omit?: bundle_productOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bundle_productInclude<ExtArgs> | null
    where?: bundle_productWhereInput
    orderBy?: bundle_productOrderByWithRelationInput | bundle_productOrderByWithRelationInput[]
    cursor?: bundle_productWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Bundle_productScalarFieldEnum | Bundle_productScalarFieldEnum[]
  }

  /**
   * product.chapter
   */
  export type product$chapterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chapter
     */
    select?: chapterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chapter
     */
    omit?: chapterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chapterInclude<ExtArgs> | null
    where?: chapterWhereInput
    orderBy?: chapterOrderByWithRelationInput | chapterOrderByWithRelationInput[]
    cursor?: chapterWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChapterScalarFieldEnum | ChapterScalarFieldEnum[]
  }

  /**
   * product.customer_reader
   */
  export type product$customer_readerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer_reader
     */
    select?: customer_readerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customer_reader
     */
    omit?: customer_readerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customer_readerInclude<ExtArgs> | null
    where?: customer_readerWhereInput
    orderBy?: customer_readerOrderByWithRelationInput | customer_readerOrderByWithRelationInput[]
    cursor?: customer_readerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Customer_readerScalarFieldEnum | Customer_readerScalarFieldEnum[]
  }

  /**
   * product.preorder
   */
  export type product$preorderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the preorder
     */
    select?: preorderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the preorder
     */
    omit?: preorderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: preorderInclude<ExtArgs> | null
    where?: preorderWhereInput
    orderBy?: preorderOrderByWithRelationInput | preorderOrderByWithRelationInput[]
    cursor?: preorderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PreorderScalarFieldEnum | PreorderScalarFieldEnum[]
  }

  /**
   * product.author
   */
  export type product$authorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the author
     */
    select?: authorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the author
     */
    omit?: authorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: authorInclude<ExtArgs> | null
    where?: authorWhereInput
  }

  /**
   * product.product_category
   */
  export type product$product_categoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product_category
     */
    select?: product_categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the product_category
     */
    omit?: product_categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: product_categoryInclude<ExtArgs> | null
    where?: product_categoryWhereInput
    orderBy?: product_categoryOrderByWithRelationInput | product_categoryOrderByWithRelationInput[]
    cursor?: product_categoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Product_categoryScalarFieldEnum | Product_categoryScalarFieldEnum[]
  }

  /**
   * product.t_sales_download
   */
  export type product$t_sales_downloadArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the t_sales_download
     */
    select?: t_sales_downloadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the t_sales_download
     */
    omit?: t_sales_downloadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: t_sales_downloadInclude<ExtArgs> | null
    where?: t_sales_downloadWhereInput
    orderBy?: t_sales_downloadOrderByWithRelationInput | t_sales_downloadOrderByWithRelationInput[]
    cursor?: t_sales_downloadWhereUniqueInput
    take?: number
    skip?: number
    distinct?: T_sales_downloadScalarFieldEnum | T_sales_downloadScalarFieldEnum[]
  }

  /**
   * product.t_sales_line
   */
  export type product$t_sales_lineArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the t_sales_line
     */
    select?: t_sales_lineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the t_sales_line
     */
    omit?: t_sales_lineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: t_sales_lineInclude<ExtArgs> | null
    where?: t_sales_lineWhereInput
    orderBy?: t_sales_lineOrderByWithRelationInput | t_sales_lineOrderByWithRelationInput[]
    cursor?: t_sales_lineWhereUniqueInput
    take?: number
    skip?: number
    distinct?: T_sales_lineScalarFieldEnum | T_sales_lineScalarFieldEnum[]
  }

  /**
   * product without action
   */
  export type productDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product
     */
    select?: productSelect<ExtArgs> | null
    /**
     * Omit specific fields from the product
     */
    omit?: productOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productInclude<ExtArgs> | null
  }


  /**
   * Model product_category
   */

  export type AggregateProduct_category = {
    _count: Product_categoryCountAggregateOutputType | null
    _min: Product_categoryMinAggregateOutputType | null
    _max: Product_categoryMaxAggregateOutputType | null
  }

  export type Product_categoryMinAggregateOutputType = {
    id_product: string | null
    id_category: string | null
    id: string | null
  }

  export type Product_categoryMaxAggregateOutputType = {
    id_product: string | null
    id_category: string | null
    id: string | null
  }

  export type Product_categoryCountAggregateOutputType = {
    id_product: number
    id_category: number
    id: number
    _all: number
  }


  export type Product_categoryMinAggregateInputType = {
    id_product?: true
    id_category?: true
    id?: true
  }

  export type Product_categoryMaxAggregateInputType = {
    id_product?: true
    id_category?: true
    id?: true
  }

  export type Product_categoryCountAggregateInputType = {
    id_product?: true
    id_category?: true
    id?: true
    _all?: true
  }

  export type Product_categoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which product_category to aggregate.
     */
    where?: product_categoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of product_categories to fetch.
     */
    orderBy?: product_categoryOrderByWithRelationInput | product_categoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: product_categoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` product_categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` product_categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned product_categories
    **/
    _count?: true | Product_categoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Product_categoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Product_categoryMaxAggregateInputType
  }

  export type GetProduct_categoryAggregateType<T extends Product_categoryAggregateArgs> = {
        [P in keyof T & keyof AggregateProduct_category]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProduct_category[P]>
      : GetScalarType<T[P], AggregateProduct_category[P]>
  }




  export type product_categoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: product_categoryWhereInput
    orderBy?: product_categoryOrderByWithAggregationInput | product_categoryOrderByWithAggregationInput[]
    by: Product_categoryScalarFieldEnum[] | Product_categoryScalarFieldEnum
    having?: product_categoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Product_categoryCountAggregateInputType | true
    _min?: Product_categoryMinAggregateInputType
    _max?: Product_categoryMaxAggregateInputType
  }

  export type Product_categoryGroupByOutputType = {
    id_product: string
    id_category: string
    id: string
    _count: Product_categoryCountAggregateOutputType | null
    _min: Product_categoryMinAggregateOutputType | null
    _max: Product_categoryMaxAggregateOutputType | null
  }

  type GetProduct_categoryGroupByPayload<T extends product_categoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Product_categoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Product_categoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Product_categoryGroupByOutputType[P]>
            : GetScalarType<T[P], Product_categoryGroupByOutputType[P]>
        }
      >
    >


  export type product_categorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_product?: boolean
    id_category?: boolean
    id?: boolean
    category?: boolean | categoryDefaultArgs<ExtArgs>
    product?: boolean | productDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["product_category"]>

  export type product_categorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_product?: boolean
    id_category?: boolean
    id?: boolean
    category?: boolean | categoryDefaultArgs<ExtArgs>
    product?: boolean | productDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["product_category"]>

  export type product_categorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_product?: boolean
    id_category?: boolean
    id?: boolean
    category?: boolean | categoryDefaultArgs<ExtArgs>
    product?: boolean | productDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["product_category"]>

  export type product_categorySelectScalar = {
    id_product?: boolean
    id_category?: boolean
    id?: boolean
  }

  export type product_categoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id_product" | "id_category" | "id", ExtArgs["result"]["product_category"]>
  export type product_categoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | categoryDefaultArgs<ExtArgs>
    product?: boolean | productDefaultArgs<ExtArgs>
  }
  export type product_categoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | categoryDefaultArgs<ExtArgs>
    product?: boolean | productDefaultArgs<ExtArgs>
  }
  export type product_categoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | categoryDefaultArgs<ExtArgs>
    product?: boolean | productDefaultArgs<ExtArgs>
  }

  export type $product_categoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "product_category"
    objects: {
      category: Prisma.$categoryPayload<ExtArgs>
      product: Prisma.$productPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id_product: string
      id_category: string
      id: string
    }, ExtArgs["result"]["product_category"]>
    composites: {}
  }

  type product_categoryGetPayload<S extends boolean | null | undefined | product_categoryDefaultArgs> = $Result.GetResult<Prisma.$product_categoryPayload, S>

  type product_categoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<product_categoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Product_categoryCountAggregateInputType | true
    }

  export interface product_categoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['product_category'], meta: { name: 'product_category' } }
    /**
     * Find zero or one Product_category that matches the filter.
     * @param {product_categoryFindUniqueArgs} args - Arguments to find a Product_category
     * @example
     * // Get one Product_category
     * const product_category = await prisma.product_category.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends product_categoryFindUniqueArgs>(args: SelectSubset<T, product_categoryFindUniqueArgs<ExtArgs>>): Prisma__product_categoryClient<$Result.GetResult<Prisma.$product_categoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Product_category that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {product_categoryFindUniqueOrThrowArgs} args - Arguments to find a Product_category
     * @example
     * // Get one Product_category
     * const product_category = await prisma.product_category.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends product_categoryFindUniqueOrThrowArgs>(args: SelectSubset<T, product_categoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__product_categoryClient<$Result.GetResult<Prisma.$product_categoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Product_category that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {product_categoryFindFirstArgs} args - Arguments to find a Product_category
     * @example
     * // Get one Product_category
     * const product_category = await prisma.product_category.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends product_categoryFindFirstArgs>(args?: SelectSubset<T, product_categoryFindFirstArgs<ExtArgs>>): Prisma__product_categoryClient<$Result.GetResult<Prisma.$product_categoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Product_category that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {product_categoryFindFirstOrThrowArgs} args - Arguments to find a Product_category
     * @example
     * // Get one Product_category
     * const product_category = await prisma.product_category.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends product_categoryFindFirstOrThrowArgs>(args?: SelectSubset<T, product_categoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__product_categoryClient<$Result.GetResult<Prisma.$product_categoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Product_categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {product_categoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Product_categories
     * const product_categories = await prisma.product_category.findMany()
     * 
     * // Get first 10 Product_categories
     * const product_categories = await prisma.product_category.findMany({ take: 10 })
     * 
     * // Only select the `id_product`
     * const product_categoryWithId_productOnly = await prisma.product_category.findMany({ select: { id_product: true } })
     * 
     */
    findMany<T extends product_categoryFindManyArgs>(args?: SelectSubset<T, product_categoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$product_categoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Product_category.
     * @param {product_categoryCreateArgs} args - Arguments to create a Product_category.
     * @example
     * // Create one Product_category
     * const Product_category = await prisma.product_category.create({
     *   data: {
     *     // ... data to create a Product_category
     *   }
     * })
     * 
     */
    create<T extends product_categoryCreateArgs>(args: SelectSubset<T, product_categoryCreateArgs<ExtArgs>>): Prisma__product_categoryClient<$Result.GetResult<Prisma.$product_categoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Product_categories.
     * @param {product_categoryCreateManyArgs} args - Arguments to create many Product_categories.
     * @example
     * // Create many Product_categories
     * const product_category = await prisma.product_category.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends product_categoryCreateManyArgs>(args?: SelectSubset<T, product_categoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Product_categories and returns the data saved in the database.
     * @param {product_categoryCreateManyAndReturnArgs} args - Arguments to create many Product_categories.
     * @example
     * // Create many Product_categories
     * const product_category = await prisma.product_category.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Product_categories and only return the `id_product`
     * const product_categoryWithId_productOnly = await prisma.product_category.createManyAndReturn({
     *   select: { id_product: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends product_categoryCreateManyAndReturnArgs>(args?: SelectSubset<T, product_categoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$product_categoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Product_category.
     * @param {product_categoryDeleteArgs} args - Arguments to delete one Product_category.
     * @example
     * // Delete one Product_category
     * const Product_category = await prisma.product_category.delete({
     *   where: {
     *     // ... filter to delete one Product_category
     *   }
     * })
     * 
     */
    delete<T extends product_categoryDeleteArgs>(args: SelectSubset<T, product_categoryDeleteArgs<ExtArgs>>): Prisma__product_categoryClient<$Result.GetResult<Prisma.$product_categoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Product_category.
     * @param {product_categoryUpdateArgs} args - Arguments to update one Product_category.
     * @example
     * // Update one Product_category
     * const product_category = await prisma.product_category.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends product_categoryUpdateArgs>(args: SelectSubset<T, product_categoryUpdateArgs<ExtArgs>>): Prisma__product_categoryClient<$Result.GetResult<Prisma.$product_categoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Product_categories.
     * @param {product_categoryDeleteManyArgs} args - Arguments to filter Product_categories to delete.
     * @example
     * // Delete a few Product_categories
     * const { count } = await prisma.product_category.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends product_categoryDeleteManyArgs>(args?: SelectSubset<T, product_categoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Product_categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {product_categoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Product_categories
     * const product_category = await prisma.product_category.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends product_categoryUpdateManyArgs>(args: SelectSubset<T, product_categoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Product_categories and returns the data updated in the database.
     * @param {product_categoryUpdateManyAndReturnArgs} args - Arguments to update many Product_categories.
     * @example
     * // Update many Product_categories
     * const product_category = await prisma.product_category.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Product_categories and only return the `id_product`
     * const product_categoryWithId_productOnly = await prisma.product_category.updateManyAndReturn({
     *   select: { id_product: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends product_categoryUpdateManyAndReturnArgs>(args: SelectSubset<T, product_categoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$product_categoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Product_category.
     * @param {product_categoryUpsertArgs} args - Arguments to update or create a Product_category.
     * @example
     * // Update or create a Product_category
     * const product_category = await prisma.product_category.upsert({
     *   create: {
     *     // ... data to create a Product_category
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Product_category we want to update
     *   }
     * })
     */
    upsert<T extends product_categoryUpsertArgs>(args: SelectSubset<T, product_categoryUpsertArgs<ExtArgs>>): Prisma__product_categoryClient<$Result.GetResult<Prisma.$product_categoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Product_categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {product_categoryCountArgs} args - Arguments to filter Product_categories to count.
     * @example
     * // Count the number of Product_categories
     * const count = await prisma.product_category.count({
     *   where: {
     *     // ... the filter for the Product_categories we want to count
     *   }
     * })
    **/
    count<T extends product_categoryCountArgs>(
      args?: Subset<T, product_categoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Product_categoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Product_category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Product_categoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Product_categoryAggregateArgs>(args: Subset<T, Product_categoryAggregateArgs>): Prisma.PrismaPromise<GetProduct_categoryAggregateType<T>>

    /**
     * Group by Product_category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {product_categoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends product_categoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: product_categoryGroupByArgs['orderBy'] }
        : { orderBy?: product_categoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, product_categoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProduct_categoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the product_category model
   */
  readonly fields: product_categoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for product_category.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__product_categoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    category<T extends categoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, categoryDefaultArgs<ExtArgs>>): Prisma__categoryClient<$Result.GetResult<Prisma.$categoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    product<T extends productDefaultArgs<ExtArgs> = {}>(args?: Subset<T, productDefaultArgs<ExtArgs>>): Prisma__productClient<$Result.GetResult<Prisma.$productPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the product_category model
   */
  interface product_categoryFieldRefs {
    readonly id_product: FieldRef<"product_category", 'String'>
    readonly id_category: FieldRef<"product_category", 'String'>
    readonly id: FieldRef<"product_category", 'String'>
  }
    

  // Custom InputTypes
  /**
   * product_category findUnique
   */
  export type product_categoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product_category
     */
    select?: product_categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the product_category
     */
    omit?: product_categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: product_categoryInclude<ExtArgs> | null
    /**
     * Filter, which product_category to fetch.
     */
    where: product_categoryWhereUniqueInput
  }

  /**
   * product_category findUniqueOrThrow
   */
  export type product_categoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product_category
     */
    select?: product_categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the product_category
     */
    omit?: product_categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: product_categoryInclude<ExtArgs> | null
    /**
     * Filter, which product_category to fetch.
     */
    where: product_categoryWhereUniqueInput
  }

  /**
   * product_category findFirst
   */
  export type product_categoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product_category
     */
    select?: product_categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the product_category
     */
    omit?: product_categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: product_categoryInclude<ExtArgs> | null
    /**
     * Filter, which product_category to fetch.
     */
    where?: product_categoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of product_categories to fetch.
     */
    orderBy?: product_categoryOrderByWithRelationInput | product_categoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for product_categories.
     */
    cursor?: product_categoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` product_categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` product_categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of product_categories.
     */
    distinct?: Product_categoryScalarFieldEnum | Product_categoryScalarFieldEnum[]
  }

  /**
   * product_category findFirstOrThrow
   */
  export type product_categoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product_category
     */
    select?: product_categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the product_category
     */
    omit?: product_categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: product_categoryInclude<ExtArgs> | null
    /**
     * Filter, which product_category to fetch.
     */
    where?: product_categoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of product_categories to fetch.
     */
    orderBy?: product_categoryOrderByWithRelationInput | product_categoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for product_categories.
     */
    cursor?: product_categoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` product_categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` product_categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of product_categories.
     */
    distinct?: Product_categoryScalarFieldEnum | Product_categoryScalarFieldEnum[]
  }

  /**
   * product_category findMany
   */
  export type product_categoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product_category
     */
    select?: product_categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the product_category
     */
    omit?: product_categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: product_categoryInclude<ExtArgs> | null
    /**
     * Filter, which product_categories to fetch.
     */
    where?: product_categoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of product_categories to fetch.
     */
    orderBy?: product_categoryOrderByWithRelationInput | product_categoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing product_categories.
     */
    cursor?: product_categoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` product_categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` product_categories.
     */
    skip?: number
    distinct?: Product_categoryScalarFieldEnum | Product_categoryScalarFieldEnum[]
  }

  /**
   * product_category create
   */
  export type product_categoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product_category
     */
    select?: product_categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the product_category
     */
    omit?: product_categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: product_categoryInclude<ExtArgs> | null
    /**
     * The data needed to create a product_category.
     */
    data: XOR<product_categoryCreateInput, product_categoryUncheckedCreateInput>
  }

  /**
   * product_category createMany
   */
  export type product_categoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many product_categories.
     */
    data: product_categoryCreateManyInput | product_categoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * product_category createManyAndReturn
   */
  export type product_categoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product_category
     */
    select?: product_categorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the product_category
     */
    omit?: product_categoryOmit<ExtArgs> | null
    /**
     * The data used to create many product_categories.
     */
    data: product_categoryCreateManyInput | product_categoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: product_categoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * product_category update
   */
  export type product_categoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product_category
     */
    select?: product_categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the product_category
     */
    omit?: product_categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: product_categoryInclude<ExtArgs> | null
    /**
     * The data needed to update a product_category.
     */
    data: XOR<product_categoryUpdateInput, product_categoryUncheckedUpdateInput>
    /**
     * Choose, which product_category to update.
     */
    where: product_categoryWhereUniqueInput
  }

  /**
   * product_category updateMany
   */
  export type product_categoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update product_categories.
     */
    data: XOR<product_categoryUpdateManyMutationInput, product_categoryUncheckedUpdateManyInput>
    /**
     * Filter which product_categories to update
     */
    where?: product_categoryWhereInput
    /**
     * Limit how many product_categories to update.
     */
    limit?: number
  }

  /**
   * product_category updateManyAndReturn
   */
  export type product_categoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product_category
     */
    select?: product_categorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the product_category
     */
    omit?: product_categoryOmit<ExtArgs> | null
    /**
     * The data used to update product_categories.
     */
    data: XOR<product_categoryUpdateManyMutationInput, product_categoryUncheckedUpdateManyInput>
    /**
     * Filter which product_categories to update
     */
    where?: product_categoryWhereInput
    /**
     * Limit how many product_categories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: product_categoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * product_category upsert
   */
  export type product_categoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product_category
     */
    select?: product_categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the product_category
     */
    omit?: product_categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: product_categoryInclude<ExtArgs> | null
    /**
     * The filter to search for the product_category to update in case it exists.
     */
    where: product_categoryWhereUniqueInput
    /**
     * In case the product_category found by the `where` argument doesn't exist, create a new product_category with this data.
     */
    create: XOR<product_categoryCreateInput, product_categoryUncheckedCreateInput>
    /**
     * In case the product_category was found with the provided `where` argument, update it with this data.
     */
    update: XOR<product_categoryUpdateInput, product_categoryUncheckedUpdateInput>
  }

  /**
   * product_category delete
   */
  export type product_categoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product_category
     */
    select?: product_categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the product_category
     */
    omit?: product_categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: product_categoryInclude<ExtArgs> | null
    /**
     * Filter which product_category to delete.
     */
    where: product_categoryWhereUniqueInput
  }

  /**
   * product_category deleteMany
   */
  export type product_categoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which product_categories to delete
     */
    where?: product_categoryWhereInput
    /**
     * Limit how many product_categories to delete.
     */
    limit?: number
  }

  /**
   * product_category without action
   */
  export type product_categoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product_category
     */
    select?: product_categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the product_category
     */
    omit?: product_categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: product_categoryInclude<ExtArgs> | null
  }


  /**
   * Model promo_code
   */

  export type AggregatePromo_code = {
    _count: Promo_codeCountAggregateOutputType | null
    _avg: Promo_codeAvgAggregateOutputType | null
    _sum: Promo_codeSumAggregateOutputType | null
    _min: Promo_codeMinAggregateOutputType | null
    _max: Promo_codeMaxAggregateOutputType | null
  }

  export type Promo_codeAvgAggregateOutputType = {
    discount_value: Decimal | null
    usage_limit: number | null
    used_count: number | null
  }

  export type Promo_codeSumAggregateOutputType = {
    discount_value: Decimal | null
    usage_limit: number | null
    used_count: number | null
  }

  export type Promo_codeMinAggregateOutputType = {
    id: string | null
    code: string | null
    discount_type: string | null
    discount_value: Decimal | null
    valid_from: Date | null
    valid_to: Date | null
    usage_limit: number | null
    used_count: number | null
    status: string | null
    id_publisher: string | null
  }

  export type Promo_codeMaxAggregateOutputType = {
    id: string | null
    code: string | null
    discount_type: string | null
    discount_value: Decimal | null
    valid_from: Date | null
    valid_to: Date | null
    usage_limit: number | null
    used_count: number | null
    status: string | null
    id_publisher: string | null
  }

  export type Promo_codeCountAggregateOutputType = {
    id: number
    code: number
    discount_type: number
    discount_value: number
    valid_from: number
    valid_to: number
    usage_limit: number
    used_count: number
    status: number
    id_publisher: number
    _all: number
  }


  export type Promo_codeAvgAggregateInputType = {
    discount_value?: true
    usage_limit?: true
    used_count?: true
  }

  export type Promo_codeSumAggregateInputType = {
    discount_value?: true
    usage_limit?: true
    used_count?: true
  }

  export type Promo_codeMinAggregateInputType = {
    id?: true
    code?: true
    discount_type?: true
    discount_value?: true
    valid_from?: true
    valid_to?: true
    usage_limit?: true
    used_count?: true
    status?: true
    id_publisher?: true
  }

  export type Promo_codeMaxAggregateInputType = {
    id?: true
    code?: true
    discount_type?: true
    discount_value?: true
    valid_from?: true
    valid_to?: true
    usage_limit?: true
    used_count?: true
    status?: true
    id_publisher?: true
  }

  export type Promo_codeCountAggregateInputType = {
    id?: true
    code?: true
    discount_type?: true
    discount_value?: true
    valid_from?: true
    valid_to?: true
    usage_limit?: true
    used_count?: true
    status?: true
    id_publisher?: true
    _all?: true
  }

  export type Promo_codeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which promo_code to aggregate.
     */
    where?: promo_codeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of promo_codes to fetch.
     */
    orderBy?: promo_codeOrderByWithRelationInput | promo_codeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: promo_codeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` promo_codes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` promo_codes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned promo_codes
    **/
    _count?: true | Promo_codeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Promo_codeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Promo_codeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Promo_codeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Promo_codeMaxAggregateInputType
  }

  export type GetPromo_codeAggregateType<T extends Promo_codeAggregateArgs> = {
        [P in keyof T & keyof AggregatePromo_code]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePromo_code[P]>
      : GetScalarType<T[P], AggregatePromo_code[P]>
  }




  export type promo_codeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: promo_codeWhereInput
    orderBy?: promo_codeOrderByWithAggregationInput | promo_codeOrderByWithAggregationInput[]
    by: Promo_codeScalarFieldEnum[] | Promo_codeScalarFieldEnum
    having?: promo_codeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Promo_codeCountAggregateInputType | true
    _avg?: Promo_codeAvgAggregateInputType
    _sum?: Promo_codeSumAggregateInputType
    _min?: Promo_codeMinAggregateInputType
    _max?: Promo_codeMaxAggregateInputType
  }

  export type Promo_codeGroupByOutputType = {
    id: string
    code: string
    discount_type: string
    discount_value: Decimal
    valid_from: Date
    valid_to: Date
    usage_limit: number
    used_count: number
    status: string
    id_publisher: string
    _count: Promo_codeCountAggregateOutputType | null
    _avg: Promo_codeAvgAggregateOutputType | null
    _sum: Promo_codeSumAggregateOutputType | null
    _min: Promo_codeMinAggregateOutputType | null
    _max: Promo_codeMaxAggregateOutputType | null
  }

  type GetPromo_codeGroupByPayload<T extends promo_codeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Promo_codeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Promo_codeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Promo_codeGroupByOutputType[P]>
            : GetScalarType<T[P], Promo_codeGroupByOutputType[P]>
        }
      >
    >


  export type promo_codeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    discount_type?: boolean
    discount_value?: boolean
    valid_from?: boolean
    valid_to?: boolean
    usage_limit?: boolean
    used_count?: boolean
    status?: boolean
    id_publisher?: boolean
    publisher?: boolean | publisherDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["promo_code"]>

  export type promo_codeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    discount_type?: boolean
    discount_value?: boolean
    valid_from?: boolean
    valid_to?: boolean
    usage_limit?: boolean
    used_count?: boolean
    status?: boolean
    id_publisher?: boolean
    publisher?: boolean | publisherDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["promo_code"]>

  export type promo_codeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    discount_type?: boolean
    discount_value?: boolean
    valid_from?: boolean
    valid_to?: boolean
    usage_limit?: boolean
    used_count?: boolean
    status?: boolean
    id_publisher?: boolean
    publisher?: boolean | publisherDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["promo_code"]>

  export type promo_codeSelectScalar = {
    id?: boolean
    code?: boolean
    discount_type?: boolean
    discount_value?: boolean
    valid_from?: boolean
    valid_to?: boolean
    usage_limit?: boolean
    used_count?: boolean
    status?: boolean
    id_publisher?: boolean
  }

  export type promo_codeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code" | "discount_type" | "discount_value" | "valid_from" | "valid_to" | "usage_limit" | "used_count" | "status" | "id_publisher", ExtArgs["result"]["promo_code"]>
  export type promo_codeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    publisher?: boolean | publisherDefaultArgs<ExtArgs>
  }
  export type promo_codeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    publisher?: boolean | publisherDefaultArgs<ExtArgs>
  }
  export type promo_codeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    publisher?: boolean | publisherDefaultArgs<ExtArgs>
  }

  export type $promo_codePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "promo_code"
    objects: {
      publisher: Prisma.$publisherPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string
      discount_type: string
      discount_value: Prisma.Decimal
      valid_from: Date
      valid_to: Date
      usage_limit: number
      used_count: number
      status: string
      id_publisher: string
    }, ExtArgs["result"]["promo_code"]>
    composites: {}
  }

  type promo_codeGetPayload<S extends boolean | null | undefined | promo_codeDefaultArgs> = $Result.GetResult<Prisma.$promo_codePayload, S>

  type promo_codeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<promo_codeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Promo_codeCountAggregateInputType | true
    }

  export interface promo_codeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['promo_code'], meta: { name: 'promo_code' } }
    /**
     * Find zero or one Promo_code that matches the filter.
     * @param {promo_codeFindUniqueArgs} args - Arguments to find a Promo_code
     * @example
     * // Get one Promo_code
     * const promo_code = await prisma.promo_code.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends promo_codeFindUniqueArgs>(args: SelectSubset<T, promo_codeFindUniqueArgs<ExtArgs>>): Prisma__promo_codeClient<$Result.GetResult<Prisma.$promo_codePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Promo_code that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {promo_codeFindUniqueOrThrowArgs} args - Arguments to find a Promo_code
     * @example
     * // Get one Promo_code
     * const promo_code = await prisma.promo_code.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends promo_codeFindUniqueOrThrowArgs>(args: SelectSubset<T, promo_codeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__promo_codeClient<$Result.GetResult<Prisma.$promo_codePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Promo_code that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {promo_codeFindFirstArgs} args - Arguments to find a Promo_code
     * @example
     * // Get one Promo_code
     * const promo_code = await prisma.promo_code.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends promo_codeFindFirstArgs>(args?: SelectSubset<T, promo_codeFindFirstArgs<ExtArgs>>): Prisma__promo_codeClient<$Result.GetResult<Prisma.$promo_codePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Promo_code that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {promo_codeFindFirstOrThrowArgs} args - Arguments to find a Promo_code
     * @example
     * // Get one Promo_code
     * const promo_code = await prisma.promo_code.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends promo_codeFindFirstOrThrowArgs>(args?: SelectSubset<T, promo_codeFindFirstOrThrowArgs<ExtArgs>>): Prisma__promo_codeClient<$Result.GetResult<Prisma.$promo_codePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Promo_codes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {promo_codeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Promo_codes
     * const promo_codes = await prisma.promo_code.findMany()
     * 
     * // Get first 10 Promo_codes
     * const promo_codes = await prisma.promo_code.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const promo_codeWithIdOnly = await prisma.promo_code.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends promo_codeFindManyArgs>(args?: SelectSubset<T, promo_codeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$promo_codePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Promo_code.
     * @param {promo_codeCreateArgs} args - Arguments to create a Promo_code.
     * @example
     * // Create one Promo_code
     * const Promo_code = await prisma.promo_code.create({
     *   data: {
     *     // ... data to create a Promo_code
     *   }
     * })
     * 
     */
    create<T extends promo_codeCreateArgs>(args: SelectSubset<T, promo_codeCreateArgs<ExtArgs>>): Prisma__promo_codeClient<$Result.GetResult<Prisma.$promo_codePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Promo_codes.
     * @param {promo_codeCreateManyArgs} args - Arguments to create many Promo_codes.
     * @example
     * // Create many Promo_codes
     * const promo_code = await prisma.promo_code.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends promo_codeCreateManyArgs>(args?: SelectSubset<T, promo_codeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Promo_codes and returns the data saved in the database.
     * @param {promo_codeCreateManyAndReturnArgs} args - Arguments to create many Promo_codes.
     * @example
     * // Create many Promo_codes
     * const promo_code = await prisma.promo_code.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Promo_codes and only return the `id`
     * const promo_codeWithIdOnly = await prisma.promo_code.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends promo_codeCreateManyAndReturnArgs>(args?: SelectSubset<T, promo_codeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$promo_codePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Promo_code.
     * @param {promo_codeDeleteArgs} args - Arguments to delete one Promo_code.
     * @example
     * // Delete one Promo_code
     * const Promo_code = await prisma.promo_code.delete({
     *   where: {
     *     // ... filter to delete one Promo_code
     *   }
     * })
     * 
     */
    delete<T extends promo_codeDeleteArgs>(args: SelectSubset<T, promo_codeDeleteArgs<ExtArgs>>): Prisma__promo_codeClient<$Result.GetResult<Prisma.$promo_codePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Promo_code.
     * @param {promo_codeUpdateArgs} args - Arguments to update one Promo_code.
     * @example
     * // Update one Promo_code
     * const promo_code = await prisma.promo_code.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends promo_codeUpdateArgs>(args: SelectSubset<T, promo_codeUpdateArgs<ExtArgs>>): Prisma__promo_codeClient<$Result.GetResult<Prisma.$promo_codePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Promo_codes.
     * @param {promo_codeDeleteManyArgs} args - Arguments to filter Promo_codes to delete.
     * @example
     * // Delete a few Promo_codes
     * const { count } = await prisma.promo_code.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends promo_codeDeleteManyArgs>(args?: SelectSubset<T, promo_codeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Promo_codes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {promo_codeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Promo_codes
     * const promo_code = await prisma.promo_code.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends promo_codeUpdateManyArgs>(args: SelectSubset<T, promo_codeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Promo_codes and returns the data updated in the database.
     * @param {promo_codeUpdateManyAndReturnArgs} args - Arguments to update many Promo_codes.
     * @example
     * // Update many Promo_codes
     * const promo_code = await prisma.promo_code.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Promo_codes and only return the `id`
     * const promo_codeWithIdOnly = await prisma.promo_code.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends promo_codeUpdateManyAndReturnArgs>(args: SelectSubset<T, promo_codeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$promo_codePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Promo_code.
     * @param {promo_codeUpsertArgs} args - Arguments to update or create a Promo_code.
     * @example
     * // Update or create a Promo_code
     * const promo_code = await prisma.promo_code.upsert({
     *   create: {
     *     // ... data to create a Promo_code
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Promo_code we want to update
     *   }
     * })
     */
    upsert<T extends promo_codeUpsertArgs>(args: SelectSubset<T, promo_codeUpsertArgs<ExtArgs>>): Prisma__promo_codeClient<$Result.GetResult<Prisma.$promo_codePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Promo_codes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {promo_codeCountArgs} args - Arguments to filter Promo_codes to count.
     * @example
     * // Count the number of Promo_codes
     * const count = await prisma.promo_code.count({
     *   where: {
     *     // ... the filter for the Promo_codes we want to count
     *   }
     * })
    **/
    count<T extends promo_codeCountArgs>(
      args?: Subset<T, promo_codeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Promo_codeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Promo_code.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Promo_codeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Promo_codeAggregateArgs>(args: Subset<T, Promo_codeAggregateArgs>): Prisma.PrismaPromise<GetPromo_codeAggregateType<T>>

    /**
     * Group by Promo_code.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {promo_codeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends promo_codeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: promo_codeGroupByArgs['orderBy'] }
        : { orderBy?: promo_codeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, promo_codeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPromo_codeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the promo_code model
   */
  readonly fields: promo_codeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for promo_code.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__promo_codeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    publisher<T extends publisherDefaultArgs<ExtArgs> = {}>(args?: Subset<T, publisherDefaultArgs<ExtArgs>>): Prisma__publisherClient<$Result.GetResult<Prisma.$publisherPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the promo_code model
   */
  interface promo_codeFieldRefs {
    readonly id: FieldRef<"promo_code", 'String'>
    readonly code: FieldRef<"promo_code", 'String'>
    readonly discount_type: FieldRef<"promo_code", 'String'>
    readonly discount_value: FieldRef<"promo_code", 'Decimal'>
    readonly valid_from: FieldRef<"promo_code", 'DateTime'>
    readonly valid_to: FieldRef<"promo_code", 'DateTime'>
    readonly usage_limit: FieldRef<"promo_code", 'Int'>
    readonly used_count: FieldRef<"promo_code", 'Int'>
    readonly status: FieldRef<"promo_code", 'String'>
    readonly id_publisher: FieldRef<"promo_code", 'String'>
  }
    

  // Custom InputTypes
  /**
   * promo_code findUnique
   */
  export type promo_codeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the promo_code
     */
    select?: promo_codeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the promo_code
     */
    omit?: promo_codeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: promo_codeInclude<ExtArgs> | null
    /**
     * Filter, which promo_code to fetch.
     */
    where: promo_codeWhereUniqueInput
  }

  /**
   * promo_code findUniqueOrThrow
   */
  export type promo_codeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the promo_code
     */
    select?: promo_codeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the promo_code
     */
    omit?: promo_codeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: promo_codeInclude<ExtArgs> | null
    /**
     * Filter, which promo_code to fetch.
     */
    where: promo_codeWhereUniqueInput
  }

  /**
   * promo_code findFirst
   */
  export type promo_codeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the promo_code
     */
    select?: promo_codeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the promo_code
     */
    omit?: promo_codeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: promo_codeInclude<ExtArgs> | null
    /**
     * Filter, which promo_code to fetch.
     */
    where?: promo_codeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of promo_codes to fetch.
     */
    orderBy?: promo_codeOrderByWithRelationInput | promo_codeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for promo_codes.
     */
    cursor?: promo_codeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` promo_codes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` promo_codes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of promo_codes.
     */
    distinct?: Promo_codeScalarFieldEnum | Promo_codeScalarFieldEnum[]
  }

  /**
   * promo_code findFirstOrThrow
   */
  export type promo_codeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the promo_code
     */
    select?: promo_codeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the promo_code
     */
    omit?: promo_codeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: promo_codeInclude<ExtArgs> | null
    /**
     * Filter, which promo_code to fetch.
     */
    where?: promo_codeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of promo_codes to fetch.
     */
    orderBy?: promo_codeOrderByWithRelationInput | promo_codeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for promo_codes.
     */
    cursor?: promo_codeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` promo_codes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` promo_codes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of promo_codes.
     */
    distinct?: Promo_codeScalarFieldEnum | Promo_codeScalarFieldEnum[]
  }

  /**
   * promo_code findMany
   */
  export type promo_codeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the promo_code
     */
    select?: promo_codeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the promo_code
     */
    omit?: promo_codeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: promo_codeInclude<ExtArgs> | null
    /**
     * Filter, which promo_codes to fetch.
     */
    where?: promo_codeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of promo_codes to fetch.
     */
    orderBy?: promo_codeOrderByWithRelationInput | promo_codeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing promo_codes.
     */
    cursor?: promo_codeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` promo_codes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` promo_codes.
     */
    skip?: number
    distinct?: Promo_codeScalarFieldEnum | Promo_codeScalarFieldEnum[]
  }

  /**
   * promo_code create
   */
  export type promo_codeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the promo_code
     */
    select?: promo_codeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the promo_code
     */
    omit?: promo_codeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: promo_codeInclude<ExtArgs> | null
    /**
     * The data needed to create a promo_code.
     */
    data: XOR<promo_codeCreateInput, promo_codeUncheckedCreateInput>
  }

  /**
   * promo_code createMany
   */
  export type promo_codeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many promo_codes.
     */
    data: promo_codeCreateManyInput | promo_codeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * promo_code createManyAndReturn
   */
  export type promo_codeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the promo_code
     */
    select?: promo_codeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the promo_code
     */
    omit?: promo_codeOmit<ExtArgs> | null
    /**
     * The data used to create many promo_codes.
     */
    data: promo_codeCreateManyInput | promo_codeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: promo_codeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * promo_code update
   */
  export type promo_codeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the promo_code
     */
    select?: promo_codeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the promo_code
     */
    omit?: promo_codeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: promo_codeInclude<ExtArgs> | null
    /**
     * The data needed to update a promo_code.
     */
    data: XOR<promo_codeUpdateInput, promo_codeUncheckedUpdateInput>
    /**
     * Choose, which promo_code to update.
     */
    where: promo_codeWhereUniqueInput
  }

  /**
   * promo_code updateMany
   */
  export type promo_codeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update promo_codes.
     */
    data: XOR<promo_codeUpdateManyMutationInput, promo_codeUncheckedUpdateManyInput>
    /**
     * Filter which promo_codes to update
     */
    where?: promo_codeWhereInput
    /**
     * Limit how many promo_codes to update.
     */
    limit?: number
  }

  /**
   * promo_code updateManyAndReturn
   */
  export type promo_codeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the promo_code
     */
    select?: promo_codeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the promo_code
     */
    omit?: promo_codeOmit<ExtArgs> | null
    /**
     * The data used to update promo_codes.
     */
    data: XOR<promo_codeUpdateManyMutationInput, promo_codeUncheckedUpdateManyInput>
    /**
     * Filter which promo_codes to update
     */
    where?: promo_codeWhereInput
    /**
     * Limit how many promo_codes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: promo_codeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * promo_code upsert
   */
  export type promo_codeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the promo_code
     */
    select?: promo_codeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the promo_code
     */
    omit?: promo_codeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: promo_codeInclude<ExtArgs> | null
    /**
     * The filter to search for the promo_code to update in case it exists.
     */
    where: promo_codeWhereUniqueInput
    /**
     * In case the promo_code found by the `where` argument doesn't exist, create a new promo_code with this data.
     */
    create: XOR<promo_codeCreateInput, promo_codeUncheckedCreateInput>
    /**
     * In case the promo_code was found with the provided `where` argument, update it with this data.
     */
    update: XOR<promo_codeUpdateInput, promo_codeUncheckedUpdateInput>
  }

  /**
   * promo_code delete
   */
  export type promo_codeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the promo_code
     */
    select?: promo_codeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the promo_code
     */
    omit?: promo_codeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: promo_codeInclude<ExtArgs> | null
    /**
     * Filter which promo_code to delete.
     */
    where: promo_codeWhereUniqueInput
  }

  /**
   * promo_code deleteMany
   */
  export type promo_codeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which promo_codes to delete
     */
    where?: promo_codeWhereInput
    /**
     * Limit how many promo_codes to delete.
     */
    limit?: number
  }

  /**
   * promo_code without action
   */
  export type promo_codeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the promo_code
     */
    select?: promo_codeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the promo_code
     */
    omit?: promo_codeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: promo_codeInclude<ExtArgs> | null
  }


  /**
   * Model publisher
   */

  export type AggregatePublisher = {
    _count: PublisherCountAggregateOutputType | null
    _min: PublisherMinAggregateOutputType | null
    _max: PublisherMaxAggregateOutputType | null
  }

  export type PublisherMinAggregateOutputType = {
    id: string | null
    id_account: string | null
    name: string | null
    description: string | null
    website: string | null
    address: string | null
    logo: string | null
  }

  export type PublisherMaxAggregateOutputType = {
    id: string | null
    id_account: string | null
    name: string | null
    description: string | null
    website: string | null
    address: string | null
    logo: string | null
  }

  export type PublisherCountAggregateOutputType = {
    id: number
    id_account: number
    name: number
    description: number
    website: number
    address: number
    logo: number
    _all: number
  }


  export type PublisherMinAggregateInputType = {
    id?: true
    id_account?: true
    name?: true
    description?: true
    website?: true
    address?: true
    logo?: true
  }

  export type PublisherMaxAggregateInputType = {
    id?: true
    id_account?: true
    name?: true
    description?: true
    website?: true
    address?: true
    logo?: true
  }

  export type PublisherCountAggregateInputType = {
    id?: true
    id_account?: true
    name?: true
    description?: true
    website?: true
    address?: true
    logo?: true
    _all?: true
  }

  export type PublisherAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which publisher to aggregate.
     */
    where?: publisherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of publishers to fetch.
     */
    orderBy?: publisherOrderByWithRelationInput | publisherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: publisherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` publishers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` publishers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned publishers
    **/
    _count?: true | PublisherCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PublisherMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PublisherMaxAggregateInputType
  }

  export type GetPublisherAggregateType<T extends PublisherAggregateArgs> = {
        [P in keyof T & keyof AggregatePublisher]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePublisher[P]>
      : GetScalarType<T[P], AggregatePublisher[P]>
  }




  export type publisherGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: publisherWhereInput
    orderBy?: publisherOrderByWithAggregationInput | publisherOrderByWithAggregationInput[]
    by: PublisherScalarFieldEnum[] | PublisherScalarFieldEnum
    having?: publisherScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PublisherCountAggregateInputType | true
    _min?: PublisherMinAggregateInputType
    _max?: PublisherMaxAggregateInputType
  }

  export type PublisherGroupByOutputType = {
    id: string
    id_account: string | null
    name: string
    description: string | null
    website: string | null
    address: string | null
    logo: string | null
    _count: PublisherCountAggregateOutputType | null
    _min: PublisherMinAggregateOutputType | null
    _max: PublisherMaxAggregateOutputType | null
  }

  type GetPublisherGroupByPayload<T extends publisherGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PublisherGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PublisherGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PublisherGroupByOutputType[P]>
            : GetScalarType<T[P], PublisherGroupByOutputType[P]>
        }
      >
    >


  export type publisherSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    id_account?: boolean
    name?: boolean
    description?: boolean
    website?: boolean
    address?: boolean
    logo?: boolean
    auth_user?: boolean | publisher$auth_userArgs<ExtArgs>
    promo_code?: boolean | publisher$promo_codeArgs<ExtArgs>
    auth_account?: boolean | publisher$auth_accountArgs<ExtArgs>
    publisher_author?: boolean | publisher$publisher_authorArgs<ExtArgs>
    t_ai_credit?: boolean | publisher$t_ai_creditArgs<ExtArgs>
    transaction?: boolean | publisher$transactionArgs<ExtArgs>
    withdrawal?: boolean | publisher$withdrawalArgs<ExtArgs>
    _count?: boolean | PublisherCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["publisher"]>

  export type publisherSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    id_account?: boolean
    name?: boolean
    description?: boolean
    website?: boolean
    address?: boolean
    logo?: boolean
    auth_account?: boolean | publisher$auth_accountArgs<ExtArgs>
  }, ExtArgs["result"]["publisher"]>

  export type publisherSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    id_account?: boolean
    name?: boolean
    description?: boolean
    website?: boolean
    address?: boolean
    logo?: boolean
    auth_account?: boolean | publisher$auth_accountArgs<ExtArgs>
  }, ExtArgs["result"]["publisher"]>

  export type publisherSelectScalar = {
    id?: boolean
    id_account?: boolean
    name?: boolean
    description?: boolean
    website?: boolean
    address?: boolean
    logo?: boolean
  }

  export type publisherOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "id_account" | "name" | "description" | "website" | "address" | "logo", ExtArgs["result"]["publisher"]>
  export type publisherInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    auth_user?: boolean | publisher$auth_userArgs<ExtArgs>
    promo_code?: boolean | publisher$promo_codeArgs<ExtArgs>
    auth_account?: boolean | publisher$auth_accountArgs<ExtArgs>
    publisher_author?: boolean | publisher$publisher_authorArgs<ExtArgs>
    t_ai_credit?: boolean | publisher$t_ai_creditArgs<ExtArgs>
    transaction?: boolean | publisher$transactionArgs<ExtArgs>
    withdrawal?: boolean | publisher$withdrawalArgs<ExtArgs>
    _count?: boolean | PublisherCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type publisherIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    auth_account?: boolean | publisher$auth_accountArgs<ExtArgs>
  }
  export type publisherIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    auth_account?: boolean | publisher$auth_accountArgs<ExtArgs>
  }

  export type $publisherPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "publisher"
    objects: {
      auth_user: Prisma.$auth_userPayload<ExtArgs>[]
      promo_code: Prisma.$promo_codePayload<ExtArgs>[]
      auth_account: Prisma.$auth_accountPayload<ExtArgs> | null
      publisher_author: Prisma.$publisher_authorPayload<ExtArgs>[]
      t_ai_credit: Prisma.$t_ai_creditPayload<ExtArgs>[]
      transaction: Prisma.$transactionPayload<ExtArgs>[]
      withdrawal: Prisma.$withdrawalPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      id_account: string | null
      name: string
      description: string | null
      website: string | null
      address: string | null
      logo: string | null
    }, ExtArgs["result"]["publisher"]>
    composites: {}
  }

  type publisherGetPayload<S extends boolean | null | undefined | publisherDefaultArgs> = $Result.GetResult<Prisma.$publisherPayload, S>

  type publisherCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<publisherFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PublisherCountAggregateInputType | true
    }

  export interface publisherDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['publisher'], meta: { name: 'publisher' } }
    /**
     * Find zero or one Publisher that matches the filter.
     * @param {publisherFindUniqueArgs} args - Arguments to find a Publisher
     * @example
     * // Get one Publisher
     * const publisher = await prisma.publisher.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends publisherFindUniqueArgs>(args: SelectSubset<T, publisherFindUniqueArgs<ExtArgs>>): Prisma__publisherClient<$Result.GetResult<Prisma.$publisherPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Publisher that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {publisherFindUniqueOrThrowArgs} args - Arguments to find a Publisher
     * @example
     * // Get one Publisher
     * const publisher = await prisma.publisher.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends publisherFindUniqueOrThrowArgs>(args: SelectSubset<T, publisherFindUniqueOrThrowArgs<ExtArgs>>): Prisma__publisherClient<$Result.GetResult<Prisma.$publisherPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Publisher that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {publisherFindFirstArgs} args - Arguments to find a Publisher
     * @example
     * // Get one Publisher
     * const publisher = await prisma.publisher.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends publisherFindFirstArgs>(args?: SelectSubset<T, publisherFindFirstArgs<ExtArgs>>): Prisma__publisherClient<$Result.GetResult<Prisma.$publisherPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Publisher that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {publisherFindFirstOrThrowArgs} args - Arguments to find a Publisher
     * @example
     * // Get one Publisher
     * const publisher = await prisma.publisher.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends publisherFindFirstOrThrowArgs>(args?: SelectSubset<T, publisherFindFirstOrThrowArgs<ExtArgs>>): Prisma__publisherClient<$Result.GetResult<Prisma.$publisherPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Publishers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {publisherFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Publishers
     * const publishers = await prisma.publisher.findMany()
     * 
     * // Get first 10 Publishers
     * const publishers = await prisma.publisher.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const publisherWithIdOnly = await prisma.publisher.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends publisherFindManyArgs>(args?: SelectSubset<T, publisherFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$publisherPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Publisher.
     * @param {publisherCreateArgs} args - Arguments to create a Publisher.
     * @example
     * // Create one Publisher
     * const Publisher = await prisma.publisher.create({
     *   data: {
     *     // ... data to create a Publisher
     *   }
     * })
     * 
     */
    create<T extends publisherCreateArgs>(args: SelectSubset<T, publisherCreateArgs<ExtArgs>>): Prisma__publisherClient<$Result.GetResult<Prisma.$publisherPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Publishers.
     * @param {publisherCreateManyArgs} args - Arguments to create many Publishers.
     * @example
     * // Create many Publishers
     * const publisher = await prisma.publisher.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends publisherCreateManyArgs>(args?: SelectSubset<T, publisherCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Publishers and returns the data saved in the database.
     * @param {publisherCreateManyAndReturnArgs} args - Arguments to create many Publishers.
     * @example
     * // Create many Publishers
     * const publisher = await prisma.publisher.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Publishers and only return the `id`
     * const publisherWithIdOnly = await prisma.publisher.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends publisherCreateManyAndReturnArgs>(args?: SelectSubset<T, publisherCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$publisherPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Publisher.
     * @param {publisherDeleteArgs} args - Arguments to delete one Publisher.
     * @example
     * // Delete one Publisher
     * const Publisher = await prisma.publisher.delete({
     *   where: {
     *     // ... filter to delete one Publisher
     *   }
     * })
     * 
     */
    delete<T extends publisherDeleteArgs>(args: SelectSubset<T, publisherDeleteArgs<ExtArgs>>): Prisma__publisherClient<$Result.GetResult<Prisma.$publisherPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Publisher.
     * @param {publisherUpdateArgs} args - Arguments to update one Publisher.
     * @example
     * // Update one Publisher
     * const publisher = await prisma.publisher.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends publisherUpdateArgs>(args: SelectSubset<T, publisherUpdateArgs<ExtArgs>>): Prisma__publisherClient<$Result.GetResult<Prisma.$publisherPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Publishers.
     * @param {publisherDeleteManyArgs} args - Arguments to filter Publishers to delete.
     * @example
     * // Delete a few Publishers
     * const { count } = await prisma.publisher.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends publisherDeleteManyArgs>(args?: SelectSubset<T, publisherDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Publishers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {publisherUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Publishers
     * const publisher = await prisma.publisher.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends publisherUpdateManyArgs>(args: SelectSubset<T, publisherUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Publishers and returns the data updated in the database.
     * @param {publisherUpdateManyAndReturnArgs} args - Arguments to update many Publishers.
     * @example
     * // Update many Publishers
     * const publisher = await prisma.publisher.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Publishers and only return the `id`
     * const publisherWithIdOnly = await prisma.publisher.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends publisherUpdateManyAndReturnArgs>(args: SelectSubset<T, publisherUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$publisherPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Publisher.
     * @param {publisherUpsertArgs} args - Arguments to update or create a Publisher.
     * @example
     * // Update or create a Publisher
     * const publisher = await prisma.publisher.upsert({
     *   create: {
     *     // ... data to create a Publisher
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Publisher we want to update
     *   }
     * })
     */
    upsert<T extends publisherUpsertArgs>(args: SelectSubset<T, publisherUpsertArgs<ExtArgs>>): Prisma__publisherClient<$Result.GetResult<Prisma.$publisherPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Publishers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {publisherCountArgs} args - Arguments to filter Publishers to count.
     * @example
     * // Count the number of Publishers
     * const count = await prisma.publisher.count({
     *   where: {
     *     // ... the filter for the Publishers we want to count
     *   }
     * })
    **/
    count<T extends publisherCountArgs>(
      args?: Subset<T, publisherCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PublisherCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Publisher.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PublisherAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PublisherAggregateArgs>(args: Subset<T, PublisherAggregateArgs>): Prisma.PrismaPromise<GetPublisherAggregateType<T>>

    /**
     * Group by Publisher.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {publisherGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends publisherGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: publisherGroupByArgs['orderBy'] }
        : { orderBy?: publisherGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, publisherGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPublisherGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the publisher model
   */
  readonly fields: publisherFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for publisher.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__publisherClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    auth_user<T extends publisher$auth_userArgs<ExtArgs> = {}>(args?: Subset<T, publisher$auth_userArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$auth_userPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    promo_code<T extends publisher$promo_codeArgs<ExtArgs> = {}>(args?: Subset<T, publisher$promo_codeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$promo_codePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    auth_account<T extends publisher$auth_accountArgs<ExtArgs> = {}>(args?: Subset<T, publisher$auth_accountArgs<ExtArgs>>): Prisma__auth_accountClient<$Result.GetResult<Prisma.$auth_accountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    publisher_author<T extends publisher$publisher_authorArgs<ExtArgs> = {}>(args?: Subset<T, publisher$publisher_authorArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$publisher_authorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    t_ai_credit<T extends publisher$t_ai_creditArgs<ExtArgs> = {}>(args?: Subset<T, publisher$t_ai_creditArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$t_ai_creditPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    transaction<T extends publisher$transactionArgs<ExtArgs> = {}>(args?: Subset<T, publisher$transactionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$transactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    withdrawal<T extends publisher$withdrawalArgs<ExtArgs> = {}>(args?: Subset<T, publisher$withdrawalArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$withdrawalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the publisher model
   */
  interface publisherFieldRefs {
    readonly id: FieldRef<"publisher", 'String'>
    readonly id_account: FieldRef<"publisher", 'String'>
    readonly name: FieldRef<"publisher", 'String'>
    readonly description: FieldRef<"publisher", 'String'>
    readonly website: FieldRef<"publisher", 'String'>
    readonly address: FieldRef<"publisher", 'String'>
    readonly logo: FieldRef<"publisher", 'String'>
  }
    

  // Custom InputTypes
  /**
   * publisher findUnique
   */
  export type publisherFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the publisher
     */
    select?: publisherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the publisher
     */
    omit?: publisherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: publisherInclude<ExtArgs> | null
    /**
     * Filter, which publisher to fetch.
     */
    where: publisherWhereUniqueInput
  }

  /**
   * publisher findUniqueOrThrow
   */
  export type publisherFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the publisher
     */
    select?: publisherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the publisher
     */
    omit?: publisherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: publisherInclude<ExtArgs> | null
    /**
     * Filter, which publisher to fetch.
     */
    where: publisherWhereUniqueInput
  }

  /**
   * publisher findFirst
   */
  export type publisherFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the publisher
     */
    select?: publisherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the publisher
     */
    omit?: publisherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: publisherInclude<ExtArgs> | null
    /**
     * Filter, which publisher to fetch.
     */
    where?: publisherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of publishers to fetch.
     */
    orderBy?: publisherOrderByWithRelationInput | publisherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for publishers.
     */
    cursor?: publisherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` publishers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` publishers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of publishers.
     */
    distinct?: PublisherScalarFieldEnum | PublisherScalarFieldEnum[]
  }

  /**
   * publisher findFirstOrThrow
   */
  export type publisherFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the publisher
     */
    select?: publisherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the publisher
     */
    omit?: publisherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: publisherInclude<ExtArgs> | null
    /**
     * Filter, which publisher to fetch.
     */
    where?: publisherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of publishers to fetch.
     */
    orderBy?: publisherOrderByWithRelationInput | publisherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for publishers.
     */
    cursor?: publisherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` publishers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` publishers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of publishers.
     */
    distinct?: PublisherScalarFieldEnum | PublisherScalarFieldEnum[]
  }

  /**
   * publisher findMany
   */
  export type publisherFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the publisher
     */
    select?: publisherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the publisher
     */
    omit?: publisherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: publisherInclude<ExtArgs> | null
    /**
     * Filter, which publishers to fetch.
     */
    where?: publisherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of publishers to fetch.
     */
    orderBy?: publisherOrderByWithRelationInput | publisherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing publishers.
     */
    cursor?: publisherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` publishers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` publishers.
     */
    skip?: number
    distinct?: PublisherScalarFieldEnum | PublisherScalarFieldEnum[]
  }

  /**
   * publisher create
   */
  export type publisherCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the publisher
     */
    select?: publisherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the publisher
     */
    omit?: publisherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: publisherInclude<ExtArgs> | null
    /**
     * The data needed to create a publisher.
     */
    data: XOR<publisherCreateInput, publisherUncheckedCreateInput>
  }

  /**
   * publisher createMany
   */
  export type publisherCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many publishers.
     */
    data: publisherCreateManyInput | publisherCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * publisher createManyAndReturn
   */
  export type publisherCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the publisher
     */
    select?: publisherSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the publisher
     */
    omit?: publisherOmit<ExtArgs> | null
    /**
     * The data used to create many publishers.
     */
    data: publisherCreateManyInput | publisherCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: publisherIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * publisher update
   */
  export type publisherUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the publisher
     */
    select?: publisherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the publisher
     */
    omit?: publisherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: publisherInclude<ExtArgs> | null
    /**
     * The data needed to update a publisher.
     */
    data: XOR<publisherUpdateInput, publisherUncheckedUpdateInput>
    /**
     * Choose, which publisher to update.
     */
    where: publisherWhereUniqueInput
  }

  /**
   * publisher updateMany
   */
  export type publisherUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update publishers.
     */
    data: XOR<publisherUpdateManyMutationInput, publisherUncheckedUpdateManyInput>
    /**
     * Filter which publishers to update
     */
    where?: publisherWhereInput
    /**
     * Limit how many publishers to update.
     */
    limit?: number
  }

  /**
   * publisher updateManyAndReturn
   */
  export type publisherUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the publisher
     */
    select?: publisherSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the publisher
     */
    omit?: publisherOmit<ExtArgs> | null
    /**
     * The data used to update publishers.
     */
    data: XOR<publisherUpdateManyMutationInput, publisherUncheckedUpdateManyInput>
    /**
     * Filter which publishers to update
     */
    where?: publisherWhereInput
    /**
     * Limit how many publishers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: publisherIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * publisher upsert
   */
  export type publisherUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the publisher
     */
    select?: publisherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the publisher
     */
    omit?: publisherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: publisherInclude<ExtArgs> | null
    /**
     * The filter to search for the publisher to update in case it exists.
     */
    where: publisherWhereUniqueInput
    /**
     * In case the publisher found by the `where` argument doesn't exist, create a new publisher with this data.
     */
    create: XOR<publisherCreateInput, publisherUncheckedCreateInput>
    /**
     * In case the publisher was found with the provided `where` argument, update it with this data.
     */
    update: XOR<publisherUpdateInput, publisherUncheckedUpdateInput>
  }

  /**
   * publisher delete
   */
  export type publisherDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the publisher
     */
    select?: publisherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the publisher
     */
    omit?: publisherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: publisherInclude<ExtArgs> | null
    /**
     * Filter which publisher to delete.
     */
    where: publisherWhereUniqueInput
  }

  /**
   * publisher deleteMany
   */
  export type publisherDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which publishers to delete
     */
    where?: publisherWhereInput
    /**
     * Limit how many publishers to delete.
     */
    limit?: number
  }

  /**
   * publisher.auth_user
   */
  export type publisher$auth_userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auth_user
     */
    select?: auth_userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the auth_user
     */
    omit?: auth_userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auth_userInclude<ExtArgs> | null
    where?: auth_userWhereInput
    orderBy?: auth_userOrderByWithRelationInput | auth_userOrderByWithRelationInput[]
    cursor?: auth_userWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Auth_userScalarFieldEnum | Auth_userScalarFieldEnum[]
  }

  /**
   * publisher.promo_code
   */
  export type publisher$promo_codeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the promo_code
     */
    select?: promo_codeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the promo_code
     */
    omit?: promo_codeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: promo_codeInclude<ExtArgs> | null
    where?: promo_codeWhereInput
    orderBy?: promo_codeOrderByWithRelationInput | promo_codeOrderByWithRelationInput[]
    cursor?: promo_codeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Promo_codeScalarFieldEnum | Promo_codeScalarFieldEnum[]
  }

  /**
   * publisher.auth_account
   */
  export type publisher$auth_accountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auth_account
     */
    select?: auth_accountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the auth_account
     */
    omit?: auth_accountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auth_accountInclude<ExtArgs> | null
    where?: auth_accountWhereInput
  }

  /**
   * publisher.publisher_author
   */
  export type publisher$publisher_authorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the publisher_author
     */
    select?: publisher_authorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the publisher_author
     */
    omit?: publisher_authorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: publisher_authorInclude<ExtArgs> | null
    where?: publisher_authorWhereInput
    orderBy?: publisher_authorOrderByWithRelationInput | publisher_authorOrderByWithRelationInput[]
    cursor?: publisher_authorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Publisher_authorScalarFieldEnum | Publisher_authorScalarFieldEnum[]
  }

  /**
   * publisher.t_ai_credit
   */
  export type publisher$t_ai_creditArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the t_ai_credit
     */
    select?: t_ai_creditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the t_ai_credit
     */
    omit?: t_ai_creditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: t_ai_creditInclude<ExtArgs> | null
    where?: t_ai_creditWhereInput
    orderBy?: t_ai_creditOrderByWithRelationInput | t_ai_creditOrderByWithRelationInput[]
    cursor?: t_ai_creditWhereUniqueInput
    take?: number
    skip?: number
    distinct?: T_ai_creditScalarFieldEnum | T_ai_creditScalarFieldEnum[]
  }

  /**
   * publisher.transaction
   */
  export type publisher$transactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaction
     */
    select?: transactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transaction
     */
    omit?: transactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transactionInclude<ExtArgs> | null
    where?: transactionWhereInput
    orderBy?: transactionOrderByWithRelationInput | transactionOrderByWithRelationInput[]
    cursor?: transactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * publisher.withdrawal
   */
  export type publisher$withdrawalArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the withdrawal
     */
    select?: withdrawalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the withdrawal
     */
    omit?: withdrawalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: withdrawalInclude<ExtArgs> | null
    where?: withdrawalWhereInput
    orderBy?: withdrawalOrderByWithRelationInput | withdrawalOrderByWithRelationInput[]
    cursor?: withdrawalWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WithdrawalScalarFieldEnum | WithdrawalScalarFieldEnum[]
  }

  /**
   * publisher without action
   */
  export type publisherDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the publisher
     */
    select?: publisherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the publisher
     */
    omit?: publisherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: publisherInclude<ExtArgs> | null
  }


  /**
   * Model publisher_author
   */

  export type AggregatePublisher_author = {
    _count: Publisher_authorCountAggregateOutputType | null
    _min: Publisher_authorMinAggregateOutputType | null
    _max: Publisher_authorMaxAggregateOutputType | null
  }

  export type Publisher_authorMinAggregateOutputType = {
    id: string | null
    publisher_id: string | null
    author_id: string | null
  }

  export type Publisher_authorMaxAggregateOutputType = {
    id: string | null
    publisher_id: string | null
    author_id: string | null
  }

  export type Publisher_authorCountAggregateOutputType = {
    id: number
    publisher_id: number
    author_id: number
    _all: number
  }


  export type Publisher_authorMinAggregateInputType = {
    id?: true
    publisher_id?: true
    author_id?: true
  }

  export type Publisher_authorMaxAggregateInputType = {
    id?: true
    publisher_id?: true
    author_id?: true
  }

  export type Publisher_authorCountAggregateInputType = {
    id?: true
    publisher_id?: true
    author_id?: true
    _all?: true
  }

  export type Publisher_authorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which publisher_author to aggregate.
     */
    where?: publisher_authorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of publisher_authors to fetch.
     */
    orderBy?: publisher_authorOrderByWithRelationInput | publisher_authorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: publisher_authorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` publisher_authors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` publisher_authors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned publisher_authors
    **/
    _count?: true | Publisher_authorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Publisher_authorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Publisher_authorMaxAggregateInputType
  }

  export type GetPublisher_authorAggregateType<T extends Publisher_authorAggregateArgs> = {
        [P in keyof T & keyof AggregatePublisher_author]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePublisher_author[P]>
      : GetScalarType<T[P], AggregatePublisher_author[P]>
  }




  export type publisher_authorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: publisher_authorWhereInput
    orderBy?: publisher_authorOrderByWithAggregationInput | publisher_authorOrderByWithAggregationInput[]
    by: Publisher_authorScalarFieldEnum[] | Publisher_authorScalarFieldEnum
    having?: publisher_authorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Publisher_authorCountAggregateInputType | true
    _min?: Publisher_authorMinAggregateInputType
    _max?: Publisher_authorMaxAggregateInputType
  }

  export type Publisher_authorGroupByOutputType = {
    id: string
    publisher_id: string
    author_id: string
    _count: Publisher_authorCountAggregateOutputType | null
    _min: Publisher_authorMinAggregateOutputType | null
    _max: Publisher_authorMaxAggregateOutputType | null
  }

  type GetPublisher_authorGroupByPayload<T extends publisher_authorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Publisher_authorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Publisher_authorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Publisher_authorGroupByOutputType[P]>
            : GetScalarType<T[P], Publisher_authorGroupByOutputType[P]>
        }
      >
    >


  export type publisher_authorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    publisher_id?: boolean
    author_id?: boolean
    author?: boolean | authorDefaultArgs<ExtArgs>
    publisher?: boolean | publisherDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["publisher_author"]>

  export type publisher_authorSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    publisher_id?: boolean
    author_id?: boolean
    author?: boolean | authorDefaultArgs<ExtArgs>
    publisher?: boolean | publisherDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["publisher_author"]>

  export type publisher_authorSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    publisher_id?: boolean
    author_id?: boolean
    author?: boolean | authorDefaultArgs<ExtArgs>
    publisher?: boolean | publisherDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["publisher_author"]>

  export type publisher_authorSelectScalar = {
    id?: boolean
    publisher_id?: boolean
    author_id?: boolean
  }

  export type publisher_authorOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "publisher_id" | "author_id", ExtArgs["result"]["publisher_author"]>
  export type publisher_authorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    author?: boolean | authorDefaultArgs<ExtArgs>
    publisher?: boolean | publisherDefaultArgs<ExtArgs>
  }
  export type publisher_authorIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    author?: boolean | authorDefaultArgs<ExtArgs>
    publisher?: boolean | publisherDefaultArgs<ExtArgs>
  }
  export type publisher_authorIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    author?: boolean | authorDefaultArgs<ExtArgs>
    publisher?: boolean | publisherDefaultArgs<ExtArgs>
  }

  export type $publisher_authorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "publisher_author"
    objects: {
      author: Prisma.$authorPayload<ExtArgs>
      publisher: Prisma.$publisherPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      publisher_id: string
      author_id: string
    }, ExtArgs["result"]["publisher_author"]>
    composites: {}
  }

  type publisher_authorGetPayload<S extends boolean | null | undefined | publisher_authorDefaultArgs> = $Result.GetResult<Prisma.$publisher_authorPayload, S>

  type publisher_authorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<publisher_authorFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Publisher_authorCountAggregateInputType | true
    }

  export interface publisher_authorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['publisher_author'], meta: { name: 'publisher_author' } }
    /**
     * Find zero or one Publisher_author that matches the filter.
     * @param {publisher_authorFindUniqueArgs} args - Arguments to find a Publisher_author
     * @example
     * // Get one Publisher_author
     * const publisher_author = await prisma.publisher_author.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends publisher_authorFindUniqueArgs>(args: SelectSubset<T, publisher_authorFindUniqueArgs<ExtArgs>>): Prisma__publisher_authorClient<$Result.GetResult<Prisma.$publisher_authorPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Publisher_author that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {publisher_authorFindUniqueOrThrowArgs} args - Arguments to find a Publisher_author
     * @example
     * // Get one Publisher_author
     * const publisher_author = await prisma.publisher_author.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends publisher_authorFindUniqueOrThrowArgs>(args: SelectSubset<T, publisher_authorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__publisher_authorClient<$Result.GetResult<Prisma.$publisher_authorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Publisher_author that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {publisher_authorFindFirstArgs} args - Arguments to find a Publisher_author
     * @example
     * // Get one Publisher_author
     * const publisher_author = await prisma.publisher_author.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends publisher_authorFindFirstArgs>(args?: SelectSubset<T, publisher_authorFindFirstArgs<ExtArgs>>): Prisma__publisher_authorClient<$Result.GetResult<Prisma.$publisher_authorPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Publisher_author that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {publisher_authorFindFirstOrThrowArgs} args - Arguments to find a Publisher_author
     * @example
     * // Get one Publisher_author
     * const publisher_author = await prisma.publisher_author.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends publisher_authorFindFirstOrThrowArgs>(args?: SelectSubset<T, publisher_authorFindFirstOrThrowArgs<ExtArgs>>): Prisma__publisher_authorClient<$Result.GetResult<Prisma.$publisher_authorPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Publisher_authors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {publisher_authorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Publisher_authors
     * const publisher_authors = await prisma.publisher_author.findMany()
     * 
     * // Get first 10 Publisher_authors
     * const publisher_authors = await prisma.publisher_author.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const publisher_authorWithIdOnly = await prisma.publisher_author.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends publisher_authorFindManyArgs>(args?: SelectSubset<T, publisher_authorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$publisher_authorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Publisher_author.
     * @param {publisher_authorCreateArgs} args - Arguments to create a Publisher_author.
     * @example
     * // Create one Publisher_author
     * const Publisher_author = await prisma.publisher_author.create({
     *   data: {
     *     // ... data to create a Publisher_author
     *   }
     * })
     * 
     */
    create<T extends publisher_authorCreateArgs>(args: SelectSubset<T, publisher_authorCreateArgs<ExtArgs>>): Prisma__publisher_authorClient<$Result.GetResult<Prisma.$publisher_authorPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Publisher_authors.
     * @param {publisher_authorCreateManyArgs} args - Arguments to create many Publisher_authors.
     * @example
     * // Create many Publisher_authors
     * const publisher_author = await prisma.publisher_author.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends publisher_authorCreateManyArgs>(args?: SelectSubset<T, publisher_authorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Publisher_authors and returns the data saved in the database.
     * @param {publisher_authorCreateManyAndReturnArgs} args - Arguments to create many Publisher_authors.
     * @example
     * // Create many Publisher_authors
     * const publisher_author = await prisma.publisher_author.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Publisher_authors and only return the `id`
     * const publisher_authorWithIdOnly = await prisma.publisher_author.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends publisher_authorCreateManyAndReturnArgs>(args?: SelectSubset<T, publisher_authorCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$publisher_authorPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Publisher_author.
     * @param {publisher_authorDeleteArgs} args - Arguments to delete one Publisher_author.
     * @example
     * // Delete one Publisher_author
     * const Publisher_author = await prisma.publisher_author.delete({
     *   where: {
     *     // ... filter to delete one Publisher_author
     *   }
     * })
     * 
     */
    delete<T extends publisher_authorDeleteArgs>(args: SelectSubset<T, publisher_authorDeleteArgs<ExtArgs>>): Prisma__publisher_authorClient<$Result.GetResult<Prisma.$publisher_authorPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Publisher_author.
     * @param {publisher_authorUpdateArgs} args - Arguments to update one Publisher_author.
     * @example
     * // Update one Publisher_author
     * const publisher_author = await prisma.publisher_author.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends publisher_authorUpdateArgs>(args: SelectSubset<T, publisher_authorUpdateArgs<ExtArgs>>): Prisma__publisher_authorClient<$Result.GetResult<Prisma.$publisher_authorPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Publisher_authors.
     * @param {publisher_authorDeleteManyArgs} args - Arguments to filter Publisher_authors to delete.
     * @example
     * // Delete a few Publisher_authors
     * const { count } = await prisma.publisher_author.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends publisher_authorDeleteManyArgs>(args?: SelectSubset<T, publisher_authorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Publisher_authors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {publisher_authorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Publisher_authors
     * const publisher_author = await prisma.publisher_author.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends publisher_authorUpdateManyArgs>(args: SelectSubset<T, publisher_authorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Publisher_authors and returns the data updated in the database.
     * @param {publisher_authorUpdateManyAndReturnArgs} args - Arguments to update many Publisher_authors.
     * @example
     * // Update many Publisher_authors
     * const publisher_author = await prisma.publisher_author.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Publisher_authors and only return the `id`
     * const publisher_authorWithIdOnly = await prisma.publisher_author.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends publisher_authorUpdateManyAndReturnArgs>(args: SelectSubset<T, publisher_authorUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$publisher_authorPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Publisher_author.
     * @param {publisher_authorUpsertArgs} args - Arguments to update or create a Publisher_author.
     * @example
     * // Update or create a Publisher_author
     * const publisher_author = await prisma.publisher_author.upsert({
     *   create: {
     *     // ... data to create a Publisher_author
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Publisher_author we want to update
     *   }
     * })
     */
    upsert<T extends publisher_authorUpsertArgs>(args: SelectSubset<T, publisher_authorUpsertArgs<ExtArgs>>): Prisma__publisher_authorClient<$Result.GetResult<Prisma.$publisher_authorPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Publisher_authors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {publisher_authorCountArgs} args - Arguments to filter Publisher_authors to count.
     * @example
     * // Count the number of Publisher_authors
     * const count = await prisma.publisher_author.count({
     *   where: {
     *     // ... the filter for the Publisher_authors we want to count
     *   }
     * })
    **/
    count<T extends publisher_authorCountArgs>(
      args?: Subset<T, publisher_authorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Publisher_authorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Publisher_author.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Publisher_authorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Publisher_authorAggregateArgs>(args: Subset<T, Publisher_authorAggregateArgs>): Prisma.PrismaPromise<GetPublisher_authorAggregateType<T>>

    /**
     * Group by Publisher_author.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {publisher_authorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends publisher_authorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: publisher_authorGroupByArgs['orderBy'] }
        : { orderBy?: publisher_authorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, publisher_authorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPublisher_authorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the publisher_author model
   */
  readonly fields: publisher_authorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for publisher_author.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__publisher_authorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    author<T extends authorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, authorDefaultArgs<ExtArgs>>): Prisma__authorClient<$Result.GetResult<Prisma.$authorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    publisher<T extends publisherDefaultArgs<ExtArgs> = {}>(args?: Subset<T, publisherDefaultArgs<ExtArgs>>): Prisma__publisherClient<$Result.GetResult<Prisma.$publisherPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the publisher_author model
   */
  interface publisher_authorFieldRefs {
    readonly id: FieldRef<"publisher_author", 'String'>
    readonly publisher_id: FieldRef<"publisher_author", 'String'>
    readonly author_id: FieldRef<"publisher_author", 'String'>
  }
    

  // Custom InputTypes
  /**
   * publisher_author findUnique
   */
  export type publisher_authorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the publisher_author
     */
    select?: publisher_authorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the publisher_author
     */
    omit?: publisher_authorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: publisher_authorInclude<ExtArgs> | null
    /**
     * Filter, which publisher_author to fetch.
     */
    where: publisher_authorWhereUniqueInput
  }

  /**
   * publisher_author findUniqueOrThrow
   */
  export type publisher_authorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the publisher_author
     */
    select?: publisher_authorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the publisher_author
     */
    omit?: publisher_authorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: publisher_authorInclude<ExtArgs> | null
    /**
     * Filter, which publisher_author to fetch.
     */
    where: publisher_authorWhereUniqueInput
  }

  /**
   * publisher_author findFirst
   */
  export type publisher_authorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the publisher_author
     */
    select?: publisher_authorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the publisher_author
     */
    omit?: publisher_authorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: publisher_authorInclude<ExtArgs> | null
    /**
     * Filter, which publisher_author to fetch.
     */
    where?: publisher_authorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of publisher_authors to fetch.
     */
    orderBy?: publisher_authorOrderByWithRelationInput | publisher_authorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for publisher_authors.
     */
    cursor?: publisher_authorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` publisher_authors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` publisher_authors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of publisher_authors.
     */
    distinct?: Publisher_authorScalarFieldEnum | Publisher_authorScalarFieldEnum[]
  }

  /**
   * publisher_author findFirstOrThrow
   */
  export type publisher_authorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the publisher_author
     */
    select?: publisher_authorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the publisher_author
     */
    omit?: publisher_authorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: publisher_authorInclude<ExtArgs> | null
    /**
     * Filter, which publisher_author to fetch.
     */
    where?: publisher_authorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of publisher_authors to fetch.
     */
    orderBy?: publisher_authorOrderByWithRelationInput | publisher_authorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for publisher_authors.
     */
    cursor?: publisher_authorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` publisher_authors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` publisher_authors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of publisher_authors.
     */
    distinct?: Publisher_authorScalarFieldEnum | Publisher_authorScalarFieldEnum[]
  }

  /**
   * publisher_author findMany
   */
  export type publisher_authorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the publisher_author
     */
    select?: publisher_authorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the publisher_author
     */
    omit?: publisher_authorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: publisher_authorInclude<ExtArgs> | null
    /**
     * Filter, which publisher_authors to fetch.
     */
    where?: publisher_authorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of publisher_authors to fetch.
     */
    orderBy?: publisher_authorOrderByWithRelationInput | publisher_authorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing publisher_authors.
     */
    cursor?: publisher_authorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` publisher_authors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` publisher_authors.
     */
    skip?: number
    distinct?: Publisher_authorScalarFieldEnum | Publisher_authorScalarFieldEnum[]
  }

  /**
   * publisher_author create
   */
  export type publisher_authorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the publisher_author
     */
    select?: publisher_authorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the publisher_author
     */
    omit?: publisher_authorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: publisher_authorInclude<ExtArgs> | null
    /**
     * The data needed to create a publisher_author.
     */
    data: XOR<publisher_authorCreateInput, publisher_authorUncheckedCreateInput>
  }

  /**
   * publisher_author createMany
   */
  export type publisher_authorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many publisher_authors.
     */
    data: publisher_authorCreateManyInput | publisher_authorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * publisher_author createManyAndReturn
   */
  export type publisher_authorCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the publisher_author
     */
    select?: publisher_authorSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the publisher_author
     */
    omit?: publisher_authorOmit<ExtArgs> | null
    /**
     * The data used to create many publisher_authors.
     */
    data: publisher_authorCreateManyInput | publisher_authorCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: publisher_authorIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * publisher_author update
   */
  export type publisher_authorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the publisher_author
     */
    select?: publisher_authorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the publisher_author
     */
    omit?: publisher_authorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: publisher_authorInclude<ExtArgs> | null
    /**
     * The data needed to update a publisher_author.
     */
    data: XOR<publisher_authorUpdateInput, publisher_authorUncheckedUpdateInput>
    /**
     * Choose, which publisher_author to update.
     */
    where: publisher_authorWhereUniqueInput
  }

  /**
   * publisher_author updateMany
   */
  export type publisher_authorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update publisher_authors.
     */
    data: XOR<publisher_authorUpdateManyMutationInput, publisher_authorUncheckedUpdateManyInput>
    /**
     * Filter which publisher_authors to update
     */
    where?: publisher_authorWhereInput
    /**
     * Limit how many publisher_authors to update.
     */
    limit?: number
  }

  /**
   * publisher_author updateManyAndReturn
   */
  export type publisher_authorUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the publisher_author
     */
    select?: publisher_authorSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the publisher_author
     */
    omit?: publisher_authorOmit<ExtArgs> | null
    /**
     * The data used to update publisher_authors.
     */
    data: XOR<publisher_authorUpdateManyMutationInput, publisher_authorUncheckedUpdateManyInput>
    /**
     * Filter which publisher_authors to update
     */
    where?: publisher_authorWhereInput
    /**
     * Limit how many publisher_authors to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: publisher_authorIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * publisher_author upsert
   */
  export type publisher_authorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the publisher_author
     */
    select?: publisher_authorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the publisher_author
     */
    omit?: publisher_authorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: publisher_authorInclude<ExtArgs> | null
    /**
     * The filter to search for the publisher_author to update in case it exists.
     */
    where: publisher_authorWhereUniqueInput
    /**
     * In case the publisher_author found by the `where` argument doesn't exist, create a new publisher_author with this data.
     */
    create: XOR<publisher_authorCreateInput, publisher_authorUncheckedCreateInput>
    /**
     * In case the publisher_author was found with the provided `where` argument, update it with this data.
     */
    update: XOR<publisher_authorUpdateInput, publisher_authorUncheckedUpdateInput>
  }

  /**
   * publisher_author delete
   */
  export type publisher_authorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the publisher_author
     */
    select?: publisher_authorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the publisher_author
     */
    omit?: publisher_authorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: publisher_authorInclude<ExtArgs> | null
    /**
     * Filter which publisher_author to delete.
     */
    where: publisher_authorWhereUniqueInput
  }

  /**
   * publisher_author deleteMany
   */
  export type publisher_authorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which publisher_authors to delete
     */
    where?: publisher_authorWhereInput
    /**
     * Limit how many publisher_authors to delete.
     */
    limit?: number
  }

  /**
   * publisher_author without action
   */
  export type publisher_authorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the publisher_author
     */
    select?: publisher_authorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the publisher_author
     */
    omit?: publisher_authorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: publisher_authorInclude<ExtArgs> | null
  }


  /**
   * Model ranking
   */

  export type AggregateRanking = {
    _count: RankingCountAggregateOutputType | null
    _min: RankingMinAggregateOutputType | null
    _max: RankingMaxAggregateOutputType | null
  }

  export type RankingMinAggregateOutputType = {
    id: string | null
    id_book: string | null
  }

  export type RankingMaxAggregateOutputType = {
    id: string | null
    id_book: string | null
  }

  export type RankingCountAggregateOutputType = {
    id: number
    id_book: number
    _all: number
  }


  export type RankingMinAggregateInputType = {
    id?: true
    id_book?: true
  }

  export type RankingMaxAggregateInputType = {
    id?: true
    id_book?: true
  }

  export type RankingCountAggregateInputType = {
    id?: true
    id_book?: true
    _all?: true
  }

  export type RankingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ranking to aggregate.
     */
    where?: rankingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rankings to fetch.
     */
    orderBy?: rankingOrderByWithRelationInput | rankingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: rankingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rankings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rankings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned rankings
    **/
    _count?: true | RankingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RankingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RankingMaxAggregateInputType
  }

  export type GetRankingAggregateType<T extends RankingAggregateArgs> = {
        [P in keyof T & keyof AggregateRanking]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRanking[P]>
      : GetScalarType<T[P], AggregateRanking[P]>
  }




  export type rankingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: rankingWhereInput
    orderBy?: rankingOrderByWithAggregationInput | rankingOrderByWithAggregationInput[]
    by: RankingScalarFieldEnum[] | RankingScalarFieldEnum
    having?: rankingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RankingCountAggregateInputType | true
    _min?: RankingMinAggregateInputType
    _max?: RankingMaxAggregateInputType
  }

  export type RankingGroupByOutputType = {
    id: string
    id_book: string
    _count: RankingCountAggregateOutputType | null
    _min: RankingMinAggregateOutputType | null
    _max: RankingMaxAggregateOutputType | null
  }

  type GetRankingGroupByPayload<T extends rankingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RankingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RankingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RankingGroupByOutputType[P]>
            : GetScalarType<T[P], RankingGroupByOutputType[P]>
        }
      >
    >


  export type rankingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    id_book?: boolean
    book?: boolean | bookDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ranking"]>

  export type rankingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    id_book?: boolean
    book?: boolean | bookDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ranking"]>

  export type rankingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    id_book?: boolean
    book?: boolean | bookDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ranking"]>

  export type rankingSelectScalar = {
    id?: boolean
    id_book?: boolean
  }

  export type rankingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "id_book", ExtArgs["result"]["ranking"]>
  export type rankingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    book?: boolean | bookDefaultArgs<ExtArgs>
  }
  export type rankingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    book?: boolean | bookDefaultArgs<ExtArgs>
  }
  export type rankingIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    book?: boolean | bookDefaultArgs<ExtArgs>
  }

  export type $rankingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ranking"
    objects: {
      book: Prisma.$bookPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      id_book: string
    }, ExtArgs["result"]["ranking"]>
    composites: {}
  }

  type rankingGetPayload<S extends boolean | null | undefined | rankingDefaultArgs> = $Result.GetResult<Prisma.$rankingPayload, S>

  type rankingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<rankingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RankingCountAggregateInputType | true
    }

  export interface rankingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ranking'], meta: { name: 'ranking' } }
    /**
     * Find zero or one Ranking that matches the filter.
     * @param {rankingFindUniqueArgs} args - Arguments to find a Ranking
     * @example
     * // Get one Ranking
     * const ranking = await prisma.ranking.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends rankingFindUniqueArgs>(args: SelectSubset<T, rankingFindUniqueArgs<ExtArgs>>): Prisma__rankingClient<$Result.GetResult<Prisma.$rankingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Ranking that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {rankingFindUniqueOrThrowArgs} args - Arguments to find a Ranking
     * @example
     * // Get one Ranking
     * const ranking = await prisma.ranking.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends rankingFindUniqueOrThrowArgs>(args: SelectSubset<T, rankingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__rankingClient<$Result.GetResult<Prisma.$rankingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ranking that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rankingFindFirstArgs} args - Arguments to find a Ranking
     * @example
     * // Get one Ranking
     * const ranking = await prisma.ranking.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends rankingFindFirstArgs>(args?: SelectSubset<T, rankingFindFirstArgs<ExtArgs>>): Prisma__rankingClient<$Result.GetResult<Prisma.$rankingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ranking that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rankingFindFirstOrThrowArgs} args - Arguments to find a Ranking
     * @example
     * // Get one Ranking
     * const ranking = await prisma.ranking.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends rankingFindFirstOrThrowArgs>(args?: SelectSubset<T, rankingFindFirstOrThrowArgs<ExtArgs>>): Prisma__rankingClient<$Result.GetResult<Prisma.$rankingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Rankings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rankingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Rankings
     * const rankings = await prisma.ranking.findMany()
     * 
     * // Get first 10 Rankings
     * const rankings = await prisma.ranking.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rankingWithIdOnly = await prisma.ranking.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends rankingFindManyArgs>(args?: SelectSubset<T, rankingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$rankingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Ranking.
     * @param {rankingCreateArgs} args - Arguments to create a Ranking.
     * @example
     * // Create one Ranking
     * const Ranking = await prisma.ranking.create({
     *   data: {
     *     // ... data to create a Ranking
     *   }
     * })
     * 
     */
    create<T extends rankingCreateArgs>(args: SelectSubset<T, rankingCreateArgs<ExtArgs>>): Prisma__rankingClient<$Result.GetResult<Prisma.$rankingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Rankings.
     * @param {rankingCreateManyArgs} args - Arguments to create many Rankings.
     * @example
     * // Create many Rankings
     * const ranking = await prisma.ranking.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends rankingCreateManyArgs>(args?: SelectSubset<T, rankingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Rankings and returns the data saved in the database.
     * @param {rankingCreateManyAndReturnArgs} args - Arguments to create many Rankings.
     * @example
     * // Create many Rankings
     * const ranking = await prisma.ranking.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Rankings and only return the `id`
     * const rankingWithIdOnly = await prisma.ranking.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends rankingCreateManyAndReturnArgs>(args?: SelectSubset<T, rankingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$rankingPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Ranking.
     * @param {rankingDeleteArgs} args - Arguments to delete one Ranking.
     * @example
     * // Delete one Ranking
     * const Ranking = await prisma.ranking.delete({
     *   where: {
     *     // ... filter to delete one Ranking
     *   }
     * })
     * 
     */
    delete<T extends rankingDeleteArgs>(args: SelectSubset<T, rankingDeleteArgs<ExtArgs>>): Prisma__rankingClient<$Result.GetResult<Prisma.$rankingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Ranking.
     * @param {rankingUpdateArgs} args - Arguments to update one Ranking.
     * @example
     * // Update one Ranking
     * const ranking = await prisma.ranking.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends rankingUpdateArgs>(args: SelectSubset<T, rankingUpdateArgs<ExtArgs>>): Prisma__rankingClient<$Result.GetResult<Prisma.$rankingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Rankings.
     * @param {rankingDeleteManyArgs} args - Arguments to filter Rankings to delete.
     * @example
     * // Delete a few Rankings
     * const { count } = await prisma.ranking.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends rankingDeleteManyArgs>(args?: SelectSubset<T, rankingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Rankings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rankingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Rankings
     * const ranking = await prisma.ranking.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends rankingUpdateManyArgs>(args: SelectSubset<T, rankingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Rankings and returns the data updated in the database.
     * @param {rankingUpdateManyAndReturnArgs} args - Arguments to update many Rankings.
     * @example
     * // Update many Rankings
     * const ranking = await prisma.ranking.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Rankings and only return the `id`
     * const rankingWithIdOnly = await prisma.ranking.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends rankingUpdateManyAndReturnArgs>(args: SelectSubset<T, rankingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$rankingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Ranking.
     * @param {rankingUpsertArgs} args - Arguments to update or create a Ranking.
     * @example
     * // Update or create a Ranking
     * const ranking = await prisma.ranking.upsert({
     *   create: {
     *     // ... data to create a Ranking
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ranking we want to update
     *   }
     * })
     */
    upsert<T extends rankingUpsertArgs>(args: SelectSubset<T, rankingUpsertArgs<ExtArgs>>): Prisma__rankingClient<$Result.GetResult<Prisma.$rankingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Rankings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rankingCountArgs} args - Arguments to filter Rankings to count.
     * @example
     * // Count the number of Rankings
     * const count = await prisma.ranking.count({
     *   where: {
     *     // ... the filter for the Rankings we want to count
     *   }
     * })
    **/
    count<T extends rankingCountArgs>(
      args?: Subset<T, rankingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RankingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ranking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RankingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RankingAggregateArgs>(args: Subset<T, RankingAggregateArgs>): Prisma.PrismaPromise<GetRankingAggregateType<T>>

    /**
     * Group by Ranking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rankingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends rankingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: rankingGroupByArgs['orderBy'] }
        : { orderBy?: rankingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, rankingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRankingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ranking model
   */
  readonly fields: rankingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ranking.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__rankingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    book<T extends bookDefaultArgs<ExtArgs> = {}>(args?: Subset<T, bookDefaultArgs<ExtArgs>>): Prisma__bookClient<$Result.GetResult<Prisma.$bookPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ranking model
   */
  interface rankingFieldRefs {
    readonly id: FieldRef<"ranking", 'String'>
    readonly id_book: FieldRef<"ranking", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ranking findUnique
   */
  export type rankingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ranking
     */
    select?: rankingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ranking
     */
    omit?: rankingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rankingInclude<ExtArgs> | null
    /**
     * Filter, which ranking to fetch.
     */
    where: rankingWhereUniqueInput
  }

  /**
   * ranking findUniqueOrThrow
   */
  export type rankingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ranking
     */
    select?: rankingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ranking
     */
    omit?: rankingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rankingInclude<ExtArgs> | null
    /**
     * Filter, which ranking to fetch.
     */
    where: rankingWhereUniqueInput
  }

  /**
   * ranking findFirst
   */
  export type rankingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ranking
     */
    select?: rankingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ranking
     */
    omit?: rankingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rankingInclude<ExtArgs> | null
    /**
     * Filter, which ranking to fetch.
     */
    where?: rankingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rankings to fetch.
     */
    orderBy?: rankingOrderByWithRelationInput | rankingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for rankings.
     */
    cursor?: rankingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rankings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rankings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of rankings.
     */
    distinct?: RankingScalarFieldEnum | RankingScalarFieldEnum[]
  }

  /**
   * ranking findFirstOrThrow
   */
  export type rankingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ranking
     */
    select?: rankingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ranking
     */
    omit?: rankingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rankingInclude<ExtArgs> | null
    /**
     * Filter, which ranking to fetch.
     */
    where?: rankingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rankings to fetch.
     */
    orderBy?: rankingOrderByWithRelationInput | rankingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for rankings.
     */
    cursor?: rankingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rankings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rankings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of rankings.
     */
    distinct?: RankingScalarFieldEnum | RankingScalarFieldEnum[]
  }

  /**
   * ranking findMany
   */
  export type rankingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ranking
     */
    select?: rankingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ranking
     */
    omit?: rankingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rankingInclude<ExtArgs> | null
    /**
     * Filter, which rankings to fetch.
     */
    where?: rankingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rankings to fetch.
     */
    orderBy?: rankingOrderByWithRelationInput | rankingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing rankings.
     */
    cursor?: rankingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rankings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rankings.
     */
    skip?: number
    distinct?: RankingScalarFieldEnum | RankingScalarFieldEnum[]
  }

  /**
   * ranking create
   */
  export type rankingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ranking
     */
    select?: rankingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ranking
     */
    omit?: rankingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rankingInclude<ExtArgs> | null
    /**
     * The data needed to create a ranking.
     */
    data: XOR<rankingCreateInput, rankingUncheckedCreateInput>
  }

  /**
   * ranking createMany
   */
  export type rankingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many rankings.
     */
    data: rankingCreateManyInput | rankingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ranking createManyAndReturn
   */
  export type rankingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ranking
     */
    select?: rankingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ranking
     */
    omit?: rankingOmit<ExtArgs> | null
    /**
     * The data used to create many rankings.
     */
    data: rankingCreateManyInput | rankingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rankingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ranking update
   */
  export type rankingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ranking
     */
    select?: rankingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ranking
     */
    omit?: rankingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rankingInclude<ExtArgs> | null
    /**
     * The data needed to update a ranking.
     */
    data: XOR<rankingUpdateInput, rankingUncheckedUpdateInput>
    /**
     * Choose, which ranking to update.
     */
    where: rankingWhereUniqueInput
  }

  /**
   * ranking updateMany
   */
  export type rankingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update rankings.
     */
    data: XOR<rankingUpdateManyMutationInput, rankingUncheckedUpdateManyInput>
    /**
     * Filter which rankings to update
     */
    where?: rankingWhereInput
    /**
     * Limit how many rankings to update.
     */
    limit?: number
  }

  /**
   * ranking updateManyAndReturn
   */
  export type rankingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ranking
     */
    select?: rankingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ranking
     */
    omit?: rankingOmit<ExtArgs> | null
    /**
     * The data used to update rankings.
     */
    data: XOR<rankingUpdateManyMutationInput, rankingUncheckedUpdateManyInput>
    /**
     * Filter which rankings to update
     */
    where?: rankingWhereInput
    /**
     * Limit how many rankings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rankingIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ranking upsert
   */
  export type rankingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ranking
     */
    select?: rankingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ranking
     */
    omit?: rankingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rankingInclude<ExtArgs> | null
    /**
     * The filter to search for the ranking to update in case it exists.
     */
    where: rankingWhereUniqueInput
    /**
     * In case the ranking found by the `where` argument doesn't exist, create a new ranking with this data.
     */
    create: XOR<rankingCreateInput, rankingUncheckedCreateInput>
    /**
     * In case the ranking was found with the provided `where` argument, update it with this data.
     */
    update: XOR<rankingUpdateInput, rankingUncheckedUpdateInput>
  }

  /**
   * ranking delete
   */
  export type rankingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ranking
     */
    select?: rankingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ranking
     */
    omit?: rankingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rankingInclude<ExtArgs> | null
    /**
     * Filter which ranking to delete.
     */
    where: rankingWhereUniqueInput
  }

  /**
   * ranking deleteMany
   */
  export type rankingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which rankings to delete
     */
    where?: rankingWhereInput
    /**
     * Limit how many rankings to delete.
     */
    limit?: number
  }

  /**
   * ranking without action
   */
  export type rankingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ranking
     */
    select?: rankingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ranking
     */
    omit?: rankingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rankingInclude<ExtArgs> | null
  }


  /**
   * Model reviews
   */

  export type AggregateReviews = {
    _count: ReviewsCountAggregateOutputType | null
    _avg: ReviewsAvgAggregateOutputType | null
    _sum: ReviewsSumAggregateOutputType | null
    _min: ReviewsMinAggregateOutputType | null
    _max: ReviewsMaxAggregateOutputType | null
  }

  export type ReviewsAvgAggregateOutputType = {
    rating: Decimal | null
  }

  export type ReviewsSumAggregateOutputType = {
    rating: Decimal | null
  }

  export type ReviewsMinAggregateOutputType = {
    id: string | null
    id_book: string | null
    comments: string | null
    rating: Decimal | null
    created_at: Date | null
    deleted_at: Date | null
    parent: string | null
    id_user: string | null
  }

  export type ReviewsMaxAggregateOutputType = {
    id: string | null
    id_book: string | null
    comments: string | null
    rating: Decimal | null
    created_at: Date | null
    deleted_at: Date | null
    parent: string | null
    id_user: string | null
  }

  export type ReviewsCountAggregateOutputType = {
    id: number
    id_book: number
    comments: number
    rating: number
    created_at: number
    deleted_at: number
    parent: number
    id_user: number
    _all: number
  }


  export type ReviewsAvgAggregateInputType = {
    rating?: true
  }

  export type ReviewsSumAggregateInputType = {
    rating?: true
  }

  export type ReviewsMinAggregateInputType = {
    id?: true
    id_book?: true
    comments?: true
    rating?: true
    created_at?: true
    deleted_at?: true
    parent?: true
    id_user?: true
  }

  export type ReviewsMaxAggregateInputType = {
    id?: true
    id_book?: true
    comments?: true
    rating?: true
    created_at?: true
    deleted_at?: true
    parent?: true
    id_user?: true
  }

  export type ReviewsCountAggregateInputType = {
    id?: true
    id_book?: true
    comments?: true
    rating?: true
    created_at?: true
    deleted_at?: true
    parent?: true
    id_user?: true
    _all?: true
  }

  export type ReviewsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which reviews to aggregate.
     */
    where?: reviewsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reviews to fetch.
     */
    orderBy?: reviewsOrderByWithRelationInput | reviewsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: reviewsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned reviews
    **/
    _count?: true | ReviewsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReviewsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReviewsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReviewsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReviewsMaxAggregateInputType
  }

  export type GetReviewsAggregateType<T extends ReviewsAggregateArgs> = {
        [P in keyof T & keyof AggregateReviews]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReviews[P]>
      : GetScalarType<T[P], AggregateReviews[P]>
  }




  export type reviewsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: reviewsWhereInput
    orderBy?: reviewsOrderByWithAggregationInput | reviewsOrderByWithAggregationInput[]
    by: ReviewsScalarFieldEnum[] | ReviewsScalarFieldEnum
    having?: reviewsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReviewsCountAggregateInputType | true
    _avg?: ReviewsAvgAggregateInputType
    _sum?: ReviewsSumAggregateInputType
    _min?: ReviewsMinAggregateInputType
    _max?: ReviewsMaxAggregateInputType
  }

  export type ReviewsGroupByOutputType = {
    id: string
    id_book: string
    comments: string
    rating: Decimal | null
    created_at: Date
    deleted_at: Date | null
    parent: string | null
    id_user: string
    _count: ReviewsCountAggregateOutputType | null
    _avg: ReviewsAvgAggregateOutputType | null
    _sum: ReviewsSumAggregateOutputType | null
    _min: ReviewsMinAggregateOutputType | null
    _max: ReviewsMaxAggregateOutputType | null
  }

  type GetReviewsGroupByPayload<T extends reviewsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReviewsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReviewsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReviewsGroupByOutputType[P]>
            : GetScalarType<T[P], ReviewsGroupByOutputType[P]>
        }
      >
    >


  export type reviewsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    id_book?: boolean
    comments?: boolean
    rating?: boolean
    created_at?: boolean
    deleted_at?: boolean
    parent?: boolean
    id_user?: boolean
    book?: boolean | bookDefaultArgs<ExtArgs>
    auth_user?: boolean | auth_userDefaultArgs<ExtArgs>
    reviews_likes?: boolean | reviews$reviews_likesArgs<ExtArgs>
    _count?: boolean | ReviewsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reviews"]>

  export type reviewsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    id_book?: boolean
    comments?: boolean
    rating?: boolean
    created_at?: boolean
    deleted_at?: boolean
    parent?: boolean
    id_user?: boolean
    book?: boolean | bookDefaultArgs<ExtArgs>
    auth_user?: boolean | auth_userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reviews"]>

  export type reviewsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    id_book?: boolean
    comments?: boolean
    rating?: boolean
    created_at?: boolean
    deleted_at?: boolean
    parent?: boolean
    id_user?: boolean
    book?: boolean | bookDefaultArgs<ExtArgs>
    auth_user?: boolean | auth_userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reviews"]>

  export type reviewsSelectScalar = {
    id?: boolean
    id_book?: boolean
    comments?: boolean
    rating?: boolean
    created_at?: boolean
    deleted_at?: boolean
    parent?: boolean
    id_user?: boolean
  }

  export type reviewsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "id_book" | "comments" | "rating" | "created_at" | "deleted_at" | "parent" | "id_user", ExtArgs["result"]["reviews"]>
  export type reviewsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    book?: boolean | bookDefaultArgs<ExtArgs>
    auth_user?: boolean | auth_userDefaultArgs<ExtArgs>
    reviews_likes?: boolean | reviews$reviews_likesArgs<ExtArgs>
    _count?: boolean | ReviewsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type reviewsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    book?: boolean | bookDefaultArgs<ExtArgs>
    auth_user?: boolean | auth_userDefaultArgs<ExtArgs>
  }
  export type reviewsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    book?: boolean | bookDefaultArgs<ExtArgs>
    auth_user?: boolean | auth_userDefaultArgs<ExtArgs>
  }

  export type $reviewsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "reviews"
    objects: {
      book: Prisma.$bookPayload<ExtArgs>
      auth_user: Prisma.$auth_userPayload<ExtArgs>
      reviews_likes: Prisma.$reviews_likesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      id_book: string
      comments: string
      rating: Prisma.Decimal | null
      created_at: Date
      deleted_at: Date | null
      parent: string | null
      id_user: string
    }, ExtArgs["result"]["reviews"]>
    composites: {}
  }

  type reviewsGetPayload<S extends boolean | null | undefined | reviewsDefaultArgs> = $Result.GetResult<Prisma.$reviewsPayload, S>

  type reviewsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<reviewsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReviewsCountAggregateInputType | true
    }

  export interface reviewsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['reviews'], meta: { name: 'reviews' } }
    /**
     * Find zero or one Reviews that matches the filter.
     * @param {reviewsFindUniqueArgs} args - Arguments to find a Reviews
     * @example
     * // Get one Reviews
     * const reviews = await prisma.reviews.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends reviewsFindUniqueArgs>(args: SelectSubset<T, reviewsFindUniqueArgs<ExtArgs>>): Prisma__reviewsClient<$Result.GetResult<Prisma.$reviewsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Reviews that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {reviewsFindUniqueOrThrowArgs} args - Arguments to find a Reviews
     * @example
     * // Get one Reviews
     * const reviews = await prisma.reviews.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends reviewsFindUniqueOrThrowArgs>(args: SelectSubset<T, reviewsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__reviewsClient<$Result.GetResult<Prisma.$reviewsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Reviews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reviewsFindFirstArgs} args - Arguments to find a Reviews
     * @example
     * // Get one Reviews
     * const reviews = await prisma.reviews.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends reviewsFindFirstArgs>(args?: SelectSubset<T, reviewsFindFirstArgs<ExtArgs>>): Prisma__reviewsClient<$Result.GetResult<Prisma.$reviewsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Reviews that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reviewsFindFirstOrThrowArgs} args - Arguments to find a Reviews
     * @example
     * // Get one Reviews
     * const reviews = await prisma.reviews.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends reviewsFindFirstOrThrowArgs>(args?: SelectSubset<T, reviewsFindFirstOrThrowArgs<ExtArgs>>): Prisma__reviewsClient<$Result.GetResult<Prisma.$reviewsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Reviews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reviewsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reviews
     * const reviews = await prisma.reviews.findMany()
     * 
     * // Get first 10 Reviews
     * const reviews = await prisma.reviews.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reviewsWithIdOnly = await prisma.reviews.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends reviewsFindManyArgs>(args?: SelectSubset<T, reviewsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$reviewsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Reviews.
     * @param {reviewsCreateArgs} args - Arguments to create a Reviews.
     * @example
     * // Create one Reviews
     * const Reviews = await prisma.reviews.create({
     *   data: {
     *     // ... data to create a Reviews
     *   }
     * })
     * 
     */
    create<T extends reviewsCreateArgs>(args: SelectSubset<T, reviewsCreateArgs<ExtArgs>>): Prisma__reviewsClient<$Result.GetResult<Prisma.$reviewsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Reviews.
     * @param {reviewsCreateManyArgs} args - Arguments to create many Reviews.
     * @example
     * // Create many Reviews
     * const reviews = await prisma.reviews.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends reviewsCreateManyArgs>(args?: SelectSubset<T, reviewsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Reviews and returns the data saved in the database.
     * @param {reviewsCreateManyAndReturnArgs} args - Arguments to create many Reviews.
     * @example
     * // Create many Reviews
     * const reviews = await prisma.reviews.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Reviews and only return the `id`
     * const reviewsWithIdOnly = await prisma.reviews.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends reviewsCreateManyAndReturnArgs>(args?: SelectSubset<T, reviewsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$reviewsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Reviews.
     * @param {reviewsDeleteArgs} args - Arguments to delete one Reviews.
     * @example
     * // Delete one Reviews
     * const Reviews = await prisma.reviews.delete({
     *   where: {
     *     // ... filter to delete one Reviews
     *   }
     * })
     * 
     */
    delete<T extends reviewsDeleteArgs>(args: SelectSubset<T, reviewsDeleteArgs<ExtArgs>>): Prisma__reviewsClient<$Result.GetResult<Prisma.$reviewsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Reviews.
     * @param {reviewsUpdateArgs} args - Arguments to update one Reviews.
     * @example
     * // Update one Reviews
     * const reviews = await prisma.reviews.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends reviewsUpdateArgs>(args: SelectSubset<T, reviewsUpdateArgs<ExtArgs>>): Prisma__reviewsClient<$Result.GetResult<Prisma.$reviewsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Reviews.
     * @param {reviewsDeleteManyArgs} args - Arguments to filter Reviews to delete.
     * @example
     * // Delete a few Reviews
     * const { count } = await prisma.reviews.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends reviewsDeleteManyArgs>(args?: SelectSubset<T, reviewsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reviewsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reviews
     * const reviews = await prisma.reviews.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends reviewsUpdateManyArgs>(args: SelectSubset<T, reviewsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reviews and returns the data updated in the database.
     * @param {reviewsUpdateManyAndReturnArgs} args - Arguments to update many Reviews.
     * @example
     * // Update many Reviews
     * const reviews = await prisma.reviews.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Reviews and only return the `id`
     * const reviewsWithIdOnly = await prisma.reviews.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends reviewsUpdateManyAndReturnArgs>(args: SelectSubset<T, reviewsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$reviewsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Reviews.
     * @param {reviewsUpsertArgs} args - Arguments to update or create a Reviews.
     * @example
     * // Update or create a Reviews
     * const reviews = await prisma.reviews.upsert({
     *   create: {
     *     // ... data to create a Reviews
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Reviews we want to update
     *   }
     * })
     */
    upsert<T extends reviewsUpsertArgs>(args: SelectSubset<T, reviewsUpsertArgs<ExtArgs>>): Prisma__reviewsClient<$Result.GetResult<Prisma.$reviewsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Reviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reviewsCountArgs} args - Arguments to filter Reviews to count.
     * @example
     * // Count the number of Reviews
     * const count = await prisma.reviews.count({
     *   where: {
     *     // ... the filter for the Reviews we want to count
     *   }
     * })
    **/
    count<T extends reviewsCountArgs>(
      args?: Subset<T, reviewsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReviewsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Reviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReviewsAggregateArgs>(args: Subset<T, ReviewsAggregateArgs>): Prisma.PrismaPromise<GetReviewsAggregateType<T>>

    /**
     * Group by Reviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reviewsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends reviewsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: reviewsGroupByArgs['orderBy'] }
        : { orderBy?: reviewsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, reviewsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReviewsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the reviews model
   */
  readonly fields: reviewsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for reviews.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__reviewsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    book<T extends bookDefaultArgs<ExtArgs> = {}>(args?: Subset<T, bookDefaultArgs<ExtArgs>>): Prisma__bookClient<$Result.GetResult<Prisma.$bookPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    auth_user<T extends auth_userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, auth_userDefaultArgs<ExtArgs>>): Prisma__auth_userClient<$Result.GetResult<Prisma.$auth_userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    reviews_likes<T extends reviews$reviews_likesArgs<ExtArgs> = {}>(args?: Subset<T, reviews$reviews_likesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$reviews_likesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the reviews model
   */
  interface reviewsFieldRefs {
    readonly id: FieldRef<"reviews", 'String'>
    readonly id_book: FieldRef<"reviews", 'String'>
    readonly comments: FieldRef<"reviews", 'String'>
    readonly rating: FieldRef<"reviews", 'Decimal'>
    readonly created_at: FieldRef<"reviews", 'DateTime'>
    readonly deleted_at: FieldRef<"reviews", 'DateTime'>
    readonly parent: FieldRef<"reviews", 'String'>
    readonly id_user: FieldRef<"reviews", 'String'>
  }
    

  // Custom InputTypes
  /**
   * reviews findUnique
   */
  export type reviewsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reviews
     */
    select?: reviewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reviews
     */
    omit?: reviewsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reviewsInclude<ExtArgs> | null
    /**
     * Filter, which reviews to fetch.
     */
    where: reviewsWhereUniqueInput
  }

  /**
   * reviews findUniqueOrThrow
   */
  export type reviewsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reviews
     */
    select?: reviewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reviews
     */
    omit?: reviewsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reviewsInclude<ExtArgs> | null
    /**
     * Filter, which reviews to fetch.
     */
    where: reviewsWhereUniqueInput
  }

  /**
   * reviews findFirst
   */
  export type reviewsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reviews
     */
    select?: reviewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reviews
     */
    omit?: reviewsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reviewsInclude<ExtArgs> | null
    /**
     * Filter, which reviews to fetch.
     */
    where?: reviewsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reviews to fetch.
     */
    orderBy?: reviewsOrderByWithRelationInput | reviewsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for reviews.
     */
    cursor?: reviewsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of reviews.
     */
    distinct?: ReviewsScalarFieldEnum | ReviewsScalarFieldEnum[]
  }

  /**
   * reviews findFirstOrThrow
   */
  export type reviewsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reviews
     */
    select?: reviewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reviews
     */
    omit?: reviewsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reviewsInclude<ExtArgs> | null
    /**
     * Filter, which reviews to fetch.
     */
    where?: reviewsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reviews to fetch.
     */
    orderBy?: reviewsOrderByWithRelationInput | reviewsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for reviews.
     */
    cursor?: reviewsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of reviews.
     */
    distinct?: ReviewsScalarFieldEnum | ReviewsScalarFieldEnum[]
  }

  /**
   * reviews findMany
   */
  export type reviewsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reviews
     */
    select?: reviewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reviews
     */
    omit?: reviewsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reviewsInclude<ExtArgs> | null
    /**
     * Filter, which reviews to fetch.
     */
    where?: reviewsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reviews to fetch.
     */
    orderBy?: reviewsOrderByWithRelationInput | reviewsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing reviews.
     */
    cursor?: reviewsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reviews.
     */
    skip?: number
    distinct?: ReviewsScalarFieldEnum | ReviewsScalarFieldEnum[]
  }

  /**
   * reviews create
   */
  export type reviewsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reviews
     */
    select?: reviewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reviews
     */
    omit?: reviewsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reviewsInclude<ExtArgs> | null
    /**
     * The data needed to create a reviews.
     */
    data: XOR<reviewsCreateInput, reviewsUncheckedCreateInput>
  }

  /**
   * reviews createMany
   */
  export type reviewsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many reviews.
     */
    data: reviewsCreateManyInput | reviewsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * reviews createManyAndReturn
   */
  export type reviewsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reviews
     */
    select?: reviewsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the reviews
     */
    omit?: reviewsOmit<ExtArgs> | null
    /**
     * The data used to create many reviews.
     */
    data: reviewsCreateManyInput | reviewsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reviewsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * reviews update
   */
  export type reviewsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reviews
     */
    select?: reviewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reviews
     */
    omit?: reviewsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reviewsInclude<ExtArgs> | null
    /**
     * The data needed to update a reviews.
     */
    data: XOR<reviewsUpdateInput, reviewsUncheckedUpdateInput>
    /**
     * Choose, which reviews to update.
     */
    where: reviewsWhereUniqueInput
  }

  /**
   * reviews updateMany
   */
  export type reviewsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update reviews.
     */
    data: XOR<reviewsUpdateManyMutationInput, reviewsUncheckedUpdateManyInput>
    /**
     * Filter which reviews to update
     */
    where?: reviewsWhereInput
    /**
     * Limit how many reviews to update.
     */
    limit?: number
  }

  /**
   * reviews updateManyAndReturn
   */
  export type reviewsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reviews
     */
    select?: reviewsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the reviews
     */
    omit?: reviewsOmit<ExtArgs> | null
    /**
     * The data used to update reviews.
     */
    data: XOR<reviewsUpdateManyMutationInput, reviewsUncheckedUpdateManyInput>
    /**
     * Filter which reviews to update
     */
    where?: reviewsWhereInput
    /**
     * Limit how many reviews to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reviewsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * reviews upsert
   */
  export type reviewsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reviews
     */
    select?: reviewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reviews
     */
    omit?: reviewsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reviewsInclude<ExtArgs> | null
    /**
     * The filter to search for the reviews to update in case it exists.
     */
    where: reviewsWhereUniqueInput
    /**
     * In case the reviews found by the `where` argument doesn't exist, create a new reviews with this data.
     */
    create: XOR<reviewsCreateInput, reviewsUncheckedCreateInput>
    /**
     * In case the reviews was found with the provided `where` argument, update it with this data.
     */
    update: XOR<reviewsUpdateInput, reviewsUncheckedUpdateInput>
  }

  /**
   * reviews delete
   */
  export type reviewsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reviews
     */
    select?: reviewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reviews
     */
    omit?: reviewsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reviewsInclude<ExtArgs> | null
    /**
     * Filter which reviews to delete.
     */
    where: reviewsWhereUniqueInput
  }

  /**
   * reviews deleteMany
   */
  export type reviewsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which reviews to delete
     */
    where?: reviewsWhereInput
    /**
     * Limit how many reviews to delete.
     */
    limit?: number
  }

  /**
   * reviews.reviews_likes
   */
  export type reviews$reviews_likesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reviews_likes
     */
    select?: reviews_likesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reviews_likes
     */
    omit?: reviews_likesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reviews_likesInclude<ExtArgs> | null
    where?: reviews_likesWhereInput
    orderBy?: reviews_likesOrderByWithRelationInput | reviews_likesOrderByWithRelationInput[]
    cursor?: reviews_likesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Reviews_likesScalarFieldEnum | Reviews_likesScalarFieldEnum[]
  }

  /**
   * reviews without action
   */
  export type reviewsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reviews
     */
    select?: reviewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reviews
     */
    omit?: reviewsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reviewsInclude<ExtArgs> | null
  }


  /**
   * Model reviews_likes
   */

  export type AggregateReviews_likes = {
    _count: Reviews_likesCountAggregateOutputType | null
    _min: Reviews_likesMinAggregateOutputType | null
    _max: Reviews_likesMaxAggregateOutputType | null
  }

  export type Reviews_likesMinAggregateOutputType = {
    id: string | null
    id_reviews: string | null
    id_user: string | null
  }

  export type Reviews_likesMaxAggregateOutputType = {
    id: string | null
    id_reviews: string | null
    id_user: string | null
  }

  export type Reviews_likesCountAggregateOutputType = {
    id: number
    id_reviews: number
    id_user: number
    _all: number
  }


  export type Reviews_likesMinAggregateInputType = {
    id?: true
    id_reviews?: true
    id_user?: true
  }

  export type Reviews_likesMaxAggregateInputType = {
    id?: true
    id_reviews?: true
    id_user?: true
  }

  export type Reviews_likesCountAggregateInputType = {
    id?: true
    id_reviews?: true
    id_user?: true
    _all?: true
  }

  export type Reviews_likesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which reviews_likes to aggregate.
     */
    where?: reviews_likesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reviews_likes to fetch.
     */
    orderBy?: reviews_likesOrderByWithRelationInput | reviews_likesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: reviews_likesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reviews_likes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reviews_likes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned reviews_likes
    **/
    _count?: true | Reviews_likesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Reviews_likesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Reviews_likesMaxAggregateInputType
  }

  export type GetReviews_likesAggregateType<T extends Reviews_likesAggregateArgs> = {
        [P in keyof T & keyof AggregateReviews_likes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReviews_likes[P]>
      : GetScalarType<T[P], AggregateReviews_likes[P]>
  }




  export type reviews_likesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: reviews_likesWhereInput
    orderBy?: reviews_likesOrderByWithAggregationInput | reviews_likesOrderByWithAggregationInput[]
    by: Reviews_likesScalarFieldEnum[] | Reviews_likesScalarFieldEnum
    having?: reviews_likesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Reviews_likesCountAggregateInputType | true
    _min?: Reviews_likesMinAggregateInputType
    _max?: Reviews_likesMaxAggregateInputType
  }

  export type Reviews_likesGroupByOutputType = {
    id: string
    id_reviews: string
    id_user: string
    _count: Reviews_likesCountAggregateOutputType | null
    _min: Reviews_likesMinAggregateOutputType | null
    _max: Reviews_likesMaxAggregateOutputType | null
  }

  type GetReviews_likesGroupByPayload<T extends reviews_likesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Reviews_likesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Reviews_likesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Reviews_likesGroupByOutputType[P]>
            : GetScalarType<T[P], Reviews_likesGroupByOutputType[P]>
        }
      >
    >


  export type reviews_likesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    id_reviews?: boolean
    id_user?: boolean
    reviews?: boolean | reviewsDefaultArgs<ExtArgs>
    auth_user?: boolean | auth_userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reviews_likes"]>

  export type reviews_likesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    id_reviews?: boolean
    id_user?: boolean
    reviews?: boolean | reviewsDefaultArgs<ExtArgs>
    auth_user?: boolean | auth_userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reviews_likes"]>

  export type reviews_likesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    id_reviews?: boolean
    id_user?: boolean
    reviews?: boolean | reviewsDefaultArgs<ExtArgs>
    auth_user?: boolean | auth_userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reviews_likes"]>

  export type reviews_likesSelectScalar = {
    id?: boolean
    id_reviews?: boolean
    id_user?: boolean
  }

  export type reviews_likesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "id_reviews" | "id_user", ExtArgs["result"]["reviews_likes"]>
  export type reviews_likesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reviews?: boolean | reviewsDefaultArgs<ExtArgs>
    auth_user?: boolean | auth_userDefaultArgs<ExtArgs>
  }
  export type reviews_likesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reviews?: boolean | reviewsDefaultArgs<ExtArgs>
    auth_user?: boolean | auth_userDefaultArgs<ExtArgs>
  }
  export type reviews_likesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reviews?: boolean | reviewsDefaultArgs<ExtArgs>
    auth_user?: boolean | auth_userDefaultArgs<ExtArgs>
  }

  export type $reviews_likesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "reviews_likes"
    objects: {
      reviews: Prisma.$reviewsPayload<ExtArgs>
      auth_user: Prisma.$auth_userPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      id_reviews: string
      id_user: string
    }, ExtArgs["result"]["reviews_likes"]>
    composites: {}
  }

  type reviews_likesGetPayload<S extends boolean | null | undefined | reviews_likesDefaultArgs> = $Result.GetResult<Prisma.$reviews_likesPayload, S>

  type reviews_likesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<reviews_likesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Reviews_likesCountAggregateInputType | true
    }

  export interface reviews_likesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['reviews_likes'], meta: { name: 'reviews_likes' } }
    /**
     * Find zero or one Reviews_likes that matches the filter.
     * @param {reviews_likesFindUniqueArgs} args - Arguments to find a Reviews_likes
     * @example
     * // Get one Reviews_likes
     * const reviews_likes = await prisma.reviews_likes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends reviews_likesFindUniqueArgs>(args: SelectSubset<T, reviews_likesFindUniqueArgs<ExtArgs>>): Prisma__reviews_likesClient<$Result.GetResult<Prisma.$reviews_likesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Reviews_likes that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {reviews_likesFindUniqueOrThrowArgs} args - Arguments to find a Reviews_likes
     * @example
     * // Get one Reviews_likes
     * const reviews_likes = await prisma.reviews_likes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends reviews_likesFindUniqueOrThrowArgs>(args: SelectSubset<T, reviews_likesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__reviews_likesClient<$Result.GetResult<Prisma.$reviews_likesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Reviews_likes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reviews_likesFindFirstArgs} args - Arguments to find a Reviews_likes
     * @example
     * // Get one Reviews_likes
     * const reviews_likes = await prisma.reviews_likes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends reviews_likesFindFirstArgs>(args?: SelectSubset<T, reviews_likesFindFirstArgs<ExtArgs>>): Prisma__reviews_likesClient<$Result.GetResult<Prisma.$reviews_likesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Reviews_likes that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reviews_likesFindFirstOrThrowArgs} args - Arguments to find a Reviews_likes
     * @example
     * // Get one Reviews_likes
     * const reviews_likes = await prisma.reviews_likes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends reviews_likesFindFirstOrThrowArgs>(args?: SelectSubset<T, reviews_likesFindFirstOrThrowArgs<ExtArgs>>): Prisma__reviews_likesClient<$Result.GetResult<Prisma.$reviews_likesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Reviews_likes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reviews_likesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reviews_likes
     * const reviews_likes = await prisma.reviews_likes.findMany()
     * 
     * // Get first 10 Reviews_likes
     * const reviews_likes = await prisma.reviews_likes.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reviews_likesWithIdOnly = await prisma.reviews_likes.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends reviews_likesFindManyArgs>(args?: SelectSubset<T, reviews_likesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$reviews_likesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Reviews_likes.
     * @param {reviews_likesCreateArgs} args - Arguments to create a Reviews_likes.
     * @example
     * // Create one Reviews_likes
     * const Reviews_likes = await prisma.reviews_likes.create({
     *   data: {
     *     // ... data to create a Reviews_likes
     *   }
     * })
     * 
     */
    create<T extends reviews_likesCreateArgs>(args: SelectSubset<T, reviews_likesCreateArgs<ExtArgs>>): Prisma__reviews_likesClient<$Result.GetResult<Prisma.$reviews_likesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Reviews_likes.
     * @param {reviews_likesCreateManyArgs} args - Arguments to create many Reviews_likes.
     * @example
     * // Create many Reviews_likes
     * const reviews_likes = await prisma.reviews_likes.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends reviews_likesCreateManyArgs>(args?: SelectSubset<T, reviews_likesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Reviews_likes and returns the data saved in the database.
     * @param {reviews_likesCreateManyAndReturnArgs} args - Arguments to create many Reviews_likes.
     * @example
     * // Create many Reviews_likes
     * const reviews_likes = await prisma.reviews_likes.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Reviews_likes and only return the `id`
     * const reviews_likesWithIdOnly = await prisma.reviews_likes.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends reviews_likesCreateManyAndReturnArgs>(args?: SelectSubset<T, reviews_likesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$reviews_likesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Reviews_likes.
     * @param {reviews_likesDeleteArgs} args - Arguments to delete one Reviews_likes.
     * @example
     * // Delete one Reviews_likes
     * const Reviews_likes = await prisma.reviews_likes.delete({
     *   where: {
     *     // ... filter to delete one Reviews_likes
     *   }
     * })
     * 
     */
    delete<T extends reviews_likesDeleteArgs>(args: SelectSubset<T, reviews_likesDeleteArgs<ExtArgs>>): Prisma__reviews_likesClient<$Result.GetResult<Prisma.$reviews_likesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Reviews_likes.
     * @param {reviews_likesUpdateArgs} args - Arguments to update one Reviews_likes.
     * @example
     * // Update one Reviews_likes
     * const reviews_likes = await prisma.reviews_likes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends reviews_likesUpdateArgs>(args: SelectSubset<T, reviews_likesUpdateArgs<ExtArgs>>): Prisma__reviews_likesClient<$Result.GetResult<Prisma.$reviews_likesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Reviews_likes.
     * @param {reviews_likesDeleteManyArgs} args - Arguments to filter Reviews_likes to delete.
     * @example
     * // Delete a few Reviews_likes
     * const { count } = await prisma.reviews_likes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends reviews_likesDeleteManyArgs>(args?: SelectSubset<T, reviews_likesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reviews_likes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reviews_likesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reviews_likes
     * const reviews_likes = await prisma.reviews_likes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends reviews_likesUpdateManyArgs>(args: SelectSubset<T, reviews_likesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reviews_likes and returns the data updated in the database.
     * @param {reviews_likesUpdateManyAndReturnArgs} args - Arguments to update many Reviews_likes.
     * @example
     * // Update many Reviews_likes
     * const reviews_likes = await prisma.reviews_likes.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Reviews_likes and only return the `id`
     * const reviews_likesWithIdOnly = await prisma.reviews_likes.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends reviews_likesUpdateManyAndReturnArgs>(args: SelectSubset<T, reviews_likesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$reviews_likesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Reviews_likes.
     * @param {reviews_likesUpsertArgs} args - Arguments to update or create a Reviews_likes.
     * @example
     * // Update or create a Reviews_likes
     * const reviews_likes = await prisma.reviews_likes.upsert({
     *   create: {
     *     // ... data to create a Reviews_likes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Reviews_likes we want to update
     *   }
     * })
     */
    upsert<T extends reviews_likesUpsertArgs>(args: SelectSubset<T, reviews_likesUpsertArgs<ExtArgs>>): Prisma__reviews_likesClient<$Result.GetResult<Prisma.$reviews_likesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Reviews_likes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reviews_likesCountArgs} args - Arguments to filter Reviews_likes to count.
     * @example
     * // Count the number of Reviews_likes
     * const count = await prisma.reviews_likes.count({
     *   where: {
     *     // ... the filter for the Reviews_likes we want to count
     *   }
     * })
    **/
    count<T extends reviews_likesCountArgs>(
      args?: Subset<T, reviews_likesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Reviews_likesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Reviews_likes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Reviews_likesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Reviews_likesAggregateArgs>(args: Subset<T, Reviews_likesAggregateArgs>): Prisma.PrismaPromise<GetReviews_likesAggregateType<T>>

    /**
     * Group by Reviews_likes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reviews_likesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends reviews_likesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: reviews_likesGroupByArgs['orderBy'] }
        : { orderBy?: reviews_likesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, reviews_likesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReviews_likesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the reviews_likes model
   */
  readonly fields: reviews_likesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for reviews_likes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__reviews_likesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    reviews<T extends reviewsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, reviewsDefaultArgs<ExtArgs>>): Prisma__reviewsClient<$Result.GetResult<Prisma.$reviewsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    auth_user<T extends auth_userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, auth_userDefaultArgs<ExtArgs>>): Prisma__auth_userClient<$Result.GetResult<Prisma.$auth_userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the reviews_likes model
   */
  interface reviews_likesFieldRefs {
    readonly id: FieldRef<"reviews_likes", 'String'>
    readonly id_reviews: FieldRef<"reviews_likes", 'String'>
    readonly id_user: FieldRef<"reviews_likes", 'String'>
  }
    

  // Custom InputTypes
  /**
   * reviews_likes findUnique
   */
  export type reviews_likesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reviews_likes
     */
    select?: reviews_likesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reviews_likes
     */
    omit?: reviews_likesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reviews_likesInclude<ExtArgs> | null
    /**
     * Filter, which reviews_likes to fetch.
     */
    where: reviews_likesWhereUniqueInput
  }

  /**
   * reviews_likes findUniqueOrThrow
   */
  export type reviews_likesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reviews_likes
     */
    select?: reviews_likesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reviews_likes
     */
    omit?: reviews_likesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reviews_likesInclude<ExtArgs> | null
    /**
     * Filter, which reviews_likes to fetch.
     */
    where: reviews_likesWhereUniqueInput
  }

  /**
   * reviews_likes findFirst
   */
  export type reviews_likesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reviews_likes
     */
    select?: reviews_likesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reviews_likes
     */
    omit?: reviews_likesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reviews_likesInclude<ExtArgs> | null
    /**
     * Filter, which reviews_likes to fetch.
     */
    where?: reviews_likesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reviews_likes to fetch.
     */
    orderBy?: reviews_likesOrderByWithRelationInput | reviews_likesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for reviews_likes.
     */
    cursor?: reviews_likesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reviews_likes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reviews_likes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of reviews_likes.
     */
    distinct?: Reviews_likesScalarFieldEnum | Reviews_likesScalarFieldEnum[]
  }

  /**
   * reviews_likes findFirstOrThrow
   */
  export type reviews_likesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reviews_likes
     */
    select?: reviews_likesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reviews_likes
     */
    omit?: reviews_likesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reviews_likesInclude<ExtArgs> | null
    /**
     * Filter, which reviews_likes to fetch.
     */
    where?: reviews_likesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reviews_likes to fetch.
     */
    orderBy?: reviews_likesOrderByWithRelationInput | reviews_likesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for reviews_likes.
     */
    cursor?: reviews_likesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reviews_likes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reviews_likes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of reviews_likes.
     */
    distinct?: Reviews_likesScalarFieldEnum | Reviews_likesScalarFieldEnum[]
  }

  /**
   * reviews_likes findMany
   */
  export type reviews_likesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reviews_likes
     */
    select?: reviews_likesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reviews_likes
     */
    omit?: reviews_likesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reviews_likesInclude<ExtArgs> | null
    /**
     * Filter, which reviews_likes to fetch.
     */
    where?: reviews_likesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reviews_likes to fetch.
     */
    orderBy?: reviews_likesOrderByWithRelationInput | reviews_likesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing reviews_likes.
     */
    cursor?: reviews_likesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reviews_likes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reviews_likes.
     */
    skip?: number
    distinct?: Reviews_likesScalarFieldEnum | Reviews_likesScalarFieldEnum[]
  }

  /**
   * reviews_likes create
   */
  export type reviews_likesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reviews_likes
     */
    select?: reviews_likesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reviews_likes
     */
    omit?: reviews_likesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reviews_likesInclude<ExtArgs> | null
    /**
     * The data needed to create a reviews_likes.
     */
    data: XOR<reviews_likesCreateInput, reviews_likesUncheckedCreateInput>
  }

  /**
   * reviews_likes createMany
   */
  export type reviews_likesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many reviews_likes.
     */
    data: reviews_likesCreateManyInput | reviews_likesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * reviews_likes createManyAndReturn
   */
  export type reviews_likesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reviews_likes
     */
    select?: reviews_likesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the reviews_likes
     */
    omit?: reviews_likesOmit<ExtArgs> | null
    /**
     * The data used to create many reviews_likes.
     */
    data: reviews_likesCreateManyInput | reviews_likesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reviews_likesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * reviews_likes update
   */
  export type reviews_likesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reviews_likes
     */
    select?: reviews_likesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reviews_likes
     */
    omit?: reviews_likesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reviews_likesInclude<ExtArgs> | null
    /**
     * The data needed to update a reviews_likes.
     */
    data: XOR<reviews_likesUpdateInput, reviews_likesUncheckedUpdateInput>
    /**
     * Choose, which reviews_likes to update.
     */
    where: reviews_likesWhereUniqueInput
  }

  /**
   * reviews_likes updateMany
   */
  export type reviews_likesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update reviews_likes.
     */
    data: XOR<reviews_likesUpdateManyMutationInput, reviews_likesUncheckedUpdateManyInput>
    /**
     * Filter which reviews_likes to update
     */
    where?: reviews_likesWhereInput
    /**
     * Limit how many reviews_likes to update.
     */
    limit?: number
  }

  /**
   * reviews_likes updateManyAndReturn
   */
  export type reviews_likesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reviews_likes
     */
    select?: reviews_likesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the reviews_likes
     */
    omit?: reviews_likesOmit<ExtArgs> | null
    /**
     * The data used to update reviews_likes.
     */
    data: XOR<reviews_likesUpdateManyMutationInput, reviews_likesUncheckedUpdateManyInput>
    /**
     * Filter which reviews_likes to update
     */
    where?: reviews_likesWhereInput
    /**
     * Limit how many reviews_likes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reviews_likesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * reviews_likes upsert
   */
  export type reviews_likesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reviews_likes
     */
    select?: reviews_likesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reviews_likes
     */
    omit?: reviews_likesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reviews_likesInclude<ExtArgs> | null
    /**
     * The filter to search for the reviews_likes to update in case it exists.
     */
    where: reviews_likesWhereUniqueInput
    /**
     * In case the reviews_likes found by the `where` argument doesn't exist, create a new reviews_likes with this data.
     */
    create: XOR<reviews_likesCreateInput, reviews_likesUncheckedCreateInput>
    /**
     * In case the reviews_likes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<reviews_likesUpdateInput, reviews_likesUncheckedUpdateInput>
  }

  /**
   * reviews_likes delete
   */
  export type reviews_likesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reviews_likes
     */
    select?: reviews_likesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reviews_likes
     */
    omit?: reviews_likesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reviews_likesInclude<ExtArgs> | null
    /**
     * Filter which reviews_likes to delete.
     */
    where: reviews_likesWhereUniqueInput
  }

  /**
   * reviews_likes deleteMany
   */
  export type reviews_likesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which reviews_likes to delete
     */
    where?: reviews_likesWhereInput
    /**
     * Limit how many reviews_likes to delete.
     */
    limit?: number
  }

  /**
   * reviews_likes without action
   */
  export type reviews_likesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reviews_likes
     */
    select?: reviews_likesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reviews_likes
     */
    omit?: reviews_likesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reviews_likesInclude<ExtArgs> | null
  }


  /**
   * Model t_ai_credit
   */

  export type AggregateT_ai_credit = {
    _count: T_ai_creditCountAggregateOutputType | null
    _avg: T_ai_creditAvgAggregateOutputType | null
    _sum: T_ai_creditSumAggregateOutputType | null
    _min: T_ai_creditMinAggregateOutputType | null
    _max: T_ai_creditMaxAggregateOutputType | null
  }

  export type T_ai_creditAvgAggregateOutputType = {
    balance: number | null
  }

  export type T_ai_creditSumAggregateOutputType = {
    balance: number | null
  }

  export type T_ai_creditMinAggregateOutputType = {
    id: string | null
    id_publisher: string | null
    balance: number | null
    last_topup_at: Date | null
  }

  export type T_ai_creditMaxAggregateOutputType = {
    id: string | null
    id_publisher: string | null
    balance: number | null
    last_topup_at: Date | null
  }

  export type T_ai_creditCountAggregateOutputType = {
    id: number
    id_publisher: number
    balance: number
    last_topup_at: number
    _all: number
  }


  export type T_ai_creditAvgAggregateInputType = {
    balance?: true
  }

  export type T_ai_creditSumAggregateInputType = {
    balance?: true
  }

  export type T_ai_creditMinAggregateInputType = {
    id?: true
    id_publisher?: true
    balance?: true
    last_topup_at?: true
  }

  export type T_ai_creditMaxAggregateInputType = {
    id?: true
    id_publisher?: true
    balance?: true
    last_topup_at?: true
  }

  export type T_ai_creditCountAggregateInputType = {
    id?: true
    id_publisher?: true
    balance?: true
    last_topup_at?: true
    _all?: true
  }

  export type T_ai_creditAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which t_ai_credit to aggregate.
     */
    where?: t_ai_creditWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of t_ai_credits to fetch.
     */
    orderBy?: t_ai_creditOrderByWithRelationInput | t_ai_creditOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: t_ai_creditWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` t_ai_credits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` t_ai_credits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned t_ai_credits
    **/
    _count?: true | T_ai_creditCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: T_ai_creditAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: T_ai_creditSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: T_ai_creditMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: T_ai_creditMaxAggregateInputType
  }

  export type GetT_ai_creditAggregateType<T extends T_ai_creditAggregateArgs> = {
        [P in keyof T & keyof AggregateT_ai_credit]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateT_ai_credit[P]>
      : GetScalarType<T[P], AggregateT_ai_credit[P]>
  }




  export type t_ai_creditGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: t_ai_creditWhereInput
    orderBy?: t_ai_creditOrderByWithAggregationInput | t_ai_creditOrderByWithAggregationInput[]
    by: T_ai_creditScalarFieldEnum[] | T_ai_creditScalarFieldEnum
    having?: t_ai_creditScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: T_ai_creditCountAggregateInputType | true
    _avg?: T_ai_creditAvgAggregateInputType
    _sum?: T_ai_creditSumAggregateInputType
    _min?: T_ai_creditMinAggregateInputType
    _max?: T_ai_creditMaxAggregateInputType
  }

  export type T_ai_creditGroupByOutputType = {
    id: string
    id_publisher: string
    balance: number
    last_topup_at: Date | null
    _count: T_ai_creditCountAggregateOutputType | null
    _avg: T_ai_creditAvgAggregateOutputType | null
    _sum: T_ai_creditSumAggregateOutputType | null
    _min: T_ai_creditMinAggregateOutputType | null
    _max: T_ai_creditMaxAggregateOutputType | null
  }

  type GetT_ai_creditGroupByPayload<T extends t_ai_creditGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<T_ai_creditGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof T_ai_creditGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], T_ai_creditGroupByOutputType[P]>
            : GetScalarType<T[P], T_ai_creditGroupByOutputType[P]>
        }
      >
    >


  export type t_ai_creditSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    id_publisher?: boolean
    balance?: boolean
    last_topup_at?: boolean
    publisher?: boolean | publisherDefaultArgs<ExtArgs>
    t_ai_credit_topup?: boolean | t_ai_credit$t_ai_credit_topupArgs<ExtArgs>
    _count?: boolean | T_ai_creditCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["t_ai_credit"]>

  export type t_ai_creditSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    id_publisher?: boolean
    balance?: boolean
    last_topup_at?: boolean
    publisher?: boolean | publisherDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["t_ai_credit"]>

  export type t_ai_creditSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    id_publisher?: boolean
    balance?: boolean
    last_topup_at?: boolean
    publisher?: boolean | publisherDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["t_ai_credit"]>

  export type t_ai_creditSelectScalar = {
    id?: boolean
    id_publisher?: boolean
    balance?: boolean
    last_topup_at?: boolean
  }

  export type t_ai_creditOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "id_publisher" | "balance" | "last_topup_at", ExtArgs["result"]["t_ai_credit"]>
  export type t_ai_creditInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    publisher?: boolean | publisherDefaultArgs<ExtArgs>
    t_ai_credit_topup?: boolean | t_ai_credit$t_ai_credit_topupArgs<ExtArgs>
    _count?: boolean | T_ai_creditCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type t_ai_creditIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    publisher?: boolean | publisherDefaultArgs<ExtArgs>
  }
  export type t_ai_creditIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    publisher?: boolean | publisherDefaultArgs<ExtArgs>
  }

  export type $t_ai_creditPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "t_ai_credit"
    objects: {
      publisher: Prisma.$publisherPayload<ExtArgs>
      t_ai_credit_topup: Prisma.$t_ai_credit_topupPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      id_publisher: string
      balance: number
      last_topup_at: Date | null
    }, ExtArgs["result"]["t_ai_credit"]>
    composites: {}
  }

  type t_ai_creditGetPayload<S extends boolean | null | undefined | t_ai_creditDefaultArgs> = $Result.GetResult<Prisma.$t_ai_creditPayload, S>

  type t_ai_creditCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<t_ai_creditFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: T_ai_creditCountAggregateInputType | true
    }

  export interface t_ai_creditDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['t_ai_credit'], meta: { name: 't_ai_credit' } }
    /**
     * Find zero or one T_ai_credit that matches the filter.
     * @param {t_ai_creditFindUniqueArgs} args - Arguments to find a T_ai_credit
     * @example
     * // Get one T_ai_credit
     * const t_ai_credit = await prisma.t_ai_credit.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends t_ai_creditFindUniqueArgs>(args: SelectSubset<T, t_ai_creditFindUniqueArgs<ExtArgs>>): Prisma__t_ai_creditClient<$Result.GetResult<Prisma.$t_ai_creditPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one T_ai_credit that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {t_ai_creditFindUniqueOrThrowArgs} args - Arguments to find a T_ai_credit
     * @example
     * // Get one T_ai_credit
     * const t_ai_credit = await prisma.t_ai_credit.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends t_ai_creditFindUniqueOrThrowArgs>(args: SelectSubset<T, t_ai_creditFindUniqueOrThrowArgs<ExtArgs>>): Prisma__t_ai_creditClient<$Result.GetResult<Prisma.$t_ai_creditPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first T_ai_credit that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {t_ai_creditFindFirstArgs} args - Arguments to find a T_ai_credit
     * @example
     * // Get one T_ai_credit
     * const t_ai_credit = await prisma.t_ai_credit.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends t_ai_creditFindFirstArgs>(args?: SelectSubset<T, t_ai_creditFindFirstArgs<ExtArgs>>): Prisma__t_ai_creditClient<$Result.GetResult<Prisma.$t_ai_creditPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first T_ai_credit that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {t_ai_creditFindFirstOrThrowArgs} args - Arguments to find a T_ai_credit
     * @example
     * // Get one T_ai_credit
     * const t_ai_credit = await prisma.t_ai_credit.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends t_ai_creditFindFirstOrThrowArgs>(args?: SelectSubset<T, t_ai_creditFindFirstOrThrowArgs<ExtArgs>>): Prisma__t_ai_creditClient<$Result.GetResult<Prisma.$t_ai_creditPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more T_ai_credits that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {t_ai_creditFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all T_ai_credits
     * const t_ai_credits = await prisma.t_ai_credit.findMany()
     * 
     * // Get first 10 T_ai_credits
     * const t_ai_credits = await prisma.t_ai_credit.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const t_ai_creditWithIdOnly = await prisma.t_ai_credit.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends t_ai_creditFindManyArgs>(args?: SelectSubset<T, t_ai_creditFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$t_ai_creditPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a T_ai_credit.
     * @param {t_ai_creditCreateArgs} args - Arguments to create a T_ai_credit.
     * @example
     * // Create one T_ai_credit
     * const T_ai_credit = await prisma.t_ai_credit.create({
     *   data: {
     *     // ... data to create a T_ai_credit
     *   }
     * })
     * 
     */
    create<T extends t_ai_creditCreateArgs>(args: SelectSubset<T, t_ai_creditCreateArgs<ExtArgs>>): Prisma__t_ai_creditClient<$Result.GetResult<Prisma.$t_ai_creditPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many T_ai_credits.
     * @param {t_ai_creditCreateManyArgs} args - Arguments to create many T_ai_credits.
     * @example
     * // Create many T_ai_credits
     * const t_ai_credit = await prisma.t_ai_credit.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends t_ai_creditCreateManyArgs>(args?: SelectSubset<T, t_ai_creditCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many T_ai_credits and returns the data saved in the database.
     * @param {t_ai_creditCreateManyAndReturnArgs} args - Arguments to create many T_ai_credits.
     * @example
     * // Create many T_ai_credits
     * const t_ai_credit = await prisma.t_ai_credit.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many T_ai_credits and only return the `id`
     * const t_ai_creditWithIdOnly = await prisma.t_ai_credit.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends t_ai_creditCreateManyAndReturnArgs>(args?: SelectSubset<T, t_ai_creditCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$t_ai_creditPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a T_ai_credit.
     * @param {t_ai_creditDeleteArgs} args - Arguments to delete one T_ai_credit.
     * @example
     * // Delete one T_ai_credit
     * const T_ai_credit = await prisma.t_ai_credit.delete({
     *   where: {
     *     // ... filter to delete one T_ai_credit
     *   }
     * })
     * 
     */
    delete<T extends t_ai_creditDeleteArgs>(args: SelectSubset<T, t_ai_creditDeleteArgs<ExtArgs>>): Prisma__t_ai_creditClient<$Result.GetResult<Prisma.$t_ai_creditPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one T_ai_credit.
     * @param {t_ai_creditUpdateArgs} args - Arguments to update one T_ai_credit.
     * @example
     * // Update one T_ai_credit
     * const t_ai_credit = await prisma.t_ai_credit.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends t_ai_creditUpdateArgs>(args: SelectSubset<T, t_ai_creditUpdateArgs<ExtArgs>>): Prisma__t_ai_creditClient<$Result.GetResult<Prisma.$t_ai_creditPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more T_ai_credits.
     * @param {t_ai_creditDeleteManyArgs} args - Arguments to filter T_ai_credits to delete.
     * @example
     * // Delete a few T_ai_credits
     * const { count } = await prisma.t_ai_credit.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends t_ai_creditDeleteManyArgs>(args?: SelectSubset<T, t_ai_creditDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more T_ai_credits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {t_ai_creditUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many T_ai_credits
     * const t_ai_credit = await prisma.t_ai_credit.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends t_ai_creditUpdateManyArgs>(args: SelectSubset<T, t_ai_creditUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more T_ai_credits and returns the data updated in the database.
     * @param {t_ai_creditUpdateManyAndReturnArgs} args - Arguments to update many T_ai_credits.
     * @example
     * // Update many T_ai_credits
     * const t_ai_credit = await prisma.t_ai_credit.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more T_ai_credits and only return the `id`
     * const t_ai_creditWithIdOnly = await prisma.t_ai_credit.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends t_ai_creditUpdateManyAndReturnArgs>(args: SelectSubset<T, t_ai_creditUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$t_ai_creditPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one T_ai_credit.
     * @param {t_ai_creditUpsertArgs} args - Arguments to update or create a T_ai_credit.
     * @example
     * // Update or create a T_ai_credit
     * const t_ai_credit = await prisma.t_ai_credit.upsert({
     *   create: {
     *     // ... data to create a T_ai_credit
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the T_ai_credit we want to update
     *   }
     * })
     */
    upsert<T extends t_ai_creditUpsertArgs>(args: SelectSubset<T, t_ai_creditUpsertArgs<ExtArgs>>): Prisma__t_ai_creditClient<$Result.GetResult<Prisma.$t_ai_creditPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of T_ai_credits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {t_ai_creditCountArgs} args - Arguments to filter T_ai_credits to count.
     * @example
     * // Count the number of T_ai_credits
     * const count = await prisma.t_ai_credit.count({
     *   where: {
     *     // ... the filter for the T_ai_credits we want to count
     *   }
     * })
    **/
    count<T extends t_ai_creditCountArgs>(
      args?: Subset<T, t_ai_creditCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], T_ai_creditCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a T_ai_credit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {T_ai_creditAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends T_ai_creditAggregateArgs>(args: Subset<T, T_ai_creditAggregateArgs>): Prisma.PrismaPromise<GetT_ai_creditAggregateType<T>>

    /**
     * Group by T_ai_credit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {t_ai_creditGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends t_ai_creditGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: t_ai_creditGroupByArgs['orderBy'] }
        : { orderBy?: t_ai_creditGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, t_ai_creditGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetT_ai_creditGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the t_ai_credit model
   */
  readonly fields: t_ai_creditFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for t_ai_credit.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__t_ai_creditClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    publisher<T extends publisherDefaultArgs<ExtArgs> = {}>(args?: Subset<T, publisherDefaultArgs<ExtArgs>>): Prisma__publisherClient<$Result.GetResult<Prisma.$publisherPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    t_ai_credit_topup<T extends t_ai_credit$t_ai_credit_topupArgs<ExtArgs> = {}>(args?: Subset<T, t_ai_credit$t_ai_credit_topupArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$t_ai_credit_topupPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the t_ai_credit model
   */
  interface t_ai_creditFieldRefs {
    readonly id: FieldRef<"t_ai_credit", 'String'>
    readonly id_publisher: FieldRef<"t_ai_credit", 'String'>
    readonly balance: FieldRef<"t_ai_credit", 'Int'>
    readonly last_topup_at: FieldRef<"t_ai_credit", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * t_ai_credit findUnique
   */
  export type t_ai_creditFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the t_ai_credit
     */
    select?: t_ai_creditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the t_ai_credit
     */
    omit?: t_ai_creditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: t_ai_creditInclude<ExtArgs> | null
    /**
     * Filter, which t_ai_credit to fetch.
     */
    where: t_ai_creditWhereUniqueInput
  }

  /**
   * t_ai_credit findUniqueOrThrow
   */
  export type t_ai_creditFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the t_ai_credit
     */
    select?: t_ai_creditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the t_ai_credit
     */
    omit?: t_ai_creditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: t_ai_creditInclude<ExtArgs> | null
    /**
     * Filter, which t_ai_credit to fetch.
     */
    where: t_ai_creditWhereUniqueInput
  }

  /**
   * t_ai_credit findFirst
   */
  export type t_ai_creditFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the t_ai_credit
     */
    select?: t_ai_creditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the t_ai_credit
     */
    omit?: t_ai_creditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: t_ai_creditInclude<ExtArgs> | null
    /**
     * Filter, which t_ai_credit to fetch.
     */
    where?: t_ai_creditWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of t_ai_credits to fetch.
     */
    orderBy?: t_ai_creditOrderByWithRelationInput | t_ai_creditOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for t_ai_credits.
     */
    cursor?: t_ai_creditWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` t_ai_credits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` t_ai_credits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of t_ai_credits.
     */
    distinct?: T_ai_creditScalarFieldEnum | T_ai_creditScalarFieldEnum[]
  }

  /**
   * t_ai_credit findFirstOrThrow
   */
  export type t_ai_creditFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the t_ai_credit
     */
    select?: t_ai_creditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the t_ai_credit
     */
    omit?: t_ai_creditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: t_ai_creditInclude<ExtArgs> | null
    /**
     * Filter, which t_ai_credit to fetch.
     */
    where?: t_ai_creditWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of t_ai_credits to fetch.
     */
    orderBy?: t_ai_creditOrderByWithRelationInput | t_ai_creditOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for t_ai_credits.
     */
    cursor?: t_ai_creditWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` t_ai_credits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` t_ai_credits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of t_ai_credits.
     */
    distinct?: T_ai_creditScalarFieldEnum | T_ai_creditScalarFieldEnum[]
  }

  /**
   * t_ai_credit findMany
   */
  export type t_ai_creditFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the t_ai_credit
     */
    select?: t_ai_creditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the t_ai_credit
     */
    omit?: t_ai_creditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: t_ai_creditInclude<ExtArgs> | null
    /**
     * Filter, which t_ai_credits to fetch.
     */
    where?: t_ai_creditWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of t_ai_credits to fetch.
     */
    orderBy?: t_ai_creditOrderByWithRelationInput | t_ai_creditOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing t_ai_credits.
     */
    cursor?: t_ai_creditWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` t_ai_credits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` t_ai_credits.
     */
    skip?: number
    distinct?: T_ai_creditScalarFieldEnum | T_ai_creditScalarFieldEnum[]
  }

  /**
   * t_ai_credit create
   */
  export type t_ai_creditCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the t_ai_credit
     */
    select?: t_ai_creditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the t_ai_credit
     */
    omit?: t_ai_creditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: t_ai_creditInclude<ExtArgs> | null
    /**
     * The data needed to create a t_ai_credit.
     */
    data: XOR<t_ai_creditCreateInput, t_ai_creditUncheckedCreateInput>
  }

  /**
   * t_ai_credit createMany
   */
  export type t_ai_creditCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many t_ai_credits.
     */
    data: t_ai_creditCreateManyInput | t_ai_creditCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * t_ai_credit createManyAndReturn
   */
  export type t_ai_creditCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the t_ai_credit
     */
    select?: t_ai_creditSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the t_ai_credit
     */
    omit?: t_ai_creditOmit<ExtArgs> | null
    /**
     * The data used to create many t_ai_credits.
     */
    data: t_ai_creditCreateManyInput | t_ai_creditCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: t_ai_creditIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * t_ai_credit update
   */
  export type t_ai_creditUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the t_ai_credit
     */
    select?: t_ai_creditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the t_ai_credit
     */
    omit?: t_ai_creditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: t_ai_creditInclude<ExtArgs> | null
    /**
     * The data needed to update a t_ai_credit.
     */
    data: XOR<t_ai_creditUpdateInput, t_ai_creditUncheckedUpdateInput>
    /**
     * Choose, which t_ai_credit to update.
     */
    where: t_ai_creditWhereUniqueInput
  }

  /**
   * t_ai_credit updateMany
   */
  export type t_ai_creditUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update t_ai_credits.
     */
    data: XOR<t_ai_creditUpdateManyMutationInput, t_ai_creditUncheckedUpdateManyInput>
    /**
     * Filter which t_ai_credits to update
     */
    where?: t_ai_creditWhereInput
    /**
     * Limit how many t_ai_credits to update.
     */
    limit?: number
  }

  /**
   * t_ai_credit updateManyAndReturn
   */
  export type t_ai_creditUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the t_ai_credit
     */
    select?: t_ai_creditSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the t_ai_credit
     */
    omit?: t_ai_creditOmit<ExtArgs> | null
    /**
     * The data used to update t_ai_credits.
     */
    data: XOR<t_ai_creditUpdateManyMutationInput, t_ai_creditUncheckedUpdateManyInput>
    /**
     * Filter which t_ai_credits to update
     */
    where?: t_ai_creditWhereInput
    /**
     * Limit how many t_ai_credits to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: t_ai_creditIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * t_ai_credit upsert
   */
  export type t_ai_creditUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the t_ai_credit
     */
    select?: t_ai_creditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the t_ai_credit
     */
    omit?: t_ai_creditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: t_ai_creditInclude<ExtArgs> | null
    /**
     * The filter to search for the t_ai_credit to update in case it exists.
     */
    where: t_ai_creditWhereUniqueInput
    /**
     * In case the t_ai_credit found by the `where` argument doesn't exist, create a new t_ai_credit with this data.
     */
    create: XOR<t_ai_creditCreateInput, t_ai_creditUncheckedCreateInput>
    /**
     * In case the t_ai_credit was found with the provided `where` argument, update it with this data.
     */
    update: XOR<t_ai_creditUpdateInput, t_ai_creditUncheckedUpdateInput>
  }

  /**
   * t_ai_credit delete
   */
  export type t_ai_creditDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the t_ai_credit
     */
    select?: t_ai_creditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the t_ai_credit
     */
    omit?: t_ai_creditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: t_ai_creditInclude<ExtArgs> | null
    /**
     * Filter which t_ai_credit to delete.
     */
    where: t_ai_creditWhereUniqueInput
  }

  /**
   * t_ai_credit deleteMany
   */
  export type t_ai_creditDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which t_ai_credits to delete
     */
    where?: t_ai_creditWhereInput
    /**
     * Limit how many t_ai_credits to delete.
     */
    limit?: number
  }

  /**
   * t_ai_credit.t_ai_credit_topup
   */
  export type t_ai_credit$t_ai_credit_topupArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the t_ai_credit_topup
     */
    select?: t_ai_credit_topupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the t_ai_credit_topup
     */
    omit?: t_ai_credit_topupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: t_ai_credit_topupInclude<ExtArgs> | null
    where?: t_ai_credit_topupWhereInput
    orderBy?: t_ai_credit_topupOrderByWithRelationInput | t_ai_credit_topupOrderByWithRelationInput[]
    cursor?: t_ai_credit_topupWhereUniqueInput
    take?: number
    skip?: number
    distinct?: T_ai_credit_topupScalarFieldEnum | T_ai_credit_topupScalarFieldEnum[]
  }

  /**
   * t_ai_credit without action
   */
  export type t_ai_creditDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the t_ai_credit
     */
    select?: t_ai_creditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the t_ai_credit
     */
    omit?: t_ai_creditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: t_ai_creditInclude<ExtArgs> | null
  }


  /**
   * Model t_ai_credit_topup
   */

  export type AggregateT_ai_credit_topup = {
    _count: T_ai_credit_topupCountAggregateOutputType | null
    _avg: T_ai_credit_topupAvgAggregateOutputType | null
    _sum: T_ai_credit_topupSumAggregateOutputType | null
    _min: T_ai_credit_topupMinAggregateOutputType | null
    _max: T_ai_credit_topupMaxAggregateOutputType | null
  }

  export type T_ai_credit_topupAvgAggregateOutputType = {
    amount: number | null
  }

  export type T_ai_credit_topupSumAggregateOutputType = {
    amount: number | null
  }

  export type T_ai_credit_topupMinAggregateOutputType = {
    id: string | null
    id_t_ai_credit: string | null
    amount: number | null
    created_at: Date | null
    status: string | null
  }

  export type T_ai_credit_topupMaxAggregateOutputType = {
    id: string | null
    id_t_ai_credit: string | null
    amount: number | null
    created_at: Date | null
    status: string | null
  }

  export type T_ai_credit_topupCountAggregateOutputType = {
    id: number
    id_t_ai_credit: number
    amount: number
    created_at: number
    status: number
    _all: number
  }


  export type T_ai_credit_topupAvgAggregateInputType = {
    amount?: true
  }

  export type T_ai_credit_topupSumAggregateInputType = {
    amount?: true
  }

  export type T_ai_credit_topupMinAggregateInputType = {
    id?: true
    id_t_ai_credit?: true
    amount?: true
    created_at?: true
    status?: true
  }

  export type T_ai_credit_topupMaxAggregateInputType = {
    id?: true
    id_t_ai_credit?: true
    amount?: true
    created_at?: true
    status?: true
  }

  export type T_ai_credit_topupCountAggregateInputType = {
    id?: true
    id_t_ai_credit?: true
    amount?: true
    created_at?: true
    status?: true
    _all?: true
  }

  export type T_ai_credit_topupAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which t_ai_credit_topup to aggregate.
     */
    where?: t_ai_credit_topupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of t_ai_credit_topups to fetch.
     */
    orderBy?: t_ai_credit_topupOrderByWithRelationInput | t_ai_credit_topupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: t_ai_credit_topupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` t_ai_credit_topups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` t_ai_credit_topups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned t_ai_credit_topups
    **/
    _count?: true | T_ai_credit_topupCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: T_ai_credit_topupAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: T_ai_credit_topupSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: T_ai_credit_topupMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: T_ai_credit_topupMaxAggregateInputType
  }

  export type GetT_ai_credit_topupAggregateType<T extends T_ai_credit_topupAggregateArgs> = {
        [P in keyof T & keyof AggregateT_ai_credit_topup]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateT_ai_credit_topup[P]>
      : GetScalarType<T[P], AggregateT_ai_credit_topup[P]>
  }




  export type t_ai_credit_topupGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: t_ai_credit_topupWhereInput
    orderBy?: t_ai_credit_topupOrderByWithAggregationInput | t_ai_credit_topupOrderByWithAggregationInput[]
    by: T_ai_credit_topupScalarFieldEnum[] | T_ai_credit_topupScalarFieldEnum
    having?: t_ai_credit_topupScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: T_ai_credit_topupCountAggregateInputType | true
    _avg?: T_ai_credit_topupAvgAggregateInputType
    _sum?: T_ai_credit_topupSumAggregateInputType
    _min?: T_ai_credit_topupMinAggregateInputType
    _max?: T_ai_credit_topupMaxAggregateInputType
  }

  export type T_ai_credit_topupGroupByOutputType = {
    id: string
    id_t_ai_credit: string
    amount: number
    created_at: Date
    status: string
    _count: T_ai_credit_topupCountAggregateOutputType | null
    _avg: T_ai_credit_topupAvgAggregateOutputType | null
    _sum: T_ai_credit_topupSumAggregateOutputType | null
    _min: T_ai_credit_topupMinAggregateOutputType | null
    _max: T_ai_credit_topupMaxAggregateOutputType | null
  }

  type GetT_ai_credit_topupGroupByPayload<T extends t_ai_credit_topupGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<T_ai_credit_topupGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof T_ai_credit_topupGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], T_ai_credit_topupGroupByOutputType[P]>
            : GetScalarType<T[P], T_ai_credit_topupGroupByOutputType[P]>
        }
      >
    >


  export type t_ai_credit_topupSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    id_t_ai_credit?: boolean
    amount?: boolean
    created_at?: boolean
    status?: boolean
    t_ai_credit?: boolean | t_ai_creditDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["t_ai_credit_topup"]>

  export type t_ai_credit_topupSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    id_t_ai_credit?: boolean
    amount?: boolean
    created_at?: boolean
    status?: boolean
    t_ai_credit?: boolean | t_ai_creditDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["t_ai_credit_topup"]>

  export type t_ai_credit_topupSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    id_t_ai_credit?: boolean
    amount?: boolean
    created_at?: boolean
    status?: boolean
    t_ai_credit?: boolean | t_ai_creditDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["t_ai_credit_topup"]>

  export type t_ai_credit_topupSelectScalar = {
    id?: boolean
    id_t_ai_credit?: boolean
    amount?: boolean
    created_at?: boolean
    status?: boolean
  }

  export type t_ai_credit_topupOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "id_t_ai_credit" | "amount" | "created_at" | "status", ExtArgs["result"]["t_ai_credit_topup"]>
  export type t_ai_credit_topupInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    t_ai_credit?: boolean | t_ai_creditDefaultArgs<ExtArgs>
  }
  export type t_ai_credit_topupIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    t_ai_credit?: boolean | t_ai_creditDefaultArgs<ExtArgs>
  }
  export type t_ai_credit_topupIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    t_ai_credit?: boolean | t_ai_creditDefaultArgs<ExtArgs>
  }

  export type $t_ai_credit_topupPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "t_ai_credit_topup"
    objects: {
      t_ai_credit: Prisma.$t_ai_creditPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      id_t_ai_credit: string
      amount: number
      created_at: Date
      status: string
    }, ExtArgs["result"]["t_ai_credit_topup"]>
    composites: {}
  }

  type t_ai_credit_topupGetPayload<S extends boolean | null | undefined | t_ai_credit_topupDefaultArgs> = $Result.GetResult<Prisma.$t_ai_credit_topupPayload, S>

  type t_ai_credit_topupCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<t_ai_credit_topupFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: T_ai_credit_topupCountAggregateInputType | true
    }

  export interface t_ai_credit_topupDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['t_ai_credit_topup'], meta: { name: 't_ai_credit_topup' } }
    /**
     * Find zero or one T_ai_credit_topup that matches the filter.
     * @param {t_ai_credit_topupFindUniqueArgs} args - Arguments to find a T_ai_credit_topup
     * @example
     * // Get one T_ai_credit_topup
     * const t_ai_credit_topup = await prisma.t_ai_credit_topup.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends t_ai_credit_topupFindUniqueArgs>(args: SelectSubset<T, t_ai_credit_topupFindUniqueArgs<ExtArgs>>): Prisma__t_ai_credit_topupClient<$Result.GetResult<Prisma.$t_ai_credit_topupPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one T_ai_credit_topup that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {t_ai_credit_topupFindUniqueOrThrowArgs} args - Arguments to find a T_ai_credit_topup
     * @example
     * // Get one T_ai_credit_topup
     * const t_ai_credit_topup = await prisma.t_ai_credit_topup.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends t_ai_credit_topupFindUniqueOrThrowArgs>(args: SelectSubset<T, t_ai_credit_topupFindUniqueOrThrowArgs<ExtArgs>>): Prisma__t_ai_credit_topupClient<$Result.GetResult<Prisma.$t_ai_credit_topupPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first T_ai_credit_topup that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {t_ai_credit_topupFindFirstArgs} args - Arguments to find a T_ai_credit_topup
     * @example
     * // Get one T_ai_credit_topup
     * const t_ai_credit_topup = await prisma.t_ai_credit_topup.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends t_ai_credit_topupFindFirstArgs>(args?: SelectSubset<T, t_ai_credit_topupFindFirstArgs<ExtArgs>>): Prisma__t_ai_credit_topupClient<$Result.GetResult<Prisma.$t_ai_credit_topupPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first T_ai_credit_topup that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {t_ai_credit_topupFindFirstOrThrowArgs} args - Arguments to find a T_ai_credit_topup
     * @example
     * // Get one T_ai_credit_topup
     * const t_ai_credit_topup = await prisma.t_ai_credit_topup.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends t_ai_credit_topupFindFirstOrThrowArgs>(args?: SelectSubset<T, t_ai_credit_topupFindFirstOrThrowArgs<ExtArgs>>): Prisma__t_ai_credit_topupClient<$Result.GetResult<Prisma.$t_ai_credit_topupPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more T_ai_credit_topups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {t_ai_credit_topupFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all T_ai_credit_topups
     * const t_ai_credit_topups = await prisma.t_ai_credit_topup.findMany()
     * 
     * // Get first 10 T_ai_credit_topups
     * const t_ai_credit_topups = await prisma.t_ai_credit_topup.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const t_ai_credit_topupWithIdOnly = await prisma.t_ai_credit_topup.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends t_ai_credit_topupFindManyArgs>(args?: SelectSubset<T, t_ai_credit_topupFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$t_ai_credit_topupPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a T_ai_credit_topup.
     * @param {t_ai_credit_topupCreateArgs} args - Arguments to create a T_ai_credit_topup.
     * @example
     * // Create one T_ai_credit_topup
     * const T_ai_credit_topup = await prisma.t_ai_credit_topup.create({
     *   data: {
     *     // ... data to create a T_ai_credit_topup
     *   }
     * })
     * 
     */
    create<T extends t_ai_credit_topupCreateArgs>(args: SelectSubset<T, t_ai_credit_topupCreateArgs<ExtArgs>>): Prisma__t_ai_credit_topupClient<$Result.GetResult<Prisma.$t_ai_credit_topupPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many T_ai_credit_topups.
     * @param {t_ai_credit_topupCreateManyArgs} args - Arguments to create many T_ai_credit_topups.
     * @example
     * // Create many T_ai_credit_topups
     * const t_ai_credit_topup = await prisma.t_ai_credit_topup.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends t_ai_credit_topupCreateManyArgs>(args?: SelectSubset<T, t_ai_credit_topupCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many T_ai_credit_topups and returns the data saved in the database.
     * @param {t_ai_credit_topupCreateManyAndReturnArgs} args - Arguments to create many T_ai_credit_topups.
     * @example
     * // Create many T_ai_credit_topups
     * const t_ai_credit_topup = await prisma.t_ai_credit_topup.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many T_ai_credit_topups and only return the `id`
     * const t_ai_credit_topupWithIdOnly = await prisma.t_ai_credit_topup.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends t_ai_credit_topupCreateManyAndReturnArgs>(args?: SelectSubset<T, t_ai_credit_topupCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$t_ai_credit_topupPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a T_ai_credit_topup.
     * @param {t_ai_credit_topupDeleteArgs} args - Arguments to delete one T_ai_credit_topup.
     * @example
     * // Delete one T_ai_credit_topup
     * const T_ai_credit_topup = await prisma.t_ai_credit_topup.delete({
     *   where: {
     *     // ... filter to delete one T_ai_credit_topup
     *   }
     * })
     * 
     */
    delete<T extends t_ai_credit_topupDeleteArgs>(args: SelectSubset<T, t_ai_credit_topupDeleteArgs<ExtArgs>>): Prisma__t_ai_credit_topupClient<$Result.GetResult<Prisma.$t_ai_credit_topupPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one T_ai_credit_topup.
     * @param {t_ai_credit_topupUpdateArgs} args - Arguments to update one T_ai_credit_topup.
     * @example
     * // Update one T_ai_credit_topup
     * const t_ai_credit_topup = await prisma.t_ai_credit_topup.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends t_ai_credit_topupUpdateArgs>(args: SelectSubset<T, t_ai_credit_topupUpdateArgs<ExtArgs>>): Prisma__t_ai_credit_topupClient<$Result.GetResult<Prisma.$t_ai_credit_topupPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more T_ai_credit_topups.
     * @param {t_ai_credit_topupDeleteManyArgs} args - Arguments to filter T_ai_credit_topups to delete.
     * @example
     * // Delete a few T_ai_credit_topups
     * const { count } = await prisma.t_ai_credit_topup.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends t_ai_credit_topupDeleteManyArgs>(args?: SelectSubset<T, t_ai_credit_topupDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more T_ai_credit_topups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {t_ai_credit_topupUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many T_ai_credit_topups
     * const t_ai_credit_topup = await prisma.t_ai_credit_topup.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends t_ai_credit_topupUpdateManyArgs>(args: SelectSubset<T, t_ai_credit_topupUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more T_ai_credit_topups and returns the data updated in the database.
     * @param {t_ai_credit_topupUpdateManyAndReturnArgs} args - Arguments to update many T_ai_credit_topups.
     * @example
     * // Update many T_ai_credit_topups
     * const t_ai_credit_topup = await prisma.t_ai_credit_topup.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more T_ai_credit_topups and only return the `id`
     * const t_ai_credit_topupWithIdOnly = await prisma.t_ai_credit_topup.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends t_ai_credit_topupUpdateManyAndReturnArgs>(args: SelectSubset<T, t_ai_credit_topupUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$t_ai_credit_topupPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one T_ai_credit_topup.
     * @param {t_ai_credit_topupUpsertArgs} args - Arguments to update or create a T_ai_credit_topup.
     * @example
     * // Update or create a T_ai_credit_topup
     * const t_ai_credit_topup = await prisma.t_ai_credit_topup.upsert({
     *   create: {
     *     // ... data to create a T_ai_credit_topup
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the T_ai_credit_topup we want to update
     *   }
     * })
     */
    upsert<T extends t_ai_credit_topupUpsertArgs>(args: SelectSubset<T, t_ai_credit_topupUpsertArgs<ExtArgs>>): Prisma__t_ai_credit_topupClient<$Result.GetResult<Prisma.$t_ai_credit_topupPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of T_ai_credit_topups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {t_ai_credit_topupCountArgs} args - Arguments to filter T_ai_credit_topups to count.
     * @example
     * // Count the number of T_ai_credit_topups
     * const count = await prisma.t_ai_credit_topup.count({
     *   where: {
     *     // ... the filter for the T_ai_credit_topups we want to count
     *   }
     * })
    **/
    count<T extends t_ai_credit_topupCountArgs>(
      args?: Subset<T, t_ai_credit_topupCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], T_ai_credit_topupCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a T_ai_credit_topup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {T_ai_credit_topupAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends T_ai_credit_topupAggregateArgs>(args: Subset<T, T_ai_credit_topupAggregateArgs>): Prisma.PrismaPromise<GetT_ai_credit_topupAggregateType<T>>

    /**
     * Group by T_ai_credit_topup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {t_ai_credit_topupGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends t_ai_credit_topupGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: t_ai_credit_topupGroupByArgs['orderBy'] }
        : { orderBy?: t_ai_credit_topupGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, t_ai_credit_topupGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetT_ai_credit_topupGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the t_ai_credit_topup model
   */
  readonly fields: t_ai_credit_topupFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for t_ai_credit_topup.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__t_ai_credit_topupClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    t_ai_credit<T extends t_ai_creditDefaultArgs<ExtArgs> = {}>(args?: Subset<T, t_ai_creditDefaultArgs<ExtArgs>>): Prisma__t_ai_creditClient<$Result.GetResult<Prisma.$t_ai_creditPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the t_ai_credit_topup model
   */
  interface t_ai_credit_topupFieldRefs {
    readonly id: FieldRef<"t_ai_credit_topup", 'String'>
    readonly id_t_ai_credit: FieldRef<"t_ai_credit_topup", 'String'>
    readonly amount: FieldRef<"t_ai_credit_topup", 'Int'>
    readonly created_at: FieldRef<"t_ai_credit_topup", 'DateTime'>
    readonly status: FieldRef<"t_ai_credit_topup", 'String'>
  }
    

  // Custom InputTypes
  /**
   * t_ai_credit_topup findUnique
   */
  export type t_ai_credit_topupFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the t_ai_credit_topup
     */
    select?: t_ai_credit_topupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the t_ai_credit_topup
     */
    omit?: t_ai_credit_topupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: t_ai_credit_topupInclude<ExtArgs> | null
    /**
     * Filter, which t_ai_credit_topup to fetch.
     */
    where: t_ai_credit_topupWhereUniqueInput
  }

  /**
   * t_ai_credit_topup findUniqueOrThrow
   */
  export type t_ai_credit_topupFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the t_ai_credit_topup
     */
    select?: t_ai_credit_topupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the t_ai_credit_topup
     */
    omit?: t_ai_credit_topupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: t_ai_credit_topupInclude<ExtArgs> | null
    /**
     * Filter, which t_ai_credit_topup to fetch.
     */
    where: t_ai_credit_topupWhereUniqueInput
  }

  /**
   * t_ai_credit_topup findFirst
   */
  export type t_ai_credit_topupFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the t_ai_credit_topup
     */
    select?: t_ai_credit_topupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the t_ai_credit_topup
     */
    omit?: t_ai_credit_topupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: t_ai_credit_topupInclude<ExtArgs> | null
    /**
     * Filter, which t_ai_credit_topup to fetch.
     */
    where?: t_ai_credit_topupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of t_ai_credit_topups to fetch.
     */
    orderBy?: t_ai_credit_topupOrderByWithRelationInput | t_ai_credit_topupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for t_ai_credit_topups.
     */
    cursor?: t_ai_credit_topupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` t_ai_credit_topups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` t_ai_credit_topups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of t_ai_credit_topups.
     */
    distinct?: T_ai_credit_topupScalarFieldEnum | T_ai_credit_topupScalarFieldEnum[]
  }

  /**
   * t_ai_credit_topup findFirstOrThrow
   */
  export type t_ai_credit_topupFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the t_ai_credit_topup
     */
    select?: t_ai_credit_topupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the t_ai_credit_topup
     */
    omit?: t_ai_credit_topupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: t_ai_credit_topupInclude<ExtArgs> | null
    /**
     * Filter, which t_ai_credit_topup to fetch.
     */
    where?: t_ai_credit_topupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of t_ai_credit_topups to fetch.
     */
    orderBy?: t_ai_credit_topupOrderByWithRelationInput | t_ai_credit_topupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for t_ai_credit_topups.
     */
    cursor?: t_ai_credit_topupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` t_ai_credit_topups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` t_ai_credit_topups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of t_ai_credit_topups.
     */
    distinct?: T_ai_credit_topupScalarFieldEnum | T_ai_credit_topupScalarFieldEnum[]
  }

  /**
   * t_ai_credit_topup findMany
   */
  export type t_ai_credit_topupFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the t_ai_credit_topup
     */
    select?: t_ai_credit_topupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the t_ai_credit_topup
     */
    omit?: t_ai_credit_topupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: t_ai_credit_topupInclude<ExtArgs> | null
    /**
     * Filter, which t_ai_credit_topups to fetch.
     */
    where?: t_ai_credit_topupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of t_ai_credit_topups to fetch.
     */
    orderBy?: t_ai_credit_topupOrderByWithRelationInput | t_ai_credit_topupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing t_ai_credit_topups.
     */
    cursor?: t_ai_credit_topupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` t_ai_credit_topups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` t_ai_credit_topups.
     */
    skip?: number
    distinct?: T_ai_credit_topupScalarFieldEnum | T_ai_credit_topupScalarFieldEnum[]
  }

  /**
   * t_ai_credit_topup create
   */
  export type t_ai_credit_topupCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the t_ai_credit_topup
     */
    select?: t_ai_credit_topupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the t_ai_credit_topup
     */
    omit?: t_ai_credit_topupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: t_ai_credit_topupInclude<ExtArgs> | null
    /**
     * The data needed to create a t_ai_credit_topup.
     */
    data: XOR<t_ai_credit_topupCreateInput, t_ai_credit_topupUncheckedCreateInput>
  }

  /**
   * t_ai_credit_topup createMany
   */
  export type t_ai_credit_topupCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many t_ai_credit_topups.
     */
    data: t_ai_credit_topupCreateManyInput | t_ai_credit_topupCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * t_ai_credit_topup createManyAndReturn
   */
  export type t_ai_credit_topupCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the t_ai_credit_topup
     */
    select?: t_ai_credit_topupSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the t_ai_credit_topup
     */
    omit?: t_ai_credit_topupOmit<ExtArgs> | null
    /**
     * The data used to create many t_ai_credit_topups.
     */
    data: t_ai_credit_topupCreateManyInput | t_ai_credit_topupCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: t_ai_credit_topupIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * t_ai_credit_topup update
   */
  export type t_ai_credit_topupUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the t_ai_credit_topup
     */
    select?: t_ai_credit_topupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the t_ai_credit_topup
     */
    omit?: t_ai_credit_topupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: t_ai_credit_topupInclude<ExtArgs> | null
    /**
     * The data needed to update a t_ai_credit_topup.
     */
    data: XOR<t_ai_credit_topupUpdateInput, t_ai_credit_topupUncheckedUpdateInput>
    /**
     * Choose, which t_ai_credit_topup to update.
     */
    where: t_ai_credit_topupWhereUniqueInput
  }

  /**
   * t_ai_credit_topup updateMany
   */
  export type t_ai_credit_topupUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update t_ai_credit_topups.
     */
    data: XOR<t_ai_credit_topupUpdateManyMutationInput, t_ai_credit_topupUncheckedUpdateManyInput>
    /**
     * Filter which t_ai_credit_topups to update
     */
    where?: t_ai_credit_topupWhereInput
    /**
     * Limit how many t_ai_credit_topups to update.
     */
    limit?: number
  }

  /**
   * t_ai_credit_topup updateManyAndReturn
   */
  export type t_ai_credit_topupUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the t_ai_credit_topup
     */
    select?: t_ai_credit_topupSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the t_ai_credit_topup
     */
    omit?: t_ai_credit_topupOmit<ExtArgs> | null
    /**
     * The data used to update t_ai_credit_topups.
     */
    data: XOR<t_ai_credit_topupUpdateManyMutationInput, t_ai_credit_topupUncheckedUpdateManyInput>
    /**
     * Filter which t_ai_credit_topups to update
     */
    where?: t_ai_credit_topupWhereInput
    /**
     * Limit how many t_ai_credit_topups to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: t_ai_credit_topupIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * t_ai_credit_topup upsert
   */
  export type t_ai_credit_topupUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the t_ai_credit_topup
     */
    select?: t_ai_credit_topupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the t_ai_credit_topup
     */
    omit?: t_ai_credit_topupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: t_ai_credit_topupInclude<ExtArgs> | null
    /**
     * The filter to search for the t_ai_credit_topup to update in case it exists.
     */
    where: t_ai_credit_topupWhereUniqueInput
    /**
     * In case the t_ai_credit_topup found by the `where` argument doesn't exist, create a new t_ai_credit_topup with this data.
     */
    create: XOR<t_ai_credit_topupCreateInput, t_ai_credit_topupUncheckedCreateInput>
    /**
     * In case the t_ai_credit_topup was found with the provided `where` argument, update it with this data.
     */
    update: XOR<t_ai_credit_topupUpdateInput, t_ai_credit_topupUncheckedUpdateInput>
  }

  /**
   * t_ai_credit_topup delete
   */
  export type t_ai_credit_topupDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the t_ai_credit_topup
     */
    select?: t_ai_credit_topupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the t_ai_credit_topup
     */
    omit?: t_ai_credit_topupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: t_ai_credit_topupInclude<ExtArgs> | null
    /**
     * Filter which t_ai_credit_topup to delete.
     */
    where: t_ai_credit_topupWhereUniqueInput
  }

  /**
   * t_ai_credit_topup deleteMany
   */
  export type t_ai_credit_topupDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which t_ai_credit_topups to delete
     */
    where?: t_ai_credit_topupWhereInput
    /**
     * Limit how many t_ai_credit_topups to delete.
     */
    limit?: number
  }

  /**
   * t_ai_credit_topup without action
   */
  export type t_ai_credit_topupDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the t_ai_credit_topup
     */
    select?: t_ai_credit_topupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the t_ai_credit_topup
     */
    omit?: t_ai_credit_topupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: t_ai_credit_topupInclude<ExtArgs> | null
  }


  /**
   * Model t_sales
   */

  export type AggregateT_sales = {
    _count: T_salesCountAggregateOutputType | null
    _avg: T_salesAvgAggregateOutputType | null
    _sum: T_salesSumAggregateOutputType | null
    _min: T_salesMinAggregateOutputType | null
    _max: T_salesMaxAggregateOutputType | null
  }

  export type T_salesAvgAggregateOutputType = {
    total: Decimal | null
  }

  export type T_salesSumAggregateOutputType = {
    total: Decimal | null
  }

  export type T_salesMinAggregateOutputType = {
    id: string | null
    id_customer: string | null
    status: string | null
    total: Decimal | null
    currency: string | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
    midtrans_order_id: string | null
  }

  export type T_salesMaxAggregateOutputType = {
    id: string | null
    id_customer: string | null
    status: string | null
    total: Decimal | null
    currency: string | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
    midtrans_order_id: string | null
  }

  export type T_salesCountAggregateOutputType = {
    id: number
    id_customer: number
    status: number
    total: number
    currency: number
    info: number
    created_at: number
    updated_at: number
    deleted_at: number
    midtrans_order_id: number
    midtrans_success: number
    midtrans_pending: number
    midtrans_error: number
    _all: number
  }


  export type T_salesAvgAggregateInputType = {
    total?: true
  }

  export type T_salesSumAggregateInputType = {
    total?: true
  }

  export type T_salesMinAggregateInputType = {
    id?: true
    id_customer?: true
    status?: true
    total?: true
    currency?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    midtrans_order_id?: true
  }

  export type T_salesMaxAggregateInputType = {
    id?: true
    id_customer?: true
    status?: true
    total?: true
    currency?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    midtrans_order_id?: true
  }

  export type T_salesCountAggregateInputType = {
    id?: true
    id_customer?: true
    status?: true
    total?: true
    currency?: true
    info?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    midtrans_order_id?: true
    midtrans_success?: true
    midtrans_pending?: true
    midtrans_error?: true
    _all?: true
  }

  export type T_salesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which t_sales to aggregate.
     */
    where?: t_salesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of t_sales to fetch.
     */
    orderBy?: t_salesOrderByWithRelationInput | t_salesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: t_salesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` t_sales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` t_sales.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned t_sales
    **/
    _count?: true | T_salesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: T_salesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: T_salesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: T_salesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: T_salesMaxAggregateInputType
  }

  export type GetT_salesAggregateType<T extends T_salesAggregateArgs> = {
        [P in keyof T & keyof AggregateT_sales]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateT_sales[P]>
      : GetScalarType<T[P], AggregateT_sales[P]>
  }




  export type t_salesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: t_salesWhereInput
    orderBy?: t_salesOrderByWithAggregationInput | t_salesOrderByWithAggregationInput[]
    by: T_salesScalarFieldEnum[] | T_salesScalarFieldEnum
    having?: t_salesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: T_salesCountAggregateInputType | true
    _avg?: T_salesAvgAggregateInputType
    _sum?: T_salesSumAggregateInputType
    _min?: T_salesMinAggregateInputType
    _max?: T_salesMaxAggregateInputType
  }

  export type T_salesGroupByOutputType = {
    id: string
    id_customer: string
    status: string
    total: Decimal
    currency: string
    info: JsonValue
    created_at: Date
    updated_at: Date | null
    deleted_at: Date | null
    midtrans_order_id: string
    midtrans_success: JsonValue | null
    midtrans_pending: JsonValue | null
    midtrans_error: JsonValue | null
    _count: T_salesCountAggregateOutputType | null
    _avg: T_salesAvgAggregateOutputType | null
    _sum: T_salesSumAggregateOutputType | null
    _min: T_salesMinAggregateOutputType | null
    _max: T_salesMaxAggregateOutputType | null
  }

  type GetT_salesGroupByPayload<T extends t_salesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<T_salesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof T_salesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], T_salesGroupByOutputType[P]>
            : GetScalarType<T[P], T_salesGroupByOutputType[P]>
        }
      >
    >


  export type t_salesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    id_customer?: boolean
    status?: boolean
    total?: boolean
    currency?: boolean
    info?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    midtrans_order_id?: boolean
    midtrans_success?: boolean
    midtrans_pending?: boolean
    midtrans_error?: boolean
    customer?: boolean | customerDefaultArgs<ExtArgs>
    t_sales_line?: boolean | t_sales$t_sales_lineArgs<ExtArgs>
    _count?: boolean | T_salesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["t_sales"]>

  export type t_salesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    id_customer?: boolean
    status?: boolean
    total?: boolean
    currency?: boolean
    info?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    midtrans_order_id?: boolean
    midtrans_success?: boolean
    midtrans_pending?: boolean
    midtrans_error?: boolean
    customer?: boolean | customerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["t_sales"]>

  export type t_salesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    id_customer?: boolean
    status?: boolean
    total?: boolean
    currency?: boolean
    info?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    midtrans_order_id?: boolean
    midtrans_success?: boolean
    midtrans_pending?: boolean
    midtrans_error?: boolean
    customer?: boolean | customerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["t_sales"]>

  export type t_salesSelectScalar = {
    id?: boolean
    id_customer?: boolean
    status?: boolean
    total?: boolean
    currency?: boolean
    info?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    midtrans_order_id?: boolean
    midtrans_success?: boolean
    midtrans_pending?: boolean
    midtrans_error?: boolean
  }

  export type t_salesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "id_customer" | "status" | "total" | "currency" | "info" | "created_at" | "updated_at" | "deleted_at" | "midtrans_order_id" | "midtrans_success" | "midtrans_pending" | "midtrans_error", ExtArgs["result"]["t_sales"]>
  export type t_salesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | customerDefaultArgs<ExtArgs>
    t_sales_line?: boolean | t_sales$t_sales_lineArgs<ExtArgs>
    _count?: boolean | T_salesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type t_salesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | customerDefaultArgs<ExtArgs>
  }
  export type t_salesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | customerDefaultArgs<ExtArgs>
  }

  export type $t_salesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "t_sales"
    objects: {
      customer: Prisma.$customerPayload<ExtArgs>
      t_sales_line: Prisma.$t_sales_linePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      id_customer: string
      status: string
      total: Prisma.Decimal
      currency: string
      info: Prisma.JsonValue
      created_at: Date
      updated_at: Date | null
      deleted_at: Date | null
      midtrans_order_id: string
      midtrans_success: Prisma.JsonValue | null
      midtrans_pending: Prisma.JsonValue | null
      midtrans_error: Prisma.JsonValue | null
    }, ExtArgs["result"]["t_sales"]>
    composites: {}
  }

  type t_salesGetPayload<S extends boolean | null | undefined | t_salesDefaultArgs> = $Result.GetResult<Prisma.$t_salesPayload, S>

  type t_salesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<t_salesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: T_salesCountAggregateInputType | true
    }

  export interface t_salesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['t_sales'], meta: { name: 't_sales' } }
    /**
     * Find zero or one T_sales that matches the filter.
     * @param {t_salesFindUniqueArgs} args - Arguments to find a T_sales
     * @example
     * // Get one T_sales
     * const t_sales = await prisma.t_sales.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends t_salesFindUniqueArgs>(args: SelectSubset<T, t_salesFindUniqueArgs<ExtArgs>>): Prisma__t_salesClient<$Result.GetResult<Prisma.$t_salesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one T_sales that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {t_salesFindUniqueOrThrowArgs} args - Arguments to find a T_sales
     * @example
     * // Get one T_sales
     * const t_sales = await prisma.t_sales.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends t_salesFindUniqueOrThrowArgs>(args: SelectSubset<T, t_salesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__t_salesClient<$Result.GetResult<Prisma.$t_salesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first T_sales that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {t_salesFindFirstArgs} args - Arguments to find a T_sales
     * @example
     * // Get one T_sales
     * const t_sales = await prisma.t_sales.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends t_salesFindFirstArgs>(args?: SelectSubset<T, t_salesFindFirstArgs<ExtArgs>>): Prisma__t_salesClient<$Result.GetResult<Prisma.$t_salesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first T_sales that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {t_salesFindFirstOrThrowArgs} args - Arguments to find a T_sales
     * @example
     * // Get one T_sales
     * const t_sales = await prisma.t_sales.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends t_salesFindFirstOrThrowArgs>(args?: SelectSubset<T, t_salesFindFirstOrThrowArgs<ExtArgs>>): Prisma__t_salesClient<$Result.GetResult<Prisma.$t_salesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more T_sales that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {t_salesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all T_sales
     * const t_sales = await prisma.t_sales.findMany()
     * 
     * // Get first 10 T_sales
     * const t_sales = await prisma.t_sales.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const t_salesWithIdOnly = await prisma.t_sales.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends t_salesFindManyArgs>(args?: SelectSubset<T, t_salesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$t_salesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a T_sales.
     * @param {t_salesCreateArgs} args - Arguments to create a T_sales.
     * @example
     * // Create one T_sales
     * const T_sales = await prisma.t_sales.create({
     *   data: {
     *     // ... data to create a T_sales
     *   }
     * })
     * 
     */
    create<T extends t_salesCreateArgs>(args: SelectSubset<T, t_salesCreateArgs<ExtArgs>>): Prisma__t_salesClient<$Result.GetResult<Prisma.$t_salesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many T_sales.
     * @param {t_salesCreateManyArgs} args - Arguments to create many T_sales.
     * @example
     * // Create many T_sales
     * const t_sales = await prisma.t_sales.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends t_salesCreateManyArgs>(args?: SelectSubset<T, t_salesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many T_sales and returns the data saved in the database.
     * @param {t_salesCreateManyAndReturnArgs} args - Arguments to create many T_sales.
     * @example
     * // Create many T_sales
     * const t_sales = await prisma.t_sales.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many T_sales and only return the `id`
     * const t_salesWithIdOnly = await prisma.t_sales.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends t_salesCreateManyAndReturnArgs>(args?: SelectSubset<T, t_salesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$t_salesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a T_sales.
     * @param {t_salesDeleteArgs} args - Arguments to delete one T_sales.
     * @example
     * // Delete one T_sales
     * const T_sales = await prisma.t_sales.delete({
     *   where: {
     *     // ... filter to delete one T_sales
     *   }
     * })
     * 
     */
    delete<T extends t_salesDeleteArgs>(args: SelectSubset<T, t_salesDeleteArgs<ExtArgs>>): Prisma__t_salesClient<$Result.GetResult<Prisma.$t_salesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one T_sales.
     * @param {t_salesUpdateArgs} args - Arguments to update one T_sales.
     * @example
     * // Update one T_sales
     * const t_sales = await prisma.t_sales.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends t_salesUpdateArgs>(args: SelectSubset<T, t_salesUpdateArgs<ExtArgs>>): Prisma__t_salesClient<$Result.GetResult<Prisma.$t_salesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more T_sales.
     * @param {t_salesDeleteManyArgs} args - Arguments to filter T_sales to delete.
     * @example
     * // Delete a few T_sales
     * const { count } = await prisma.t_sales.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends t_salesDeleteManyArgs>(args?: SelectSubset<T, t_salesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more T_sales.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {t_salesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many T_sales
     * const t_sales = await prisma.t_sales.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends t_salesUpdateManyArgs>(args: SelectSubset<T, t_salesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more T_sales and returns the data updated in the database.
     * @param {t_salesUpdateManyAndReturnArgs} args - Arguments to update many T_sales.
     * @example
     * // Update many T_sales
     * const t_sales = await prisma.t_sales.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more T_sales and only return the `id`
     * const t_salesWithIdOnly = await prisma.t_sales.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends t_salesUpdateManyAndReturnArgs>(args: SelectSubset<T, t_salesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$t_salesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one T_sales.
     * @param {t_salesUpsertArgs} args - Arguments to update or create a T_sales.
     * @example
     * // Update or create a T_sales
     * const t_sales = await prisma.t_sales.upsert({
     *   create: {
     *     // ... data to create a T_sales
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the T_sales we want to update
     *   }
     * })
     */
    upsert<T extends t_salesUpsertArgs>(args: SelectSubset<T, t_salesUpsertArgs<ExtArgs>>): Prisma__t_salesClient<$Result.GetResult<Prisma.$t_salesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of T_sales.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {t_salesCountArgs} args - Arguments to filter T_sales to count.
     * @example
     * // Count the number of T_sales
     * const count = await prisma.t_sales.count({
     *   where: {
     *     // ... the filter for the T_sales we want to count
     *   }
     * })
    **/
    count<T extends t_salesCountArgs>(
      args?: Subset<T, t_salesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], T_salesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a T_sales.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {T_salesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends T_salesAggregateArgs>(args: Subset<T, T_salesAggregateArgs>): Prisma.PrismaPromise<GetT_salesAggregateType<T>>

    /**
     * Group by T_sales.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {t_salesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends t_salesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: t_salesGroupByArgs['orderBy'] }
        : { orderBy?: t_salesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, t_salesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetT_salesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the t_sales model
   */
  readonly fields: t_salesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for t_sales.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__t_salesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    customer<T extends customerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, customerDefaultArgs<ExtArgs>>): Prisma__customerClient<$Result.GetResult<Prisma.$customerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    t_sales_line<T extends t_sales$t_sales_lineArgs<ExtArgs> = {}>(args?: Subset<T, t_sales$t_sales_lineArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$t_sales_linePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the t_sales model
   */
  interface t_salesFieldRefs {
    readonly id: FieldRef<"t_sales", 'String'>
    readonly id_customer: FieldRef<"t_sales", 'String'>
    readonly status: FieldRef<"t_sales", 'String'>
    readonly total: FieldRef<"t_sales", 'Decimal'>
    readonly currency: FieldRef<"t_sales", 'String'>
    readonly info: FieldRef<"t_sales", 'Json'>
    readonly created_at: FieldRef<"t_sales", 'DateTime'>
    readonly updated_at: FieldRef<"t_sales", 'DateTime'>
    readonly deleted_at: FieldRef<"t_sales", 'DateTime'>
    readonly midtrans_order_id: FieldRef<"t_sales", 'String'>
    readonly midtrans_success: FieldRef<"t_sales", 'Json'>
    readonly midtrans_pending: FieldRef<"t_sales", 'Json'>
    readonly midtrans_error: FieldRef<"t_sales", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * t_sales findUnique
   */
  export type t_salesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the t_sales
     */
    select?: t_salesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the t_sales
     */
    omit?: t_salesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: t_salesInclude<ExtArgs> | null
    /**
     * Filter, which t_sales to fetch.
     */
    where: t_salesWhereUniqueInput
  }

  /**
   * t_sales findUniqueOrThrow
   */
  export type t_salesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the t_sales
     */
    select?: t_salesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the t_sales
     */
    omit?: t_salesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: t_salesInclude<ExtArgs> | null
    /**
     * Filter, which t_sales to fetch.
     */
    where: t_salesWhereUniqueInput
  }

  /**
   * t_sales findFirst
   */
  export type t_salesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the t_sales
     */
    select?: t_salesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the t_sales
     */
    omit?: t_salesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: t_salesInclude<ExtArgs> | null
    /**
     * Filter, which t_sales to fetch.
     */
    where?: t_salesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of t_sales to fetch.
     */
    orderBy?: t_salesOrderByWithRelationInput | t_salesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for t_sales.
     */
    cursor?: t_salesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` t_sales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` t_sales.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of t_sales.
     */
    distinct?: T_salesScalarFieldEnum | T_salesScalarFieldEnum[]
  }

  /**
   * t_sales findFirstOrThrow
   */
  export type t_salesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the t_sales
     */
    select?: t_salesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the t_sales
     */
    omit?: t_salesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: t_salesInclude<ExtArgs> | null
    /**
     * Filter, which t_sales to fetch.
     */
    where?: t_salesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of t_sales to fetch.
     */
    orderBy?: t_salesOrderByWithRelationInput | t_salesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for t_sales.
     */
    cursor?: t_salesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` t_sales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` t_sales.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of t_sales.
     */
    distinct?: T_salesScalarFieldEnum | T_salesScalarFieldEnum[]
  }

  /**
   * t_sales findMany
   */
  export type t_salesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the t_sales
     */
    select?: t_salesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the t_sales
     */
    omit?: t_salesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: t_salesInclude<ExtArgs> | null
    /**
     * Filter, which t_sales to fetch.
     */
    where?: t_salesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of t_sales to fetch.
     */
    orderBy?: t_salesOrderByWithRelationInput | t_salesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing t_sales.
     */
    cursor?: t_salesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` t_sales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` t_sales.
     */
    skip?: number
    distinct?: T_salesScalarFieldEnum | T_salesScalarFieldEnum[]
  }

  /**
   * t_sales create
   */
  export type t_salesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the t_sales
     */
    select?: t_salesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the t_sales
     */
    omit?: t_salesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: t_salesInclude<ExtArgs> | null
    /**
     * The data needed to create a t_sales.
     */
    data: XOR<t_salesCreateInput, t_salesUncheckedCreateInput>
  }

  /**
   * t_sales createMany
   */
  export type t_salesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many t_sales.
     */
    data: t_salesCreateManyInput | t_salesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * t_sales createManyAndReturn
   */
  export type t_salesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the t_sales
     */
    select?: t_salesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the t_sales
     */
    omit?: t_salesOmit<ExtArgs> | null
    /**
     * The data used to create many t_sales.
     */
    data: t_salesCreateManyInput | t_salesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: t_salesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * t_sales update
   */
  export type t_salesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the t_sales
     */
    select?: t_salesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the t_sales
     */
    omit?: t_salesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: t_salesInclude<ExtArgs> | null
    /**
     * The data needed to update a t_sales.
     */
    data: XOR<t_salesUpdateInput, t_salesUncheckedUpdateInput>
    /**
     * Choose, which t_sales to update.
     */
    where: t_salesWhereUniqueInput
  }

  /**
   * t_sales updateMany
   */
  export type t_salesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update t_sales.
     */
    data: XOR<t_salesUpdateManyMutationInput, t_salesUncheckedUpdateManyInput>
    /**
     * Filter which t_sales to update
     */
    where?: t_salesWhereInput
    /**
     * Limit how many t_sales to update.
     */
    limit?: number
  }

  /**
   * t_sales updateManyAndReturn
   */
  export type t_salesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the t_sales
     */
    select?: t_salesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the t_sales
     */
    omit?: t_salesOmit<ExtArgs> | null
    /**
     * The data used to update t_sales.
     */
    data: XOR<t_salesUpdateManyMutationInput, t_salesUncheckedUpdateManyInput>
    /**
     * Filter which t_sales to update
     */
    where?: t_salesWhereInput
    /**
     * Limit how many t_sales to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: t_salesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * t_sales upsert
   */
  export type t_salesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the t_sales
     */
    select?: t_salesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the t_sales
     */
    omit?: t_salesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: t_salesInclude<ExtArgs> | null
    /**
     * The filter to search for the t_sales to update in case it exists.
     */
    where: t_salesWhereUniqueInput
    /**
     * In case the t_sales found by the `where` argument doesn't exist, create a new t_sales with this data.
     */
    create: XOR<t_salesCreateInput, t_salesUncheckedCreateInput>
    /**
     * In case the t_sales was found with the provided `where` argument, update it with this data.
     */
    update: XOR<t_salesUpdateInput, t_salesUncheckedUpdateInput>
  }

  /**
   * t_sales delete
   */
  export type t_salesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the t_sales
     */
    select?: t_salesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the t_sales
     */
    omit?: t_salesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: t_salesInclude<ExtArgs> | null
    /**
     * Filter which t_sales to delete.
     */
    where: t_salesWhereUniqueInput
  }

  /**
   * t_sales deleteMany
   */
  export type t_salesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which t_sales to delete
     */
    where?: t_salesWhereInput
    /**
     * Limit how many t_sales to delete.
     */
    limit?: number
  }

  /**
   * t_sales.t_sales_line
   */
  export type t_sales$t_sales_lineArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the t_sales_line
     */
    select?: t_sales_lineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the t_sales_line
     */
    omit?: t_sales_lineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: t_sales_lineInclude<ExtArgs> | null
    where?: t_sales_lineWhereInput
    orderBy?: t_sales_lineOrderByWithRelationInput | t_sales_lineOrderByWithRelationInput[]
    cursor?: t_sales_lineWhereUniqueInput
    take?: number
    skip?: number
    distinct?: T_sales_lineScalarFieldEnum | T_sales_lineScalarFieldEnum[]
  }

  /**
   * t_sales without action
   */
  export type t_salesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the t_sales
     */
    select?: t_salesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the t_sales
     */
    omit?: t_salesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: t_salesInclude<ExtArgs> | null
  }


  /**
   * Model t_sales_download
   */

  export type AggregateT_sales_download = {
    _count: T_sales_downloadCountAggregateOutputType | null
    _min: T_sales_downloadMinAggregateOutputType | null
    _max: T_sales_downloadMaxAggregateOutputType | null
  }

  export type T_sales_downloadMinAggregateOutputType = {
    id: string | null
    id_product: string | null
    id_customer: string | null
    downloaded_at: Date | null
    ip_address: string | null
    download_key: string | null
  }

  export type T_sales_downloadMaxAggregateOutputType = {
    id: string | null
    id_product: string | null
    id_customer: string | null
    downloaded_at: Date | null
    ip_address: string | null
    download_key: string | null
  }

  export type T_sales_downloadCountAggregateOutputType = {
    id: number
    id_product: number
    id_customer: number
    downloaded_at: number
    ip_address: number
    download_key: number
    _all: number
  }


  export type T_sales_downloadMinAggregateInputType = {
    id?: true
    id_product?: true
    id_customer?: true
    downloaded_at?: true
    ip_address?: true
    download_key?: true
  }

  export type T_sales_downloadMaxAggregateInputType = {
    id?: true
    id_product?: true
    id_customer?: true
    downloaded_at?: true
    ip_address?: true
    download_key?: true
  }

  export type T_sales_downloadCountAggregateInputType = {
    id?: true
    id_product?: true
    id_customer?: true
    downloaded_at?: true
    ip_address?: true
    download_key?: true
    _all?: true
  }

  export type T_sales_downloadAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which t_sales_download to aggregate.
     */
    where?: t_sales_downloadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of t_sales_downloads to fetch.
     */
    orderBy?: t_sales_downloadOrderByWithRelationInput | t_sales_downloadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: t_sales_downloadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` t_sales_downloads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` t_sales_downloads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned t_sales_downloads
    **/
    _count?: true | T_sales_downloadCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: T_sales_downloadMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: T_sales_downloadMaxAggregateInputType
  }

  export type GetT_sales_downloadAggregateType<T extends T_sales_downloadAggregateArgs> = {
        [P in keyof T & keyof AggregateT_sales_download]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateT_sales_download[P]>
      : GetScalarType<T[P], AggregateT_sales_download[P]>
  }




  export type t_sales_downloadGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: t_sales_downloadWhereInput
    orderBy?: t_sales_downloadOrderByWithAggregationInput | t_sales_downloadOrderByWithAggregationInput[]
    by: T_sales_downloadScalarFieldEnum[] | T_sales_downloadScalarFieldEnum
    having?: t_sales_downloadScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: T_sales_downloadCountAggregateInputType | true
    _min?: T_sales_downloadMinAggregateInputType
    _max?: T_sales_downloadMaxAggregateInputType
  }

  export type T_sales_downloadGroupByOutputType = {
    id: string
    id_product: string
    id_customer: string
    downloaded_at: Date | null
    ip_address: string | null
    download_key: string
    _count: T_sales_downloadCountAggregateOutputType | null
    _min: T_sales_downloadMinAggregateOutputType | null
    _max: T_sales_downloadMaxAggregateOutputType | null
  }

  type GetT_sales_downloadGroupByPayload<T extends t_sales_downloadGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<T_sales_downloadGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof T_sales_downloadGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], T_sales_downloadGroupByOutputType[P]>
            : GetScalarType<T[P], T_sales_downloadGroupByOutputType[P]>
        }
      >
    >


  export type t_sales_downloadSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    id_product?: boolean
    id_customer?: boolean
    downloaded_at?: boolean
    ip_address?: boolean
    download_key?: boolean
    customer?: boolean | customerDefaultArgs<ExtArgs>
    product?: boolean | productDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["t_sales_download"]>

  export type t_sales_downloadSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    id_product?: boolean
    id_customer?: boolean
    downloaded_at?: boolean
    ip_address?: boolean
    download_key?: boolean
    customer?: boolean | customerDefaultArgs<ExtArgs>
    product?: boolean | productDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["t_sales_download"]>

  export type t_sales_downloadSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    id_product?: boolean
    id_customer?: boolean
    downloaded_at?: boolean
    ip_address?: boolean
    download_key?: boolean
    customer?: boolean | customerDefaultArgs<ExtArgs>
    product?: boolean | productDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["t_sales_download"]>

  export type t_sales_downloadSelectScalar = {
    id?: boolean
    id_product?: boolean
    id_customer?: boolean
    downloaded_at?: boolean
    ip_address?: boolean
    download_key?: boolean
  }

  export type t_sales_downloadOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "id_product" | "id_customer" | "downloaded_at" | "ip_address" | "download_key", ExtArgs["result"]["t_sales_download"]>
  export type t_sales_downloadInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | customerDefaultArgs<ExtArgs>
    product?: boolean | productDefaultArgs<ExtArgs>
  }
  export type t_sales_downloadIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | customerDefaultArgs<ExtArgs>
    product?: boolean | productDefaultArgs<ExtArgs>
  }
  export type t_sales_downloadIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | customerDefaultArgs<ExtArgs>
    product?: boolean | productDefaultArgs<ExtArgs>
  }

  export type $t_sales_downloadPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "t_sales_download"
    objects: {
      customer: Prisma.$customerPayload<ExtArgs>
      product: Prisma.$productPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      id_product: string
      id_customer: string
      downloaded_at: Date | null
      ip_address: string | null
      download_key: string
    }, ExtArgs["result"]["t_sales_download"]>
    composites: {}
  }

  type t_sales_downloadGetPayload<S extends boolean | null | undefined | t_sales_downloadDefaultArgs> = $Result.GetResult<Prisma.$t_sales_downloadPayload, S>

  type t_sales_downloadCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<t_sales_downloadFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: T_sales_downloadCountAggregateInputType | true
    }

  export interface t_sales_downloadDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['t_sales_download'], meta: { name: 't_sales_download' } }
    /**
     * Find zero or one T_sales_download that matches the filter.
     * @param {t_sales_downloadFindUniqueArgs} args - Arguments to find a T_sales_download
     * @example
     * // Get one T_sales_download
     * const t_sales_download = await prisma.t_sales_download.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends t_sales_downloadFindUniqueArgs>(args: SelectSubset<T, t_sales_downloadFindUniqueArgs<ExtArgs>>): Prisma__t_sales_downloadClient<$Result.GetResult<Prisma.$t_sales_downloadPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one T_sales_download that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {t_sales_downloadFindUniqueOrThrowArgs} args - Arguments to find a T_sales_download
     * @example
     * // Get one T_sales_download
     * const t_sales_download = await prisma.t_sales_download.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends t_sales_downloadFindUniqueOrThrowArgs>(args: SelectSubset<T, t_sales_downloadFindUniqueOrThrowArgs<ExtArgs>>): Prisma__t_sales_downloadClient<$Result.GetResult<Prisma.$t_sales_downloadPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first T_sales_download that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {t_sales_downloadFindFirstArgs} args - Arguments to find a T_sales_download
     * @example
     * // Get one T_sales_download
     * const t_sales_download = await prisma.t_sales_download.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends t_sales_downloadFindFirstArgs>(args?: SelectSubset<T, t_sales_downloadFindFirstArgs<ExtArgs>>): Prisma__t_sales_downloadClient<$Result.GetResult<Prisma.$t_sales_downloadPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first T_sales_download that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {t_sales_downloadFindFirstOrThrowArgs} args - Arguments to find a T_sales_download
     * @example
     * // Get one T_sales_download
     * const t_sales_download = await prisma.t_sales_download.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends t_sales_downloadFindFirstOrThrowArgs>(args?: SelectSubset<T, t_sales_downloadFindFirstOrThrowArgs<ExtArgs>>): Prisma__t_sales_downloadClient<$Result.GetResult<Prisma.$t_sales_downloadPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more T_sales_downloads that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {t_sales_downloadFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all T_sales_downloads
     * const t_sales_downloads = await prisma.t_sales_download.findMany()
     * 
     * // Get first 10 T_sales_downloads
     * const t_sales_downloads = await prisma.t_sales_download.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const t_sales_downloadWithIdOnly = await prisma.t_sales_download.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends t_sales_downloadFindManyArgs>(args?: SelectSubset<T, t_sales_downloadFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$t_sales_downloadPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a T_sales_download.
     * @param {t_sales_downloadCreateArgs} args - Arguments to create a T_sales_download.
     * @example
     * // Create one T_sales_download
     * const T_sales_download = await prisma.t_sales_download.create({
     *   data: {
     *     // ... data to create a T_sales_download
     *   }
     * })
     * 
     */
    create<T extends t_sales_downloadCreateArgs>(args: SelectSubset<T, t_sales_downloadCreateArgs<ExtArgs>>): Prisma__t_sales_downloadClient<$Result.GetResult<Prisma.$t_sales_downloadPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many T_sales_downloads.
     * @param {t_sales_downloadCreateManyArgs} args - Arguments to create many T_sales_downloads.
     * @example
     * // Create many T_sales_downloads
     * const t_sales_download = await prisma.t_sales_download.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends t_sales_downloadCreateManyArgs>(args?: SelectSubset<T, t_sales_downloadCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many T_sales_downloads and returns the data saved in the database.
     * @param {t_sales_downloadCreateManyAndReturnArgs} args - Arguments to create many T_sales_downloads.
     * @example
     * // Create many T_sales_downloads
     * const t_sales_download = await prisma.t_sales_download.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many T_sales_downloads and only return the `id`
     * const t_sales_downloadWithIdOnly = await prisma.t_sales_download.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends t_sales_downloadCreateManyAndReturnArgs>(args?: SelectSubset<T, t_sales_downloadCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$t_sales_downloadPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a T_sales_download.
     * @param {t_sales_downloadDeleteArgs} args - Arguments to delete one T_sales_download.
     * @example
     * // Delete one T_sales_download
     * const T_sales_download = await prisma.t_sales_download.delete({
     *   where: {
     *     // ... filter to delete one T_sales_download
     *   }
     * })
     * 
     */
    delete<T extends t_sales_downloadDeleteArgs>(args: SelectSubset<T, t_sales_downloadDeleteArgs<ExtArgs>>): Prisma__t_sales_downloadClient<$Result.GetResult<Prisma.$t_sales_downloadPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one T_sales_download.
     * @param {t_sales_downloadUpdateArgs} args - Arguments to update one T_sales_download.
     * @example
     * // Update one T_sales_download
     * const t_sales_download = await prisma.t_sales_download.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends t_sales_downloadUpdateArgs>(args: SelectSubset<T, t_sales_downloadUpdateArgs<ExtArgs>>): Prisma__t_sales_downloadClient<$Result.GetResult<Prisma.$t_sales_downloadPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more T_sales_downloads.
     * @param {t_sales_downloadDeleteManyArgs} args - Arguments to filter T_sales_downloads to delete.
     * @example
     * // Delete a few T_sales_downloads
     * const { count } = await prisma.t_sales_download.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends t_sales_downloadDeleteManyArgs>(args?: SelectSubset<T, t_sales_downloadDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more T_sales_downloads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {t_sales_downloadUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many T_sales_downloads
     * const t_sales_download = await prisma.t_sales_download.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends t_sales_downloadUpdateManyArgs>(args: SelectSubset<T, t_sales_downloadUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more T_sales_downloads and returns the data updated in the database.
     * @param {t_sales_downloadUpdateManyAndReturnArgs} args - Arguments to update many T_sales_downloads.
     * @example
     * // Update many T_sales_downloads
     * const t_sales_download = await prisma.t_sales_download.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more T_sales_downloads and only return the `id`
     * const t_sales_downloadWithIdOnly = await prisma.t_sales_download.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends t_sales_downloadUpdateManyAndReturnArgs>(args: SelectSubset<T, t_sales_downloadUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$t_sales_downloadPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one T_sales_download.
     * @param {t_sales_downloadUpsertArgs} args - Arguments to update or create a T_sales_download.
     * @example
     * // Update or create a T_sales_download
     * const t_sales_download = await prisma.t_sales_download.upsert({
     *   create: {
     *     // ... data to create a T_sales_download
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the T_sales_download we want to update
     *   }
     * })
     */
    upsert<T extends t_sales_downloadUpsertArgs>(args: SelectSubset<T, t_sales_downloadUpsertArgs<ExtArgs>>): Prisma__t_sales_downloadClient<$Result.GetResult<Prisma.$t_sales_downloadPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of T_sales_downloads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {t_sales_downloadCountArgs} args - Arguments to filter T_sales_downloads to count.
     * @example
     * // Count the number of T_sales_downloads
     * const count = await prisma.t_sales_download.count({
     *   where: {
     *     // ... the filter for the T_sales_downloads we want to count
     *   }
     * })
    **/
    count<T extends t_sales_downloadCountArgs>(
      args?: Subset<T, t_sales_downloadCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], T_sales_downloadCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a T_sales_download.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {T_sales_downloadAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends T_sales_downloadAggregateArgs>(args: Subset<T, T_sales_downloadAggregateArgs>): Prisma.PrismaPromise<GetT_sales_downloadAggregateType<T>>

    /**
     * Group by T_sales_download.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {t_sales_downloadGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends t_sales_downloadGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: t_sales_downloadGroupByArgs['orderBy'] }
        : { orderBy?: t_sales_downloadGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, t_sales_downloadGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetT_sales_downloadGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the t_sales_download model
   */
  readonly fields: t_sales_downloadFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for t_sales_download.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__t_sales_downloadClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    customer<T extends customerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, customerDefaultArgs<ExtArgs>>): Prisma__customerClient<$Result.GetResult<Prisma.$customerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    product<T extends productDefaultArgs<ExtArgs> = {}>(args?: Subset<T, productDefaultArgs<ExtArgs>>): Prisma__productClient<$Result.GetResult<Prisma.$productPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the t_sales_download model
   */
  interface t_sales_downloadFieldRefs {
    readonly id: FieldRef<"t_sales_download", 'String'>
    readonly id_product: FieldRef<"t_sales_download", 'String'>
    readonly id_customer: FieldRef<"t_sales_download", 'String'>
    readonly downloaded_at: FieldRef<"t_sales_download", 'DateTime'>
    readonly ip_address: FieldRef<"t_sales_download", 'String'>
    readonly download_key: FieldRef<"t_sales_download", 'String'>
  }
    

  // Custom InputTypes
  /**
   * t_sales_download findUnique
   */
  export type t_sales_downloadFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the t_sales_download
     */
    select?: t_sales_downloadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the t_sales_download
     */
    omit?: t_sales_downloadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: t_sales_downloadInclude<ExtArgs> | null
    /**
     * Filter, which t_sales_download to fetch.
     */
    where: t_sales_downloadWhereUniqueInput
  }

  /**
   * t_sales_download findUniqueOrThrow
   */
  export type t_sales_downloadFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the t_sales_download
     */
    select?: t_sales_downloadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the t_sales_download
     */
    omit?: t_sales_downloadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: t_sales_downloadInclude<ExtArgs> | null
    /**
     * Filter, which t_sales_download to fetch.
     */
    where: t_sales_downloadWhereUniqueInput
  }

  /**
   * t_sales_download findFirst
   */
  export type t_sales_downloadFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the t_sales_download
     */
    select?: t_sales_downloadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the t_sales_download
     */
    omit?: t_sales_downloadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: t_sales_downloadInclude<ExtArgs> | null
    /**
     * Filter, which t_sales_download to fetch.
     */
    where?: t_sales_downloadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of t_sales_downloads to fetch.
     */
    orderBy?: t_sales_downloadOrderByWithRelationInput | t_sales_downloadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for t_sales_downloads.
     */
    cursor?: t_sales_downloadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` t_sales_downloads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` t_sales_downloads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of t_sales_downloads.
     */
    distinct?: T_sales_downloadScalarFieldEnum | T_sales_downloadScalarFieldEnum[]
  }

  /**
   * t_sales_download findFirstOrThrow
   */
  export type t_sales_downloadFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the t_sales_download
     */
    select?: t_sales_downloadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the t_sales_download
     */
    omit?: t_sales_downloadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: t_sales_downloadInclude<ExtArgs> | null
    /**
     * Filter, which t_sales_download to fetch.
     */
    where?: t_sales_downloadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of t_sales_downloads to fetch.
     */
    orderBy?: t_sales_downloadOrderByWithRelationInput | t_sales_downloadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for t_sales_downloads.
     */
    cursor?: t_sales_downloadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` t_sales_downloads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` t_sales_downloads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of t_sales_downloads.
     */
    distinct?: T_sales_downloadScalarFieldEnum | T_sales_downloadScalarFieldEnum[]
  }

  /**
   * t_sales_download findMany
   */
  export type t_sales_downloadFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the t_sales_download
     */
    select?: t_sales_downloadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the t_sales_download
     */
    omit?: t_sales_downloadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: t_sales_downloadInclude<ExtArgs> | null
    /**
     * Filter, which t_sales_downloads to fetch.
     */
    where?: t_sales_downloadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of t_sales_downloads to fetch.
     */
    orderBy?: t_sales_downloadOrderByWithRelationInput | t_sales_downloadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing t_sales_downloads.
     */
    cursor?: t_sales_downloadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` t_sales_downloads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` t_sales_downloads.
     */
    skip?: number
    distinct?: T_sales_downloadScalarFieldEnum | T_sales_downloadScalarFieldEnum[]
  }

  /**
   * t_sales_download create
   */
  export type t_sales_downloadCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the t_sales_download
     */
    select?: t_sales_downloadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the t_sales_download
     */
    omit?: t_sales_downloadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: t_sales_downloadInclude<ExtArgs> | null
    /**
     * The data needed to create a t_sales_download.
     */
    data: XOR<t_sales_downloadCreateInput, t_sales_downloadUncheckedCreateInput>
  }

  /**
   * t_sales_download createMany
   */
  export type t_sales_downloadCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many t_sales_downloads.
     */
    data: t_sales_downloadCreateManyInput | t_sales_downloadCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * t_sales_download createManyAndReturn
   */
  export type t_sales_downloadCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the t_sales_download
     */
    select?: t_sales_downloadSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the t_sales_download
     */
    omit?: t_sales_downloadOmit<ExtArgs> | null
    /**
     * The data used to create many t_sales_downloads.
     */
    data: t_sales_downloadCreateManyInput | t_sales_downloadCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: t_sales_downloadIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * t_sales_download update
   */
  export type t_sales_downloadUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the t_sales_download
     */
    select?: t_sales_downloadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the t_sales_download
     */
    omit?: t_sales_downloadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: t_sales_downloadInclude<ExtArgs> | null
    /**
     * The data needed to update a t_sales_download.
     */
    data: XOR<t_sales_downloadUpdateInput, t_sales_downloadUncheckedUpdateInput>
    /**
     * Choose, which t_sales_download to update.
     */
    where: t_sales_downloadWhereUniqueInput
  }

  /**
   * t_sales_download updateMany
   */
  export type t_sales_downloadUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update t_sales_downloads.
     */
    data: XOR<t_sales_downloadUpdateManyMutationInput, t_sales_downloadUncheckedUpdateManyInput>
    /**
     * Filter which t_sales_downloads to update
     */
    where?: t_sales_downloadWhereInput
    /**
     * Limit how many t_sales_downloads to update.
     */
    limit?: number
  }

  /**
   * t_sales_download updateManyAndReturn
   */
  export type t_sales_downloadUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the t_sales_download
     */
    select?: t_sales_downloadSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the t_sales_download
     */
    omit?: t_sales_downloadOmit<ExtArgs> | null
    /**
     * The data used to update t_sales_downloads.
     */
    data: XOR<t_sales_downloadUpdateManyMutationInput, t_sales_downloadUncheckedUpdateManyInput>
    /**
     * Filter which t_sales_downloads to update
     */
    where?: t_sales_downloadWhereInput
    /**
     * Limit how many t_sales_downloads to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: t_sales_downloadIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * t_sales_download upsert
   */
  export type t_sales_downloadUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the t_sales_download
     */
    select?: t_sales_downloadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the t_sales_download
     */
    omit?: t_sales_downloadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: t_sales_downloadInclude<ExtArgs> | null
    /**
     * The filter to search for the t_sales_download to update in case it exists.
     */
    where: t_sales_downloadWhereUniqueInput
    /**
     * In case the t_sales_download found by the `where` argument doesn't exist, create a new t_sales_download with this data.
     */
    create: XOR<t_sales_downloadCreateInput, t_sales_downloadUncheckedCreateInput>
    /**
     * In case the t_sales_download was found with the provided `where` argument, update it with this data.
     */
    update: XOR<t_sales_downloadUpdateInput, t_sales_downloadUncheckedUpdateInput>
  }

  /**
   * t_sales_download delete
   */
  export type t_sales_downloadDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the t_sales_download
     */
    select?: t_sales_downloadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the t_sales_download
     */
    omit?: t_sales_downloadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: t_sales_downloadInclude<ExtArgs> | null
    /**
     * Filter which t_sales_download to delete.
     */
    where: t_sales_downloadWhereUniqueInput
  }

  /**
   * t_sales_download deleteMany
   */
  export type t_sales_downloadDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which t_sales_downloads to delete
     */
    where?: t_sales_downloadWhereInput
    /**
     * Limit how many t_sales_downloads to delete.
     */
    limit?: number
  }

  /**
   * t_sales_download without action
   */
  export type t_sales_downloadDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the t_sales_download
     */
    select?: t_sales_downloadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the t_sales_download
     */
    omit?: t_sales_downloadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: t_sales_downloadInclude<ExtArgs> | null
  }


  /**
   * Model t_sales_line
   */

  export type AggregateT_sales_line = {
    _count: T_sales_lineCountAggregateOutputType | null
    _avg: T_sales_lineAvgAggregateOutputType | null
    _sum: T_sales_lineSumAggregateOutputType | null
    _min: T_sales_lineMinAggregateOutputType | null
    _max: T_sales_lineMaxAggregateOutputType | null
  }

  export type T_sales_lineAvgAggregateOutputType = {
    unit_price: Decimal | null
    qty: number | null
    total_price: Decimal | null
  }

  export type T_sales_lineSumAggregateOutputType = {
    unit_price: Decimal | null
    qty: number | null
    total_price: Decimal | null
  }

  export type T_sales_lineMinAggregateOutputType = {
    id: string | null
    id_sales: string | null
    unit_price: Decimal | null
    qty: number | null
    total_price: Decimal | null
    id_product: string | null
    id_bundle: string | null
  }

  export type T_sales_lineMaxAggregateOutputType = {
    id: string | null
    id_sales: string | null
    unit_price: Decimal | null
    qty: number | null
    total_price: Decimal | null
    id_product: string | null
    id_bundle: string | null
  }

  export type T_sales_lineCountAggregateOutputType = {
    id: number
    id_sales: number
    unit_price: number
    qty: number
    total_price: number
    id_product: number
    id_bundle: number
    _all: number
  }


  export type T_sales_lineAvgAggregateInputType = {
    unit_price?: true
    qty?: true
    total_price?: true
  }

  export type T_sales_lineSumAggregateInputType = {
    unit_price?: true
    qty?: true
    total_price?: true
  }

  export type T_sales_lineMinAggregateInputType = {
    id?: true
    id_sales?: true
    unit_price?: true
    qty?: true
    total_price?: true
    id_product?: true
    id_bundle?: true
  }

  export type T_sales_lineMaxAggregateInputType = {
    id?: true
    id_sales?: true
    unit_price?: true
    qty?: true
    total_price?: true
    id_product?: true
    id_bundle?: true
  }

  export type T_sales_lineCountAggregateInputType = {
    id?: true
    id_sales?: true
    unit_price?: true
    qty?: true
    total_price?: true
    id_product?: true
    id_bundle?: true
    _all?: true
  }

  export type T_sales_lineAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which t_sales_line to aggregate.
     */
    where?: t_sales_lineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of t_sales_lines to fetch.
     */
    orderBy?: t_sales_lineOrderByWithRelationInput | t_sales_lineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: t_sales_lineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` t_sales_lines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` t_sales_lines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned t_sales_lines
    **/
    _count?: true | T_sales_lineCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: T_sales_lineAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: T_sales_lineSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: T_sales_lineMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: T_sales_lineMaxAggregateInputType
  }

  export type GetT_sales_lineAggregateType<T extends T_sales_lineAggregateArgs> = {
        [P in keyof T & keyof AggregateT_sales_line]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateT_sales_line[P]>
      : GetScalarType<T[P], AggregateT_sales_line[P]>
  }




  export type t_sales_lineGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: t_sales_lineWhereInput
    orderBy?: t_sales_lineOrderByWithAggregationInput | t_sales_lineOrderByWithAggregationInput[]
    by: T_sales_lineScalarFieldEnum[] | T_sales_lineScalarFieldEnum
    having?: t_sales_lineScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: T_sales_lineCountAggregateInputType | true
    _avg?: T_sales_lineAvgAggregateInputType
    _sum?: T_sales_lineSumAggregateInputType
    _min?: T_sales_lineMinAggregateInputType
    _max?: T_sales_lineMaxAggregateInputType
  }

  export type T_sales_lineGroupByOutputType = {
    id: string
    id_sales: string
    unit_price: Decimal
    qty: number
    total_price: Decimal
    id_product: string | null
    id_bundle: string | null
    _count: T_sales_lineCountAggregateOutputType | null
    _avg: T_sales_lineAvgAggregateOutputType | null
    _sum: T_sales_lineSumAggregateOutputType | null
    _min: T_sales_lineMinAggregateOutputType | null
    _max: T_sales_lineMaxAggregateOutputType | null
  }

  type GetT_sales_lineGroupByPayload<T extends t_sales_lineGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<T_sales_lineGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof T_sales_lineGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], T_sales_lineGroupByOutputType[P]>
            : GetScalarType<T[P], T_sales_lineGroupByOutputType[P]>
        }
      >
    >


  export type t_sales_lineSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    id_sales?: boolean
    unit_price?: boolean
    qty?: boolean
    total_price?: boolean
    id_product?: boolean
    id_bundle?: boolean
    bundle?: boolean | t_sales_line$bundleArgs<ExtArgs>
    product?: boolean | t_sales_line$productArgs<ExtArgs>
    t_sales?: boolean | t_salesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["t_sales_line"]>

  export type t_sales_lineSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    id_sales?: boolean
    unit_price?: boolean
    qty?: boolean
    total_price?: boolean
    id_product?: boolean
    id_bundle?: boolean
    bundle?: boolean | t_sales_line$bundleArgs<ExtArgs>
    product?: boolean | t_sales_line$productArgs<ExtArgs>
    t_sales?: boolean | t_salesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["t_sales_line"]>

  export type t_sales_lineSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    id_sales?: boolean
    unit_price?: boolean
    qty?: boolean
    total_price?: boolean
    id_product?: boolean
    id_bundle?: boolean
    bundle?: boolean | t_sales_line$bundleArgs<ExtArgs>
    product?: boolean | t_sales_line$productArgs<ExtArgs>
    t_sales?: boolean | t_salesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["t_sales_line"]>

  export type t_sales_lineSelectScalar = {
    id?: boolean
    id_sales?: boolean
    unit_price?: boolean
    qty?: boolean
    total_price?: boolean
    id_product?: boolean
    id_bundle?: boolean
  }

  export type t_sales_lineOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "id_sales" | "unit_price" | "qty" | "total_price" | "id_product" | "id_bundle", ExtArgs["result"]["t_sales_line"]>
  export type t_sales_lineInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bundle?: boolean | t_sales_line$bundleArgs<ExtArgs>
    product?: boolean | t_sales_line$productArgs<ExtArgs>
    t_sales?: boolean | t_salesDefaultArgs<ExtArgs>
  }
  export type t_sales_lineIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bundle?: boolean | t_sales_line$bundleArgs<ExtArgs>
    product?: boolean | t_sales_line$productArgs<ExtArgs>
    t_sales?: boolean | t_salesDefaultArgs<ExtArgs>
  }
  export type t_sales_lineIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bundle?: boolean | t_sales_line$bundleArgs<ExtArgs>
    product?: boolean | t_sales_line$productArgs<ExtArgs>
    t_sales?: boolean | t_salesDefaultArgs<ExtArgs>
  }

  export type $t_sales_linePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "t_sales_line"
    objects: {
      bundle: Prisma.$bundlePayload<ExtArgs> | null
      product: Prisma.$productPayload<ExtArgs> | null
      t_sales: Prisma.$t_salesPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      id_sales: string
      unit_price: Prisma.Decimal
      qty: number
      total_price: Prisma.Decimal
      id_product: string | null
      id_bundle: string | null
    }, ExtArgs["result"]["t_sales_line"]>
    composites: {}
  }

  type t_sales_lineGetPayload<S extends boolean | null | undefined | t_sales_lineDefaultArgs> = $Result.GetResult<Prisma.$t_sales_linePayload, S>

  type t_sales_lineCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<t_sales_lineFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: T_sales_lineCountAggregateInputType | true
    }

  export interface t_sales_lineDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['t_sales_line'], meta: { name: 't_sales_line' } }
    /**
     * Find zero or one T_sales_line that matches the filter.
     * @param {t_sales_lineFindUniqueArgs} args - Arguments to find a T_sales_line
     * @example
     * // Get one T_sales_line
     * const t_sales_line = await prisma.t_sales_line.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends t_sales_lineFindUniqueArgs>(args: SelectSubset<T, t_sales_lineFindUniqueArgs<ExtArgs>>): Prisma__t_sales_lineClient<$Result.GetResult<Prisma.$t_sales_linePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one T_sales_line that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {t_sales_lineFindUniqueOrThrowArgs} args - Arguments to find a T_sales_line
     * @example
     * // Get one T_sales_line
     * const t_sales_line = await prisma.t_sales_line.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends t_sales_lineFindUniqueOrThrowArgs>(args: SelectSubset<T, t_sales_lineFindUniqueOrThrowArgs<ExtArgs>>): Prisma__t_sales_lineClient<$Result.GetResult<Prisma.$t_sales_linePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first T_sales_line that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {t_sales_lineFindFirstArgs} args - Arguments to find a T_sales_line
     * @example
     * // Get one T_sales_line
     * const t_sales_line = await prisma.t_sales_line.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends t_sales_lineFindFirstArgs>(args?: SelectSubset<T, t_sales_lineFindFirstArgs<ExtArgs>>): Prisma__t_sales_lineClient<$Result.GetResult<Prisma.$t_sales_linePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first T_sales_line that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {t_sales_lineFindFirstOrThrowArgs} args - Arguments to find a T_sales_line
     * @example
     * // Get one T_sales_line
     * const t_sales_line = await prisma.t_sales_line.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends t_sales_lineFindFirstOrThrowArgs>(args?: SelectSubset<T, t_sales_lineFindFirstOrThrowArgs<ExtArgs>>): Prisma__t_sales_lineClient<$Result.GetResult<Prisma.$t_sales_linePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more T_sales_lines that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {t_sales_lineFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all T_sales_lines
     * const t_sales_lines = await prisma.t_sales_line.findMany()
     * 
     * // Get first 10 T_sales_lines
     * const t_sales_lines = await prisma.t_sales_line.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const t_sales_lineWithIdOnly = await prisma.t_sales_line.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends t_sales_lineFindManyArgs>(args?: SelectSubset<T, t_sales_lineFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$t_sales_linePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a T_sales_line.
     * @param {t_sales_lineCreateArgs} args - Arguments to create a T_sales_line.
     * @example
     * // Create one T_sales_line
     * const T_sales_line = await prisma.t_sales_line.create({
     *   data: {
     *     // ... data to create a T_sales_line
     *   }
     * })
     * 
     */
    create<T extends t_sales_lineCreateArgs>(args: SelectSubset<T, t_sales_lineCreateArgs<ExtArgs>>): Prisma__t_sales_lineClient<$Result.GetResult<Prisma.$t_sales_linePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many T_sales_lines.
     * @param {t_sales_lineCreateManyArgs} args - Arguments to create many T_sales_lines.
     * @example
     * // Create many T_sales_lines
     * const t_sales_line = await prisma.t_sales_line.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends t_sales_lineCreateManyArgs>(args?: SelectSubset<T, t_sales_lineCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many T_sales_lines and returns the data saved in the database.
     * @param {t_sales_lineCreateManyAndReturnArgs} args - Arguments to create many T_sales_lines.
     * @example
     * // Create many T_sales_lines
     * const t_sales_line = await prisma.t_sales_line.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many T_sales_lines and only return the `id`
     * const t_sales_lineWithIdOnly = await prisma.t_sales_line.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends t_sales_lineCreateManyAndReturnArgs>(args?: SelectSubset<T, t_sales_lineCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$t_sales_linePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a T_sales_line.
     * @param {t_sales_lineDeleteArgs} args - Arguments to delete one T_sales_line.
     * @example
     * // Delete one T_sales_line
     * const T_sales_line = await prisma.t_sales_line.delete({
     *   where: {
     *     // ... filter to delete one T_sales_line
     *   }
     * })
     * 
     */
    delete<T extends t_sales_lineDeleteArgs>(args: SelectSubset<T, t_sales_lineDeleteArgs<ExtArgs>>): Prisma__t_sales_lineClient<$Result.GetResult<Prisma.$t_sales_linePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one T_sales_line.
     * @param {t_sales_lineUpdateArgs} args - Arguments to update one T_sales_line.
     * @example
     * // Update one T_sales_line
     * const t_sales_line = await prisma.t_sales_line.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends t_sales_lineUpdateArgs>(args: SelectSubset<T, t_sales_lineUpdateArgs<ExtArgs>>): Prisma__t_sales_lineClient<$Result.GetResult<Prisma.$t_sales_linePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more T_sales_lines.
     * @param {t_sales_lineDeleteManyArgs} args - Arguments to filter T_sales_lines to delete.
     * @example
     * // Delete a few T_sales_lines
     * const { count } = await prisma.t_sales_line.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends t_sales_lineDeleteManyArgs>(args?: SelectSubset<T, t_sales_lineDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more T_sales_lines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {t_sales_lineUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many T_sales_lines
     * const t_sales_line = await prisma.t_sales_line.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends t_sales_lineUpdateManyArgs>(args: SelectSubset<T, t_sales_lineUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more T_sales_lines and returns the data updated in the database.
     * @param {t_sales_lineUpdateManyAndReturnArgs} args - Arguments to update many T_sales_lines.
     * @example
     * // Update many T_sales_lines
     * const t_sales_line = await prisma.t_sales_line.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more T_sales_lines and only return the `id`
     * const t_sales_lineWithIdOnly = await prisma.t_sales_line.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends t_sales_lineUpdateManyAndReturnArgs>(args: SelectSubset<T, t_sales_lineUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$t_sales_linePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one T_sales_line.
     * @param {t_sales_lineUpsertArgs} args - Arguments to update or create a T_sales_line.
     * @example
     * // Update or create a T_sales_line
     * const t_sales_line = await prisma.t_sales_line.upsert({
     *   create: {
     *     // ... data to create a T_sales_line
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the T_sales_line we want to update
     *   }
     * })
     */
    upsert<T extends t_sales_lineUpsertArgs>(args: SelectSubset<T, t_sales_lineUpsertArgs<ExtArgs>>): Prisma__t_sales_lineClient<$Result.GetResult<Prisma.$t_sales_linePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of T_sales_lines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {t_sales_lineCountArgs} args - Arguments to filter T_sales_lines to count.
     * @example
     * // Count the number of T_sales_lines
     * const count = await prisma.t_sales_line.count({
     *   where: {
     *     // ... the filter for the T_sales_lines we want to count
     *   }
     * })
    **/
    count<T extends t_sales_lineCountArgs>(
      args?: Subset<T, t_sales_lineCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], T_sales_lineCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a T_sales_line.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {T_sales_lineAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends T_sales_lineAggregateArgs>(args: Subset<T, T_sales_lineAggregateArgs>): Prisma.PrismaPromise<GetT_sales_lineAggregateType<T>>

    /**
     * Group by T_sales_line.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {t_sales_lineGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends t_sales_lineGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: t_sales_lineGroupByArgs['orderBy'] }
        : { orderBy?: t_sales_lineGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, t_sales_lineGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetT_sales_lineGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the t_sales_line model
   */
  readonly fields: t_sales_lineFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for t_sales_line.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__t_sales_lineClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bundle<T extends t_sales_line$bundleArgs<ExtArgs> = {}>(args?: Subset<T, t_sales_line$bundleArgs<ExtArgs>>): Prisma__bundleClient<$Result.GetResult<Prisma.$bundlePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    product<T extends t_sales_line$productArgs<ExtArgs> = {}>(args?: Subset<T, t_sales_line$productArgs<ExtArgs>>): Prisma__productClient<$Result.GetResult<Prisma.$productPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    t_sales<T extends t_salesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, t_salesDefaultArgs<ExtArgs>>): Prisma__t_salesClient<$Result.GetResult<Prisma.$t_salesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the t_sales_line model
   */
  interface t_sales_lineFieldRefs {
    readonly id: FieldRef<"t_sales_line", 'String'>
    readonly id_sales: FieldRef<"t_sales_line", 'String'>
    readonly unit_price: FieldRef<"t_sales_line", 'Decimal'>
    readonly qty: FieldRef<"t_sales_line", 'Int'>
    readonly total_price: FieldRef<"t_sales_line", 'Decimal'>
    readonly id_product: FieldRef<"t_sales_line", 'String'>
    readonly id_bundle: FieldRef<"t_sales_line", 'String'>
  }
    

  // Custom InputTypes
  /**
   * t_sales_line findUnique
   */
  export type t_sales_lineFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the t_sales_line
     */
    select?: t_sales_lineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the t_sales_line
     */
    omit?: t_sales_lineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: t_sales_lineInclude<ExtArgs> | null
    /**
     * Filter, which t_sales_line to fetch.
     */
    where: t_sales_lineWhereUniqueInput
  }

  /**
   * t_sales_line findUniqueOrThrow
   */
  export type t_sales_lineFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the t_sales_line
     */
    select?: t_sales_lineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the t_sales_line
     */
    omit?: t_sales_lineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: t_sales_lineInclude<ExtArgs> | null
    /**
     * Filter, which t_sales_line to fetch.
     */
    where: t_sales_lineWhereUniqueInput
  }

  /**
   * t_sales_line findFirst
   */
  export type t_sales_lineFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the t_sales_line
     */
    select?: t_sales_lineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the t_sales_line
     */
    omit?: t_sales_lineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: t_sales_lineInclude<ExtArgs> | null
    /**
     * Filter, which t_sales_line to fetch.
     */
    where?: t_sales_lineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of t_sales_lines to fetch.
     */
    orderBy?: t_sales_lineOrderByWithRelationInput | t_sales_lineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for t_sales_lines.
     */
    cursor?: t_sales_lineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` t_sales_lines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` t_sales_lines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of t_sales_lines.
     */
    distinct?: T_sales_lineScalarFieldEnum | T_sales_lineScalarFieldEnum[]
  }

  /**
   * t_sales_line findFirstOrThrow
   */
  export type t_sales_lineFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the t_sales_line
     */
    select?: t_sales_lineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the t_sales_line
     */
    omit?: t_sales_lineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: t_sales_lineInclude<ExtArgs> | null
    /**
     * Filter, which t_sales_line to fetch.
     */
    where?: t_sales_lineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of t_sales_lines to fetch.
     */
    orderBy?: t_sales_lineOrderByWithRelationInput | t_sales_lineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for t_sales_lines.
     */
    cursor?: t_sales_lineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` t_sales_lines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` t_sales_lines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of t_sales_lines.
     */
    distinct?: T_sales_lineScalarFieldEnum | T_sales_lineScalarFieldEnum[]
  }

  /**
   * t_sales_line findMany
   */
  export type t_sales_lineFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the t_sales_line
     */
    select?: t_sales_lineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the t_sales_line
     */
    omit?: t_sales_lineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: t_sales_lineInclude<ExtArgs> | null
    /**
     * Filter, which t_sales_lines to fetch.
     */
    where?: t_sales_lineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of t_sales_lines to fetch.
     */
    orderBy?: t_sales_lineOrderByWithRelationInput | t_sales_lineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing t_sales_lines.
     */
    cursor?: t_sales_lineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` t_sales_lines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` t_sales_lines.
     */
    skip?: number
    distinct?: T_sales_lineScalarFieldEnum | T_sales_lineScalarFieldEnum[]
  }

  /**
   * t_sales_line create
   */
  export type t_sales_lineCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the t_sales_line
     */
    select?: t_sales_lineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the t_sales_line
     */
    omit?: t_sales_lineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: t_sales_lineInclude<ExtArgs> | null
    /**
     * The data needed to create a t_sales_line.
     */
    data: XOR<t_sales_lineCreateInput, t_sales_lineUncheckedCreateInput>
  }

  /**
   * t_sales_line createMany
   */
  export type t_sales_lineCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many t_sales_lines.
     */
    data: t_sales_lineCreateManyInput | t_sales_lineCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * t_sales_line createManyAndReturn
   */
  export type t_sales_lineCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the t_sales_line
     */
    select?: t_sales_lineSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the t_sales_line
     */
    omit?: t_sales_lineOmit<ExtArgs> | null
    /**
     * The data used to create many t_sales_lines.
     */
    data: t_sales_lineCreateManyInput | t_sales_lineCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: t_sales_lineIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * t_sales_line update
   */
  export type t_sales_lineUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the t_sales_line
     */
    select?: t_sales_lineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the t_sales_line
     */
    omit?: t_sales_lineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: t_sales_lineInclude<ExtArgs> | null
    /**
     * The data needed to update a t_sales_line.
     */
    data: XOR<t_sales_lineUpdateInput, t_sales_lineUncheckedUpdateInput>
    /**
     * Choose, which t_sales_line to update.
     */
    where: t_sales_lineWhereUniqueInput
  }

  /**
   * t_sales_line updateMany
   */
  export type t_sales_lineUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update t_sales_lines.
     */
    data: XOR<t_sales_lineUpdateManyMutationInput, t_sales_lineUncheckedUpdateManyInput>
    /**
     * Filter which t_sales_lines to update
     */
    where?: t_sales_lineWhereInput
    /**
     * Limit how many t_sales_lines to update.
     */
    limit?: number
  }

  /**
   * t_sales_line updateManyAndReturn
   */
  export type t_sales_lineUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the t_sales_line
     */
    select?: t_sales_lineSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the t_sales_line
     */
    omit?: t_sales_lineOmit<ExtArgs> | null
    /**
     * The data used to update t_sales_lines.
     */
    data: XOR<t_sales_lineUpdateManyMutationInput, t_sales_lineUncheckedUpdateManyInput>
    /**
     * Filter which t_sales_lines to update
     */
    where?: t_sales_lineWhereInput
    /**
     * Limit how many t_sales_lines to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: t_sales_lineIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * t_sales_line upsert
   */
  export type t_sales_lineUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the t_sales_line
     */
    select?: t_sales_lineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the t_sales_line
     */
    omit?: t_sales_lineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: t_sales_lineInclude<ExtArgs> | null
    /**
     * The filter to search for the t_sales_line to update in case it exists.
     */
    where: t_sales_lineWhereUniqueInput
    /**
     * In case the t_sales_line found by the `where` argument doesn't exist, create a new t_sales_line with this data.
     */
    create: XOR<t_sales_lineCreateInput, t_sales_lineUncheckedCreateInput>
    /**
     * In case the t_sales_line was found with the provided `where` argument, update it with this data.
     */
    update: XOR<t_sales_lineUpdateInput, t_sales_lineUncheckedUpdateInput>
  }

  /**
   * t_sales_line delete
   */
  export type t_sales_lineDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the t_sales_line
     */
    select?: t_sales_lineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the t_sales_line
     */
    omit?: t_sales_lineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: t_sales_lineInclude<ExtArgs> | null
    /**
     * Filter which t_sales_line to delete.
     */
    where: t_sales_lineWhereUniqueInput
  }

  /**
   * t_sales_line deleteMany
   */
  export type t_sales_lineDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which t_sales_lines to delete
     */
    where?: t_sales_lineWhereInput
    /**
     * Limit how many t_sales_lines to delete.
     */
    limit?: number
  }

  /**
   * t_sales_line.bundle
   */
  export type t_sales_line$bundleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bundle
     */
    select?: bundleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bundle
     */
    omit?: bundleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bundleInclude<ExtArgs> | null
    where?: bundleWhereInput
  }

  /**
   * t_sales_line.product
   */
  export type t_sales_line$productArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product
     */
    select?: productSelect<ExtArgs> | null
    /**
     * Omit specific fields from the product
     */
    omit?: productOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productInclude<ExtArgs> | null
    where?: productWhereInput
  }

  /**
   * t_sales_line without action
   */
  export type t_sales_lineDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the t_sales_line
     */
    select?: t_sales_lineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the t_sales_line
     */
    omit?: t_sales_lineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: t_sales_lineInclude<ExtArgs> | null
  }


  /**
   * Model tags
   */

  export type AggregateTags = {
    _count: TagsCountAggregateOutputType | null
    _min: TagsMinAggregateOutputType | null
    _max: TagsMaxAggregateOutputType | null
  }

  export type TagsMinAggregateOutputType = {
    id: string | null
    name: string | null
    id_parent: string | null
    deleted_at: Date | null
    slug: string | null
    img: string | null
  }

  export type TagsMaxAggregateOutputType = {
    id: string | null
    name: string | null
    id_parent: string | null
    deleted_at: Date | null
    slug: string | null
    img: string | null
  }

  export type TagsCountAggregateOutputType = {
    id: number
    name: number
    id_parent: number
    deleted_at: number
    slug: number
    img: number
    _all: number
  }


  export type TagsMinAggregateInputType = {
    id?: true
    name?: true
    id_parent?: true
    deleted_at?: true
    slug?: true
    img?: true
  }

  export type TagsMaxAggregateInputType = {
    id?: true
    name?: true
    id_parent?: true
    deleted_at?: true
    slug?: true
    img?: true
  }

  export type TagsCountAggregateInputType = {
    id?: true
    name?: true
    id_parent?: true
    deleted_at?: true
    slug?: true
    img?: true
    _all?: true
  }

  export type TagsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tags to aggregate.
     */
    where?: tagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tags to fetch.
     */
    orderBy?: tagsOrderByWithRelationInput | tagsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tags
    **/
    _count?: true | TagsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TagsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TagsMaxAggregateInputType
  }

  export type GetTagsAggregateType<T extends TagsAggregateArgs> = {
        [P in keyof T & keyof AggregateTags]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTags[P]>
      : GetScalarType<T[P], AggregateTags[P]>
  }




  export type tagsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tagsWhereInput
    orderBy?: tagsOrderByWithAggregationInput | tagsOrderByWithAggregationInput[]
    by: TagsScalarFieldEnum[] | TagsScalarFieldEnum
    having?: tagsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TagsCountAggregateInputType | true
    _min?: TagsMinAggregateInputType
    _max?: TagsMaxAggregateInputType
  }

  export type TagsGroupByOutputType = {
    id: string
    name: string
    id_parent: string | null
    deleted_at: Date | null
    slug: string | null
    img: string | null
    _count: TagsCountAggregateOutputType | null
    _min: TagsMinAggregateOutputType | null
    _max: TagsMaxAggregateOutputType | null
  }

  type GetTagsGroupByPayload<T extends tagsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TagsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TagsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TagsGroupByOutputType[P]>
            : GetScalarType<T[P], TagsGroupByOutputType[P]>
        }
      >
    >


  export type tagsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    id_parent?: boolean
    deleted_at?: boolean
    slug?: boolean
    img?: boolean
    book_tags?: boolean | tags$book_tagsArgs<ExtArgs>
    tags?: boolean | tags$tagsArgs<ExtArgs>
    other_tags?: boolean | tags$other_tagsArgs<ExtArgs>
    _count?: boolean | TagsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tags"]>

  export type tagsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    id_parent?: boolean
    deleted_at?: boolean
    slug?: boolean
    img?: boolean
    tags?: boolean | tags$tagsArgs<ExtArgs>
  }, ExtArgs["result"]["tags"]>

  export type tagsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    id_parent?: boolean
    deleted_at?: boolean
    slug?: boolean
    img?: boolean
    tags?: boolean | tags$tagsArgs<ExtArgs>
  }, ExtArgs["result"]["tags"]>

  export type tagsSelectScalar = {
    id?: boolean
    name?: boolean
    id_parent?: boolean
    deleted_at?: boolean
    slug?: boolean
    img?: boolean
  }

  export type tagsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "id_parent" | "deleted_at" | "slug" | "img", ExtArgs["result"]["tags"]>
  export type tagsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    book_tags?: boolean | tags$book_tagsArgs<ExtArgs>
    tags?: boolean | tags$tagsArgs<ExtArgs>
    other_tags?: boolean | tags$other_tagsArgs<ExtArgs>
    _count?: boolean | TagsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type tagsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tags?: boolean | tags$tagsArgs<ExtArgs>
  }
  export type tagsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tags?: boolean | tags$tagsArgs<ExtArgs>
  }

  export type $tagsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "tags"
    objects: {
      book_tags: Prisma.$book_tagsPayload<ExtArgs>[]
      tags: Prisma.$tagsPayload<ExtArgs> | null
      other_tags: Prisma.$tagsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      id_parent: string | null
      deleted_at: Date | null
      slug: string | null
      img: string | null
    }, ExtArgs["result"]["tags"]>
    composites: {}
  }

  type tagsGetPayload<S extends boolean | null | undefined | tagsDefaultArgs> = $Result.GetResult<Prisma.$tagsPayload, S>

  type tagsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<tagsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TagsCountAggregateInputType | true
    }

  export interface tagsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['tags'], meta: { name: 'tags' } }
    /**
     * Find zero or one Tags that matches the filter.
     * @param {tagsFindUniqueArgs} args - Arguments to find a Tags
     * @example
     * // Get one Tags
     * const tags = await prisma.tags.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends tagsFindUniqueArgs>(args: SelectSubset<T, tagsFindUniqueArgs<ExtArgs>>): Prisma__tagsClient<$Result.GetResult<Prisma.$tagsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tags that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {tagsFindUniqueOrThrowArgs} args - Arguments to find a Tags
     * @example
     * // Get one Tags
     * const tags = await prisma.tags.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends tagsFindUniqueOrThrowArgs>(args: SelectSubset<T, tagsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__tagsClient<$Result.GetResult<Prisma.$tagsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tagsFindFirstArgs} args - Arguments to find a Tags
     * @example
     * // Get one Tags
     * const tags = await prisma.tags.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends tagsFindFirstArgs>(args?: SelectSubset<T, tagsFindFirstArgs<ExtArgs>>): Prisma__tagsClient<$Result.GetResult<Prisma.$tagsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tags that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tagsFindFirstOrThrowArgs} args - Arguments to find a Tags
     * @example
     * // Get one Tags
     * const tags = await prisma.tags.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends tagsFindFirstOrThrowArgs>(args?: SelectSubset<T, tagsFindFirstOrThrowArgs<ExtArgs>>): Prisma__tagsClient<$Result.GetResult<Prisma.$tagsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tagsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tags
     * const tags = await prisma.tags.findMany()
     * 
     * // Get first 10 Tags
     * const tags = await prisma.tags.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tagsWithIdOnly = await prisma.tags.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends tagsFindManyArgs>(args?: SelectSubset<T, tagsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tagsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tags.
     * @param {tagsCreateArgs} args - Arguments to create a Tags.
     * @example
     * // Create one Tags
     * const Tags = await prisma.tags.create({
     *   data: {
     *     // ... data to create a Tags
     *   }
     * })
     * 
     */
    create<T extends tagsCreateArgs>(args: SelectSubset<T, tagsCreateArgs<ExtArgs>>): Prisma__tagsClient<$Result.GetResult<Prisma.$tagsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tags.
     * @param {tagsCreateManyArgs} args - Arguments to create many Tags.
     * @example
     * // Create many Tags
     * const tags = await prisma.tags.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends tagsCreateManyArgs>(args?: SelectSubset<T, tagsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tags and returns the data saved in the database.
     * @param {tagsCreateManyAndReturnArgs} args - Arguments to create many Tags.
     * @example
     * // Create many Tags
     * const tags = await prisma.tags.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tags and only return the `id`
     * const tagsWithIdOnly = await prisma.tags.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends tagsCreateManyAndReturnArgs>(args?: SelectSubset<T, tagsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tagsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Tags.
     * @param {tagsDeleteArgs} args - Arguments to delete one Tags.
     * @example
     * // Delete one Tags
     * const Tags = await prisma.tags.delete({
     *   where: {
     *     // ... filter to delete one Tags
     *   }
     * })
     * 
     */
    delete<T extends tagsDeleteArgs>(args: SelectSubset<T, tagsDeleteArgs<ExtArgs>>): Prisma__tagsClient<$Result.GetResult<Prisma.$tagsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tags.
     * @param {tagsUpdateArgs} args - Arguments to update one Tags.
     * @example
     * // Update one Tags
     * const tags = await prisma.tags.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends tagsUpdateArgs>(args: SelectSubset<T, tagsUpdateArgs<ExtArgs>>): Prisma__tagsClient<$Result.GetResult<Prisma.$tagsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tags.
     * @param {tagsDeleteManyArgs} args - Arguments to filter Tags to delete.
     * @example
     * // Delete a few Tags
     * const { count } = await prisma.tags.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends tagsDeleteManyArgs>(args?: SelectSubset<T, tagsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tagsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tags
     * const tags = await prisma.tags.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends tagsUpdateManyArgs>(args: SelectSubset<T, tagsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tags and returns the data updated in the database.
     * @param {tagsUpdateManyAndReturnArgs} args - Arguments to update many Tags.
     * @example
     * // Update many Tags
     * const tags = await prisma.tags.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Tags and only return the `id`
     * const tagsWithIdOnly = await prisma.tags.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends tagsUpdateManyAndReturnArgs>(args: SelectSubset<T, tagsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tagsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Tags.
     * @param {tagsUpsertArgs} args - Arguments to update or create a Tags.
     * @example
     * // Update or create a Tags
     * const tags = await prisma.tags.upsert({
     *   create: {
     *     // ... data to create a Tags
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tags we want to update
     *   }
     * })
     */
    upsert<T extends tagsUpsertArgs>(args: SelectSubset<T, tagsUpsertArgs<ExtArgs>>): Prisma__tagsClient<$Result.GetResult<Prisma.$tagsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tagsCountArgs} args - Arguments to filter Tags to count.
     * @example
     * // Count the number of Tags
     * const count = await prisma.tags.count({
     *   where: {
     *     // ... the filter for the Tags we want to count
     *   }
     * })
    **/
    count<T extends tagsCountArgs>(
      args?: Subset<T, tagsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TagsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TagsAggregateArgs>(args: Subset<T, TagsAggregateArgs>): Prisma.PrismaPromise<GetTagsAggregateType<T>>

    /**
     * Group by Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tagsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tagsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tagsGroupByArgs['orderBy'] }
        : { orderBy?: tagsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tagsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTagsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the tags model
   */
  readonly fields: tagsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for tags.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__tagsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    book_tags<T extends tags$book_tagsArgs<ExtArgs> = {}>(args?: Subset<T, tags$book_tagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$book_tagsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tags<T extends tags$tagsArgs<ExtArgs> = {}>(args?: Subset<T, tags$tagsArgs<ExtArgs>>): Prisma__tagsClient<$Result.GetResult<Prisma.$tagsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    other_tags<T extends tags$other_tagsArgs<ExtArgs> = {}>(args?: Subset<T, tags$other_tagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tagsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the tags model
   */
  interface tagsFieldRefs {
    readonly id: FieldRef<"tags", 'String'>
    readonly name: FieldRef<"tags", 'String'>
    readonly id_parent: FieldRef<"tags", 'String'>
    readonly deleted_at: FieldRef<"tags", 'DateTime'>
    readonly slug: FieldRef<"tags", 'String'>
    readonly img: FieldRef<"tags", 'String'>
  }
    

  // Custom InputTypes
  /**
   * tags findUnique
   */
  export type tagsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tags
     */
    select?: tagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tags
     */
    omit?: tagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tagsInclude<ExtArgs> | null
    /**
     * Filter, which tags to fetch.
     */
    where: tagsWhereUniqueInput
  }

  /**
   * tags findUniqueOrThrow
   */
  export type tagsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tags
     */
    select?: tagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tags
     */
    omit?: tagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tagsInclude<ExtArgs> | null
    /**
     * Filter, which tags to fetch.
     */
    where: tagsWhereUniqueInput
  }

  /**
   * tags findFirst
   */
  export type tagsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tags
     */
    select?: tagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tags
     */
    omit?: tagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tagsInclude<ExtArgs> | null
    /**
     * Filter, which tags to fetch.
     */
    where?: tagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tags to fetch.
     */
    orderBy?: tagsOrderByWithRelationInput | tagsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tags.
     */
    cursor?: tagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tags.
     */
    distinct?: TagsScalarFieldEnum | TagsScalarFieldEnum[]
  }

  /**
   * tags findFirstOrThrow
   */
  export type tagsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tags
     */
    select?: tagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tags
     */
    omit?: tagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tagsInclude<ExtArgs> | null
    /**
     * Filter, which tags to fetch.
     */
    where?: tagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tags to fetch.
     */
    orderBy?: tagsOrderByWithRelationInput | tagsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tags.
     */
    cursor?: tagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tags.
     */
    distinct?: TagsScalarFieldEnum | TagsScalarFieldEnum[]
  }

  /**
   * tags findMany
   */
  export type tagsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tags
     */
    select?: tagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tags
     */
    omit?: tagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tagsInclude<ExtArgs> | null
    /**
     * Filter, which tags to fetch.
     */
    where?: tagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tags to fetch.
     */
    orderBy?: tagsOrderByWithRelationInput | tagsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tags.
     */
    cursor?: tagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tags.
     */
    skip?: number
    distinct?: TagsScalarFieldEnum | TagsScalarFieldEnum[]
  }

  /**
   * tags create
   */
  export type tagsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tags
     */
    select?: tagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tags
     */
    omit?: tagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tagsInclude<ExtArgs> | null
    /**
     * The data needed to create a tags.
     */
    data: XOR<tagsCreateInput, tagsUncheckedCreateInput>
  }

  /**
   * tags createMany
   */
  export type tagsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tags.
     */
    data: tagsCreateManyInput | tagsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * tags createManyAndReturn
   */
  export type tagsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tags
     */
    select?: tagsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the tags
     */
    omit?: tagsOmit<ExtArgs> | null
    /**
     * The data used to create many tags.
     */
    data: tagsCreateManyInput | tagsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tagsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * tags update
   */
  export type tagsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tags
     */
    select?: tagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tags
     */
    omit?: tagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tagsInclude<ExtArgs> | null
    /**
     * The data needed to update a tags.
     */
    data: XOR<tagsUpdateInput, tagsUncheckedUpdateInput>
    /**
     * Choose, which tags to update.
     */
    where: tagsWhereUniqueInput
  }

  /**
   * tags updateMany
   */
  export type tagsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tags.
     */
    data: XOR<tagsUpdateManyMutationInput, tagsUncheckedUpdateManyInput>
    /**
     * Filter which tags to update
     */
    where?: tagsWhereInput
    /**
     * Limit how many tags to update.
     */
    limit?: number
  }

  /**
   * tags updateManyAndReturn
   */
  export type tagsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tags
     */
    select?: tagsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the tags
     */
    omit?: tagsOmit<ExtArgs> | null
    /**
     * The data used to update tags.
     */
    data: XOR<tagsUpdateManyMutationInput, tagsUncheckedUpdateManyInput>
    /**
     * Filter which tags to update
     */
    where?: tagsWhereInput
    /**
     * Limit how many tags to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tagsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * tags upsert
   */
  export type tagsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tags
     */
    select?: tagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tags
     */
    omit?: tagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tagsInclude<ExtArgs> | null
    /**
     * The filter to search for the tags to update in case it exists.
     */
    where: tagsWhereUniqueInput
    /**
     * In case the tags found by the `where` argument doesn't exist, create a new tags with this data.
     */
    create: XOR<tagsCreateInput, tagsUncheckedCreateInput>
    /**
     * In case the tags was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tagsUpdateInput, tagsUncheckedUpdateInput>
  }

  /**
   * tags delete
   */
  export type tagsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tags
     */
    select?: tagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tags
     */
    omit?: tagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tagsInclude<ExtArgs> | null
    /**
     * Filter which tags to delete.
     */
    where: tagsWhereUniqueInput
  }

  /**
   * tags deleteMany
   */
  export type tagsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tags to delete
     */
    where?: tagsWhereInput
    /**
     * Limit how many tags to delete.
     */
    limit?: number
  }

  /**
   * tags.book_tags
   */
  export type tags$book_tagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the book_tags
     */
    select?: book_tagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the book_tags
     */
    omit?: book_tagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: book_tagsInclude<ExtArgs> | null
    where?: book_tagsWhereInput
    orderBy?: book_tagsOrderByWithRelationInput | book_tagsOrderByWithRelationInput[]
    cursor?: book_tagsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Book_tagsScalarFieldEnum | Book_tagsScalarFieldEnum[]
  }

  /**
   * tags.tags
   */
  export type tags$tagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tags
     */
    select?: tagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tags
     */
    omit?: tagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tagsInclude<ExtArgs> | null
    where?: tagsWhereInput
  }

  /**
   * tags.other_tags
   */
  export type tags$other_tagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tags
     */
    select?: tagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tags
     */
    omit?: tagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tagsInclude<ExtArgs> | null
    where?: tagsWhereInput
    orderBy?: tagsOrderByWithRelationInput | tagsOrderByWithRelationInput[]
    cursor?: tagsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TagsScalarFieldEnum | TagsScalarFieldEnum[]
  }

  /**
   * tags without action
   */
  export type tagsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tags
     */
    select?: tagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tags
     */
    omit?: tagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tagsInclude<ExtArgs> | null
  }


  /**
   * Model transaction
   */

  export type AggregateTransaction = {
    _count: TransactionCountAggregateOutputType | null
    _avg: TransactionAvgAggregateOutputType | null
    _sum: TransactionSumAggregateOutputType | null
    _min: TransactionMinAggregateOutputType | null
    _max: TransactionMaxAggregateOutputType | null
  }

  export type TransactionAvgAggregateOutputType = {
    amount: Decimal | null
  }

  export type TransactionSumAggregateOutputType = {
    amount: Decimal | null
  }

  export type TransactionMinAggregateOutputType = {
    id: string | null
    id_publisher: string | null
    type: string | null
    amount: Decimal | null
    created_at: Date | null
  }

  export type TransactionMaxAggregateOutputType = {
    id: string | null
    id_publisher: string | null
    type: string | null
    amount: Decimal | null
    created_at: Date | null
  }

  export type TransactionCountAggregateOutputType = {
    id: number
    id_publisher: number
    type: number
    amount: number
    created_at: number
    info: number
    _all: number
  }


  export type TransactionAvgAggregateInputType = {
    amount?: true
  }

  export type TransactionSumAggregateInputType = {
    amount?: true
  }

  export type TransactionMinAggregateInputType = {
    id?: true
    id_publisher?: true
    type?: true
    amount?: true
    created_at?: true
  }

  export type TransactionMaxAggregateInputType = {
    id?: true
    id_publisher?: true
    type?: true
    amount?: true
    created_at?: true
  }

  export type TransactionCountAggregateInputType = {
    id?: true
    id_publisher?: true
    type?: true
    amount?: true
    created_at?: true
    info?: true
    _all?: true
  }

  export type TransactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which transaction to aggregate.
     */
    where?: transactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of transactions to fetch.
     */
    orderBy?: transactionOrderByWithRelationInput | transactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: transactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned transactions
    **/
    _count?: true | TransactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TransactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TransactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TransactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TransactionMaxAggregateInputType
  }

  export type GetTransactionAggregateType<T extends TransactionAggregateArgs> = {
        [P in keyof T & keyof AggregateTransaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTransaction[P]>
      : GetScalarType<T[P], AggregateTransaction[P]>
  }




  export type transactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: transactionWhereInput
    orderBy?: transactionOrderByWithAggregationInput | transactionOrderByWithAggregationInput[]
    by: TransactionScalarFieldEnum[] | TransactionScalarFieldEnum
    having?: transactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TransactionCountAggregateInputType | true
    _avg?: TransactionAvgAggregateInputType
    _sum?: TransactionSumAggregateInputType
    _min?: TransactionMinAggregateInputType
    _max?: TransactionMaxAggregateInputType
  }

  export type TransactionGroupByOutputType = {
    id: string
    id_publisher: string
    type: string
    amount: Decimal
    created_at: Date
    info: JsonValue
    _count: TransactionCountAggregateOutputType | null
    _avg: TransactionAvgAggregateOutputType | null
    _sum: TransactionSumAggregateOutputType | null
    _min: TransactionMinAggregateOutputType | null
    _max: TransactionMaxAggregateOutputType | null
  }

  type GetTransactionGroupByPayload<T extends transactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TransactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TransactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TransactionGroupByOutputType[P]>
            : GetScalarType<T[P], TransactionGroupByOutputType[P]>
        }
      >
    >


  export type transactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    id_publisher?: boolean
    type?: boolean
    amount?: boolean
    created_at?: boolean
    info?: boolean
    publisher?: boolean | publisherDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transaction"]>

  export type transactionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    id_publisher?: boolean
    type?: boolean
    amount?: boolean
    created_at?: boolean
    info?: boolean
    publisher?: boolean | publisherDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transaction"]>

  export type transactionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    id_publisher?: boolean
    type?: boolean
    amount?: boolean
    created_at?: boolean
    info?: boolean
    publisher?: boolean | publisherDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transaction"]>

  export type transactionSelectScalar = {
    id?: boolean
    id_publisher?: boolean
    type?: boolean
    amount?: boolean
    created_at?: boolean
    info?: boolean
  }

  export type transactionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "id_publisher" | "type" | "amount" | "created_at" | "info", ExtArgs["result"]["transaction"]>
  export type transactionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    publisher?: boolean | publisherDefaultArgs<ExtArgs>
  }
  export type transactionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    publisher?: boolean | publisherDefaultArgs<ExtArgs>
  }
  export type transactionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    publisher?: boolean | publisherDefaultArgs<ExtArgs>
  }

  export type $transactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "transaction"
    objects: {
      publisher: Prisma.$publisherPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      id_publisher: string
      type: string
      amount: Prisma.Decimal
      created_at: Date
      info: Prisma.JsonValue
    }, ExtArgs["result"]["transaction"]>
    composites: {}
  }

  type transactionGetPayload<S extends boolean | null | undefined | transactionDefaultArgs> = $Result.GetResult<Prisma.$transactionPayload, S>

  type transactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<transactionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TransactionCountAggregateInputType | true
    }

  export interface transactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['transaction'], meta: { name: 'transaction' } }
    /**
     * Find zero or one Transaction that matches the filter.
     * @param {transactionFindUniqueArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends transactionFindUniqueArgs>(args: SelectSubset<T, transactionFindUniqueArgs<ExtArgs>>): Prisma__transactionClient<$Result.GetResult<Prisma.$transactionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Transaction that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {transactionFindUniqueOrThrowArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends transactionFindUniqueOrThrowArgs>(args: SelectSubset<T, transactionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__transactionClient<$Result.GetResult<Prisma.$transactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Transaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transactionFindFirstArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends transactionFindFirstArgs>(args?: SelectSubset<T, transactionFindFirstArgs<ExtArgs>>): Prisma__transactionClient<$Result.GetResult<Prisma.$transactionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Transaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transactionFindFirstOrThrowArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends transactionFindFirstOrThrowArgs>(args?: SelectSubset<T, transactionFindFirstOrThrowArgs<ExtArgs>>): Prisma__transactionClient<$Result.GetResult<Prisma.$transactionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Transactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transactionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Transactions
     * const transactions = await prisma.transaction.findMany()
     * 
     * // Get first 10 Transactions
     * const transactions = await prisma.transaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const transactionWithIdOnly = await prisma.transaction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends transactionFindManyArgs>(args?: SelectSubset<T, transactionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$transactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Transaction.
     * @param {transactionCreateArgs} args - Arguments to create a Transaction.
     * @example
     * // Create one Transaction
     * const Transaction = await prisma.transaction.create({
     *   data: {
     *     // ... data to create a Transaction
     *   }
     * })
     * 
     */
    create<T extends transactionCreateArgs>(args: SelectSubset<T, transactionCreateArgs<ExtArgs>>): Prisma__transactionClient<$Result.GetResult<Prisma.$transactionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Transactions.
     * @param {transactionCreateManyArgs} args - Arguments to create many Transactions.
     * @example
     * // Create many Transactions
     * const transaction = await prisma.transaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends transactionCreateManyArgs>(args?: SelectSubset<T, transactionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Transactions and returns the data saved in the database.
     * @param {transactionCreateManyAndReturnArgs} args - Arguments to create many Transactions.
     * @example
     * // Create many Transactions
     * const transaction = await prisma.transaction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Transactions and only return the `id`
     * const transactionWithIdOnly = await prisma.transaction.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends transactionCreateManyAndReturnArgs>(args?: SelectSubset<T, transactionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$transactionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Transaction.
     * @param {transactionDeleteArgs} args - Arguments to delete one Transaction.
     * @example
     * // Delete one Transaction
     * const Transaction = await prisma.transaction.delete({
     *   where: {
     *     // ... filter to delete one Transaction
     *   }
     * })
     * 
     */
    delete<T extends transactionDeleteArgs>(args: SelectSubset<T, transactionDeleteArgs<ExtArgs>>): Prisma__transactionClient<$Result.GetResult<Prisma.$transactionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Transaction.
     * @param {transactionUpdateArgs} args - Arguments to update one Transaction.
     * @example
     * // Update one Transaction
     * const transaction = await prisma.transaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends transactionUpdateArgs>(args: SelectSubset<T, transactionUpdateArgs<ExtArgs>>): Prisma__transactionClient<$Result.GetResult<Prisma.$transactionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Transactions.
     * @param {transactionDeleteManyArgs} args - Arguments to filter Transactions to delete.
     * @example
     * // Delete a few Transactions
     * const { count } = await prisma.transaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends transactionDeleteManyArgs>(args?: SelectSubset<T, transactionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Transactions
     * const transaction = await prisma.transaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends transactionUpdateManyArgs>(args: SelectSubset<T, transactionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transactions and returns the data updated in the database.
     * @param {transactionUpdateManyAndReturnArgs} args - Arguments to update many Transactions.
     * @example
     * // Update many Transactions
     * const transaction = await prisma.transaction.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Transactions and only return the `id`
     * const transactionWithIdOnly = await prisma.transaction.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends transactionUpdateManyAndReturnArgs>(args: SelectSubset<T, transactionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$transactionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Transaction.
     * @param {transactionUpsertArgs} args - Arguments to update or create a Transaction.
     * @example
     * // Update or create a Transaction
     * const transaction = await prisma.transaction.upsert({
     *   create: {
     *     // ... data to create a Transaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Transaction we want to update
     *   }
     * })
     */
    upsert<T extends transactionUpsertArgs>(args: SelectSubset<T, transactionUpsertArgs<ExtArgs>>): Prisma__transactionClient<$Result.GetResult<Prisma.$transactionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transactionCountArgs} args - Arguments to filter Transactions to count.
     * @example
     * // Count the number of Transactions
     * const count = await prisma.transaction.count({
     *   where: {
     *     // ... the filter for the Transactions we want to count
     *   }
     * })
    **/
    count<T extends transactionCountArgs>(
      args?: Subset<T, transactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TransactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TransactionAggregateArgs>(args: Subset<T, TransactionAggregateArgs>): Prisma.PrismaPromise<GetTransactionAggregateType<T>>

    /**
     * Group by Transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends transactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: transactionGroupByArgs['orderBy'] }
        : { orderBy?: transactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, transactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTransactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the transaction model
   */
  readonly fields: transactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for transaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__transactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    publisher<T extends publisherDefaultArgs<ExtArgs> = {}>(args?: Subset<T, publisherDefaultArgs<ExtArgs>>): Prisma__publisherClient<$Result.GetResult<Prisma.$publisherPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the transaction model
   */
  interface transactionFieldRefs {
    readonly id: FieldRef<"transaction", 'String'>
    readonly id_publisher: FieldRef<"transaction", 'String'>
    readonly type: FieldRef<"transaction", 'String'>
    readonly amount: FieldRef<"transaction", 'Decimal'>
    readonly created_at: FieldRef<"transaction", 'DateTime'>
    readonly info: FieldRef<"transaction", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * transaction findUnique
   */
  export type transactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaction
     */
    select?: transactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transaction
     */
    omit?: transactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transactionInclude<ExtArgs> | null
    /**
     * Filter, which transaction to fetch.
     */
    where: transactionWhereUniqueInput
  }

  /**
   * transaction findUniqueOrThrow
   */
  export type transactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaction
     */
    select?: transactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transaction
     */
    omit?: transactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transactionInclude<ExtArgs> | null
    /**
     * Filter, which transaction to fetch.
     */
    where: transactionWhereUniqueInput
  }

  /**
   * transaction findFirst
   */
  export type transactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaction
     */
    select?: transactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transaction
     */
    omit?: transactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transactionInclude<ExtArgs> | null
    /**
     * Filter, which transaction to fetch.
     */
    where?: transactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of transactions to fetch.
     */
    orderBy?: transactionOrderByWithRelationInput | transactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for transactions.
     */
    cursor?: transactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of transactions.
     */
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * transaction findFirstOrThrow
   */
  export type transactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaction
     */
    select?: transactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transaction
     */
    omit?: transactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transactionInclude<ExtArgs> | null
    /**
     * Filter, which transaction to fetch.
     */
    where?: transactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of transactions to fetch.
     */
    orderBy?: transactionOrderByWithRelationInput | transactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for transactions.
     */
    cursor?: transactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of transactions.
     */
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * transaction findMany
   */
  export type transactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaction
     */
    select?: transactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transaction
     */
    omit?: transactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transactionInclude<ExtArgs> | null
    /**
     * Filter, which transactions to fetch.
     */
    where?: transactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of transactions to fetch.
     */
    orderBy?: transactionOrderByWithRelationInput | transactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing transactions.
     */
    cursor?: transactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` transactions.
     */
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * transaction create
   */
  export type transactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaction
     */
    select?: transactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transaction
     */
    omit?: transactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transactionInclude<ExtArgs> | null
    /**
     * The data needed to create a transaction.
     */
    data: XOR<transactionCreateInput, transactionUncheckedCreateInput>
  }

  /**
   * transaction createMany
   */
  export type transactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many transactions.
     */
    data: transactionCreateManyInput | transactionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * transaction createManyAndReturn
   */
  export type transactionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaction
     */
    select?: transactionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the transaction
     */
    omit?: transactionOmit<ExtArgs> | null
    /**
     * The data used to create many transactions.
     */
    data: transactionCreateManyInput | transactionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transactionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * transaction update
   */
  export type transactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaction
     */
    select?: transactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transaction
     */
    omit?: transactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transactionInclude<ExtArgs> | null
    /**
     * The data needed to update a transaction.
     */
    data: XOR<transactionUpdateInput, transactionUncheckedUpdateInput>
    /**
     * Choose, which transaction to update.
     */
    where: transactionWhereUniqueInput
  }

  /**
   * transaction updateMany
   */
  export type transactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update transactions.
     */
    data: XOR<transactionUpdateManyMutationInput, transactionUncheckedUpdateManyInput>
    /**
     * Filter which transactions to update
     */
    where?: transactionWhereInput
    /**
     * Limit how many transactions to update.
     */
    limit?: number
  }

  /**
   * transaction updateManyAndReturn
   */
  export type transactionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaction
     */
    select?: transactionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the transaction
     */
    omit?: transactionOmit<ExtArgs> | null
    /**
     * The data used to update transactions.
     */
    data: XOR<transactionUpdateManyMutationInput, transactionUncheckedUpdateManyInput>
    /**
     * Filter which transactions to update
     */
    where?: transactionWhereInput
    /**
     * Limit how many transactions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transactionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * transaction upsert
   */
  export type transactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaction
     */
    select?: transactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transaction
     */
    omit?: transactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transactionInclude<ExtArgs> | null
    /**
     * The filter to search for the transaction to update in case it exists.
     */
    where: transactionWhereUniqueInput
    /**
     * In case the transaction found by the `where` argument doesn't exist, create a new transaction with this data.
     */
    create: XOR<transactionCreateInput, transactionUncheckedCreateInput>
    /**
     * In case the transaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<transactionUpdateInput, transactionUncheckedUpdateInput>
  }

  /**
   * transaction delete
   */
  export type transactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaction
     */
    select?: transactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transaction
     */
    omit?: transactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transactionInclude<ExtArgs> | null
    /**
     * Filter which transaction to delete.
     */
    where: transactionWhereUniqueInput
  }

  /**
   * transaction deleteMany
   */
  export type transactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which transactions to delete
     */
    where?: transactionWhereInput
    /**
     * Limit how many transactions to delete.
     */
    limit?: number
  }

  /**
   * transaction without action
   */
  export type transactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaction
     */
    select?: transactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transaction
     */
    omit?: transactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transactionInclude<ExtArgs> | null
  }


  /**
   * Model withdrawal
   */

  export type AggregateWithdrawal = {
    _count: WithdrawalCountAggregateOutputType | null
    _avg: WithdrawalAvgAggregateOutputType | null
    _sum: WithdrawalSumAggregateOutputType | null
    _min: WithdrawalMinAggregateOutputType | null
    _max: WithdrawalMaxAggregateOutputType | null
  }

  export type WithdrawalAvgAggregateOutputType = {
    amount: Decimal | null
  }

  export type WithdrawalSumAggregateOutputType = {
    amount: Decimal | null
  }

  export type WithdrawalMinAggregateOutputType = {
    id: string | null
    id_publisher: string | null
    amount: Decimal | null
    status: string | null
    requested_at: Date | null
    processed_at: Date | null
  }

  export type WithdrawalMaxAggregateOutputType = {
    id: string | null
    id_publisher: string | null
    amount: Decimal | null
    status: string | null
    requested_at: Date | null
    processed_at: Date | null
  }

  export type WithdrawalCountAggregateOutputType = {
    id: number
    id_publisher: number
    amount: number
    status: number
    requested_at: number
    processed_at: number
    _all: number
  }


  export type WithdrawalAvgAggregateInputType = {
    amount?: true
  }

  export type WithdrawalSumAggregateInputType = {
    amount?: true
  }

  export type WithdrawalMinAggregateInputType = {
    id?: true
    id_publisher?: true
    amount?: true
    status?: true
    requested_at?: true
    processed_at?: true
  }

  export type WithdrawalMaxAggregateInputType = {
    id?: true
    id_publisher?: true
    amount?: true
    status?: true
    requested_at?: true
    processed_at?: true
  }

  export type WithdrawalCountAggregateInputType = {
    id?: true
    id_publisher?: true
    amount?: true
    status?: true
    requested_at?: true
    processed_at?: true
    _all?: true
  }

  export type WithdrawalAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which withdrawal to aggregate.
     */
    where?: withdrawalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of withdrawals to fetch.
     */
    orderBy?: withdrawalOrderByWithRelationInput | withdrawalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: withdrawalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` withdrawals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` withdrawals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned withdrawals
    **/
    _count?: true | WithdrawalCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WithdrawalAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WithdrawalSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WithdrawalMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WithdrawalMaxAggregateInputType
  }

  export type GetWithdrawalAggregateType<T extends WithdrawalAggregateArgs> = {
        [P in keyof T & keyof AggregateWithdrawal]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWithdrawal[P]>
      : GetScalarType<T[P], AggregateWithdrawal[P]>
  }




  export type withdrawalGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: withdrawalWhereInput
    orderBy?: withdrawalOrderByWithAggregationInput | withdrawalOrderByWithAggregationInput[]
    by: WithdrawalScalarFieldEnum[] | WithdrawalScalarFieldEnum
    having?: withdrawalScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WithdrawalCountAggregateInputType | true
    _avg?: WithdrawalAvgAggregateInputType
    _sum?: WithdrawalSumAggregateInputType
    _min?: WithdrawalMinAggregateInputType
    _max?: WithdrawalMaxAggregateInputType
  }

  export type WithdrawalGroupByOutputType = {
    id: string
    id_publisher: string
    amount: Decimal
    status: string
    requested_at: Date
    processed_at: Date | null
    _count: WithdrawalCountAggregateOutputType | null
    _avg: WithdrawalAvgAggregateOutputType | null
    _sum: WithdrawalSumAggregateOutputType | null
    _min: WithdrawalMinAggregateOutputType | null
    _max: WithdrawalMaxAggregateOutputType | null
  }

  type GetWithdrawalGroupByPayload<T extends withdrawalGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WithdrawalGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WithdrawalGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WithdrawalGroupByOutputType[P]>
            : GetScalarType<T[P], WithdrawalGroupByOutputType[P]>
        }
      >
    >


  export type withdrawalSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    id_publisher?: boolean
    amount?: boolean
    status?: boolean
    requested_at?: boolean
    processed_at?: boolean
    publisher?: boolean | publisherDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["withdrawal"]>

  export type withdrawalSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    id_publisher?: boolean
    amount?: boolean
    status?: boolean
    requested_at?: boolean
    processed_at?: boolean
    publisher?: boolean | publisherDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["withdrawal"]>

  export type withdrawalSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    id_publisher?: boolean
    amount?: boolean
    status?: boolean
    requested_at?: boolean
    processed_at?: boolean
    publisher?: boolean | publisherDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["withdrawal"]>

  export type withdrawalSelectScalar = {
    id?: boolean
    id_publisher?: boolean
    amount?: boolean
    status?: boolean
    requested_at?: boolean
    processed_at?: boolean
  }

  export type withdrawalOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "id_publisher" | "amount" | "status" | "requested_at" | "processed_at", ExtArgs["result"]["withdrawal"]>
  export type withdrawalInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    publisher?: boolean | publisherDefaultArgs<ExtArgs>
  }
  export type withdrawalIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    publisher?: boolean | publisherDefaultArgs<ExtArgs>
  }
  export type withdrawalIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    publisher?: boolean | publisherDefaultArgs<ExtArgs>
  }

  export type $withdrawalPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "withdrawal"
    objects: {
      publisher: Prisma.$publisherPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      id_publisher: string
      amount: Prisma.Decimal
      status: string
      requested_at: Date
      processed_at: Date | null
    }, ExtArgs["result"]["withdrawal"]>
    composites: {}
  }

  type withdrawalGetPayload<S extends boolean | null | undefined | withdrawalDefaultArgs> = $Result.GetResult<Prisma.$withdrawalPayload, S>

  type withdrawalCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<withdrawalFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WithdrawalCountAggregateInputType | true
    }

  export interface withdrawalDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['withdrawal'], meta: { name: 'withdrawal' } }
    /**
     * Find zero or one Withdrawal that matches the filter.
     * @param {withdrawalFindUniqueArgs} args - Arguments to find a Withdrawal
     * @example
     * // Get one Withdrawal
     * const withdrawal = await prisma.withdrawal.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends withdrawalFindUniqueArgs>(args: SelectSubset<T, withdrawalFindUniqueArgs<ExtArgs>>): Prisma__withdrawalClient<$Result.GetResult<Prisma.$withdrawalPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Withdrawal that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {withdrawalFindUniqueOrThrowArgs} args - Arguments to find a Withdrawal
     * @example
     * // Get one Withdrawal
     * const withdrawal = await prisma.withdrawal.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends withdrawalFindUniqueOrThrowArgs>(args: SelectSubset<T, withdrawalFindUniqueOrThrowArgs<ExtArgs>>): Prisma__withdrawalClient<$Result.GetResult<Prisma.$withdrawalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Withdrawal that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {withdrawalFindFirstArgs} args - Arguments to find a Withdrawal
     * @example
     * // Get one Withdrawal
     * const withdrawal = await prisma.withdrawal.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends withdrawalFindFirstArgs>(args?: SelectSubset<T, withdrawalFindFirstArgs<ExtArgs>>): Prisma__withdrawalClient<$Result.GetResult<Prisma.$withdrawalPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Withdrawal that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {withdrawalFindFirstOrThrowArgs} args - Arguments to find a Withdrawal
     * @example
     * // Get one Withdrawal
     * const withdrawal = await prisma.withdrawal.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends withdrawalFindFirstOrThrowArgs>(args?: SelectSubset<T, withdrawalFindFirstOrThrowArgs<ExtArgs>>): Prisma__withdrawalClient<$Result.GetResult<Prisma.$withdrawalPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Withdrawals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {withdrawalFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Withdrawals
     * const withdrawals = await prisma.withdrawal.findMany()
     * 
     * // Get first 10 Withdrawals
     * const withdrawals = await prisma.withdrawal.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const withdrawalWithIdOnly = await prisma.withdrawal.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends withdrawalFindManyArgs>(args?: SelectSubset<T, withdrawalFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$withdrawalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Withdrawal.
     * @param {withdrawalCreateArgs} args - Arguments to create a Withdrawal.
     * @example
     * // Create one Withdrawal
     * const Withdrawal = await prisma.withdrawal.create({
     *   data: {
     *     // ... data to create a Withdrawal
     *   }
     * })
     * 
     */
    create<T extends withdrawalCreateArgs>(args: SelectSubset<T, withdrawalCreateArgs<ExtArgs>>): Prisma__withdrawalClient<$Result.GetResult<Prisma.$withdrawalPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Withdrawals.
     * @param {withdrawalCreateManyArgs} args - Arguments to create many Withdrawals.
     * @example
     * // Create many Withdrawals
     * const withdrawal = await prisma.withdrawal.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends withdrawalCreateManyArgs>(args?: SelectSubset<T, withdrawalCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Withdrawals and returns the data saved in the database.
     * @param {withdrawalCreateManyAndReturnArgs} args - Arguments to create many Withdrawals.
     * @example
     * // Create many Withdrawals
     * const withdrawal = await prisma.withdrawal.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Withdrawals and only return the `id`
     * const withdrawalWithIdOnly = await prisma.withdrawal.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends withdrawalCreateManyAndReturnArgs>(args?: SelectSubset<T, withdrawalCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$withdrawalPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Withdrawal.
     * @param {withdrawalDeleteArgs} args - Arguments to delete one Withdrawal.
     * @example
     * // Delete one Withdrawal
     * const Withdrawal = await prisma.withdrawal.delete({
     *   where: {
     *     // ... filter to delete one Withdrawal
     *   }
     * })
     * 
     */
    delete<T extends withdrawalDeleteArgs>(args: SelectSubset<T, withdrawalDeleteArgs<ExtArgs>>): Prisma__withdrawalClient<$Result.GetResult<Prisma.$withdrawalPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Withdrawal.
     * @param {withdrawalUpdateArgs} args - Arguments to update one Withdrawal.
     * @example
     * // Update one Withdrawal
     * const withdrawal = await prisma.withdrawal.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends withdrawalUpdateArgs>(args: SelectSubset<T, withdrawalUpdateArgs<ExtArgs>>): Prisma__withdrawalClient<$Result.GetResult<Prisma.$withdrawalPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Withdrawals.
     * @param {withdrawalDeleteManyArgs} args - Arguments to filter Withdrawals to delete.
     * @example
     * // Delete a few Withdrawals
     * const { count } = await prisma.withdrawal.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends withdrawalDeleteManyArgs>(args?: SelectSubset<T, withdrawalDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Withdrawals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {withdrawalUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Withdrawals
     * const withdrawal = await prisma.withdrawal.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends withdrawalUpdateManyArgs>(args: SelectSubset<T, withdrawalUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Withdrawals and returns the data updated in the database.
     * @param {withdrawalUpdateManyAndReturnArgs} args - Arguments to update many Withdrawals.
     * @example
     * // Update many Withdrawals
     * const withdrawal = await prisma.withdrawal.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Withdrawals and only return the `id`
     * const withdrawalWithIdOnly = await prisma.withdrawal.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends withdrawalUpdateManyAndReturnArgs>(args: SelectSubset<T, withdrawalUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$withdrawalPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Withdrawal.
     * @param {withdrawalUpsertArgs} args - Arguments to update or create a Withdrawal.
     * @example
     * // Update or create a Withdrawal
     * const withdrawal = await prisma.withdrawal.upsert({
     *   create: {
     *     // ... data to create a Withdrawal
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Withdrawal we want to update
     *   }
     * })
     */
    upsert<T extends withdrawalUpsertArgs>(args: SelectSubset<T, withdrawalUpsertArgs<ExtArgs>>): Prisma__withdrawalClient<$Result.GetResult<Prisma.$withdrawalPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Withdrawals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {withdrawalCountArgs} args - Arguments to filter Withdrawals to count.
     * @example
     * // Count the number of Withdrawals
     * const count = await prisma.withdrawal.count({
     *   where: {
     *     // ... the filter for the Withdrawals we want to count
     *   }
     * })
    **/
    count<T extends withdrawalCountArgs>(
      args?: Subset<T, withdrawalCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WithdrawalCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Withdrawal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WithdrawalAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WithdrawalAggregateArgs>(args: Subset<T, WithdrawalAggregateArgs>): Prisma.PrismaPromise<GetWithdrawalAggregateType<T>>

    /**
     * Group by Withdrawal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {withdrawalGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends withdrawalGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: withdrawalGroupByArgs['orderBy'] }
        : { orderBy?: withdrawalGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, withdrawalGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWithdrawalGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the withdrawal model
   */
  readonly fields: withdrawalFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for withdrawal.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__withdrawalClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    publisher<T extends publisherDefaultArgs<ExtArgs> = {}>(args?: Subset<T, publisherDefaultArgs<ExtArgs>>): Prisma__publisherClient<$Result.GetResult<Prisma.$publisherPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the withdrawal model
   */
  interface withdrawalFieldRefs {
    readonly id: FieldRef<"withdrawal", 'String'>
    readonly id_publisher: FieldRef<"withdrawal", 'String'>
    readonly amount: FieldRef<"withdrawal", 'Decimal'>
    readonly status: FieldRef<"withdrawal", 'String'>
    readonly requested_at: FieldRef<"withdrawal", 'DateTime'>
    readonly processed_at: FieldRef<"withdrawal", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * withdrawal findUnique
   */
  export type withdrawalFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the withdrawal
     */
    select?: withdrawalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the withdrawal
     */
    omit?: withdrawalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: withdrawalInclude<ExtArgs> | null
    /**
     * Filter, which withdrawal to fetch.
     */
    where: withdrawalWhereUniqueInput
  }

  /**
   * withdrawal findUniqueOrThrow
   */
  export type withdrawalFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the withdrawal
     */
    select?: withdrawalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the withdrawal
     */
    omit?: withdrawalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: withdrawalInclude<ExtArgs> | null
    /**
     * Filter, which withdrawal to fetch.
     */
    where: withdrawalWhereUniqueInput
  }

  /**
   * withdrawal findFirst
   */
  export type withdrawalFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the withdrawal
     */
    select?: withdrawalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the withdrawal
     */
    omit?: withdrawalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: withdrawalInclude<ExtArgs> | null
    /**
     * Filter, which withdrawal to fetch.
     */
    where?: withdrawalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of withdrawals to fetch.
     */
    orderBy?: withdrawalOrderByWithRelationInput | withdrawalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for withdrawals.
     */
    cursor?: withdrawalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` withdrawals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` withdrawals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of withdrawals.
     */
    distinct?: WithdrawalScalarFieldEnum | WithdrawalScalarFieldEnum[]
  }

  /**
   * withdrawal findFirstOrThrow
   */
  export type withdrawalFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the withdrawal
     */
    select?: withdrawalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the withdrawal
     */
    omit?: withdrawalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: withdrawalInclude<ExtArgs> | null
    /**
     * Filter, which withdrawal to fetch.
     */
    where?: withdrawalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of withdrawals to fetch.
     */
    orderBy?: withdrawalOrderByWithRelationInput | withdrawalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for withdrawals.
     */
    cursor?: withdrawalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` withdrawals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` withdrawals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of withdrawals.
     */
    distinct?: WithdrawalScalarFieldEnum | WithdrawalScalarFieldEnum[]
  }

  /**
   * withdrawal findMany
   */
  export type withdrawalFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the withdrawal
     */
    select?: withdrawalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the withdrawal
     */
    omit?: withdrawalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: withdrawalInclude<ExtArgs> | null
    /**
     * Filter, which withdrawals to fetch.
     */
    where?: withdrawalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of withdrawals to fetch.
     */
    orderBy?: withdrawalOrderByWithRelationInput | withdrawalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing withdrawals.
     */
    cursor?: withdrawalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` withdrawals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` withdrawals.
     */
    skip?: number
    distinct?: WithdrawalScalarFieldEnum | WithdrawalScalarFieldEnum[]
  }

  /**
   * withdrawal create
   */
  export type withdrawalCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the withdrawal
     */
    select?: withdrawalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the withdrawal
     */
    omit?: withdrawalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: withdrawalInclude<ExtArgs> | null
    /**
     * The data needed to create a withdrawal.
     */
    data: XOR<withdrawalCreateInput, withdrawalUncheckedCreateInput>
  }

  /**
   * withdrawal createMany
   */
  export type withdrawalCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many withdrawals.
     */
    data: withdrawalCreateManyInput | withdrawalCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * withdrawal createManyAndReturn
   */
  export type withdrawalCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the withdrawal
     */
    select?: withdrawalSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the withdrawal
     */
    omit?: withdrawalOmit<ExtArgs> | null
    /**
     * The data used to create many withdrawals.
     */
    data: withdrawalCreateManyInput | withdrawalCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: withdrawalIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * withdrawal update
   */
  export type withdrawalUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the withdrawal
     */
    select?: withdrawalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the withdrawal
     */
    omit?: withdrawalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: withdrawalInclude<ExtArgs> | null
    /**
     * The data needed to update a withdrawal.
     */
    data: XOR<withdrawalUpdateInput, withdrawalUncheckedUpdateInput>
    /**
     * Choose, which withdrawal to update.
     */
    where: withdrawalWhereUniqueInput
  }

  /**
   * withdrawal updateMany
   */
  export type withdrawalUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update withdrawals.
     */
    data: XOR<withdrawalUpdateManyMutationInput, withdrawalUncheckedUpdateManyInput>
    /**
     * Filter which withdrawals to update
     */
    where?: withdrawalWhereInput
    /**
     * Limit how many withdrawals to update.
     */
    limit?: number
  }

  /**
   * withdrawal updateManyAndReturn
   */
  export type withdrawalUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the withdrawal
     */
    select?: withdrawalSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the withdrawal
     */
    omit?: withdrawalOmit<ExtArgs> | null
    /**
     * The data used to update withdrawals.
     */
    data: XOR<withdrawalUpdateManyMutationInput, withdrawalUncheckedUpdateManyInput>
    /**
     * Filter which withdrawals to update
     */
    where?: withdrawalWhereInput
    /**
     * Limit how many withdrawals to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: withdrawalIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * withdrawal upsert
   */
  export type withdrawalUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the withdrawal
     */
    select?: withdrawalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the withdrawal
     */
    omit?: withdrawalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: withdrawalInclude<ExtArgs> | null
    /**
     * The filter to search for the withdrawal to update in case it exists.
     */
    where: withdrawalWhereUniqueInput
    /**
     * In case the withdrawal found by the `where` argument doesn't exist, create a new withdrawal with this data.
     */
    create: XOR<withdrawalCreateInput, withdrawalUncheckedCreateInput>
    /**
     * In case the withdrawal was found with the provided `where` argument, update it with this data.
     */
    update: XOR<withdrawalUpdateInput, withdrawalUncheckedUpdateInput>
  }

  /**
   * withdrawal delete
   */
  export type withdrawalDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the withdrawal
     */
    select?: withdrawalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the withdrawal
     */
    omit?: withdrawalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: withdrawalInclude<ExtArgs> | null
    /**
     * Filter which withdrawal to delete.
     */
    where: withdrawalWhereUniqueInput
  }

  /**
   * withdrawal deleteMany
   */
  export type withdrawalDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which withdrawals to delete
     */
    where?: withdrawalWhereInput
    /**
     * Limit how many withdrawals to delete.
     */
    limit?: number
  }

  /**
   * withdrawal without action
   */
  export type withdrawalDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the withdrawal
     */
    select?: withdrawalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the withdrawal
     */
    omit?: withdrawalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: withdrawalInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const AffiliateScalarFieldEnum: {
    id: 'id',
    name: 'name',
    id_account: 'id_account'
  };

  export type AffiliateScalarFieldEnum = (typeof AffiliateScalarFieldEnum)[keyof typeof AffiliateScalarFieldEnum]


  export const Auth_accountScalarFieldEnum: {
    id: 'id',
    password: 'password',
    id_provider: 'id_provider',
    access_token: 'access_token',
    refresh_token: 'refresh_token',
    id_token: 'id_token',
    access_token_expires_at: 'access_token_expires_at',
    refresh_token_expires_at: 'refresh_token_expires_at',
    scope: 'scope',
    created_at: 'created_at',
    updated_at: 'updated_at',
    id_user: 'id_user',
    id_account: 'id_account'
  };

  export type Auth_accountScalarFieldEnum = (typeof Auth_accountScalarFieldEnum)[keyof typeof Auth_accountScalarFieldEnum]


  export const Auth_sessionScalarFieldEnum: {
    id: 'id',
    expires_at: 'expires_at',
    token: 'token',
    created_at: 'created_at',
    updated_at: 'updated_at',
    ip_address: 'ip_address',
    user_agent: 'user_agent',
    id_user: 'id_user'
  };

  export type Auth_sessionScalarFieldEnum = (typeof Auth_sessionScalarFieldEnum)[keyof typeof Auth_sessionScalarFieldEnum]


  export const Auth_two_factorScalarFieldEnum: {
    id: 'id',
    secret: 'secret',
    backup_codes: 'backup_codes',
    id_user: 'id_user'
  };

  export type Auth_two_factorScalarFieldEnum = (typeof Auth_two_factorScalarFieldEnum)[keyof typeof Auth_two_factorScalarFieldEnum]


  export const Auth_userScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    email_verified: 'email_verified',
    image: 'image',
    created_at: 'created_at',
    updated_at: 'updated_at',
    username: 'username',
    display_username: 'display_username',
    two_factor_enabled: 'two_factor_enabled',
    id_customer: 'id_customer',
    id_author: 'id_author',
    id_affiliate: 'id_affiliate',
    id_publisher: 'id_publisher',
    id_internal: 'id_internal'
  };

  export type Auth_userScalarFieldEnum = (typeof Auth_userScalarFieldEnum)[keyof typeof Auth_userScalarFieldEnum]


  export const Auth_verificationScalarFieldEnum: {
    id: 'id',
    identifier: 'identifier',
    value: 'value',
    expires_at: 'expires_at',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Auth_verificationScalarFieldEnum = (typeof Auth_verificationScalarFieldEnum)[keyof typeof Auth_verificationScalarFieldEnum]


  export const AuthorScalarFieldEnum: {
    id: 'id',
    name: 'name',
    id_account: 'id_account',
    biography: 'biography',
    social_media: 'social_media',
    avatar: 'avatar'
  };

  export type AuthorScalarFieldEnum = (typeof AuthorScalarFieldEnum)[keyof typeof AuthorScalarFieldEnum]


  export const BannerScalarFieldEnum: {
    id: 'id',
    title: 'title',
    banner_file: 'banner_file',
    status: 'status',
    deleted_at: 'deleted_at',
    link: 'link'
  };

  export type BannerScalarFieldEnum = (typeof BannerScalarFieldEnum)[keyof typeof BannerScalarFieldEnum]


  export const BookScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    alias: 'alias',
    submitted_price: 'submitted_price',
    desc: 'desc',
    info: 'info',
    status: 'status',
    currency: 'currency',
    deleted_at: 'deleted_at',
    img_file: 'img_file',
    cover: 'cover',
    product_file: 'product_file',
    sku: 'sku',
    id_author: 'id_author',
    published_date: 'published_date',
    is_physical: 'is_physical',
    preorder_min_qty: 'preorder_min_qty',
    content_type: 'content_type',
    is_chapter: 'is_chapter',
    id_product: 'id_product',
    created_at: 'created_at'
  };

  export type BookScalarFieldEnum = (typeof BookScalarFieldEnum)[keyof typeof BookScalarFieldEnum]


  export const Book_approvalScalarFieldEnum: {
    id: 'id',
    id_book: 'id_book',
    id_internal: 'id_internal',
    comment: 'comment',
    status: 'status',
    created_at: 'created_at'
  };

  export type Book_approvalScalarFieldEnum = (typeof Book_approvalScalarFieldEnum)[keyof typeof Book_approvalScalarFieldEnum]


  export const Book_changes_logScalarFieldEnum: {
    id_book: 'id_book',
    created_at: 'created_at',
    changes: 'changes'
  };

  export type Book_changes_logScalarFieldEnum = (typeof Book_changes_logScalarFieldEnum)[keyof typeof Book_changes_logScalarFieldEnum]


  export const Book_genreScalarFieldEnum: {
    id: 'id',
    id_genre: 'id_genre',
    id_book: 'id_book'
  };

  export type Book_genreScalarFieldEnum = (typeof Book_genreScalarFieldEnum)[keyof typeof Book_genreScalarFieldEnum]


  export const Book_tagsScalarFieldEnum: {
    id: 'id',
    id_tags: 'id_tags',
    id_book: 'id_book'
  };

  export type Book_tagsScalarFieldEnum = (typeof Book_tagsScalarFieldEnum)[keyof typeof Book_tagsScalarFieldEnum]


  export const BundleScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    strike_price: 'strike_price',
    real_price: 'real_price',
    currency: 'currency',
    desc: 'desc',
    info: 'info',
    deleted_at: 'deleted_at',
    status: 'status',
    img_file: 'img_file',
    cover: 'cover',
    sku: 'sku'
  };

  export type BundleScalarFieldEnum = (typeof BundleScalarFieldEnum)[keyof typeof BundleScalarFieldEnum]


  export const Bundle_categoryScalarFieldEnum: {
    id: 'id',
    id_category: 'id_category',
    id_bundle: 'id_bundle'
  };

  export type Bundle_categoryScalarFieldEnum = (typeof Bundle_categoryScalarFieldEnum)[keyof typeof Bundle_categoryScalarFieldEnum]


  export const Bundle_productScalarFieldEnum: {
    id_bundle: 'id_bundle',
    id_product: 'id_product',
    id: 'id',
    qty: 'qty'
  };

  export type Bundle_productScalarFieldEnum = (typeof Bundle_productScalarFieldEnum)[keyof typeof Bundle_productScalarFieldEnum]


  export const CategoryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    id_parent: 'id_parent',
    deleted_at: 'deleted_at',
    slug: 'slug',
    img: 'img'
  };

  export type CategoryScalarFieldEnum = (typeof CategoryScalarFieldEnum)[keyof typeof CategoryScalarFieldEnum]


  export const ChapterScalarFieldEnum: {
    id: 'id',
    id_product: 'id_product',
    id_book: 'id_book',
    number: 'number',
    name: 'name',
    content: 'content',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type ChapterScalarFieldEnum = (typeof ChapterScalarFieldEnum)[keyof typeof ChapterScalarFieldEnum]


  export const CustomerScalarFieldEnum: {
    id: 'id',
    whatsapp: 'whatsapp',
    deleted_at: 'deleted_at',
    otp: 'otp',
    id_account: 'id_account',
    name: 'name',
    email: 'email'
  };

  export type CustomerScalarFieldEnum = (typeof CustomerScalarFieldEnum)[keyof typeof CustomerScalarFieldEnum]


  export const Customer_readerScalarFieldEnum: {
    id: 'id',
    id_customer: 'id_customer',
    id_product: 'id_product',
    last_page: 'last_page',
    percent: 'percent'
  };

  export type Customer_readerScalarFieldEnum = (typeof Customer_readerScalarFieldEnum)[keyof typeof Customer_readerScalarFieldEnum]


  export const Customer_trackScalarFieldEnum: {
    id: 'id',
    ts: 'ts',
    id_customer: 'id_customer',
    path: 'path',
    referrer: 'referrer',
    info: 'info',
    ip: 'ip'
  };

  export type Customer_trackScalarFieldEnum = (typeof Customer_trackScalarFieldEnum)[keyof typeof Customer_trackScalarFieldEnum]


  export const GenreScalarFieldEnum: {
    id: 'id',
    name: 'name',
    id_parent: 'id_parent',
    slug: 'slug',
    img: 'img',
    deleted_at: 'deleted_at'
  };

  export type GenreScalarFieldEnum = (typeof GenreScalarFieldEnum)[keyof typeof GenreScalarFieldEnum]


  export const InternalScalarFieldEnum: {
    id: 'id',
    id_account: 'id_account',
    name: 'name',
    is_sales_and_marketing: 'is_sales_and_marketing',
    is_support: 'is_support',
    is_management: 'is_management',
    is_it: 'is_it'
  };

  export type InternalScalarFieldEnum = (typeof InternalScalarFieldEnum)[keyof typeof InternalScalarFieldEnum]


  export const LandingScalarFieldEnum: {
    id: 'id',
    slug: 'slug',
    views: 'views',
    deleted_at: 'deleted_at',
    status: 'status',
    title: 'title'
  };

  export type LandingScalarFieldEnum = (typeof LandingScalarFieldEnum)[keyof typeof LandingScalarFieldEnum]


  export const Landing_itemsScalarFieldEnum: {
    id: 'id',
    desc: 'desc',
    img_file: 'img_file',
    tag: 'tag',
    link_to: 'link_to',
    landing_id: 'landing_id',
    idx: 'idx',
    color: 'color'
  };

  export type Landing_itemsScalarFieldEnum = (typeof Landing_itemsScalarFieldEnum)[keyof typeof Landing_itemsScalarFieldEnum]


  export const MidtrxScalarFieldEnum: {
    id: 'id',
    tz: 'tz',
    type: 'type',
    payload: 'payload'
  };

  export type MidtrxScalarFieldEnum = (typeof MidtrxScalarFieldEnum)[keyof typeof MidtrxScalarFieldEnum]


  export const PreorderScalarFieldEnum: {
    id: 'id',
    id_product: 'id_product',
    min_qty: 'min_qty',
    current_qty: 'current_qty',
    status: 'status',
    deadline: 'deadline'
  };

  export type PreorderScalarFieldEnum = (typeof PreorderScalarFieldEnum)[keyof typeof PreorderScalarFieldEnum]


  export const ProductScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    alias: 'alias',
    strike_price: 'strike_price',
    real_price: 'real_price',
    desc: 'desc',
    info: 'info',
    status: 'status',
    currency: 'currency',
    deleted_at: 'deleted_at',
    img_file: 'img_file',
    cover: 'cover',
    product_file: 'product_file',
    sku: 'sku',
    id_author: 'id_author',
    published_date: 'published_date',
    is_physical: 'is_physical',
    preorder_min_qty: 'preorder_min_qty',
    content_type: 'content_type',
    is_chapter: 'is_chapter'
  };

  export type ProductScalarFieldEnum = (typeof ProductScalarFieldEnum)[keyof typeof ProductScalarFieldEnum]


  export const Product_categoryScalarFieldEnum: {
    id_product: 'id_product',
    id_category: 'id_category',
    id: 'id'
  };

  export type Product_categoryScalarFieldEnum = (typeof Product_categoryScalarFieldEnum)[keyof typeof Product_categoryScalarFieldEnum]


  export const Promo_codeScalarFieldEnum: {
    id: 'id',
    code: 'code',
    discount_type: 'discount_type',
    discount_value: 'discount_value',
    valid_from: 'valid_from',
    valid_to: 'valid_to',
    usage_limit: 'usage_limit',
    used_count: 'used_count',
    status: 'status',
    id_publisher: 'id_publisher'
  };

  export type Promo_codeScalarFieldEnum = (typeof Promo_codeScalarFieldEnum)[keyof typeof Promo_codeScalarFieldEnum]


  export const PublisherScalarFieldEnum: {
    id: 'id',
    id_account: 'id_account',
    name: 'name',
    description: 'description',
    website: 'website',
    address: 'address',
    logo: 'logo'
  };

  export type PublisherScalarFieldEnum = (typeof PublisherScalarFieldEnum)[keyof typeof PublisherScalarFieldEnum]


  export const Publisher_authorScalarFieldEnum: {
    id: 'id',
    publisher_id: 'publisher_id',
    author_id: 'author_id'
  };

  export type Publisher_authorScalarFieldEnum = (typeof Publisher_authorScalarFieldEnum)[keyof typeof Publisher_authorScalarFieldEnum]


  export const RankingScalarFieldEnum: {
    id: 'id',
    id_book: 'id_book'
  };

  export type RankingScalarFieldEnum = (typeof RankingScalarFieldEnum)[keyof typeof RankingScalarFieldEnum]


  export const ReviewsScalarFieldEnum: {
    id: 'id',
    id_book: 'id_book',
    comments: 'comments',
    rating: 'rating',
    created_at: 'created_at',
    deleted_at: 'deleted_at',
    parent: 'parent',
    id_user: 'id_user'
  };

  export type ReviewsScalarFieldEnum = (typeof ReviewsScalarFieldEnum)[keyof typeof ReviewsScalarFieldEnum]


  export const Reviews_likesScalarFieldEnum: {
    id: 'id',
    id_reviews: 'id_reviews',
    id_user: 'id_user'
  };

  export type Reviews_likesScalarFieldEnum = (typeof Reviews_likesScalarFieldEnum)[keyof typeof Reviews_likesScalarFieldEnum]


  export const T_ai_creditScalarFieldEnum: {
    id: 'id',
    id_publisher: 'id_publisher',
    balance: 'balance',
    last_topup_at: 'last_topup_at'
  };

  export type T_ai_creditScalarFieldEnum = (typeof T_ai_creditScalarFieldEnum)[keyof typeof T_ai_creditScalarFieldEnum]


  export const T_ai_credit_topupScalarFieldEnum: {
    id: 'id',
    id_t_ai_credit: 'id_t_ai_credit',
    amount: 'amount',
    created_at: 'created_at',
    status: 'status'
  };

  export type T_ai_credit_topupScalarFieldEnum = (typeof T_ai_credit_topupScalarFieldEnum)[keyof typeof T_ai_credit_topupScalarFieldEnum]


  export const T_salesScalarFieldEnum: {
    id: 'id',
    id_customer: 'id_customer',
    status: 'status',
    total: 'total',
    currency: 'currency',
    info: 'info',
    created_at: 'created_at',
    updated_at: 'updated_at',
    deleted_at: 'deleted_at',
    midtrans_order_id: 'midtrans_order_id',
    midtrans_success: 'midtrans_success',
    midtrans_pending: 'midtrans_pending',
    midtrans_error: 'midtrans_error'
  };

  export type T_salesScalarFieldEnum = (typeof T_salesScalarFieldEnum)[keyof typeof T_salesScalarFieldEnum]


  export const T_sales_downloadScalarFieldEnum: {
    id: 'id',
    id_product: 'id_product',
    id_customer: 'id_customer',
    downloaded_at: 'downloaded_at',
    ip_address: 'ip_address',
    download_key: 'download_key'
  };

  export type T_sales_downloadScalarFieldEnum = (typeof T_sales_downloadScalarFieldEnum)[keyof typeof T_sales_downloadScalarFieldEnum]


  export const T_sales_lineScalarFieldEnum: {
    id: 'id',
    id_sales: 'id_sales',
    unit_price: 'unit_price',
    qty: 'qty',
    total_price: 'total_price',
    id_product: 'id_product',
    id_bundle: 'id_bundle'
  };

  export type T_sales_lineScalarFieldEnum = (typeof T_sales_lineScalarFieldEnum)[keyof typeof T_sales_lineScalarFieldEnum]


  export const TagsScalarFieldEnum: {
    id: 'id',
    name: 'name',
    id_parent: 'id_parent',
    deleted_at: 'deleted_at',
    slug: 'slug',
    img: 'img'
  };

  export type TagsScalarFieldEnum = (typeof TagsScalarFieldEnum)[keyof typeof TagsScalarFieldEnum]


  export const TransactionScalarFieldEnum: {
    id: 'id',
    id_publisher: 'id_publisher',
    type: 'type',
    amount: 'amount',
    created_at: 'created_at',
    info: 'info'
  };

  export type TransactionScalarFieldEnum = (typeof TransactionScalarFieldEnum)[keyof typeof TransactionScalarFieldEnum]


  export const WithdrawalScalarFieldEnum: {
    id: 'id',
    id_publisher: 'id_publisher',
    amount: 'amount',
    status: 'status',
    requested_at: 'requested_at',
    processed_at: 'processed_at'
  };

  export type WithdrawalScalarFieldEnum = (typeof WithdrawalScalarFieldEnum)[keyof typeof WithdrawalScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type affiliateWhereInput = {
    AND?: affiliateWhereInput | affiliateWhereInput[]
    OR?: affiliateWhereInput[]
    NOT?: affiliateWhereInput | affiliateWhereInput[]
    id?: UuidFilter<"affiliate"> | string
    name?: StringFilter<"affiliate"> | string
    id_account?: UuidNullableFilter<"affiliate"> | string | null
    auth_account?: XOR<Auth_accountNullableScalarRelationFilter, auth_accountWhereInput> | null
    auth_user?: Auth_userListRelationFilter
  }

  export type affiliateOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    id_account?: SortOrderInput | SortOrder
    auth_account?: auth_accountOrderByWithRelationInput
    auth_user?: auth_userOrderByRelationAggregateInput
  }

  export type affiliateWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: affiliateWhereInput | affiliateWhereInput[]
    OR?: affiliateWhereInput[]
    NOT?: affiliateWhereInput | affiliateWhereInput[]
    name?: StringFilter<"affiliate"> | string
    id_account?: UuidNullableFilter<"affiliate"> | string | null
    auth_account?: XOR<Auth_accountNullableScalarRelationFilter, auth_accountWhereInput> | null
    auth_user?: Auth_userListRelationFilter
  }, "id">

  export type affiliateOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    id_account?: SortOrderInput | SortOrder
    _count?: affiliateCountOrderByAggregateInput
    _max?: affiliateMaxOrderByAggregateInput
    _min?: affiliateMinOrderByAggregateInput
  }

  export type affiliateScalarWhereWithAggregatesInput = {
    AND?: affiliateScalarWhereWithAggregatesInput | affiliateScalarWhereWithAggregatesInput[]
    OR?: affiliateScalarWhereWithAggregatesInput[]
    NOT?: affiliateScalarWhereWithAggregatesInput | affiliateScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"affiliate"> | string
    name?: StringWithAggregatesFilter<"affiliate"> | string
    id_account?: UuidNullableWithAggregatesFilter<"affiliate"> | string | null
  }

  export type auth_accountWhereInput = {
    AND?: auth_accountWhereInput | auth_accountWhereInput[]
    OR?: auth_accountWhereInput[]
    NOT?: auth_accountWhereInput | auth_accountWhereInput[]
    id?: UuidFilter<"auth_account"> | string
    password?: StringNullableFilter<"auth_account"> | string | null
    id_provider?: StringNullableFilter<"auth_account"> | string | null
    access_token?: StringNullableFilter<"auth_account"> | string | null
    refresh_token?: StringNullableFilter<"auth_account"> | string | null
    id_token?: StringNullableFilter<"auth_account"> | string | null
    access_token_expires_at?: DateTimeNullableFilter<"auth_account"> | Date | string | null
    refresh_token_expires_at?: DateTimeNullableFilter<"auth_account"> | Date | string | null
    scope?: StringNullableFilter<"auth_account"> | string | null
    created_at?: DateTimeFilter<"auth_account"> | Date | string
    updated_at?: DateTimeNullableFilter<"auth_account"> | Date | string | null
    id_user?: UuidNullableFilter<"auth_account"> | string | null
    id_account?: StringNullableFilter<"auth_account"> | string | null
    affiliate?: AffiliateListRelationFilter
    auth_user?: XOR<Auth_userNullableScalarRelationFilter, auth_userWhereInput> | null
    author?: AuthorListRelationFilter
    customer?: CustomerListRelationFilter
    internal?: InternalListRelationFilter
    publisher?: PublisherListRelationFilter
  }

  export type auth_accountOrderByWithRelationInput = {
    id?: SortOrder
    password?: SortOrderInput | SortOrder
    id_provider?: SortOrderInput | SortOrder
    access_token?: SortOrderInput | SortOrder
    refresh_token?: SortOrderInput | SortOrder
    id_token?: SortOrderInput | SortOrder
    access_token_expires_at?: SortOrderInput | SortOrder
    refresh_token_expires_at?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrderInput | SortOrder
    id_user?: SortOrderInput | SortOrder
    id_account?: SortOrderInput | SortOrder
    affiliate?: affiliateOrderByRelationAggregateInput
    auth_user?: auth_userOrderByWithRelationInput
    author?: authorOrderByRelationAggregateInput
    customer?: customerOrderByRelationAggregateInput
    internal?: internalOrderByRelationAggregateInput
    publisher?: publisherOrderByRelationAggregateInput
  }

  export type auth_accountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: auth_accountWhereInput | auth_accountWhereInput[]
    OR?: auth_accountWhereInput[]
    NOT?: auth_accountWhereInput | auth_accountWhereInput[]
    password?: StringNullableFilter<"auth_account"> | string | null
    id_provider?: StringNullableFilter<"auth_account"> | string | null
    access_token?: StringNullableFilter<"auth_account"> | string | null
    refresh_token?: StringNullableFilter<"auth_account"> | string | null
    id_token?: StringNullableFilter<"auth_account"> | string | null
    access_token_expires_at?: DateTimeNullableFilter<"auth_account"> | Date | string | null
    refresh_token_expires_at?: DateTimeNullableFilter<"auth_account"> | Date | string | null
    scope?: StringNullableFilter<"auth_account"> | string | null
    created_at?: DateTimeFilter<"auth_account"> | Date | string
    updated_at?: DateTimeNullableFilter<"auth_account"> | Date | string | null
    id_user?: UuidNullableFilter<"auth_account"> | string | null
    id_account?: StringNullableFilter<"auth_account"> | string | null
    affiliate?: AffiliateListRelationFilter
    auth_user?: XOR<Auth_userNullableScalarRelationFilter, auth_userWhereInput> | null
    author?: AuthorListRelationFilter
    customer?: CustomerListRelationFilter
    internal?: InternalListRelationFilter
    publisher?: PublisherListRelationFilter
  }, "id">

  export type auth_accountOrderByWithAggregationInput = {
    id?: SortOrder
    password?: SortOrderInput | SortOrder
    id_provider?: SortOrderInput | SortOrder
    access_token?: SortOrderInput | SortOrder
    refresh_token?: SortOrderInput | SortOrder
    id_token?: SortOrderInput | SortOrder
    access_token_expires_at?: SortOrderInput | SortOrder
    refresh_token_expires_at?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrderInput | SortOrder
    id_user?: SortOrderInput | SortOrder
    id_account?: SortOrderInput | SortOrder
    _count?: auth_accountCountOrderByAggregateInput
    _max?: auth_accountMaxOrderByAggregateInput
    _min?: auth_accountMinOrderByAggregateInput
  }

  export type auth_accountScalarWhereWithAggregatesInput = {
    AND?: auth_accountScalarWhereWithAggregatesInput | auth_accountScalarWhereWithAggregatesInput[]
    OR?: auth_accountScalarWhereWithAggregatesInput[]
    NOT?: auth_accountScalarWhereWithAggregatesInput | auth_accountScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"auth_account"> | string
    password?: StringNullableWithAggregatesFilter<"auth_account"> | string | null
    id_provider?: StringNullableWithAggregatesFilter<"auth_account"> | string | null
    access_token?: StringNullableWithAggregatesFilter<"auth_account"> | string | null
    refresh_token?: StringNullableWithAggregatesFilter<"auth_account"> | string | null
    id_token?: StringNullableWithAggregatesFilter<"auth_account"> | string | null
    access_token_expires_at?: DateTimeNullableWithAggregatesFilter<"auth_account"> | Date | string | null
    refresh_token_expires_at?: DateTimeNullableWithAggregatesFilter<"auth_account"> | Date | string | null
    scope?: StringNullableWithAggregatesFilter<"auth_account"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"auth_account"> | Date | string
    updated_at?: DateTimeNullableWithAggregatesFilter<"auth_account"> | Date | string | null
    id_user?: UuidNullableWithAggregatesFilter<"auth_account"> | string | null
    id_account?: StringNullableWithAggregatesFilter<"auth_account"> | string | null
  }

  export type auth_sessionWhereInput = {
    AND?: auth_sessionWhereInput | auth_sessionWhereInput[]
    OR?: auth_sessionWhereInput[]
    NOT?: auth_sessionWhereInput | auth_sessionWhereInput[]
    id?: UuidFilter<"auth_session"> | string
    expires_at?: DateTimeFilter<"auth_session"> | Date | string
    token?: StringFilter<"auth_session"> | string
    created_at?: DateTimeFilter<"auth_session"> | Date | string
    updated_at?: DateTimeNullableFilter<"auth_session"> | Date | string | null
    ip_address?: StringNullableFilter<"auth_session"> | string | null
    user_agent?: StringNullableFilter<"auth_session"> | string | null
    id_user?: UuidFilter<"auth_session"> | string
    auth_user?: XOR<Auth_userScalarRelationFilter, auth_userWhereInput>
  }

  export type auth_sessionOrderByWithRelationInput = {
    id?: SortOrder
    expires_at?: SortOrder
    token?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrderInput | SortOrder
    ip_address?: SortOrderInput | SortOrder
    user_agent?: SortOrderInput | SortOrder
    id_user?: SortOrder
    auth_user?: auth_userOrderByWithRelationInput
  }

  export type auth_sessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    AND?: auth_sessionWhereInput | auth_sessionWhereInput[]
    OR?: auth_sessionWhereInput[]
    NOT?: auth_sessionWhereInput | auth_sessionWhereInput[]
    expires_at?: DateTimeFilter<"auth_session"> | Date | string
    created_at?: DateTimeFilter<"auth_session"> | Date | string
    updated_at?: DateTimeNullableFilter<"auth_session"> | Date | string | null
    ip_address?: StringNullableFilter<"auth_session"> | string | null
    user_agent?: StringNullableFilter<"auth_session"> | string | null
    id_user?: UuidFilter<"auth_session"> | string
    auth_user?: XOR<Auth_userScalarRelationFilter, auth_userWhereInput>
  }, "id" | "token">

  export type auth_sessionOrderByWithAggregationInput = {
    id?: SortOrder
    expires_at?: SortOrder
    token?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrderInput | SortOrder
    ip_address?: SortOrderInput | SortOrder
    user_agent?: SortOrderInput | SortOrder
    id_user?: SortOrder
    _count?: auth_sessionCountOrderByAggregateInput
    _max?: auth_sessionMaxOrderByAggregateInput
    _min?: auth_sessionMinOrderByAggregateInput
  }

  export type auth_sessionScalarWhereWithAggregatesInput = {
    AND?: auth_sessionScalarWhereWithAggregatesInput | auth_sessionScalarWhereWithAggregatesInput[]
    OR?: auth_sessionScalarWhereWithAggregatesInput[]
    NOT?: auth_sessionScalarWhereWithAggregatesInput | auth_sessionScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"auth_session"> | string
    expires_at?: DateTimeWithAggregatesFilter<"auth_session"> | Date | string
    token?: StringWithAggregatesFilter<"auth_session"> | string
    created_at?: DateTimeWithAggregatesFilter<"auth_session"> | Date | string
    updated_at?: DateTimeNullableWithAggregatesFilter<"auth_session"> | Date | string | null
    ip_address?: StringNullableWithAggregatesFilter<"auth_session"> | string | null
    user_agent?: StringNullableWithAggregatesFilter<"auth_session"> | string | null
    id_user?: UuidWithAggregatesFilter<"auth_session"> | string
  }

  export type auth_two_factorWhereInput = {
    AND?: auth_two_factorWhereInput | auth_two_factorWhereInput[]
    OR?: auth_two_factorWhereInput[]
    NOT?: auth_two_factorWhereInput | auth_two_factorWhereInput[]
    id?: UuidFilter<"auth_two_factor"> | string
    secret?: StringNullableFilter<"auth_two_factor"> | string | null
    backup_codes?: StringNullableFilter<"auth_two_factor"> | string | null
    id_user?: UuidFilter<"auth_two_factor"> | string
    auth_user?: XOR<Auth_userScalarRelationFilter, auth_userWhereInput>
  }

  export type auth_two_factorOrderByWithRelationInput = {
    id?: SortOrder
    secret?: SortOrderInput | SortOrder
    backup_codes?: SortOrderInput | SortOrder
    id_user?: SortOrder
    auth_user?: auth_userOrderByWithRelationInput
  }

  export type auth_two_factorWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: auth_two_factorWhereInput | auth_two_factorWhereInput[]
    OR?: auth_two_factorWhereInput[]
    NOT?: auth_two_factorWhereInput | auth_two_factorWhereInput[]
    secret?: StringNullableFilter<"auth_two_factor"> | string | null
    backup_codes?: StringNullableFilter<"auth_two_factor"> | string | null
    id_user?: UuidFilter<"auth_two_factor"> | string
    auth_user?: XOR<Auth_userScalarRelationFilter, auth_userWhereInput>
  }, "id">

  export type auth_two_factorOrderByWithAggregationInput = {
    id?: SortOrder
    secret?: SortOrderInput | SortOrder
    backup_codes?: SortOrderInput | SortOrder
    id_user?: SortOrder
    _count?: auth_two_factorCountOrderByAggregateInput
    _max?: auth_two_factorMaxOrderByAggregateInput
    _min?: auth_two_factorMinOrderByAggregateInput
  }

  export type auth_two_factorScalarWhereWithAggregatesInput = {
    AND?: auth_two_factorScalarWhereWithAggregatesInput | auth_two_factorScalarWhereWithAggregatesInput[]
    OR?: auth_two_factorScalarWhereWithAggregatesInput[]
    NOT?: auth_two_factorScalarWhereWithAggregatesInput | auth_two_factorScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"auth_two_factor"> | string
    secret?: StringNullableWithAggregatesFilter<"auth_two_factor"> | string | null
    backup_codes?: StringNullableWithAggregatesFilter<"auth_two_factor"> | string | null
    id_user?: UuidWithAggregatesFilter<"auth_two_factor"> | string
  }

  export type auth_userWhereInput = {
    AND?: auth_userWhereInput | auth_userWhereInput[]
    OR?: auth_userWhereInput[]
    NOT?: auth_userWhereInput | auth_userWhereInput[]
    id?: UuidFilter<"auth_user"> | string
    name?: StringFilter<"auth_user"> | string
    email?: StringFilter<"auth_user"> | string
    email_verified?: BoolFilter<"auth_user"> | boolean
    image?: StringNullableFilter<"auth_user"> | string | null
    created_at?: DateTimeFilter<"auth_user"> | Date | string
    updated_at?: DateTimeNullableFilter<"auth_user"> | Date | string | null
    username?: StringNullableFilter<"auth_user"> | string | null
    display_username?: StringNullableFilter<"auth_user"> | string | null
    two_factor_enabled?: BoolNullableFilter<"auth_user"> | boolean | null
    id_customer?: UuidNullableFilter<"auth_user"> | string | null
    id_author?: UuidNullableFilter<"auth_user"> | string | null
    id_affiliate?: UuidNullableFilter<"auth_user"> | string | null
    id_publisher?: UuidNullableFilter<"auth_user"> | string | null
    id_internal?: UuidNullableFilter<"auth_user"> | string | null
    auth_account?: Auth_accountListRelationFilter
    auth_session?: Auth_sessionListRelationFilter
    auth_two_factor?: Auth_two_factorListRelationFilter
    affiliate?: XOR<AffiliateNullableScalarRelationFilter, affiliateWhereInput> | null
    author?: XOR<AuthorNullableScalarRelationFilter, authorWhereInput> | null
    customer?: XOR<CustomerNullableScalarRelationFilter, customerWhereInput> | null
    internal?: XOR<InternalNullableScalarRelationFilter, internalWhereInput> | null
    publisher?: XOR<PublisherNullableScalarRelationFilter, publisherWhereInput> | null
    reviews?: ReviewsListRelationFilter
    reviews_likes?: Reviews_likesListRelationFilter
  }

  export type auth_userOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    email_verified?: SortOrder
    image?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrderInput | SortOrder
    username?: SortOrderInput | SortOrder
    display_username?: SortOrderInput | SortOrder
    two_factor_enabled?: SortOrderInput | SortOrder
    id_customer?: SortOrderInput | SortOrder
    id_author?: SortOrderInput | SortOrder
    id_affiliate?: SortOrderInput | SortOrder
    id_publisher?: SortOrderInput | SortOrder
    id_internal?: SortOrderInput | SortOrder
    auth_account?: auth_accountOrderByRelationAggregateInput
    auth_session?: auth_sessionOrderByRelationAggregateInput
    auth_two_factor?: auth_two_factorOrderByRelationAggregateInput
    affiliate?: affiliateOrderByWithRelationInput
    author?: authorOrderByWithRelationInput
    customer?: customerOrderByWithRelationInput
    internal?: internalOrderByWithRelationInput
    publisher?: publisherOrderByWithRelationInput
    reviews?: reviewsOrderByRelationAggregateInput
    reviews_likes?: reviews_likesOrderByRelationAggregateInput
  }

  export type auth_userWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: auth_userWhereInput | auth_userWhereInput[]
    OR?: auth_userWhereInput[]
    NOT?: auth_userWhereInput | auth_userWhereInput[]
    name?: StringFilter<"auth_user"> | string
    email_verified?: BoolFilter<"auth_user"> | boolean
    image?: StringNullableFilter<"auth_user"> | string | null
    created_at?: DateTimeFilter<"auth_user"> | Date | string
    updated_at?: DateTimeNullableFilter<"auth_user"> | Date | string | null
    username?: StringNullableFilter<"auth_user"> | string | null
    display_username?: StringNullableFilter<"auth_user"> | string | null
    two_factor_enabled?: BoolNullableFilter<"auth_user"> | boolean | null
    id_customer?: UuidNullableFilter<"auth_user"> | string | null
    id_author?: UuidNullableFilter<"auth_user"> | string | null
    id_affiliate?: UuidNullableFilter<"auth_user"> | string | null
    id_publisher?: UuidNullableFilter<"auth_user"> | string | null
    id_internal?: UuidNullableFilter<"auth_user"> | string | null
    auth_account?: Auth_accountListRelationFilter
    auth_session?: Auth_sessionListRelationFilter
    auth_two_factor?: Auth_two_factorListRelationFilter
    affiliate?: XOR<AffiliateNullableScalarRelationFilter, affiliateWhereInput> | null
    author?: XOR<AuthorNullableScalarRelationFilter, authorWhereInput> | null
    customer?: XOR<CustomerNullableScalarRelationFilter, customerWhereInput> | null
    internal?: XOR<InternalNullableScalarRelationFilter, internalWhereInput> | null
    publisher?: XOR<PublisherNullableScalarRelationFilter, publisherWhereInput> | null
    reviews?: ReviewsListRelationFilter
    reviews_likes?: Reviews_likesListRelationFilter
  }, "id" | "email">

  export type auth_userOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    email_verified?: SortOrder
    image?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrderInput | SortOrder
    username?: SortOrderInput | SortOrder
    display_username?: SortOrderInput | SortOrder
    two_factor_enabled?: SortOrderInput | SortOrder
    id_customer?: SortOrderInput | SortOrder
    id_author?: SortOrderInput | SortOrder
    id_affiliate?: SortOrderInput | SortOrder
    id_publisher?: SortOrderInput | SortOrder
    id_internal?: SortOrderInput | SortOrder
    _count?: auth_userCountOrderByAggregateInput
    _max?: auth_userMaxOrderByAggregateInput
    _min?: auth_userMinOrderByAggregateInput
  }

  export type auth_userScalarWhereWithAggregatesInput = {
    AND?: auth_userScalarWhereWithAggregatesInput | auth_userScalarWhereWithAggregatesInput[]
    OR?: auth_userScalarWhereWithAggregatesInput[]
    NOT?: auth_userScalarWhereWithAggregatesInput | auth_userScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"auth_user"> | string
    name?: StringWithAggregatesFilter<"auth_user"> | string
    email?: StringWithAggregatesFilter<"auth_user"> | string
    email_verified?: BoolWithAggregatesFilter<"auth_user"> | boolean
    image?: StringNullableWithAggregatesFilter<"auth_user"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"auth_user"> | Date | string
    updated_at?: DateTimeNullableWithAggregatesFilter<"auth_user"> | Date | string | null
    username?: StringNullableWithAggregatesFilter<"auth_user"> | string | null
    display_username?: StringNullableWithAggregatesFilter<"auth_user"> | string | null
    two_factor_enabled?: BoolNullableWithAggregatesFilter<"auth_user"> | boolean | null
    id_customer?: UuidNullableWithAggregatesFilter<"auth_user"> | string | null
    id_author?: UuidNullableWithAggregatesFilter<"auth_user"> | string | null
    id_affiliate?: UuidNullableWithAggregatesFilter<"auth_user"> | string | null
    id_publisher?: UuidNullableWithAggregatesFilter<"auth_user"> | string | null
    id_internal?: UuidNullableWithAggregatesFilter<"auth_user"> | string | null
  }

  export type auth_verificationWhereInput = {
    AND?: auth_verificationWhereInput | auth_verificationWhereInput[]
    OR?: auth_verificationWhereInput[]
    NOT?: auth_verificationWhereInput | auth_verificationWhereInput[]
    id?: UuidFilter<"auth_verification"> | string
    identifier?: StringFilter<"auth_verification"> | string
    value?: StringFilter<"auth_verification"> | string
    expires_at?: DateTimeFilter<"auth_verification"> | Date | string
    created_at?: DateTimeFilter<"auth_verification"> | Date | string
    updated_at?: DateTimeNullableFilter<"auth_verification"> | Date | string | null
  }

  export type auth_verificationOrderByWithRelationInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expires_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrderInput | SortOrder
  }

  export type auth_verificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: auth_verificationWhereInput | auth_verificationWhereInput[]
    OR?: auth_verificationWhereInput[]
    NOT?: auth_verificationWhereInput | auth_verificationWhereInput[]
    identifier?: StringFilter<"auth_verification"> | string
    value?: StringFilter<"auth_verification"> | string
    expires_at?: DateTimeFilter<"auth_verification"> | Date | string
    created_at?: DateTimeFilter<"auth_verification"> | Date | string
    updated_at?: DateTimeNullableFilter<"auth_verification"> | Date | string | null
  }, "id">

  export type auth_verificationOrderByWithAggregationInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expires_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrderInput | SortOrder
    _count?: auth_verificationCountOrderByAggregateInput
    _max?: auth_verificationMaxOrderByAggregateInput
    _min?: auth_verificationMinOrderByAggregateInput
  }

  export type auth_verificationScalarWhereWithAggregatesInput = {
    AND?: auth_verificationScalarWhereWithAggregatesInput | auth_verificationScalarWhereWithAggregatesInput[]
    OR?: auth_verificationScalarWhereWithAggregatesInput[]
    NOT?: auth_verificationScalarWhereWithAggregatesInput | auth_verificationScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"auth_verification"> | string
    identifier?: StringWithAggregatesFilter<"auth_verification"> | string
    value?: StringWithAggregatesFilter<"auth_verification"> | string
    expires_at?: DateTimeWithAggregatesFilter<"auth_verification"> | Date | string
    created_at?: DateTimeWithAggregatesFilter<"auth_verification"> | Date | string
    updated_at?: DateTimeNullableWithAggregatesFilter<"auth_verification"> | Date | string | null
  }

  export type authorWhereInput = {
    AND?: authorWhereInput | authorWhereInput[]
    OR?: authorWhereInput[]
    NOT?: authorWhereInput | authorWhereInput[]
    id?: UuidFilter<"author"> | string
    name?: StringFilter<"author"> | string
    id_account?: UuidNullableFilter<"author"> | string | null
    biography?: StringNullableFilter<"author"> | string | null
    social_media?: StringNullableFilter<"author"> | string | null
    avatar?: StringNullableFilter<"author"> | string | null
    auth_user?: Auth_userListRelationFilter
    auth_account?: XOR<Auth_accountNullableScalarRelationFilter, auth_accountWhereInput> | null
    book?: BookListRelationFilter
    product?: ProductListRelationFilter
    publisher_author?: Publisher_authorListRelationFilter
  }

  export type authorOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    id_account?: SortOrderInput | SortOrder
    biography?: SortOrderInput | SortOrder
    social_media?: SortOrderInput | SortOrder
    avatar?: SortOrderInput | SortOrder
    auth_user?: auth_userOrderByRelationAggregateInput
    auth_account?: auth_accountOrderByWithRelationInput
    book?: bookOrderByRelationAggregateInput
    product?: productOrderByRelationAggregateInput
    publisher_author?: publisher_authorOrderByRelationAggregateInput
  }

  export type authorWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: authorWhereInput | authorWhereInput[]
    OR?: authorWhereInput[]
    NOT?: authorWhereInput | authorWhereInput[]
    name?: StringFilter<"author"> | string
    id_account?: UuidNullableFilter<"author"> | string | null
    biography?: StringNullableFilter<"author"> | string | null
    social_media?: StringNullableFilter<"author"> | string | null
    avatar?: StringNullableFilter<"author"> | string | null
    auth_user?: Auth_userListRelationFilter
    auth_account?: XOR<Auth_accountNullableScalarRelationFilter, auth_accountWhereInput> | null
    book?: BookListRelationFilter
    product?: ProductListRelationFilter
    publisher_author?: Publisher_authorListRelationFilter
  }, "id">

  export type authorOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    id_account?: SortOrderInput | SortOrder
    biography?: SortOrderInput | SortOrder
    social_media?: SortOrderInput | SortOrder
    avatar?: SortOrderInput | SortOrder
    _count?: authorCountOrderByAggregateInput
    _max?: authorMaxOrderByAggregateInput
    _min?: authorMinOrderByAggregateInput
  }

  export type authorScalarWhereWithAggregatesInput = {
    AND?: authorScalarWhereWithAggregatesInput | authorScalarWhereWithAggregatesInput[]
    OR?: authorScalarWhereWithAggregatesInput[]
    NOT?: authorScalarWhereWithAggregatesInput | authorScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"author"> | string
    name?: StringWithAggregatesFilter<"author"> | string
    id_account?: UuidNullableWithAggregatesFilter<"author"> | string | null
    biography?: StringNullableWithAggregatesFilter<"author"> | string | null
    social_media?: StringNullableWithAggregatesFilter<"author"> | string | null
    avatar?: StringNullableWithAggregatesFilter<"author"> | string | null
  }

  export type bannerWhereInput = {
    AND?: bannerWhereInput | bannerWhereInput[]
    OR?: bannerWhereInput[]
    NOT?: bannerWhereInput | bannerWhereInput[]
    id?: UuidFilter<"banner"> | string
    title?: StringFilter<"banner"> | string
    banner_file?: StringFilter<"banner"> | string
    status?: StringNullableFilter<"banner"> | string | null
    deleted_at?: DateTimeNullableFilter<"banner"> | Date | string | null
    link?: StringNullableFilter<"banner"> | string | null
  }

  export type bannerOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    banner_file?: SortOrder
    status?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
    link?: SortOrderInput | SortOrder
  }

  export type bannerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: bannerWhereInput | bannerWhereInput[]
    OR?: bannerWhereInput[]
    NOT?: bannerWhereInput | bannerWhereInput[]
    title?: StringFilter<"banner"> | string
    banner_file?: StringFilter<"banner"> | string
    status?: StringNullableFilter<"banner"> | string | null
    deleted_at?: DateTimeNullableFilter<"banner"> | Date | string | null
    link?: StringNullableFilter<"banner"> | string | null
  }, "id">

  export type bannerOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    banner_file?: SortOrder
    status?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
    link?: SortOrderInput | SortOrder
    _count?: bannerCountOrderByAggregateInput
    _max?: bannerMaxOrderByAggregateInput
    _min?: bannerMinOrderByAggregateInput
  }

  export type bannerScalarWhereWithAggregatesInput = {
    AND?: bannerScalarWhereWithAggregatesInput | bannerScalarWhereWithAggregatesInput[]
    OR?: bannerScalarWhereWithAggregatesInput[]
    NOT?: bannerScalarWhereWithAggregatesInput | bannerScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"banner"> | string
    title?: StringWithAggregatesFilter<"banner"> | string
    banner_file?: StringWithAggregatesFilter<"banner"> | string
    status?: StringNullableWithAggregatesFilter<"banner"> | string | null
    deleted_at?: DateTimeNullableWithAggregatesFilter<"banner"> | Date | string | null
    link?: StringNullableWithAggregatesFilter<"banner"> | string | null
  }

  export type bookWhereInput = {
    AND?: bookWhereInput | bookWhereInput[]
    OR?: bookWhereInput[]
    NOT?: bookWhereInput | bookWhereInput[]
    id?: UuidFilter<"book"> | string
    name?: StringFilter<"book"> | string
    slug?: StringFilter<"book"> | string
    alias?: StringFilter<"book"> | string
    submitted_price?: DecimalFilter<"book"> | Decimal | DecimalJsLike | number | string
    desc?: StringFilter<"book"> | string
    info?: JsonNullableFilter<"book">
    status?: StringFilter<"book"> | string
    currency?: StringFilter<"book"> | string
    deleted_at?: DateTimeNullableFilter<"book"> | Date | string | null
    img_file?: StringFilter<"book"> | string
    cover?: StringFilter<"book"> | string
    product_file?: StringFilter<"book"> | string
    sku?: StringFilter<"book"> | string
    id_author?: UuidNullableFilter<"book"> | string | null
    published_date?: DateTimeFilter<"book"> | Date | string
    is_physical?: BoolFilter<"book"> | boolean
    preorder_min_qty?: IntNullableFilter<"book"> | number | null
    content_type?: StringNullableFilter<"book"> | string | null
    is_chapter?: BoolFilter<"book"> | boolean
    id_product?: UuidNullableFilter<"book"> | string | null
    created_at?: DateTimeFilter<"book"> | Date | string
    author?: XOR<AuthorNullableScalarRelationFilter, authorWhereInput> | null
    product?: XOR<ProductNullableScalarRelationFilter, productWhereInput> | null
    book_approval?: Book_approvalListRelationFilter
    book_changes_log?: Book_changes_logListRelationFilter
    book_genre?: Book_genreListRelationFilter
    book_tags?: Book_tagsListRelationFilter
    chapter?: ChapterListRelationFilter
    ranking?: RankingListRelationFilter
    reviews?: ReviewsListRelationFilter
  }

  export type bookOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    alias?: SortOrder
    submitted_price?: SortOrder
    desc?: SortOrder
    info?: SortOrderInput | SortOrder
    status?: SortOrder
    currency?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    img_file?: SortOrder
    cover?: SortOrder
    product_file?: SortOrder
    sku?: SortOrder
    id_author?: SortOrderInput | SortOrder
    published_date?: SortOrder
    is_physical?: SortOrder
    preorder_min_qty?: SortOrderInput | SortOrder
    content_type?: SortOrderInput | SortOrder
    is_chapter?: SortOrder
    id_product?: SortOrderInput | SortOrder
    created_at?: SortOrder
    author?: authorOrderByWithRelationInput
    product?: productOrderByWithRelationInput
    book_approval?: book_approvalOrderByRelationAggregateInput
    book_changes_log?: book_changes_logOrderByRelationAggregateInput
    book_genre?: book_genreOrderByRelationAggregateInput
    book_tags?: book_tagsOrderByRelationAggregateInput
    chapter?: chapterOrderByRelationAggregateInput
    ranking?: rankingOrderByRelationAggregateInput
    reviews?: reviewsOrderByRelationAggregateInput
  }

  export type bookWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: bookWhereInput | bookWhereInput[]
    OR?: bookWhereInput[]
    NOT?: bookWhereInput | bookWhereInput[]
    name?: StringFilter<"book"> | string
    slug?: StringFilter<"book"> | string
    alias?: StringFilter<"book"> | string
    submitted_price?: DecimalFilter<"book"> | Decimal | DecimalJsLike | number | string
    desc?: StringFilter<"book"> | string
    info?: JsonNullableFilter<"book">
    status?: StringFilter<"book"> | string
    currency?: StringFilter<"book"> | string
    deleted_at?: DateTimeNullableFilter<"book"> | Date | string | null
    img_file?: StringFilter<"book"> | string
    cover?: StringFilter<"book"> | string
    product_file?: StringFilter<"book"> | string
    sku?: StringFilter<"book"> | string
    id_author?: UuidNullableFilter<"book"> | string | null
    published_date?: DateTimeFilter<"book"> | Date | string
    is_physical?: BoolFilter<"book"> | boolean
    preorder_min_qty?: IntNullableFilter<"book"> | number | null
    content_type?: StringNullableFilter<"book"> | string | null
    is_chapter?: BoolFilter<"book"> | boolean
    id_product?: UuidNullableFilter<"book"> | string | null
    created_at?: DateTimeFilter<"book"> | Date | string
    author?: XOR<AuthorNullableScalarRelationFilter, authorWhereInput> | null
    product?: XOR<ProductNullableScalarRelationFilter, productWhereInput> | null
    book_approval?: Book_approvalListRelationFilter
    book_changes_log?: Book_changes_logListRelationFilter
    book_genre?: Book_genreListRelationFilter
    book_tags?: Book_tagsListRelationFilter
    chapter?: ChapterListRelationFilter
    ranking?: RankingListRelationFilter
    reviews?: ReviewsListRelationFilter
  }, "id">

  export type bookOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    alias?: SortOrder
    submitted_price?: SortOrder
    desc?: SortOrder
    info?: SortOrderInput | SortOrder
    status?: SortOrder
    currency?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    img_file?: SortOrder
    cover?: SortOrder
    product_file?: SortOrder
    sku?: SortOrder
    id_author?: SortOrderInput | SortOrder
    published_date?: SortOrder
    is_physical?: SortOrder
    preorder_min_qty?: SortOrderInput | SortOrder
    content_type?: SortOrderInput | SortOrder
    is_chapter?: SortOrder
    id_product?: SortOrderInput | SortOrder
    created_at?: SortOrder
    _count?: bookCountOrderByAggregateInput
    _avg?: bookAvgOrderByAggregateInput
    _max?: bookMaxOrderByAggregateInput
    _min?: bookMinOrderByAggregateInput
    _sum?: bookSumOrderByAggregateInput
  }

  export type bookScalarWhereWithAggregatesInput = {
    AND?: bookScalarWhereWithAggregatesInput | bookScalarWhereWithAggregatesInput[]
    OR?: bookScalarWhereWithAggregatesInput[]
    NOT?: bookScalarWhereWithAggregatesInput | bookScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"book"> | string
    name?: StringWithAggregatesFilter<"book"> | string
    slug?: StringWithAggregatesFilter<"book"> | string
    alias?: StringWithAggregatesFilter<"book"> | string
    submitted_price?: DecimalWithAggregatesFilter<"book"> | Decimal | DecimalJsLike | number | string
    desc?: StringWithAggregatesFilter<"book"> | string
    info?: JsonNullableWithAggregatesFilter<"book">
    status?: StringWithAggregatesFilter<"book"> | string
    currency?: StringWithAggregatesFilter<"book"> | string
    deleted_at?: DateTimeNullableWithAggregatesFilter<"book"> | Date | string | null
    img_file?: StringWithAggregatesFilter<"book"> | string
    cover?: StringWithAggregatesFilter<"book"> | string
    product_file?: StringWithAggregatesFilter<"book"> | string
    sku?: StringWithAggregatesFilter<"book"> | string
    id_author?: UuidNullableWithAggregatesFilter<"book"> | string | null
    published_date?: DateTimeWithAggregatesFilter<"book"> | Date | string
    is_physical?: BoolWithAggregatesFilter<"book"> | boolean
    preorder_min_qty?: IntNullableWithAggregatesFilter<"book"> | number | null
    content_type?: StringNullableWithAggregatesFilter<"book"> | string | null
    is_chapter?: BoolWithAggregatesFilter<"book"> | boolean
    id_product?: UuidNullableWithAggregatesFilter<"book"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"book"> | Date | string
  }

  export type book_approvalWhereInput = {
    AND?: book_approvalWhereInput | book_approvalWhereInput[]
    OR?: book_approvalWhereInput[]
    NOT?: book_approvalWhereInput | book_approvalWhereInput[]
    id?: UuidFilter<"book_approval"> | string
    id_book?: UuidFilter<"book_approval"> | string
    id_internal?: UuidNullableFilter<"book_approval"> | string | null
    comment?: JsonNullableFilter<"book_approval">
    status?: StringFilter<"book_approval"> | string
    created_at?: DateTimeFilter<"book_approval"> | Date | string
    book?: XOR<BookScalarRelationFilter, bookWhereInput>
    internal?: XOR<InternalNullableScalarRelationFilter, internalWhereInput> | null
  }

  export type book_approvalOrderByWithRelationInput = {
    id?: SortOrder
    id_book?: SortOrder
    id_internal?: SortOrderInput | SortOrder
    comment?: SortOrderInput | SortOrder
    status?: SortOrder
    created_at?: SortOrder
    book?: bookOrderByWithRelationInput
    internal?: internalOrderByWithRelationInput
  }

  export type book_approvalWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: book_approvalWhereInput | book_approvalWhereInput[]
    OR?: book_approvalWhereInput[]
    NOT?: book_approvalWhereInput | book_approvalWhereInput[]
    id_book?: UuidFilter<"book_approval"> | string
    id_internal?: UuidNullableFilter<"book_approval"> | string | null
    comment?: JsonNullableFilter<"book_approval">
    status?: StringFilter<"book_approval"> | string
    created_at?: DateTimeFilter<"book_approval"> | Date | string
    book?: XOR<BookScalarRelationFilter, bookWhereInput>
    internal?: XOR<InternalNullableScalarRelationFilter, internalWhereInput> | null
  }, "id">

  export type book_approvalOrderByWithAggregationInput = {
    id?: SortOrder
    id_book?: SortOrder
    id_internal?: SortOrderInput | SortOrder
    comment?: SortOrderInput | SortOrder
    status?: SortOrder
    created_at?: SortOrder
    _count?: book_approvalCountOrderByAggregateInput
    _max?: book_approvalMaxOrderByAggregateInput
    _min?: book_approvalMinOrderByAggregateInput
  }

  export type book_approvalScalarWhereWithAggregatesInput = {
    AND?: book_approvalScalarWhereWithAggregatesInput | book_approvalScalarWhereWithAggregatesInput[]
    OR?: book_approvalScalarWhereWithAggregatesInput[]
    NOT?: book_approvalScalarWhereWithAggregatesInput | book_approvalScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"book_approval"> | string
    id_book?: UuidWithAggregatesFilter<"book_approval"> | string
    id_internal?: UuidNullableWithAggregatesFilter<"book_approval"> | string | null
    comment?: JsonNullableWithAggregatesFilter<"book_approval">
    status?: StringWithAggregatesFilter<"book_approval"> | string
    created_at?: DateTimeWithAggregatesFilter<"book_approval"> | Date | string
  }

  export type book_changes_logWhereInput = {
    AND?: book_changes_logWhereInput | book_changes_logWhereInput[]
    OR?: book_changes_logWhereInput[]
    NOT?: book_changes_logWhereInput | book_changes_logWhereInput[]
    id_book?: UuidFilter<"book_changes_log"> | string
    created_at?: DateTimeFilter<"book_changes_log"> | Date | string
    changes?: JsonNullableFilter<"book_changes_log">
    book?: XOR<BookScalarRelationFilter, bookWhereInput>
  }

  export type book_changes_logOrderByWithRelationInput = {
    id_book?: SortOrder
    created_at?: SortOrder
    changes?: SortOrderInput | SortOrder
    book?: bookOrderByWithRelationInput
  }

  export type book_changes_logWhereUniqueInput = Prisma.AtLeast<{
    id_book_created_at?: book_changes_logId_bookCreated_atCompoundUniqueInput
    AND?: book_changes_logWhereInput | book_changes_logWhereInput[]
    OR?: book_changes_logWhereInput[]
    NOT?: book_changes_logWhereInput | book_changes_logWhereInput[]
    id_book?: UuidFilter<"book_changes_log"> | string
    created_at?: DateTimeFilter<"book_changes_log"> | Date | string
    changes?: JsonNullableFilter<"book_changes_log">
    book?: XOR<BookScalarRelationFilter, bookWhereInput>
  }, "id_book_created_at">

  export type book_changes_logOrderByWithAggregationInput = {
    id_book?: SortOrder
    created_at?: SortOrder
    changes?: SortOrderInput | SortOrder
    _count?: book_changes_logCountOrderByAggregateInput
    _max?: book_changes_logMaxOrderByAggregateInput
    _min?: book_changes_logMinOrderByAggregateInput
  }

  export type book_changes_logScalarWhereWithAggregatesInput = {
    AND?: book_changes_logScalarWhereWithAggregatesInput | book_changes_logScalarWhereWithAggregatesInput[]
    OR?: book_changes_logScalarWhereWithAggregatesInput[]
    NOT?: book_changes_logScalarWhereWithAggregatesInput | book_changes_logScalarWhereWithAggregatesInput[]
    id_book?: UuidWithAggregatesFilter<"book_changes_log"> | string
    created_at?: DateTimeWithAggregatesFilter<"book_changes_log"> | Date | string
    changes?: JsonNullableWithAggregatesFilter<"book_changes_log">
  }

  export type book_genreWhereInput = {
    AND?: book_genreWhereInput | book_genreWhereInput[]
    OR?: book_genreWhereInput[]
    NOT?: book_genreWhereInput | book_genreWhereInput[]
    id?: UuidFilter<"book_genre"> | string
    id_genre?: UuidFilter<"book_genre"> | string
    id_book?: UuidFilter<"book_genre"> | string
    book?: XOR<BookScalarRelationFilter, bookWhereInput>
    genre?: XOR<GenreScalarRelationFilter, genreWhereInput>
  }

  export type book_genreOrderByWithRelationInput = {
    id?: SortOrder
    id_genre?: SortOrder
    id_book?: SortOrder
    book?: bookOrderByWithRelationInput
    genre?: genreOrderByWithRelationInput
  }

  export type book_genreWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: book_genreWhereInput | book_genreWhereInput[]
    OR?: book_genreWhereInput[]
    NOT?: book_genreWhereInput | book_genreWhereInput[]
    id_genre?: UuidFilter<"book_genre"> | string
    id_book?: UuidFilter<"book_genre"> | string
    book?: XOR<BookScalarRelationFilter, bookWhereInput>
    genre?: XOR<GenreScalarRelationFilter, genreWhereInput>
  }, "id">

  export type book_genreOrderByWithAggregationInput = {
    id?: SortOrder
    id_genre?: SortOrder
    id_book?: SortOrder
    _count?: book_genreCountOrderByAggregateInput
    _max?: book_genreMaxOrderByAggregateInput
    _min?: book_genreMinOrderByAggregateInput
  }

  export type book_genreScalarWhereWithAggregatesInput = {
    AND?: book_genreScalarWhereWithAggregatesInput | book_genreScalarWhereWithAggregatesInput[]
    OR?: book_genreScalarWhereWithAggregatesInput[]
    NOT?: book_genreScalarWhereWithAggregatesInput | book_genreScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"book_genre"> | string
    id_genre?: UuidWithAggregatesFilter<"book_genre"> | string
    id_book?: UuidWithAggregatesFilter<"book_genre"> | string
  }

  export type book_tagsWhereInput = {
    AND?: book_tagsWhereInput | book_tagsWhereInput[]
    OR?: book_tagsWhereInput[]
    NOT?: book_tagsWhereInput | book_tagsWhereInput[]
    id?: UuidFilter<"book_tags"> | string
    id_tags?: UuidFilter<"book_tags"> | string
    id_book?: UuidFilter<"book_tags"> | string
    book?: XOR<BookScalarRelationFilter, bookWhereInput>
    tags?: XOR<TagsScalarRelationFilter, tagsWhereInput>
  }

  export type book_tagsOrderByWithRelationInput = {
    id?: SortOrder
    id_tags?: SortOrder
    id_book?: SortOrder
    book?: bookOrderByWithRelationInput
    tags?: tagsOrderByWithRelationInput
  }

  export type book_tagsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: book_tagsWhereInput | book_tagsWhereInput[]
    OR?: book_tagsWhereInput[]
    NOT?: book_tagsWhereInput | book_tagsWhereInput[]
    id_tags?: UuidFilter<"book_tags"> | string
    id_book?: UuidFilter<"book_tags"> | string
    book?: XOR<BookScalarRelationFilter, bookWhereInput>
    tags?: XOR<TagsScalarRelationFilter, tagsWhereInput>
  }, "id">

  export type book_tagsOrderByWithAggregationInput = {
    id?: SortOrder
    id_tags?: SortOrder
    id_book?: SortOrder
    _count?: book_tagsCountOrderByAggregateInput
    _max?: book_tagsMaxOrderByAggregateInput
    _min?: book_tagsMinOrderByAggregateInput
  }

  export type book_tagsScalarWhereWithAggregatesInput = {
    AND?: book_tagsScalarWhereWithAggregatesInput | book_tagsScalarWhereWithAggregatesInput[]
    OR?: book_tagsScalarWhereWithAggregatesInput[]
    NOT?: book_tagsScalarWhereWithAggregatesInput | book_tagsScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"book_tags"> | string
    id_tags?: UuidWithAggregatesFilter<"book_tags"> | string
    id_book?: UuidWithAggregatesFilter<"book_tags"> | string
  }

  export type bundleWhereInput = {
    AND?: bundleWhereInput | bundleWhereInput[]
    OR?: bundleWhereInput[]
    NOT?: bundleWhereInput | bundleWhereInput[]
    id?: UuidFilter<"bundle"> | string
    name?: StringFilter<"bundle"> | string
    slug?: StringFilter<"bundle"> | string
    strike_price?: DecimalNullableFilter<"bundle"> | Decimal | DecimalJsLike | number | string | null
    real_price?: DecimalFilter<"bundle"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"bundle"> | string
    desc?: StringFilter<"bundle"> | string
    info?: JsonFilter<"bundle">
    deleted_at?: DateTimeNullableFilter<"bundle"> | Date | string | null
    status?: StringFilter<"bundle"> | string
    img_file?: StringFilter<"bundle"> | string
    cover?: StringFilter<"bundle"> | string
    sku?: StringFilter<"bundle"> | string
    bundle_category?: Bundle_categoryListRelationFilter
    bundle_product?: Bundle_productListRelationFilter
    t_sales_line?: T_sales_lineListRelationFilter
  }

  export type bundleOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    strike_price?: SortOrderInput | SortOrder
    real_price?: SortOrder
    currency?: SortOrder
    desc?: SortOrder
    info?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    status?: SortOrder
    img_file?: SortOrder
    cover?: SortOrder
    sku?: SortOrder
    bundle_category?: bundle_categoryOrderByRelationAggregateInput
    bundle_product?: bundle_productOrderByRelationAggregateInput
    t_sales_line?: t_sales_lineOrderByRelationAggregateInput
  }

  export type bundleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: bundleWhereInput | bundleWhereInput[]
    OR?: bundleWhereInput[]
    NOT?: bundleWhereInput | bundleWhereInput[]
    name?: StringFilter<"bundle"> | string
    slug?: StringFilter<"bundle"> | string
    strike_price?: DecimalNullableFilter<"bundle"> | Decimal | DecimalJsLike | number | string | null
    real_price?: DecimalFilter<"bundle"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"bundle"> | string
    desc?: StringFilter<"bundle"> | string
    info?: JsonFilter<"bundle">
    deleted_at?: DateTimeNullableFilter<"bundle"> | Date | string | null
    status?: StringFilter<"bundle"> | string
    img_file?: StringFilter<"bundle"> | string
    cover?: StringFilter<"bundle"> | string
    sku?: StringFilter<"bundle"> | string
    bundle_category?: Bundle_categoryListRelationFilter
    bundle_product?: Bundle_productListRelationFilter
    t_sales_line?: T_sales_lineListRelationFilter
  }, "id">

  export type bundleOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    strike_price?: SortOrderInput | SortOrder
    real_price?: SortOrder
    currency?: SortOrder
    desc?: SortOrder
    info?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    status?: SortOrder
    img_file?: SortOrder
    cover?: SortOrder
    sku?: SortOrder
    _count?: bundleCountOrderByAggregateInput
    _avg?: bundleAvgOrderByAggregateInput
    _max?: bundleMaxOrderByAggregateInput
    _min?: bundleMinOrderByAggregateInput
    _sum?: bundleSumOrderByAggregateInput
  }

  export type bundleScalarWhereWithAggregatesInput = {
    AND?: bundleScalarWhereWithAggregatesInput | bundleScalarWhereWithAggregatesInput[]
    OR?: bundleScalarWhereWithAggregatesInput[]
    NOT?: bundleScalarWhereWithAggregatesInput | bundleScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"bundle"> | string
    name?: StringWithAggregatesFilter<"bundle"> | string
    slug?: StringWithAggregatesFilter<"bundle"> | string
    strike_price?: DecimalNullableWithAggregatesFilter<"bundle"> | Decimal | DecimalJsLike | number | string | null
    real_price?: DecimalWithAggregatesFilter<"bundle"> | Decimal | DecimalJsLike | number | string
    currency?: StringWithAggregatesFilter<"bundle"> | string
    desc?: StringWithAggregatesFilter<"bundle"> | string
    info?: JsonWithAggregatesFilter<"bundle">
    deleted_at?: DateTimeNullableWithAggregatesFilter<"bundle"> | Date | string | null
    status?: StringWithAggregatesFilter<"bundle"> | string
    img_file?: StringWithAggregatesFilter<"bundle"> | string
    cover?: StringWithAggregatesFilter<"bundle"> | string
    sku?: StringWithAggregatesFilter<"bundle"> | string
  }

  export type bundle_categoryWhereInput = {
    AND?: bundle_categoryWhereInput | bundle_categoryWhereInput[]
    OR?: bundle_categoryWhereInput[]
    NOT?: bundle_categoryWhereInput | bundle_categoryWhereInput[]
    id?: UuidFilter<"bundle_category"> | string
    id_category?: UuidFilter<"bundle_category"> | string
    id_bundle?: UuidFilter<"bundle_category"> | string
    bundle?: XOR<BundleScalarRelationFilter, bundleWhereInput>
    category?: XOR<CategoryScalarRelationFilter, categoryWhereInput>
  }

  export type bundle_categoryOrderByWithRelationInput = {
    id?: SortOrder
    id_category?: SortOrder
    id_bundle?: SortOrder
    bundle?: bundleOrderByWithRelationInput
    category?: categoryOrderByWithRelationInput
  }

  export type bundle_categoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: bundle_categoryWhereInput | bundle_categoryWhereInput[]
    OR?: bundle_categoryWhereInput[]
    NOT?: bundle_categoryWhereInput | bundle_categoryWhereInput[]
    id_category?: UuidFilter<"bundle_category"> | string
    id_bundle?: UuidFilter<"bundle_category"> | string
    bundle?: XOR<BundleScalarRelationFilter, bundleWhereInput>
    category?: XOR<CategoryScalarRelationFilter, categoryWhereInput>
  }, "id">

  export type bundle_categoryOrderByWithAggregationInput = {
    id?: SortOrder
    id_category?: SortOrder
    id_bundle?: SortOrder
    _count?: bundle_categoryCountOrderByAggregateInput
    _max?: bundle_categoryMaxOrderByAggregateInput
    _min?: bundle_categoryMinOrderByAggregateInput
  }

  export type bundle_categoryScalarWhereWithAggregatesInput = {
    AND?: bundle_categoryScalarWhereWithAggregatesInput | bundle_categoryScalarWhereWithAggregatesInput[]
    OR?: bundle_categoryScalarWhereWithAggregatesInput[]
    NOT?: bundle_categoryScalarWhereWithAggregatesInput | bundle_categoryScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"bundle_category"> | string
    id_category?: UuidWithAggregatesFilter<"bundle_category"> | string
    id_bundle?: UuidWithAggregatesFilter<"bundle_category"> | string
  }

  export type bundle_productWhereInput = {
    AND?: bundle_productWhereInput | bundle_productWhereInput[]
    OR?: bundle_productWhereInput[]
    NOT?: bundle_productWhereInput | bundle_productWhereInput[]
    id_bundle?: UuidFilter<"bundle_product"> | string
    id_product?: UuidFilter<"bundle_product"> | string
    id?: UuidFilter<"bundle_product"> | string
    qty?: IntNullableFilter<"bundle_product"> | number | null
    bundle?: XOR<BundleScalarRelationFilter, bundleWhereInput>
    product?: XOR<ProductScalarRelationFilter, productWhereInput>
  }

  export type bundle_productOrderByWithRelationInput = {
    id_bundle?: SortOrder
    id_product?: SortOrder
    id?: SortOrder
    qty?: SortOrderInput | SortOrder
    bundle?: bundleOrderByWithRelationInput
    product?: productOrderByWithRelationInput
  }

  export type bundle_productWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: bundle_productWhereInput | bundle_productWhereInput[]
    OR?: bundle_productWhereInput[]
    NOT?: bundle_productWhereInput | bundle_productWhereInput[]
    id_bundle?: UuidFilter<"bundle_product"> | string
    id_product?: UuidFilter<"bundle_product"> | string
    qty?: IntNullableFilter<"bundle_product"> | number | null
    bundle?: XOR<BundleScalarRelationFilter, bundleWhereInput>
    product?: XOR<ProductScalarRelationFilter, productWhereInput>
  }, "id">

  export type bundle_productOrderByWithAggregationInput = {
    id_bundle?: SortOrder
    id_product?: SortOrder
    id?: SortOrder
    qty?: SortOrderInput | SortOrder
    _count?: bundle_productCountOrderByAggregateInput
    _avg?: bundle_productAvgOrderByAggregateInput
    _max?: bundle_productMaxOrderByAggregateInput
    _min?: bundle_productMinOrderByAggregateInput
    _sum?: bundle_productSumOrderByAggregateInput
  }

  export type bundle_productScalarWhereWithAggregatesInput = {
    AND?: bundle_productScalarWhereWithAggregatesInput | bundle_productScalarWhereWithAggregatesInput[]
    OR?: bundle_productScalarWhereWithAggregatesInput[]
    NOT?: bundle_productScalarWhereWithAggregatesInput | bundle_productScalarWhereWithAggregatesInput[]
    id_bundle?: UuidWithAggregatesFilter<"bundle_product"> | string
    id_product?: UuidWithAggregatesFilter<"bundle_product"> | string
    id?: UuidWithAggregatesFilter<"bundle_product"> | string
    qty?: IntNullableWithAggregatesFilter<"bundle_product"> | number | null
  }

  export type categoryWhereInput = {
    AND?: categoryWhereInput | categoryWhereInput[]
    OR?: categoryWhereInput[]
    NOT?: categoryWhereInput | categoryWhereInput[]
    id?: UuidFilter<"category"> | string
    name?: StringFilter<"category"> | string
    id_parent?: UuidNullableFilter<"category"> | string | null
    deleted_at?: DateTimeNullableFilter<"category"> | Date | string | null
    slug?: StringNullableFilter<"category"> | string | null
    img?: StringNullableFilter<"category"> | string | null
    bundle_category?: Bundle_categoryListRelationFilter
    category?: XOR<CategoryNullableScalarRelationFilter, categoryWhereInput> | null
    other_category?: CategoryListRelationFilter
    product_category?: Product_categoryListRelationFilter
  }

  export type categoryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    id_parent?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
    slug?: SortOrderInput | SortOrder
    img?: SortOrderInput | SortOrder
    bundle_category?: bundle_categoryOrderByRelationAggregateInput
    category?: categoryOrderByWithRelationInput
    other_category?: categoryOrderByRelationAggregateInput
    product_category?: product_categoryOrderByRelationAggregateInput
  }

  export type categoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: categoryWhereInput | categoryWhereInput[]
    OR?: categoryWhereInput[]
    NOT?: categoryWhereInput | categoryWhereInput[]
    name?: StringFilter<"category"> | string
    id_parent?: UuidNullableFilter<"category"> | string | null
    deleted_at?: DateTimeNullableFilter<"category"> | Date | string | null
    slug?: StringNullableFilter<"category"> | string | null
    img?: StringNullableFilter<"category"> | string | null
    bundle_category?: Bundle_categoryListRelationFilter
    category?: XOR<CategoryNullableScalarRelationFilter, categoryWhereInput> | null
    other_category?: CategoryListRelationFilter
    product_category?: Product_categoryListRelationFilter
  }, "id">

  export type categoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    id_parent?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
    slug?: SortOrderInput | SortOrder
    img?: SortOrderInput | SortOrder
    _count?: categoryCountOrderByAggregateInput
    _max?: categoryMaxOrderByAggregateInput
    _min?: categoryMinOrderByAggregateInput
  }

  export type categoryScalarWhereWithAggregatesInput = {
    AND?: categoryScalarWhereWithAggregatesInput | categoryScalarWhereWithAggregatesInput[]
    OR?: categoryScalarWhereWithAggregatesInput[]
    NOT?: categoryScalarWhereWithAggregatesInput | categoryScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"category"> | string
    name?: StringWithAggregatesFilter<"category"> | string
    id_parent?: UuidNullableWithAggregatesFilter<"category"> | string | null
    deleted_at?: DateTimeNullableWithAggregatesFilter<"category"> | Date | string | null
    slug?: StringNullableWithAggregatesFilter<"category"> | string | null
    img?: StringNullableWithAggregatesFilter<"category"> | string | null
  }

  export type chapterWhereInput = {
    AND?: chapterWhereInput | chapterWhereInput[]
    OR?: chapterWhereInput[]
    NOT?: chapterWhereInput | chapterWhereInput[]
    id?: UuidFilter<"chapter"> | string
    id_product?: UuidNullableFilter<"chapter"> | string | null
    id_book?: UuidNullableFilter<"chapter"> | string | null
    number?: IntFilter<"chapter"> | number
    name?: StringFilter<"chapter"> | string
    content?: JsonFilter<"chapter">
    created_at?: DateTimeFilter<"chapter"> | Date | string
    updated_at?: DateTimeNullableFilter<"chapter"> | Date | string | null
    book?: XOR<BookNullableScalarRelationFilter, bookWhereInput> | null
    product?: XOR<ProductNullableScalarRelationFilter, productWhereInput> | null
  }

  export type chapterOrderByWithRelationInput = {
    id?: SortOrder
    id_product?: SortOrderInput | SortOrder
    id_book?: SortOrderInput | SortOrder
    number?: SortOrder
    name?: SortOrder
    content?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrderInput | SortOrder
    book?: bookOrderByWithRelationInput
    product?: productOrderByWithRelationInput
  }

  export type chapterWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: chapterWhereInput | chapterWhereInput[]
    OR?: chapterWhereInput[]
    NOT?: chapterWhereInput | chapterWhereInput[]
    id_product?: UuidNullableFilter<"chapter"> | string | null
    id_book?: UuidNullableFilter<"chapter"> | string | null
    number?: IntFilter<"chapter"> | number
    name?: StringFilter<"chapter"> | string
    content?: JsonFilter<"chapter">
    created_at?: DateTimeFilter<"chapter"> | Date | string
    updated_at?: DateTimeNullableFilter<"chapter"> | Date | string | null
    book?: XOR<BookNullableScalarRelationFilter, bookWhereInput> | null
    product?: XOR<ProductNullableScalarRelationFilter, productWhereInput> | null
  }, "id">

  export type chapterOrderByWithAggregationInput = {
    id?: SortOrder
    id_product?: SortOrderInput | SortOrder
    id_book?: SortOrderInput | SortOrder
    number?: SortOrder
    name?: SortOrder
    content?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrderInput | SortOrder
    _count?: chapterCountOrderByAggregateInput
    _avg?: chapterAvgOrderByAggregateInput
    _max?: chapterMaxOrderByAggregateInput
    _min?: chapterMinOrderByAggregateInput
    _sum?: chapterSumOrderByAggregateInput
  }

  export type chapterScalarWhereWithAggregatesInput = {
    AND?: chapterScalarWhereWithAggregatesInput | chapterScalarWhereWithAggregatesInput[]
    OR?: chapterScalarWhereWithAggregatesInput[]
    NOT?: chapterScalarWhereWithAggregatesInput | chapterScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"chapter"> | string
    id_product?: UuidNullableWithAggregatesFilter<"chapter"> | string | null
    id_book?: UuidNullableWithAggregatesFilter<"chapter"> | string | null
    number?: IntWithAggregatesFilter<"chapter"> | number
    name?: StringWithAggregatesFilter<"chapter"> | string
    content?: JsonWithAggregatesFilter<"chapter">
    created_at?: DateTimeWithAggregatesFilter<"chapter"> | Date | string
    updated_at?: DateTimeNullableWithAggregatesFilter<"chapter"> | Date | string | null
  }

  export type customerWhereInput = {
    AND?: customerWhereInput | customerWhereInput[]
    OR?: customerWhereInput[]
    NOT?: customerWhereInput | customerWhereInput[]
    id?: UuidFilter<"customer"> | string
    whatsapp?: StringFilter<"customer"> | string
    deleted_at?: DateTimeNullableFilter<"customer"> | Date | string | null
    otp?: IntNullableFilter<"customer"> | number | null
    id_account?: UuidNullableFilter<"customer"> | string | null
    name?: StringFilter<"customer"> | string
    email?: StringFilter<"customer"> | string
    auth_user?: Auth_userListRelationFilter
    auth_account?: XOR<Auth_accountNullableScalarRelationFilter, auth_accountWhereInput> | null
    customer_reader?: Customer_readerListRelationFilter
    customer_track?: Customer_trackListRelationFilter
    t_sales?: T_salesListRelationFilter
    t_sales_download?: T_sales_downloadListRelationFilter
  }

  export type customerOrderByWithRelationInput = {
    id?: SortOrder
    whatsapp?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    otp?: SortOrderInput | SortOrder
    id_account?: SortOrderInput | SortOrder
    name?: SortOrder
    email?: SortOrder
    auth_user?: auth_userOrderByRelationAggregateInput
    auth_account?: auth_accountOrderByWithRelationInput
    customer_reader?: customer_readerOrderByRelationAggregateInput
    customer_track?: customer_trackOrderByRelationAggregateInput
    t_sales?: t_salesOrderByRelationAggregateInput
    t_sales_download?: t_sales_downloadOrderByRelationAggregateInput
  }

  export type customerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: customerWhereInput | customerWhereInput[]
    OR?: customerWhereInput[]
    NOT?: customerWhereInput | customerWhereInput[]
    whatsapp?: StringFilter<"customer"> | string
    deleted_at?: DateTimeNullableFilter<"customer"> | Date | string | null
    otp?: IntNullableFilter<"customer"> | number | null
    id_account?: UuidNullableFilter<"customer"> | string | null
    name?: StringFilter<"customer"> | string
    email?: StringFilter<"customer"> | string
    auth_user?: Auth_userListRelationFilter
    auth_account?: XOR<Auth_accountNullableScalarRelationFilter, auth_accountWhereInput> | null
    customer_reader?: Customer_readerListRelationFilter
    customer_track?: Customer_trackListRelationFilter
    t_sales?: T_salesListRelationFilter
    t_sales_download?: T_sales_downloadListRelationFilter
  }, "id">

  export type customerOrderByWithAggregationInput = {
    id?: SortOrder
    whatsapp?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    otp?: SortOrderInput | SortOrder
    id_account?: SortOrderInput | SortOrder
    name?: SortOrder
    email?: SortOrder
    _count?: customerCountOrderByAggregateInput
    _avg?: customerAvgOrderByAggregateInput
    _max?: customerMaxOrderByAggregateInput
    _min?: customerMinOrderByAggregateInput
    _sum?: customerSumOrderByAggregateInput
  }

  export type customerScalarWhereWithAggregatesInput = {
    AND?: customerScalarWhereWithAggregatesInput | customerScalarWhereWithAggregatesInput[]
    OR?: customerScalarWhereWithAggregatesInput[]
    NOT?: customerScalarWhereWithAggregatesInput | customerScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"customer"> | string
    whatsapp?: StringWithAggregatesFilter<"customer"> | string
    deleted_at?: DateTimeNullableWithAggregatesFilter<"customer"> | Date | string | null
    otp?: IntNullableWithAggregatesFilter<"customer"> | number | null
    id_account?: UuidNullableWithAggregatesFilter<"customer"> | string | null
    name?: StringWithAggregatesFilter<"customer"> | string
    email?: StringWithAggregatesFilter<"customer"> | string
  }

  export type customer_readerWhereInput = {
    AND?: customer_readerWhereInput | customer_readerWhereInput[]
    OR?: customer_readerWhereInput[]
    NOT?: customer_readerWhereInput | customer_readerWhereInput[]
    id?: UuidFilter<"customer_reader"> | string
    id_customer?: UuidFilter<"customer_reader"> | string
    id_product?: UuidFilter<"customer_reader"> | string
    last_page?: IntFilter<"customer_reader"> | number
    percent?: IntFilter<"customer_reader"> | number
    customer?: XOR<CustomerScalarRelationFilter, customerWhereInput>
    product?: XOR<ProductScalarRelationFilter, productWhereInput>
  }

  export type customer_readerOrderByWithRelationInput = {
    id?: SortOrder
    id_customer?: SortOrder
    id_product?: SortOrder
    last_page?: SortOrder
    percent?: SortOrder
    customer?: customerOrderByWithRelationInput
    product?: productOrderByWithRelationInput
  }

  export type customer_readerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: customer_readerWhereInput | customer_readerWhereInput[]
    OR?: customer_readerWhereInput[]
    NOT?: customer_readerWhereInput | customer_readerWhereInput[]
    id_customer?: UuidFilter<"customer_reader"> | string
    id_product?: UuidFilter<"customer_reader"> | string
    last_page?: IntFilter<"customer_reader"> | number
    percent?: IntFilter<"customer_reader"> | number
    customer?: XOR<CustomerScalarRelationFilter, customerWhereInput>
    product?: XOR<ProductScalarRelationFilter, productWhereInput>
  }, "id">

  export type customer_readerOrderByWithAggregationInput = {
    id?: SortOrder
    id_customer?: SortOrder
    id_product?: SortOrder
    last_page?: SortOrder
    percent?: SortOrder
    _count?: customer_readerCountOrderByAggregateInput
    _avg?: customer_readerAvgOrderByAggregateInput
    _max?: customer_readerMaxOrderByAggregateInput
    _min?: customer_readerMinOrderByAggregateInput
    _sum?: customer_readerSumOrderByAggregateInput
  }

  export type customer_readerScalarWhereWithAggregatesInput = {
    AND?: customer_readerScalarWhereWithAggregatesInput | customer_readerScalarWhereWithAggregatesInput[]
    OR?: customer_readerScalarWhereWithAggregatesInput[]
    NOT?: customer_readerScalarWhereWithAggregatesInput | customer_readerScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"customer_reader"> | string
    id_customer?: UuidWithAggregatesFilter<"customer_reader"> | string
    id_product?: UuidWithAggregatesFilter<"customer_reader"> | string
    last_page?: IntWithAggregatesFilter<"customer_reader"> | number
    percent?: IntWithAggregatesFilter<"customer_reader"> | number
  }

  export type customer_trackWhereInput = {
    AND?: customer_trackWhereInput | customer_trackWhereInput[]
    OR?: customer_trackWhereInput[]
    NOT?: customer_trackWhereInput | customer_trackWhereInput[]
    id?: UuidFilter<"customer_track"> | string
    ts?: DateTimeFilter<"customer_track"> | Date | string
    id_customer?: UuidFilter<"customer_track"> | string
    path?: StringFilter<"customer_track"> | string
    referrer?: StringFilter<"customer_track"> | string
    info?: JsonFilter<"customer_track">
    ip?: StringFilter<"customer_track"> | string
    customer?: XOR<CustomerScalarRelationFilter, customerWhereInput>
  }

  export type customer_trackOrderByWithRelationInput = {
    id?: SortOrder
    ts?: SortOrder
    id_customer?: SortOrder
    path?: SortOrder
    referrer?: SortOrder
    info?: SortOrder
    ip?: SortOrder
    customer?: customerOrderByWithRelationInput
  }

  export type customer_trackWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: customer_trackWhereInput | customer_trackWhereInput[]
    OR?: customer_trackWhereInput[]
    NOT?: customer_trackWhereInput | customer_trackWhereInput[]
    ts?: DateTimeFilter<"customer_track"> | Date | string
    id_customer?: UuidFilter<"customer_track"> | string
    path?: StringFilter<"customer_track"> | string
    referrer?: StringFilter<"customer_track"> | string
    info?: JsonFilter<"customer_track">
    ip?: StringFilter<"customer_track"> | string
    customer?: XOR<CustomerScalarRelationFilter, customerWhereInput>
  }, "id">

  export type customer_trackOrderByWithAggregationInput = {
    id?: SortOrder
    ts?: SortOrder
    id_customer?: SortOrder
    path?: SortOrder
    referrer?: SortOrder
    info?: SortOrder
    ip?: SortOrder
    _count?: customer_trackCountOrderByAggregateInput
    _max?: customer_trackMaxOrderByAggregateInput
    _min?: customer_trackMinOrderByAggregateInput
  }

  export type customer_trackScalarWhereWithAggregatesInput = {
    AND?: customer_trackScalarWhereWithAggregatesInput | customer_trackScalarWhereWithAggregatesInput[]
    OR?: customer_trackScalarWhereWithAggregatesInput[]
    NOT?: customer_trackScalarWhereWithAggregatesInput | customer_trackScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"customer_track"> | string
    ts?: DateTimeWithAggregatesFilter<"customer_track"> | Date | string
    id_customer?: UuidWithAggregatesFilter<"customer_track"> | string
    path?: StringWithAggregatesFilter<"customer_track"> | string
    referrer?: StringWithAggregatesFilter<"customer_track"> | string
    info?: JsonWithAggregatesFilter<"customer_track">
    ip?: StringWithAggregatesFilter<"customer_track"> | string
  }

  export type genreWhereInput = {
    AND?: genreWhereInput | genreWhereInput[]
    OR?: genreWhereInput[]
    NOT?: genreWhereInput | genreWhereInput[]
    id?: UuidFilter<"genre"> | string
    name?: StringFilter<"genre"> | string
    id_parent?: UuidNullableFilter<"genre"> | string | null
    slug?: StringNullableFilter<"genre"> | string | null
    img?: StringNullableFilter<"genre"> | string | null
    deleted_at?: DateTimeNullableFilter<"genre"> | Date | string | null
    book_genre?: Book_genreListRelationFilter
    genre?: XOR<GenreNullableScalarRelationFilter, genreWhereInput> | null
    other_genre?: GenreListRelationFilter
  }

  export type genreOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    id_parent?: SortOrderInput | SortOrder
    slug?: SortOrderInput | SortOrder
    img?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
    book_genre?: book_genreOrderByRelationAggregateInput
    genre?: genreOrderByWithRelationInput
    other_genre?: genreOrderByRelationAggregateInput
  }

  export type genreWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: genreWhereInput | genreWhereInput[]
    OR?: genreWhereInput[]
    NOT?: genreWhereInput | genreWhereInput[]
    name?: StringFilter<"genre"> | string
    id_parent?: UuidNullableFilter<"genre"> | string | null
    slug?: StringNullableFilter<"genre"> | string | null
    img?: StringNullableFilter<"genre"> | string | null
    deleted_at?: DateTimeNullableFilter<"genre"> | Date | string | null
    book_genre?: Book_genreListRelationFilter
    genre?: XOR<GenreNullableScalarRelationFilter, genreWhereInput> | null
    other_genre?: GenreListRelationFilter
  }, "id">

  export type genreOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    id_parent?: SortOrderInput | SortOrder
    slug?: SortOrderInput | SortOrder
    img?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
    _count?: genreCountOrderByAggregateInput
    _max?: genreMaxOrderByAggregateInput
    _min?: genreMinOrderByAggregateInput
  }

  export type genreScalarWhereWithAggregatesInput = {
    AND?: genreScalarWhereWithAggregatesInput | genreScalarWhereWithAggregatesInput[]
    OR?: genreScalarWhereWithAggregatesInput[]
    NOT?: genreScalarWhereWithAggregatesInput | genreScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"genre"> | string
    name?: StringWithAggregatesFilter<"genre"> | string
    id_parent?: UuidNullableWithAggregatesFilter<"genre"> | string | null
    slug?: StringNullableWithAggregatesFilter<"genre"> | string | null
    img?: StringNullableWithAggregatesFilter<"genre"> | string | null
    deleted_at?: DateTimeNullableWithAggregatesFilter<"genre"> | Date | string | null
  }

  export type internalWhereInput = {
    AND?: internalWhereInput | internalWhereInput[]
    OR?: internalWhereInput[]
    NOT?: internalWhereInput | internalWhereInput[]
    id?: UuidFilter<"internal"> | string
    id_account?: UuidNullableFilter<"internal"> | string | null
    name?: StringFilter<"internal"> | string
    is_sales_and_marketing?: BoolFilter<"internal"> | boolean
    is_support?: BoolFilter<"internal"> | boolean
    is_management?: BoolFilter<"internal"> | boolean
    is_it?: BoolFilter<"internal"> | boolean
    auth_user?: Auth_userListRelationFilter
    book_approval?: Book_approvalListRelationFilter
    auth_account?: XOR<Auth_accountNullableScalarRelationFilter, auth_accountWhereInput> | null
  }

  export type internalOrderByWithRelationInput = {
    id?: SortOrder
    id_account?: SortOrderInput | SortOrder
    name?: SortOrder
    is_sales_and_marketing?: SortOrder
    is_support?: SortOrder
    is_management?: SortOrder
    is_it?: SortOrder
    auth_user?: auth_userOrderByRelationAggregateInput
    book_approval?: book_approvalOrderByRelationAggregateInput
    auth_account?: auth_accountOrderByWithRelationInput
  }

  export type internalWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: internalWhereInput | internalWhereInput[]
    OR?: internalWhereInput[]
    NOT?: internalWhereInput | internalWhereInput[]
    id_account?: UuidNullableFilter<"internal"> | string | null
    name?: StringFilter<"internal"> | string
    is_sales_and_marketing?: BoolFilter<"internal"> | boolean
    is_support?: BoolFilter<"internal"> | boolean
    is_management?: BoolFilter<"internal"> | boolean
    is_it?: BoolFilter<"internal"> | boolean
    auth_user?: Auth_userListRelationFilter
    book_approval?: Book_approvalListRelationFilter
    auth_account?: XOR<Auth_accountNullableScalarRelationFilter, auth_accountWhereInput> | null
  }, "id">

  export type internalOrderByWithAggregationInput = {
    id?: SortOrder
    id_account?: SortOrderInput | SortOrder
    name?: SortOrder
    is_sales_and_marketing?: SortOrder
    is_support?: SortOrder
    is_management?: SortOrder
    is_it?: SortOrder
    _count?: internalCountOrderByAggregateInput
    _max?: internalMaxOrderByAggregateInput
    _min?: internalMinOrderByAggregateInput
  }

  export type internalScalarWhereWithAggregatesInput = {
    AND?: internalScalarWhereWithAggregatesInput | internalScalarWhereWithAggregatesInput[]
    OR?: internalScalarWhereWithAggregatesInput[]
    NOT?: internalScalarWhereWithAggregatesInput | internalScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"internal"> | string
    id_account?: UuidNullableWithAggregatesFilter<"internal"> | string | null
    name?: StringWithAggregatesFilter<"internal"> | string
    is_sales_and_marketing?: BoolWithAggregatesFilter<"internal"> | boolean
    is_support?: BoolWithAggregatesFilter<"internal"> | boolean
    is_management?: BoolWithAggregatesFilter<"internal"> | boolean
    is_it?: BoolWithAggregatesFilter<"internal"> | boolean
  }

  export type landingWhereInput = {
    AND?: landingWhereInput | landingWhereInput[]
    OR?: landingWhereInput[]
    NOT?: landingWhereInput | landingWhereInput[]
    id?: UuidFilter<"landing"> | string
    slug?: StringFilter<"landing"> | string
    views?: IntFilter<"landing"> | number
    deleted_at?: DateTimeNullableFilter<"landing"> | Date | string | null
    status?: StringFilter<"landing"> | string
    title?: StringFilter<"landing"> | string
    landing_items?: Landing_itemsListRelationFilter
  }

  export type landingOrderByWithRelationInput = {
    id?: SortOrder
    slug?: SortOrder
    views?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    status?: SortOrder
    title?: SortOrder
    landing_items?: landing_itemsOrderByRelationAggregateInput
  }

  export type landingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: landingWhereInput | landingWhereInput[]
    OR?: landingWhereInput[]
    NOT?: landingWhereInput | landingWhereInput[]
    slug?: StringFilter<"landing"> | string
    views?: IntFilter<"landing"> | number
    deleted_at?: DateTimeNullableFilter<"landing"> | Date | string | null
    status?: StringFilter<"landing"> | string
    title?: StringFilter<"landing"> | string
    landing_items?: Landing_itemsListRelationFilter
  }, "id">

  export type landingOrderByWithAggregationInput = {
    id?: SortOrder
    slug?: SortOrder
    views?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    status?: SortOrder
    title?: SortOrder
    _count?: landingCountOrderByAggregateInput
    _avg?: landingAvgOrderByAggregateInput
    _max?: landingMaxOrderByAggregateInput
    _min?: landingMinOrderByAggregateInput
    _sum?: landingSumOrderByAggregateInput
  }

  export type landingScalarWhereWithAggregatesInput = {
    AND?: landingScalarWhereWithAggregatesInput | landingScalarWhereWithAggregatesInput[]
    OR?: landingScalarWhereWithAggregatesInput[]
    NOT?: landingScalarWhereWithAggregatesInput | landingScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"landing"> | string
    slug?: StringWithAggregatesFilter<"landing"> | string
    views?: IntWithAggregatesFilter<"landing"> | number
    deleted_at?: DateTimeNullableWithAggregatesFilter<"landing"> | Date | string | null
    status?: StringWithAggregatesFilter<"landing"> | string
    title?: StringWithAggregatesFilter<"landing"> | string
  }

  export type landing_itemsWhereInput = {
    AND?: landing_itemsWhereInput | landing_itemsWhereInput[]
    OR?: landing_itemsWhereInput[]
    NOT?: landing_itemsWhereInput | landing_itemsWhereInput[]
    id?: UuidFilter<"landing_items"> | string
    desc?: StringFilter<"landing_items"> | string
    img_file?: StringFilter<"landing_items"> | string
    tag?: StringFilter<"landing_items"> | string
    link_to?: StringFilter<"landing_items"> | string
    landing_id?: UuidFilter<"landing_items"> | string
    idx?: IntFilter<"landing_items"> | number
    color?: StringFilter<"landing_items"> | string
    landing?: XOR<LandingScalarRelationFilter, landingWhereInput>
  }

  export type landing_itemsOrderByWithRelationInput = {
    id?: SortOrder
    desc?: SortOrder
    img_file?: SortOrder
    tag?: SortOrder
    link_to?: SortOrder
    landing_id?: SortOrder
    idx?: SortOrder
    color?: SortOrder
    landing?: landingOrderByWithRelationInput
  }

  export type landing_itemsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: landing_itemsWhereInput | landing_itemsWhereInput[]
    OR?: landing_itemsWhereInput[]
    NOT?: landing_itemsWhereInput | landing_itemsWhereInput[]
    desc?: StringFilter<"landing_items"> | string
    img_file?: StringFilter<"landing_items"> | string
    tag?: StringFilter<"landing_items"> | string
    link_to?: StringFilter<"landing_items"> | string
    landing_id?: UuidFilter<"landing_items"> | string
    idx?: IntFilter<"landing_items"> | number
    color?: StringFilter<"landing_items"> | string
    landing?: XOR<LandingScalarRelationFilter, landingWhereInput>
  }, "id">

  export type landing_itemsOrderByWithAggregationInput = {
    id?: SortOrder
    desc?: SortOrder
    img_file?: SortOrder
    tag?: SortOrder
    link_to?: SortOrder
    landing_id?: SortOrder
    idx?: SortOrder
    color?: SortOrder
    _count?: landing_itemsCountOrderByAggregateInput
    _avg?: landing_itemsAvgOrderByAggregateInput
    _max?: landing_itemsMaxOrderByAggregateInput
    _min?: landing_itemsMinOrderByAggregateInput
    _sum?: landing_itemsSumOrderByAggregateInput
  }

  export type landing_itemsScalarWhereWithAggregatesInput = {
    AND?: landing_itemsScalarWhereWithAggregatesInput | landing_itemsScalarWhereWithAggregatesInput[]
    OR?: landing_itemsScalarWhereWithAggregatesInput[]
    NOT?: landing_itemsScalarWhereWithAggregatesInput | landing_itemsScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"landing_items"> | string
    desc?: StringWithAggregatesFilter<"landing_items"> | string
    img_file?: StringWithAggregatesFilter<"landing_items"> | string
    tag?: StringWithAggregatesFilter<"landing_items"> | string
    link_to?: StringWithAggregatesFilter<"landing_items"> | string
    landing_id?: UuidWithAggregatesFilter<"landing_items"> | string
    idx?: IntWithAggregatesFilter<"landing_items"> | number
    color?: StringWithAggregatesFilter<"landing_items"> | string
  }

  export type midtrxWhereInput = {
    AND?: midtrxWhereInput | midtrxWhereInput[]
    OR?: midtrxWhereInput[]
    NOT?: midtrxWhereInput | midtrxWhereInput[]
    id?: UuidFilter<"midtrx"> | string
    tz?: DateTimeFilter<"midtrx"> | Date | string
    type?: StringFilter<"midtrx"> | string
    payload?: JsonFilter<"midtrx">
  }

  export type midtrxOrderByWithRelationInput = {
    id?: SortOrder
    tz?: SortOrder
    type?: SortOrder
    payload?: SortOrder
  }

  export type midtrxWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: midtrxWhereInput | midtrxWhereInput[]
    OR?: midtrxWhereInput[]
    NOT?: midtrxWhereInput | midtrxWhereInput[]
    tz?: DateTimeFilter<"midtrx"> | Date | string
    type?: StringFilter<"midtrx"> | string
    payload?: JsonFilter<"midtrx">
  }, "id">

  export type midtrxOrderByWithAggregationInput = {
    id?: SortOrder
    tz?: SortOrder
    type?: SortOrder
    payload?: SortOrder
    _count?: midtrxCountOrderByAggregateInput
    _max?: midtrxMaxOrderByAggregateInput
    _min?: midtrxMinOrderByAggregateInput
  }

  export type midtrxScalarWhereWithAggregatesInput = {
    AND?: midtrxScalarWhereWithAggregatesInput | midtrxScalarWhereWithAggregatesInput[]
    OR?: midtrxScalarWhereWithAggregatesInput[]
    NOT?: midtrxScalarWhereWithAggregatesInput | midtrxScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"midtrx"> | string
    tz?: DateTimeWithAggregatesFilter<"midtrx"> | Date | string
    type?: StringWithAggregatesFilter<"midtrx"> | string
    payload?: JsonWithAggregatesFilter<"midtrx">
  }

  export type preorderWhereInput = {
    AND?: preorderWhereInput | preorderWhereInput[]
    OR?: preorderWhereInput[]
    NOT?: preorderWhereInput | preorderWhereInput[]
    id?: UuidFilter<"preorder"> | string
    id_product?: UuidFilter<"preorder"> | string
    min_qty?: IntFilter<"preorder"> | number
    current_qty?: IntFilter<"preorder"> | number
    status?: StringFilter<"preorder"> | string
    deadline?: DateTimeFilter<"preorder"> | Date | string
    product?: XOR<ProductScalarRelationFilter, productWhereInput>
  }

  export type preorderOrderByWithRelationInput = {
    id?: SortOrder
    id_product?: SortOrder
    min_qty?: SortOrder
    current_qty?: SortOrder
    status?: SortOrder
    deadline?: SortOrder
    product?: productOrderByWithRelationInput
  }

  export type preorderWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: preorderWhereInput | preorderWhereInput[]
    OR?: preorderWhereInput[]
    NOT?: preorderWhereInput | preorderWhereInput[]
    id_product?: UuidFilter<"preorder"> | string
    min_qty?: IntFilter<"preorder"> | number
    current_qty?: IntFilter<"preorder"> | number
    status?: StringFilter<"preorder"> | string
    deadline?: DateTimeFilter<"preorder"> | Date | string
    product?: XOR<ProductScalarRelationFilter, productWhereInput>
  }, "id">

  export type preorderOrderByWithAggregationInput = {
    id?: SortOrder
    id_product?: SortOrder
    min_qty?: SortOrder
    current_qty?: SortOrder
    status?: SortOrder
    deadline?: SortOrder
    _count?: preorderCountOrderByAggregateInput
    _avg?: preorderAvgOrderByAggregateInput
    _max?: preorderMaxOrderByAggregateInput
    _min?: preorderMinOrderByAggregateInput
    _sum?: preorderSumOrderByAggregateInput
  }

  export type preorderScalarWhereWithAggregatesInput = {
    AND?: preorderScalarWhereWithAggregatesInput | preorderScalarWhereWithAggregatesInput[]
    OR?: preorderScalarWhereWithAggregatesInput[]
    NOT?: preorderScalarWhereWithAggregatesInput | preorderScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"preorder"> | string
    id_product?: UuidWithAggregatesFilter<"preorder"> | string
    min_qty?: IntWithAggregatesFilter<"preorder"> | number
    current_qty?: IntWithAggregatesFilter<"preorder"> | number
    status?: StringWithAggregatesFilter<"preorder"> | string
    deadline?: DateTimeWithAggregatesFilter<"preorder"> | Date | string
  }

  export type productWhereInput = {
    AND?: productWhereInput | productWhereInput[]
    OR?: productWhereInput[]
    NOT?: productWhereInput | productWhereInput[]
    id?: UuidFilter<"product"> | string
    name?: StringFilter<"product"> | string
    slug?: StringFilter<"product"> | string
    alias?: StringFilter<"product"> | string
    strike_price?: DecimalNullableFilter<"product"> | Decimal | DecimalJsLike | number | string | null
    real_price?: DecimalFilter<"product"> | Decimal | DecimalJsLike | number | string
    desc?: StringFilter<"product"> | string
    info?: JsonNullableFilter<"product">
    status?: StringFilter<"product"> | string
    currency?: StringFilter<"product"> | string
    deleted_at?: DateTimeNullableFilter<"product"> | Date | string | null
    img_file?: StringFilter<"product"> | string
    cover?: StringFilter<"product"> | string
    product_file?: StringFilter<"product"> | string
    sku?: StringFilter<"product"> | string
    id_author?: UuidNullableFilter<"product"> | string | null
    published_date?: DateTimeFilter<"product"> | Date | string
    is_physical?: BoolFilter<"product"> | boolean
    preorder_min_qty?: IntNullableFilter<"product"> | number | null
    content_type?: StringNullableFilter<"product"> | string | null
    is_chapter?: BoolFilter<"product"> | boolean
    book?: BookListRelationFilter
    bundle_product?: Bundle_productListRelationFilter
    chapter?: ChapterListRelationFilter
    customer_reader?: Customer_readerListRelationFilter
    preorder?: PreorderListRelationFilter
    author?: XOR<AuthorNullableScalarRelationFilter, authorWhereInput> | null
    product_category?: Product_categoryListRelationFilter
    t_sales_download?: T_sales_downloadListRelationFilter
    t_sales_line?: T_sales_lineListRelationFilter
  }

  export type productOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    alias?: SortOrder
    strike_price?: SortOrderInput | SortOrder
    real_price?: SortOrder
    desc?: SortOrder
    info?: SortOrderInput | SortOrder
    status?: SortOrder
    currency?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    img_file?: SortOrder
    cover?: SortOrder
    product_file?: SortOrder
    sku?: SortOrder
    id_author?: SortOrderInput | SortOrder
    published_date?: SortOrder
    is_physical?: SortOrder
    preorder_min_qty?: SortOrderInput | SortOrder
    content_type?: SortOrderInput | SortOrder
    is_chapter?: SortOrder
    book?: bookOrderByRelationAggregateInput
    bundle_product?: bundle_productOrderByRelationAggregateInput
    chapter?: chapterOrderByRelationAggregateInput
    customer_reader?: customer_readerOrderByRelationAggregateInput
    preorder?: preorderOrderByRelationAggregateInput
    author?: authorOrderByWithRelationInput
    product_category?: product_categoryOrderByRelationAggregateInput
    t_sales_download?: t_sales_downloadOrderByRelationAggregateInput
    t_sales_line?: t_sales_lineOrderByRelationAggregateInput
  }

  export type productWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: productWhereInput | productWhereInput[]
    OR?: productWhereInput[]
    NOT?: productWhereInput | productWhereInput[]
    name?: StringFilter<"product"> | string
    slug?: StringFilter<"product"> | string
    alias?: StringFilter<"product"> | string
    strike_price?: DecimalNullableFilter<"product"> | Decimal | DecimalJsLike | number | string | null
    real_price?: DecimalFilter<"product"> | Decimal | DecimalJsLike | number | string
    desc?: StringFilter<"product"> | string
    info?: JsonNullableFilter<"product">
    status?: StringFilter<"product"> | string
    currency?: StringFilter<"product"> | string
    deleted_at?: DateTimeNullableFilter<"product"> | Date | string | null
    img_file?: StringFilter<"product"> | string
    cover?: StringFilter<"product"> | string
    product_file?: StringFilter<"product"> | string
    sku?: StringFilter<"product"> | string
    id_author?: UuidNullableFilter<"product"> | string | null
    published_date?: DateTimeFilter<"product"> | Date | string
    is_physical?: BoolFilter<"product"> | boolean
    preorder_min_qty?: IntNullableFilter<"product"> | number | null
    content_type?: StringNullableFilter<"product"> | string | null
    is_chapter?: BoolFilter<"product"> | boolean
    book?: BookListRelationFilter
    bundle_product?: Bundle_productListRelationFilter
    chapter?: ChapterListRelationFilter
    customer_reader?: Customer_readerListRelationFilter
    preorder?: PreorderListRelationFilter
    author?: XOR<AuthorNullableScalarRelationFilter, authorWhereInput> | null
    product_category?: Product_categoryListRelationFilter
    t_sales_download?: T_sales_downloadListRelationFilter
    t_sales_line?: T_sales_lineListRelationFilter
  }, "id">

  export type productOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    alias?: SortOrder
    strike_price?: SortOrderInput | SortOrder
    real_price?: SortOrder
    desc?: SortOrder
    info?: SortOrderInput | SortOrder
    status?: SortOrder
    currency?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    img_file?: SortOrder
    cover?: SortOrder
    product_file?: SortOrder
    sku?: SortOrder
    id_author?: SortOrderInput | SortOrder
    published_date?: SortOrder
    is_physical?: SortOrder
    preorder_min_qty?: SortOrderInput | SortOrder
    content_type?: SortOrderInput | SortOrder
    is_chapter?: SortOrder
    _count?: productCountOrderByAggregateInput
    _avg?: productAvgOrderByAggregateInput
    _max?: productMaxOrderByAggregateInput
    _min?: productMinOrderByAggregateInput
    _sum?: productSumOrderByAggregateInput
  }

  export type productScalarWhereWithAggregatesInput = {
    AND?: productScalarWhereWithAggregatesInput | productScalarWhereWithAggregatesInput[]
    OR?: productScalarWhereWithAggregatesInput[]
    NOT?: productScalarWhereWithAggregatesInput | productScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"product"> | string
    name?: StringWithAggregatesFilter<"product"> | string
    slug?: StringWithAggregatesFilter<"product"> | string
    alias?: StringWithAggregatesFilter<"product"> | string
    strike_price?: DecimalNullableWithAggregatesFilter<"product"> | Decimal | DecimalJsLike | number | string | null
    real_price?: DecimalWithAggregatesFilter<"product"> | Decimal | DecimalJsLike | number | string
    desc?: StringWithAggregatesFilter<"product"> | string
    info?: JsonNullableWithAggregatesFilter<"product">
    status?: StringWithAggregatesFilter<"product"> | string
    currency?: StringWithAggregatesFilter<"product"> | string
    deleted_at?: DateTimeNullableWithAggregatesFilter<"product"> | Date | string | null
    img_file?: StringWithAggregatesFilter<"product"> | string
    cover?: StringWithAggregatesFilter<"product"> | string
    product_file?: StringWithAggregatesFilter<"product"> | string
    sku?: StringWithAggregatesFilter<"product"> | string
    id_author?: UuidNullableWithAggregatesFilter<"product"> | string | null
    published_date?: DateTimeWithAggregatesFilter<"product"> | Date | string
    is_physical?: BoolWithAggregatesFilter<"product"> | boolean
    preorder_min_qty?: IntNullableWithAggregatesFilter<"product"> | number | null
    content_type?: StringNullableWithAggregatesFilter<"product"> | string | null
    is_chapter?: BoolWithAggregatesFilter<"product"> | boolean
  }

  export type product_categoryWhereInput = {
    AND?: product_categoryWhereInput | product_categoryWhereInput[]
    OR?: product_categoryWhereInput[]
    NOT?: product_categoryWhereInput | product_categoryWhereInput[]
    id_product?: UuidFilter<"product_category"> | string
    id_category?: UuidFilter<"product_category"> | string
    id?: UuidFilter<"product_category"> | string
    category?: XOR<CategoryScalarRelationFilter, categoryWhereInput>
    product?: XOR<ProductScalarRelationFilter, productWhereInput>
  }

  export type product_categoryOrderByWithRelationInput = {
    id_product?: SortOrder
    id_category?: SortOrder
    id?: SortOrder
    category?: categoryOrderByWithRelationInput
    product?: productOrderByWithRelationInput
  }

  export type product_categoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: product_categoryWhereInput | product_categoryWhereInput[]
    OR?: product_categoryWhereInput[]
    NOT?: product_categoryWhereInput | product_categoryWhereInput[]
    id_product?: UuidFilter<"product_category"> | string
    id_category?: UuidFilter<"product_category"> | string
    category?: XOR<CategoryScalarRelationFilter, categoryWhereInput>
    product?: XOR<ProductScalarRelationFilter, productWhereInput>
  }, "id">

  export type product_categoryOrderByWithAggregationInput = {
    id_product?: SortOrder
    id_category?: SortOrder
    id?: SortOrder
    _count?: product_categoryCountOrderByAggregateInput
    _max?: product_categoryMaxOrderByAggregateInput
    _min?: product_categoryMinOrderByAggregateInput
  }

  export type product_categoryScalarWhereWithAggregatesInput = {
    AND?: product_categoryScalarWhereWithAggregatesInput | product_categoryScalarWhereWithAggregatesInput[]
    OR?: product_categoryScalarWhereWithAggregatesInput[]
    NOT?: product_categoryScalarWhereWithAggregatesInput | product_categoryScalarWhereWithAggregatesInput[]
    id_product?: UuidWithAggregatesFilter<"product_category"> | string
    id_category?: UuidWithAggregatesFilter<"product_category"> | string
    id?: UuidWithAggregatesFilter<"product_category"> | string
  }

  export type promo_codeWhereInput = {
    AND?: promo_codeWhereInput | promo_codeWhereInput[]
    OR?: promo_codeWhereInput[]
    NOT?: promo_codeWhereInput | promo_codeWhereInput[]
    id?: UuidFilter<"promo_code"> | string
    code?: StringFilter<"promo_code"> | string
    discount_type?: StringFilter<"promo_code"> | string
    discount_value?: DecimalFilter<"promo_code"> | Decimal | DecimalJsLike | number | string
    valid_from?: DateTimeFilter<"promo_code"> | Date | string
    valid_to?: DateTimeFilter<"promo_code"> | Date | string
    usage_limit?: IntFilter<"promo_code"> | number
    used_count?: IntFilter<"promo_code"> | number
    status?: StringFilter<"promo_code"> | string
    id_publisher?: UuidFilter<"promo_code"> | string
    publisher?: XOR<PublisherScalarRelationFilter, publisherWhereInput>
  }

  export type promo_codeOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    discount_type?: SortOrder
    discount_value?: SortOrder
    valid_from?: SortOrder
    valid_to?: SortOrder
    usage_limit?: SortOrder
    used_count?: SortOrder
    status?: SortOrder
    id_publisher?: SortOrder
    publisher?: publisherOrderByWithRelationInput
  }

  export type promo_codeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: promo_codeWhereInput | promo_codeWhereInput[]
    OR?: promo_codeWhereInput[]
    NOT?: promo_codeWhereInput | promo_codeWhereInput[]
    discount_type?: StringFilter<"promo_code"> | string
    discount_value?: DecimalFilter<"promo_code"> | Decimal | DecimalJsLike | number | string
    valid_from?: DateTimeFilter<"promo_code"> | Date | string
    valid_to?: DateTimeFilter<"promo_code"> | Date | string
    usage_limit?: IntFilter<"promo_code"> | number
    used_count?: IntFilter<"promo_code"> | number
    status?: StringFilter<"promo_code"> | string
    id_publisher?: UuidFilter<"promo_code"> | string
    publisher?: XOR<PublisherScalarRelationFilter, publisherWhereInput>
  }, "id" | "code">

  export type promo_codeOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    discount_type?: SortOrder
    discount_value?: SortOrder
    valid_from?: SortOrder
    valid_to?: SortOrder
    usage_limit?: SortOrder
    used_count?: SortOrder
    status?: SortOrder
    id_publisher?: SortOrder
    _count?: promo_codeCountOrderByAggregateInput
    _avg?: promo_codeAvgOrderByAggregateInput
    _max?: promo_codeMaxOrderByAggregateInput
    _min?: promo_codeMinOrderByAggregateInput
    _sum?: promo_codeSumOrderByAggregateInput
  }

  export type promo_codeScalarWhereWithAggregatesInput = {
    AND?: promo_codeScalarWhereWithAggregatesInput | promo_codeScalarWhereWithAggregatesInput[]
    OR?: promo_codeScalarWhereWithAggregatesInput[]
    NOT?: promo_codeScalarWhereWithAggregatesInput | promo_codeScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"promo_code"> | string
    code?: StringWithAggregatesFilter<"promo_code"> | string
    discount_type?: StringWithAggregatesFilter<"promo_code"> | string
    discount_value?: DecimalWithAggregatesFilter<"promo_code"> | Decimal | DecimalJsLike | number | string
    valid_from?: DateTimeWithAggregatesFilter<"promo_code"> | Date | string
    valid_to?: DateTimeWithAggregatesFilter<"promo_code"> | Date | string
    usage_limit?: IntWithAggregatesFilter<"promo_code"> | number
    used_count?: IntWithAggregatesFilter<"promo_code"> | number
    status?: StringWithAggregatesFilter<"promo_code"> | string
    id_publisher?: UuidWithAggregatesFilter<"promo_code"> | string
  }

  export type publisherWhereInput = {
    AND?: publisherWhereInput | publisherWhereInput[]
    OR?: publisherWhereInput[]
    NOT?: publisherWhereInput | publisherWhereInput[]
    id?: UuidFilter<"publisher"> | string
    id_account?: UuidNullableFilter<"publisher"> | string | null
    name?: StringFilter<"publisher"> | string
    description?: StringNullableFilter<"publisher"> | string | null
    website?: StringNullableFilter<"publisher"> | string | null
    address?: StringNullableFilter<"publisher"> | string | null
    logo?: StringNullableFilter<"publisher"> | string | null
    auth_user?: Auth_userListRelationFilter
    promo_code?: Promo_codeListRelationFilter
    auth_account?: XOR<Auth_accountNullableScalarRelationFilter, auth_accountWhereInput> | null
    publisher_author?: Publisher_authorListRelationFilter
    t_ai_credit?: T_ai_creditListRelationFilter
    transaction?: TransactionListRelationFilter
    withdrawal?: WithdrawalListRelationFilter
  }

  export type publisherOrderByWithRelationInput = {
    id?: SortOrder
    id_account?: SortOrderInput | SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    logo?: SortOrderInput | SortOrder
    auth_user?: auth_userOrderByRelationAggregateInput
    promo_code?: promo_codeOrderByRelationAggregateInput
    auth_account?: auth_accountOrderByWithRelationInput
    publisher_author?: publisher_authorOrderByRelationAggregateInput
    t_ai_credit?: t_ai_creditOrderByRelationAggregateInput
    transaction?: transactionOrderByRelationAggregateInput
    withdrawal?: withdrawalOrderByRelationAggregateInput
  }

  export type publisherWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: publisherWhereInput | publisherWhereInput[]
    OR?: publisherWhereInput[]
    NOT?: publisherWhereInput | publisherWhereInput[]
    id_account?: UuidNullableFilter<"publisher"> | string | null
    name?: StringFilter<"publisher"> | string
    description?: StringNullableFilter<"publisher"> | string | null
    website?: StringNullableFilter<"publisher"> | string | null
    address?: StringNullableFilter<"publisher"> | string | null
    logo?: StringNullableFilter<"publisher"> | string | null
    auth_user?: Auth_userListRelationFilter
    promo_code?: Promo_codeListRelationFilter
    auth_account?: XOR<Auth_accountNullableScalarRelationFilter, auth_accountWhereInput> | null
    publisher_author?: Publisher_authorListRelationFilter
    t_ai_credit?: T_ai_creditListRelationFilter
    transaction?: TransactionListRelationFilter
    withdrawal?: WithdrawalListRelationFilter
  }, "id">

  export type publisherOrderByWithAggregationInput = {
    id?: SortOrder
    id_account?: SortOrderInput | SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    logo?: SortOrderInput | SortOrder
    _count?: publisherCountOrderByAggregateInput
    _max?: publisherMaxOrderByAggregateInput
    _min?: publisherMinOrderByAggregateInput
  }

  export type publisherScalarWhereWithAggregatesInput = {
    AND?: publisherScalarWhereWithAggregatesInput | publisherScalarWhereWithAggregatesInput[]
    OR?: publisherScalarWhereWithAggregatesInput[]
    NOT?: publisherScalarWhereWithAggregatesInput | publisherScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"publisher"> | string
    id_account?: UuidNullableWithAggregatesFilter<"publisher"> | string | null
    name?: StringWithAggregatesFilter<"publisher"> | string
    description?: StringNullableWithAggregatesFilter<"publisher"> | string | null
    website?: StringNullableWithAggregatesFilter<"publisher"> | string | null
    address?: StringNullableWithAggregatesFilter<"publisher"> | string | null
    logo?: StringNullableWithAggregatesFilter<"publisher"> | string | null
  }

  export type publisher_authorWhereInput = {
    AND?: publisher_authorWhereInput | publisher_authorWhereInput[]
    OR?: publisher_authorWhereInput[]
    NOT?: publisher_authorWhereInput | publisher_authorWhereInput[]
    id?: UuidFilter<"publisher_author"> | string
    publisher_id?: UuidFilter<"publisher_author"> | string
    author_id?: UuidFilter<"publisher_author"> | string
    author?: XOR<AuthorScalarRelationFilter, authorWhereInput>
    publisher?: XOR<PublisherScalarRelationFilter, publisherWhereInput>
  }

  export type publisher_authorOrderByWithRelationInput = {
    id?: SortOrder
    publisher_id?: SortOrder
    author_id?: SortOrder
    author?: authorOrderByWithRelationInput
    publisher?: publisherOrderByWithRelationInput
  }

  export type publisher_authorWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    publisher_id_author_id?: publisher_authorPublisher_idAuthor_idCompoundUniqueInput
    AND?: publisher_authorWhereInput | publisher_authorWhereInput[]
    OR?: publisher_authorWhereInput[]
    NOT?: publisher_authorWhereInput | publisher_authorWhereInput[]
    publisher_id?: UuidFilter<"publisher_author"> | string
    author_id?: UuidFilter<"publisher_author"> | string
    author?: XOR<AuthorScalarRelationFilter, authorWhereInput>
    publisher?: XOR<PublisherScalarRelationFilter, publisherWhereInput>
  }, "id" | "publisher_id_author_id">

  export type publisher_authorOrderByWithAggregationInput = {
    id?: SortOrder
    publisher_id?: SortOrder
    author_id?: SortOrder
    _count?: publisher_authorCountOrderByAggregateInput
    _max?: publisher_authorMaxOrderByAggregateInput
    _min?: publisher_authorMinOrderByAggregateInput
  }

  export type publisher_authorScalarWhereWithAggregatesInput = {
    AND?: publisher_authorScalarWhereWithAggregatesInput | publisher_authorScalarWhereWithAggregatesInput[]
    OR?: publisher_authorScalarWhereWithAggregatesInput[]
    NOT?: publisher_authorScalarWhereWithAggregatesInput | publisher_authorScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"publisher_author"> | string
    publisher_id?: UuidWithAggregatesFilter<"publisher_author"> | string
    author_id?: UuidWithAggregatesFilter<"publisher_author"> | string
  }

  export type rankingWhereInput = {
    AND?: rankingWhereInput | rankingWhereInput[]
    OR?: rankingWhereInput[]
    NOT?: rankingWhereInput | rankingWhereInput[]
    id?: UuidFilter<"ranking"> | string
    id_book?: UuidFilter<"ranking"> | string
    book?: XOR<BookScalarRelationFilter, bookWhereInput>
  }

  export type rankingOrderByWithRelationInput = {
    id?: SortOrder
    id_book?: SortOrder
    book?: bookOrderByWithRelationInput
  }

  export type rankingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: rankingWhereInput | rankingWhereInput[]
    OR?: rankingWhereInput[]
    NOT?: rankingWhereInput | rankingWhereInput[]
    id_book?: UuidFilter<"ranking"> | string
    book?: XOR<BookScalarRelationFilter, bookWhereInput>
  }, "id">

  export type rankingOrderByWithAggregationInput = {
    id?: SortOrder
    id_book?: SortOrder
    _count?: rankingCountOrderByAggregateInput
    _max?: rankingMaxOrderByAggregateInput
    _min?: rankingMinOrderByAggregateInput
  }

  export type rankingScalarWhereWithAggregatesInput = {
    AND?: rankingScalarWhereWithAggregatesInput | rankingScalarWhereWithAggregatesInput[]
    OR?: rankingScalarWhereWithAggregatesInput[]
    NOT?: rankingScalarWhereWithAggregatesInput | rankingScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"ranking"> | string
    id_book?: UuidWithAggregatesFilter<"ranking"> | string
  }

  export type reviewsWhereInput = {
    AND?: reviewsWhereInput | reviewsWhereInput[]
    OR?: reviewsWhereInput[]
    NOT?: reviewsWhereInput | reviewsWhereInput[]
    id?: UuidFilter<"reviews"> | string
    id_book?: UuidFilter<"reviews"> | string
    comments?: StringFilter<"reviews"> | string
    rating?: DecimalNullableFilter<"reviews"> | Decimal | DecimalJsLike | number | string | null
    created_at?: DateTimeFilter<"reviews"> | Date | string
    deleted_at?: DateTimeNullableFilter<"reviews"> | Date | string | null
    parent?: UuidNullableFilter<"reviews"> | string | null
    id_user?: UuidFilter<"reviews"> | string
    book?: XOR<BookScalarRelationFilter, bookWhereInput>
    auth_user?: XOR<Auth_userScalarRelationFilter, auth_userWhereInput>
    reviews_likes?: Reviews_likesListRelationFilter
  }

  export type reviewsOrderByWithRelationInput = {
    id?: SortOrder
    id_book?: SortOrder
    comments?: SortOrder
    rating?: SortOrderInput | SortOrder
    created_at?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    parent?: SortOrderInput | SortOrder
    id_user?: SortOrder
    book?: bookOrderByWithRelationInput
    auth_user?: auth_userOrderByWithRelationInput
    reviews_likes?: reviews_likesOrderByRelationAggregateInput
  }

  export type reviewsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: reviewsWhereInput | reviewsWhereInput[]
    OR?: reviewsWhereInput[]
    NOT?: reviewsWhereInput | reviewsWhereInput[]
    id_book?: UuidFilter<"reviews"> | string
    comments?: StringFilter<"reviews"> | string
    rating?: DecimalNullableFilter<"reviews"> | Decimal | DecimalJsLike | number | string | null
    created_at?: DateTimeFilter<"reviews"> | Date | string
    deleted_at?: DateTimeNullableFilter<"reviews"> | Date | string | null
    parent?: UuidNullableFilter<"reviews"> | string | null
    id_user?: UuidFilter<"reviews"> | string
    book?: XOR<BookScalarRelationFilter, bookWhereInput>
    auth_user?: XOR<Auth_userScalarRelationFilter, auth_userWhereInput>
    reviews_likes?: Reviews_likesListRelationFilter
  }, "id">

  export type reviewsOrderByWithAggregationInput = {
    id?: SortOrder
    id_book?: SortOrder
    comments?: SortOrder
    rating?: SortOrderInput | SortOrder
    created_at?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    parent?: SortOrderInput | SortOrder
    id_user?: SortOrder
    _count?: reviewsCountOrderByAggregateInput
    _avg?: reviewsAvgOrderByAggregateInput
    _max?: reviewsMaxOrderByAggregateInput
    _min?: reviewsMinOrderByAggregateInput
    _sum?: reviewsSumOrderByAggregateInput
  }

  export type reviewsScalarWhereWithAggregatesInput = {
    AND?: reviewsScalarWhereWithAggregatesInput | reviewsScalarWhereWithAggregatesInput[]
    OR?: reviewsScalarWhereWithAggregatesInput[]
    NOT?: reviewsScalarWhereWithAggregatesInput | reviewsScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"reviews"> | string
    id_book?: UuidWithAggregatesFilter<"reviews"> | string
    comments?: StringWithAggregatesFilter<"reviews"> | string
    rating?: DecimalNullableWithAggregatesFilter<"reviews"> | Decimal | DecimalJsLike | number | string | null
    created_at?: DateTimeWithAggregatesFilter<"reviews"> | Date | string
    deleted_at?: DateTimeNullableWithAggregatesFilter<"reviews"> | Date | string | null
    parent?: UuidNullableWithAggregatesFilter<"reviews"> | string | null
    id_user?: UuidWithAggregatesFilter<"reviews"> | string
  }

  export type reviews_likesWhereInput = {
    AND?: reviews_likesWhereInput | reviews_likesWhereInput[]
    OR?: reviews_likesWhereInput[]
    NOT?: reviews_likesWhereInput | reviews_likesWhereInput[]
    id?: UuidFilter<"reviews_likes"> | string
    id_reviews?: UuidFilter<"reviews_likes"> | string
    id_user?: UuidFilter<"reviews_likes"> | string
    reviews?: XOR<ReviewsScalarRelationFilter, reviewsWhereInput>
    auth_user?: XOR<Auth_userScalarRelationFilter, auth_userWhereInput>
  }

  export type reviews_likesOrderByWithRelationInput = {
    id?: SortOrder
    id_reviews?: SortOrder
    id_user?: SortOrder
    reviews?: reviewsOrderByWithRelationInput
    auth_user?: auth_userOrderByWithRelationInput
  }

  export type reviews_likesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: reviews_likesWhereInput | reviews_likesWhereInput[]
    OR?: reviews_likesWhereInput[]
    NOT?: reviews_likesWhereInput | reviews_likesWhereInput[]
    id_reviews?: UuidFilter<"reviews_likes"> | string
    id_user?: UuidFilter<"reviews_likes"> | string
    reviews?: XOR<ReviewsScalarRelationFilter, reviewsWhereInput>
    auth_user?: XOR<Auth_userScalarRelationFilter, auth_userWhereInput>
  }, "id">

  export type reviews_likesOrderByWithAggregationInput = {
    id?: SortOrder
    id_reviews?: SortOrder
    id_user?: SortOrder
    _count?: reviews_likesCountOrderByAggregateInput
    _max?: reviews_likesMaxOrderByAggregateInput
    _min?: reviews_likesMinOrderByAggregateInput
  }

  export type reviews_likesScalarWhereWithAggregatesInput = {
    AND?: reviews_likesScalarWhereWithAggregatesInput | reviews_likesScalarWhereWithAggregatesInput[]
    OR?: reviews_likesScalarWhereWithAggregatesInput[]
    NOT?: reviews_likesScalarWhereWithAggregatesInput | reviews_likesScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"reviews_likes"> | string
    id_reviews?: UuidWithAggregatesFilter<"reviews_likes"> | string
    id_user?: UuidWithAggregatesFilter<"reviews_likes"> | string
  }

  export type t_ai_creditWhereInput = {
    AND?: t_ai_creditWhereInput | t_ai_creditWhereInput[]
    OR?: t_ai_creditWhereInput[]
    NOT?: t_ai_creditWhereInput | t_ai_creditWhereInput[]
    id?: UuidFilter<"t_ai_credit"> | string
    id_publisher?: UuidFilter<"t_ai_credit"> | string
    balance?: IntFilter<"t_ai_credit"> | number
    last_topup_at?: DateTimeNullableFilter<"t_ai_credit"> | Date | string | null
    publisher?: XOR<PublisherScalarRelationFilter, publisherWhereInput>
    t_ai_credit_topup?: T_ai_credit_topupListRelationFilter
  }

  export type t_ai_creditOrderByWithRelationInput = {
    id?: SortOrder
    id_publisher?: SortOrder
    balance?: SortOrder
    last_topup_at?: SortOrderInput | SortOrder
    publisher?: publisherOrderByWithRelationInput
    t_ai_credit_topup?: t_ai_credit_topupOrderByRelationAggregateInput
  }

  export type t_ai_creditWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: t_ai_creditWhereInput | t_ai_creditWhereInput[]
    OR?: t_ai_creditWhereInput[]
    NOT?: t_ai_creditWhereInput | t_ai_creditWhereInput[]
    id_publisher?: UuidFilter<"t_ai_credit"> | string
    balance?: IntFilter<"t_ai_credit"> | number
    last_topup_at?: DateTimeNullableFilter<"t_ai_credit"> | Date | string | null
    publisher?: XOR<PublisherScalarRelationFilter, publisherWhereInput>
    t_ai_credit_topup?: T_ai_credit_topupListRelationFilter
  }, "id">

  export type t_ai_creditOrderByWithAggregationInput = {
    id?: SortOrder
    id_publisher?: SortOrder
    balance?: SortOrder
    last_topup_at?: SortOrderInput | SortOrder
    _count?: t_ai_creditCountOrderByAggregateInput
    _avg?: t_ai_creditAvgOrderByAggregateInput
    _max?: t_ai_creditMaxOrderByAggregateInput
    _min?: t_ai_creditMinOrderByAggregateInput
    _sum?: t_ai_creditSumOrderByAggregateInput
  }

  export type t_ai_creditScalarWhereWithAggregatesInput = {
    AND?: t_ai_creditScalarWhereWithAggregatesInput | t_ai_creditScalarWhereWithAggregatesInput[]
    OR?: t_ai_creditScalarWhereWithAggregatesInput[]
    NOT?: t_ai_creditScalarWhereWithAggregatesInput | t_ai_creditScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"t_ai_credit"> | string
    id_publisher?: UuidWithAggregatesFilter<"t_ai_credit"> | string
    balance?: IntWithAggregatesFilter<"t_ai_credit"> | number
    last_topup_at?: DateTimeNullableWithAggregatesFilter<"t_ai_credit"> | Date | string | null
  }

  export type t_ai_credit_topupWhereInput = {
    AND?: t_ai_credit_topupWhereInput | t_ai_credit_topupWhereInput[]
    OR?: t_ai_credit_topupWhereInput[]
    NOT?: t_ai_credit_topupWhereInput | t_ai_credit_topupWhereInput[]
    id?: UuidFilter<"t_ai_credit_topup"> | string
    id_t_ai_credit?: UuidFilter<"t_ai_credit_topup"> | string
    amount?: IntFilter<"t_ai_credit_topup"> | number
    created_at?: DateTimeFilter<"t_ai_credit_topup"> | Date | string
    status?: StringFilter<"t_ai_credit_topup"> | string
    t_ai_credit?: XOR<T_ai_creditScalarRelationFilter, t_ai_creditWhereInput>
  }

  export type t_ai_credit_topupOrderByWithRelationInput = {
    id?: SortOrder
    id_t_ai_credit?: SortOrder
    amount?: SortOrder
    created_at?: SortOrder
    status?: SortOrder
    t_ai_credit?: t_ai_creditOrderByWithRelationInput
  }

  export type t_ai_credit_topupWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: t_ai_credit_topupWhereInput | t_ai_credit_topupWhereInput[]
    OR?: t_ai_credit_topupWhereInput[]
    NOT?: t_ai_credit_topupWhereInput | t_ai_credit_topupWhereInput[]
    id_t_ai_credit?: UuidFilter<"t_ai_credit_topup"> | string
    amount?: IntFilter<"t_ai_credit_topup"> | number
    created_at?: DateTimeFilter<"t_ai_credit_topup"> | Date | string
    status?: StringFilter<"t_ai_credit_topup"> | string
    t_ai_credit?: XOR<T_ai_creditScalarRelationFilter, t_ai_creditWhereInput>
  }, "id">

  export type t_ai_credit_topupOrderByWithAggregationInput = {
    id?: SortOrder
    id_t_ai_credit?: SortOrder
    amount?: SortOrder
    created_at?: SortOrder
    status?: SortOrder
    _count?: t_ai_credit_topupCountOrderByAggregateInput
    _avg?: t_ai_credit_topupAvgOrderByAggregateInput
    _max?: t_ai_credit_topupMaxOrderByAggregateInput
    _min?: t_ai_credit_topupMinOrderByAggregateInput
    _sum?: t_ai_credit_topupSumOrderByAggregateInput
  }

  export type t_ai_credit_topupScalarWhereWithAggregatesInput = {
    AND?: t_ai_credit_topupScalarWhereWithAggregatesInput | t_ai_credit_topupScalarWhereWithAggregatesInput[]
    OR?: t_ai_credit_topupScalarWhereWithAggregatesInput[]
    NOT?: t_ai_credit_topupScalarWhereWithAggregatesInput | t_ai_credit_topupScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"t_ai_credit_topup"> | string
    id_t_ai_credit?: UuidWithAggregatesFilter<"t_ai_credit_topup"> | string
    amount?: IntWithAggregatesFilter<"t_ai_credit_topup"> | number
    created_at?: DateTimeWithAggregatesFilter<"t_ai_credit_topup"> | Date | string
    status?: StringWithAggregatesFilter<"t_ai_credit_topup"> | string
  }

  export type t_salesWhereInput = {
    AND?: t_salesWhereInput | t_salesWhereInput[]
    OR?: t_salesWhereInput[]
    NOT?: t_salesWhereInput | t_salesWhereInput[]
    id?: UuidFilter<"t_sales"> | string
    id_customer?: UuidFilter<"t_sales"> | string
    status?: StringFilter<"t_sales"> | string
    total?: DecimalFilter<"t_sales"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"t_sales"> | string
    info?: JsonFilter<"t_sales">
    created_at?: DateTimeFilter<"t_sales"> | Date | string
    updated_at?: DateTimeNullableFilter<"t_sales"> | Date | string | null
    deleted_at?: DateTimeNullableFilter<"t_sales"> | Date | string | null
    midtrans_order_id?: StringFilter<"t_sales"> | string
    midtrans_success?: JsonNullableFilter<"t_sales">
    midtrans_pending?: JsonNullableFilter<"t_sales">
    midtrans_error?: JsonNullableFilter<"t_sales">
    customer?: XOR<CustomerScalarRelationFilter, customerWhereInput>
    t_sales_line?: T_sales_lineListRelationFilter
  }

  export type t_salesOrderByWithRelationInput = {
    id?: SortOrder
    id_customer?: SortOrder
    status?: SortOrder
    total?: SortOrder
    currency?: SortOrder
    info?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
    midtrans_order_id?: SortOrder
    midtrans_success?: SortOrderInput | SortOrder
    midtrans_pending?: SortOrderInput | SortOrder
    midtrans_error?: SortOrderInput | SortOrder
    customer?: customerOrderByWithRelationInput
    t_sales_line?: t_sales_lineOrderByRelationAggregateInput
  }

  export type t_salesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: t_salesWhereInput | t_salesWhereInput[]
    OR?: t_salesWhereInput[]
    NOT?: t_salesWhereInput | t_salesWhereInput[]
    id_customer?: UuidFilter<"t_sales"> | string
    status?: StringFilter<"t_sales"> | string
    total?: DecimalFilter<"t_sales"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"t_sales"> | string
    info?: JsonFilter<"t_sales">
    created_at?: DateTimeFilter<"t_sales"> | Date | string
    updated_at?: DateTimeNullableFilter<"t_sales"> | Date | string | null
    deleted_at?: DateTimeNullableFilter<"t_sales"> | Date | string | null
    midtrans_order_id?: StringFilter<"t_sales"> | string
    midtrans_success?: JsonNullableFilter<"t_sales">
    midtrans_pending?: JsonNullableFilter<"t_sales">
    midtrans_error?: JsonNullableFilter<"t_sales">
    customer?: XOR<CustomerScalarRelationFilter, customerWhereInput>
    t_sales_line?: T_sales_lineListRelationFilter
  }, "id">

  export type t_salesOrderByWithAggregationInput = {
    id?: SortOrder
    id_customer?: SortOrder
    status?: SortOrder
    total?: SortOrder
    currency?: SortOrder
    info?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
    midtrans_order_id?: SortOrder
    midtrans_success?: SortOrderInput | SortOrder
    midtrans_pending?: SortOrderInput | SortOrder
    midtrans_error?: SortOrderInput | SortOrder
    _count?: t_salesCountOrderByAggregateInput
    _avg?: t_salesAvgOrderByAggregateInput
    _max?: t_salesMaxOrderByAggregateInput
    _min?: t_salesMinOrderByAggregateInput
    _sum?: t_salesSumOrderByAggregateInput
  }

  export type t_salesScalarWhereWithAggregatesInput = {
    AND?: t_salesScalarWhereWithAggregatesInput | t_salesScalarWhereWithAggregatesInput[]
    OR?: t_salesScalarWhereWithAggregatesInput[]
    NOT?: t_salesScalarWhereWithAggregatesInput | t_salesScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"t_sales"> | string
    id_customer?: UuidWithAggregatesFilter<"t_sales"> | string
    status?: StringWithAggregatesFilter<"t_sales"> | string
    total?: DecimalWithAggregatesFilter<"t_sales"> | Decimal | DecimalJsLike | number | string
    currency?: StringWithAggregatesFilter<"t_sales"> | string
    info?: JsonWithAggregatesFilter<"t_sales">
    created_at?: DateTimeWithAggregatesFilter<"t_sales"> | Date | string
    updated_at?: DateTimeNullableWithAggregatesFilter<"t_sales"> | Date | string | null
    deleted_at?: DateTimeNullableWithAggregatesFilter<"t_sales"> | Date | string | null
    midtrans_order_id?: StringWithAggregatesFilter<"t_sales"> | string
    midtrans_success?: JsonNullableWithAggregatesFilter<"t_sales">
    midtrans_pending?: JsonNullableWithAggregatesFilter<"t_sales">
    midtrans_error?: JsonNullableWithAggregatesFilter<"t_sales">
  }

  export type t_sales_downloadWhereInput = {
    AND?: t_sales_downloadWhereInput | t_sales_downloadWhereInput[]
    OR?: t_sales_downloadWhereInput[]
    NOT?: t_sales_downloadWhereInput | t_sales_downloadWhereInput[]
    id?: UuidFilter<"t_sales_download"> | string
    id_product?: UuidFilter<"t_sales_download"> | string
    id_customer?: UuidFilter<"t_sales_download"> | string
    downloaded_at?: DateTimeNullableFilter<"t_sales_download"> | Date | string | null
    ip_address?: StringNullableFilter<"t_sales_download"> | string | null
    download_key?: StringFilter<"t_sales_download"> | string
    customer?: XOR<CustomerScalarRelationFilter, customerWhereInput>
    product?: XOR<ProductScalarRelationFilter, productWhereInput>
  }

  export type t_sales_downloadOrderByWithRelationInput = {
    id?: SortOrder
    id_product?: SortOrder
    id_customer?: SortOrder
    downloaded_at?: SortOrderInput | SortOrder
    ip_address?: SortOrderInput | SortOrder
    download_key?: SortOrder
    customer?: customerOrderByWithRelationInput
    product?: productOrderByWithRelationInput
  }

  export type t_sales_downloadWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: t_sales_downloadWhereInput | t_sales_downloadWhereInput[]
    OR?: t_sales_downloadWhereInput[]
    NOT?: t_sales_downloadWhereInput | t_sales_downloadWhereInput[]
    id_product?: UuidFilter<"t_sales_download"> | string
    id_customer?: UuidFilter<"t_sales_download"> | string
    downloaded_at?: DateTimeNullableFilter<"t_sales_download"> | Date | string | null
    ip_address?: StringNullableFilter<"t_sales_download"> | string | null
    download_key?: StringFilter<"t_sales_download"> | string
    customer?: XOR<CustomerScalarRelationFilter, customerWhereInput>
    product?: XOR<ProductScalarRelationFilter, productWhereInput>
  }, "id">

  export type t_sales_downloadOrderByWithAggregationInput = {
    id?: SortOrder
    id_product?: SortOrder
    id_customer?: SortOrder
    downloaded_at?: SortOrderInput | SortOrder
    ip_address?: SortOrderInput | SortOrder
    download_key?: SortOrder
    _count?: t_sales_downloadCountOrderByAggregateInput
    _max?: t_sales_downloadMaxOrderByAggregateInput
    _min?: t_sales_downloadMinOrderByAggregateInput
  }

  export type t_sales_downloadScalarWhereWithAggregatesInput = {
    AND?: t_sales_downloadScalarWhereWithAggregatesInput | t_sales_downloadScalarWhereWithAggregatesInput[]
    OR?: t_sales_downloadScalarWhereWithAggregatesInput[]
    NOT?: t_sales_downloadScalarWhereWithAggregatesInput | t_sales_downloadScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"t_sales_download"> | string
    id_product?: UuidWithAggregatesFilter<"t_sales_download"> | string
    id_customer?: UuidWithAggregatesFilter<"t_sales_download"> | string
    downloaded_at?: DateTimeNullableWithAggregatesFilter<"t_sales_download"> | Date | string | null
    ip_address?: StringNullableWithAggregatesFilter<"t_sales_download"> | string | null
    download_key?: StringWithAggregatesFilter<"t_sales_download"> | string
  }

  export type t_sales_lineWhereInput = {
    AND?: t_sales_lineWhereInput | t_sales_lineWhereInput[]
    OR?: t_sales_lineWhereInput[]
    NOT?: t_sales_lineWhereInput | t_sales_lineWhereInput[]
    id?: UuidFilter<"t_sales_line"> | string
    id_sales?: UuidFilter<"t_sales_line"> | string
    unit_price?: DecimalFilter<"t_sales_line"> | Decimal | DecimalJsLike | number | string
    qty?: IntFilter<"t_sales_line"> | number
    total_price?: DecimalFilter<"t_sales_line"> | Decimal | DecimalJsLike | number | string
    id_product?: UuidNullableFilter<"t_sales_line"> | string | null
    id_bundle?: UuidNullableFilter<"t_sales_line"> | string | null
    bundle?: XOR<BundleNullableScalarRelationFilter, bundleWhereInput> | null
    product?: XOR<ProductNullableScalarRelationFilter, productWhereInput> | null
    t_sales?: XOR<T_salesScalarRelationFilter, t_salesWhereInput>
  }

  export type t_sales_lineOrderByWithRelationInput = {
    id?: SortOrder
    id_sales?: SortOrder
    unit_price?: SortOrder
    qty?: SortOrder
    total_price?: SortOrder
    id_product?: SortOrderInput | SortOrder
    id_bundle?: SortOrderInput | SortOrder
    bundle?: bundleOrderByWithRelationInput
    product?: productOrderByWithRelationInput
    t_sales?: t_salesOrderByWithRelationInput
  }

  export type t_sales_lineWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: t_sales_lineWhereInput | t_sales_lineWhereInput[]
    OR?: t_sales_lineWhereInput[]
    NOT?: t_sales_lineWhereInput | t_sales_lineWhereInput[]
    id_sales?: UuidFilter<"t_sales_line"> | string
    unit_price?: DecimalFilter<"t_sales_line"> | Decimal | DecimalJsLike | number | string
    qty?: IntFilter<"t_sales_line"> | number
    total_price?: DecimalFilter<"t_sales_line"> | Decimal | DecimalJsLike | number | string
    id_product?: UuidNullableFilter<"t_sales_line"> | string | null
    id_bundle?: UuidNullableFilter<"t_sales_line"> | string | null
    bundle?: XOR<BundleNullableScalarRelationFilter, bundleWhereInput> | null
    product?: XOR<ProductNullableScalarRelationFilter, productWhereInput> | null
    t_sales?: XOR<T_salesScalarRelationFilter, t_salesWhereInput>
  }, "id">

  export type t_sales_lineOrderByWithAggregationInput = {
    id?: SortOrder
    id_sales?: SortOrder
    unit_price?: SortOrder
    qty?: SortOrder
    total_price?: SortOrder
    id_product?: SortOrderInput | SortOrder
    id_bundle?: SortOrderInput | SortOrder
    _count?: t_sales_lineCountOrderByAggregateInput
    _avg?: t_sales_lineAvgOrderByAggregateInput
    _max?: t_sales_lineMaxOrderByAggregateInput
    _min?: t_sales_lineMinOrderByAggregateInput
    _sum?: t_sales_lineSumOrderByAggregateInput
  }

  export type t_sales_lineScalarWhereWithAggregatesInput = {
    AND?: t_sales_lineScalarWhereWithAggregatesInput | t_sales_lineScalarWhereWithAggregatesInput[]
    OR?: t_sales_lineScalarWhereWithAggregatesInput[]
    NOT?: t_sales_lineScalarWhereWithAggregatesInput | t_sales_lineScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"t_sales_line"> | string
    id_sales?: UuidWithAggregatesFilter<"t_sales_line"> | string
    unit_price?: DecimalWithAggregatesFilter<"t_sales_line"> | Decimal | DecimalJsLike | number | string
    qty?: IntWithAggregatesFilter<"t_sales_line"> | number
    total_price?: DecimalWithAggregatesFilter<"t_sales_line"> | Decimal | DecimalJsLike | number | string
    id_product?: UuidNullableWithAggregatesFilter<"t_sales_line"> | string | null
    id_bundle?: UuidNullableWithAggregatesFilter<"t_sales_line"> | string | null
  }

  export type tagsWhereInput = {
    AND?: tagsWhereInput | tagsWhereInput[]
    OR?: tagsWhereInput[]
    NOT?: tagsWhereInput | tagsWhereInput[]
    id?: UuidFilter<"tags"> | string
    name?: StringFilter<"tags"> | string
    id_parent?: UuidNullableFilter<"tags"> | string | null
    deleted_at?: DateTimeNullableFilter<"tags"> | Date | string | null
    slug?: StringNullableFilter<"tags"> | string | null
    img?: StringNullableFilter<"tags"> | string | null
    book_tags?: Book_tagsListRelationFilter
    tags?: XOR<TagsNullableScalarRelationFilter, tagsWhereInput> | null
    other_tags?: TagsListRelationFilter
  }

  export type tagsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    id_parent?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
    slug?: SortOrderInput | SortOrder
    img?: SortOrderInput | SortOrder
    book_tags?: book_tagsOrderByRelationAggregateInput
    tags?: tagsOrderByWithRelationInput
    other_tags?: tagsOrderByRelationAggregateInput
  }

  export type tagsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: tagsWhereInput | tagsWhereInput[]
    OR?: tagsWhereInput[]
    NOT?: tagsWhereInput | tagsWhereInput[]
    name?: StringFilter<"tags"> | string
    id_parent?: UuidNullableFilter<"tags"> | string | null
    deleted_at?: DateTimeNullableFilter<"tags"> | Date | string | null
    slug?: StringNullableFilter<"tags"> | string | null
    img?: StringNullableFilter<"tags"> | string | null
    book_tags?: Book_tagsListRelationFilter
    tags?: XOR<TagsNullableScalarRelationFilter, tagsWhereInput> | null
    other_tags?: TagsListRelationFilter
  }, "id">

  export type tagsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    id_parent?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
    slug?: SortOrderInput | SortOrder
    img?: SortOrderInput | SortOrder
    _count?: tagsCountOrderByAggregateInput
    _max?: tagsMaxOrderByAggregateInput
    _min?: tagsMinOrderByAggregateInput
  }

  export type tagsScalarWhereWithAggregatesInput = {
    AND?: tagsScalarWhereWithAggregatesInput | tagsScalarWhereWithAggregatesInput[]
    OR?: tagsScalarWhereWithAggregatesInput[]
    NOT?: tagsScalarWhereWithAggregatesInput | tagsScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"tags"> | string
    name?: StringWithAggregatesFilter<"tags"> | string
    id_parent?: UuidNullableWithAggregatesFilter<"tags"> | string | null
    deleted_at?: DateTimeNullableWithAggregatesFilter<"tags"> | Date | string | null
    slug?: StringNullableWithAggregatesFilter<"tags"> | string | null
    img?: StringNullableWithAggregatesFilter<"tags"> | string | null
  }

  export type transactionWhereInput = {
    AND?: transactionWhereInput | transactionWhereInput[]
    OR?: transactionWhereInput[]
    NOT?: transactionWhereInput | transactionWhereInput[]
    id?: UuidFilter<"transaction"> | string
    id_publisher?: UuidFilter<"transaction"> | string
    type?: StringFilter<"transaction"> | string
    amount?: DecimalFilter<"transaction"> | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeFilter<"transaction"> | Date | string
    info?: JsonFilter<"transaction">
    publisher?: XOR<PublisherScalarRelationFilter, publisherWhereInput>
  }

  export type transactionOrderByWithRelationInput = {
    id?: SortOrder
    id_publisher?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    created_at?: SortOrder
    info?: SortOrder
    publisher?: publisherOrderByWithRelationInput
  }

  export type transactionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: transactionWhereInput | transactionWhereInput[]
    OR?: transactionWhereInput[]
    NOT?: transactionWhereInput | transactionWhereInput[]
    id_publisher?: UuidFilter<"transaction"> | string
    type?: StringFilter<"transaction"> | string
    amount?: DecimalFilter<"transaction"> | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeFilter<"transaction"> | Date | string
    info?: JsonFilter<"transaction">
    publisher?: XOR<PublisherScalarRelationFilter, publisherWhereInput>
  }, "id">

  export type transactionOrderByWithAggregationInput = {
    id?: SortOrder
    id_publisher?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    created_at?: SortOrder
    info?: SortOrder
    _count?: transactionCountOrderByAggregateInput
    _avg?: transactionAvgOrderByAggregateInput
    _max?: transactionMaxOrderByAggregateInput
    _min?: transactionMinOrderByAggregateInput
    _sum?: transactionSumOrderByAggregateInput
  }

  export type transactionScalarWhereWithAggregatesInput = {
    AND?: transactionScalarWhereWithAggregatesInput | transactionScalarWhereWithAggregatesInput[]
    OR?: transactionScalarWhereWithAggregatesInput[]
    NOT?: transactionScalarWhereWithAggregatesInput | transactionScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"transaction"> | string
    id_publisher?: UuidWithAggregatesFilter<"transaction"> | string
    type?: StringWithAggregatesFilter<"transaction"> | string
    amount?: DecimalWithAggregatesFilter<"transaction"> | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeWithAggregatesFilter<"transaction"> | Date | string
    info?: JsonWithAggregatesFilter<"transaction">
  }

  export type withdrawalWhereInput = {
    AND?: withdrawalWhereInput | withdrawalWhereInput[]
    OR?: withdrawalWhereInput[]
    NOT?: withdrawalWhereInput | withdrawalWhereInput[]
    id?: UuidFilter<"withdrawal"> | string
    id_publisher?: UuidFilter<"withdrawal"> | string
    amount?: DecimalFilter<"withdrawal"> | Decimal | DecimalJsLike | number | string
    status?: StringFilter<"withdrawal"> | string
    requested_at?: DateTimeFilter<"withdrawal"> | Date | string
    processed_at?: DateTimeNullableFilter<"withdrawal"> | Date | string | null
    publisher?: XOR<PublisherScalarRelationFilter, publisherWhereInput>
  }

  export type withdrawalOrderByWithRelationInput = {
    id?: SortOrder
    id_publisher?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    requested_at?: SortOrder
    processed_at?: SortOrderInput | SortOrder
    publisher?: publisherOrderByWithRelationInput
  }

  export type withdrawalWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: withdrawalWhereInput | withdrawalWhereInput[]
    OR?: withdrawalWhereInput[]
    NOT?: withdrawalWhereInput | withdrawalWhereInput[]
    id_publisher?: UuidFilter<"withdrawal"> | string
    amount?: DecimalFilter<"withdrawal"> | Decimal | DecimalJsLike | number | string
    status?: StringFilter<"withdrawal"> | string
    requested_at?: DateTimeFilter<"withdrawal"> | Date | string
    processed_at?: DateTimeNullableFilter<"withdrawal"> | Date | string | null
    publisher?: XOR<PublisherScalarRelationFilter, publisherWhereInput>
  }, "id">

  export type withdrawalOrderByWithAggregationInput = {
    id?: SortOrder
    id_publisher?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    requested_at?: SortOrder
    processed_at?: SortOrderInput | SortOrder
    _count?: withdrawalCountOrderByAggregateInput
    _avg?: withdrawalAvgOrderByAggregateInput
    _max?: withdrawalMaxOrderByAggregateInput
    _min?: withdrawalMinOrderByAggregateInput
    _sum?: withdrawalSumOrderByAggregateInput
  }

  export type withdrawalScalarWhereWithAggregatesInput = {
    AND?: withdrawalScalarWhereWithAggregatesInput | withdrawalScalarWhereWithAggregatesInput[]
    OR?: withdrawalScalarWhereWithAggregatesInput[]
    NOT?: withdrawalScalarWhereWithAggregatesInput | withdrawalScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"withdrawal"> | string
    id_publisher?: UuidWithAggregatesFilter<"withdrawal"> | string
    amount?: DecimalWithAggregatesFilter<"withdrawal"> | Decimal | DecimalJsLike | number | string
    status?: StringWithAggregatesFilter<"withdrawal"> | string
    requested_at?: DateTimeWithAggregatesFilter<"withdrawal"> | Date | string
    processed_at?: DateTimeNullableWithAggregatesFilter<"withdrawal"> | Date | string | null
  }

  export type affiliateCreateInput = {
    id?: string
    name: string
    auth_account?: auth_accountCreateNestedOneWithoutAffiliateInput
    auth_user?: auth_userCreateNestedManyWithoutAffiliateInput
  }

  export type affiliateUncheckedCreateInput = {
    id?: string
    name: string
    id_account?: string | null
    auth_user?: auth_userUncheckedCreateNestedManyWithoutAffiliateInput
  }

  export type affiliateUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    auth_account?: auth_accountUpdateOneWithoutAffiliateNestedInput
    auth_user?: auth_userUpdateManyWithoutAffiliateNestedInput
  }

  export type affiliateUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    id_account?: NullableStringFieldUpdateOperationsInput | string | null
    auth_user?: auth_userUncheckedUpdateManyWithoutAffiliateNestedInput
  }

  export type affiliateCreateManyInput = {
    id?: string
    name: string
    id_account?: string | null
  }

  export type affiliateUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type affiliateUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    id_account?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type auth_accountCreateInput = {
    id?: string
    password?: string | null
    id_provider?: string | null
    access_token?: string | null
    refresh_token?: string | null
    id_token?: string | null
    access_token_expires_at?: Date | string | null
    refresh_token_expires_at?: Date | string | null
    scope?: string | null
    created_at?: Date | string
    updated_at?: Date | string | null
    id_account?: string | null
    affiliate?: affiliateCreateNestedManyWithoutAuth_accountInput
    auth_user?: auth_userCreateNestedOneWithoutAuth_accountInput
    author?: authorCreateNestedManyWithoutAuth_accountInput
    customer?: customerCreateNestedManyWithoutAuth_accountInput
    internal?: internalCreateNestedManyWithoutAuth_accountInput
    publisher?: publisherCreateNestedManyWithoutAuth_accountInput
  }

  export type auth_accountUncheckedCreateInput = {
    id?: string
    password?: string | null
    id_provider?: string | null
    access_token?: string | null
    refresh_token?: string | null
    id_token?: string | null
    access_token_expires_at?: Date | string | null
    refresh_token_expires_at?: Date | string | null
    scope?: string | null
    created_at?: Date | string
    updated_at?: Date | string | null
    id_user?: string | null
    id_account?: string | null
    affiliate?: affiliateUncheckedCreateNestedManyWithoutAuth_accountInput
    author?: authorUncheckedCreateNestedManyWithoutAuth_accountInput
    customer?: customerUncheckedCreateNestedManyWithoutAuth_accountInput
    internal?: internalUncheckedCreateNestedManyWithoutAuth_accountInput
    publisher?: publisherUncheckedCreateNestedManyWithoutAuth_accountInput
  }

  export type auth_accountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    id_provider?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token_expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refresh_token_expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    id_account?: NullableStringFieldUpdateOperationsInput | string | null
    affiliate?: affiliateUpdateManyWithoutAuth_accountNestedInput
    auth_user?: auth_userUpdateOneWithoutAuth_accountNestedInput
    author?: authorUpdateManyWithoutAuth_accountNestedInput
    customer?: customerUpdateManyWithoutAuth_accountNestedInput
    internal?: internalUpdateManyWithoutAuth_accountNestedInput
    publisher?: publisherUpdateManyWithoutAuth_accountNestedInput
  }

  export type auth_accountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    id_provider?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token_expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refresh_token_expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    id_user?: NullableStringFieldUpdateOperationsInput | string | null
    id_account?: NullableStringFieldUpdateOperationsInput | string | null
    affiliate?: affiliateUncheckedUpdateManyWithoutAuth_accountNestedInput
    author?: authorUncheckedUpdateManyWithoutAuth_accountNestedInput
    customer?: customerUncheckedUpdateManyWithoutAuth_accountNestedInput
    internal?: internalUncheckedUpdateManyWithoutAuth_accountNestedInput
    publisher?: publisherUncheckedUpdateManyWithoutAuth_accountNestedInput
  }

  export type auth_accountCreateManyInput = {
    id?: string
    password?: string | null
    id_provider?: string | null
    access_token?: string | null
    refresh_token?: string | null
    id_token?: string | null
    access_token_expires_at?: Date | string | null
    refresh_token_expires_at?: Date | string | null
    scope?: string | null
    created_at?: Date | string
    updated_at?: Date | string | null
    id_user?: string | null
    id_account?: string | null
  }

  export type auth_accountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    id_provider?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token_expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refresh_token_expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    id_account?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type auth_accountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    id_provider?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token_expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refresh_token_expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    id_user?: NullableStringFieldUpdateOperationsInput | string | null
    id_account?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type auth_sessionCreateInput = {
    id?: string
    expires_at: Date | string
    token: string
    created_at?: Date | string
    updated_at?: Date | string | null
    ip_address?: string | null
    user_agent?: string | null
    auth_user: auth_userCreateNestedOneWithoutAuth_sessionInput
  }

  export type auth_sessionUncheckedCreateInput = {
    id?: string
    expires_at: Date | string
    token: string
    created_at?: Date | string
    updated_at?: Date | string | null
    ip_address?: string | null
    user_agent?: string | null
    id_user: string
  }

  export type auth_sessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    auth_user?: auth_userUpdateOneRequiredWithoutAuth_sessionNestedInput
  }

  export type auth_sessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    id_user?: StringFieldUpdateOperationsInput | string
  }

  export type auth_sessionCreateManyInput = {
    id?: string
    expires_at: Date | string
    token: string
    created_at?: Date | string
    updated_at?: Date | string | null
    ip_address?: string | null
    user_agent?: string | null
    id_user: string
  }

  export type auth_sessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type auth_sessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    id_user?: StringFieldUpdateOperationsInput | string
  }

  export type auth_two_factorCreateInput = {
    id?: string
    secret?: string | null
    backup_codes?: string | null
    auth_user: auth_userCreateNestedOneWithoutAuth_two_factorInput
  }

  export type auth_two_factorUncheckedCreateInput = {
    id?: string
    secret?: string | null
    backup_codes?: string | null
    id_user: string
  }

  export type auth_two_factorUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    secret?: NullableStringFieldUpdateOperationsInput | string | null
    backup_codes?: NullableStringFieldUpdateOperationsInput | string | null
    auth_user?: auth_userUpdateOneRequiredWithoutAuth_two_factorNestedInput
  }

  export type auth_two_factorUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    secret?: NullableStringFieldUpdateOperationsInput | string | null
    backup_codes?: NullableStringFieldUpdateOperationsInput | string | null
    id_user?: StringFieldUpdateOperationsInput | string
  }

  export type auth_two_factorCreateManyInput = {
    id?: string
    secret?: string | null
    backup_codes?: string | null
    id_user: string
  }

  export type auth_two_factorUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    secret?: NullableStringFieldUpdateOperationsInput | string | null
    backup_codes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type auth_two_factorUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    secret?: NullableStringFieldUpdateOperationsInput | string | null
    backup_codes?: NullableStringFieldUpdateOperationsInput | string | null
    id_user?: StringFieldUpdateOperationsInput | string
  }

  export type auth_userCreateInput = {
    id?: string
    name: string
    email: string
    email_verified?: boolean
    image?: string | null
    created_at?: Date | string
    updated_at?: Date | string | null
    username?: string | null
    display_username?: string | null
    two_factor_enabled?: boolean | null
    auth_account?: auth_accountCreateNestedManyWithoutAuth_userInput
    auth_session?: auth_sessionCreateNestedManyWithoutAuth_userInput
    auth_two_factor?: auth_two_factorCreateNestedManyWithoutAuth_userInput
    affiliate?: affiliateCreateNestedOneWithoutAuth_userInput
    author?: authorCreateNestedOneWithoutAuth_userInput
    customer?: customerCreateNestedOneWithoutAuth_userInput
    internal?: internalCreateNestedOneWithoutAuth_userInput
    publisher?: publisherCreateNestedOneWithoutAuth_userInput
    reviews?: reviewsCreateNestedManyWithoutAuth_userInput
    reviews_likes?: reviews_likesCreateNestedManyWithoutAuth_userInput
  }

  export type auth_userUncheckedCreateInput = {
    id?: string
    name: string
    email: string
    email_verified?: boolean
    image?: string | null
    created_at?: Date | string
    updated_at?: Date | string | null
    username?: string | null
    display_username?: string | null
    two_factor_enabled?: boolean | null
    id_customer?: string | null
    id_author?: string | null
    id_affiliate?: string | null
    id_publisher?: string | null
    id_internal?: string | null
    auth_account?: auth_accountUncheckedCreateNestedManyWithoutAuth_userInput
    auth_session?: auth_sessionUncheckedCreateNestedManyWithoutAuth_userInput
    auth_two_factor?: auth_two_factorUncheckedCreateNestedManyWithoutAuth_userInput
    reviews?: reviewsUncheckedCreateNestedManyWithoutAuth_userInput
    reviews_likes?: reviews_likesUncheckedCreateNestedManyWithoutAuth_userInput
  }

  export type auth_userUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    email_verified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    display_username?: NullableStringFieldUpdateOperationsInput | string | null
    two_factor_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    auth_account?: auth_accountUpdateManyWithoutAuth_userNestedInput
    auth_session?: auth_sessionUpdateManyWithoutAuth_userNestedInput
    auth_two_factor?: auth_two_factorUpdateManyWithoutAuth_userNestedInput
    affiliate?: affiliateUpdateOneWithoutAuth_userNestedInput
    author?: authorUpdateOneWithoutAuth_userNestedInput
    customer?: customerUpdateOneWithoutAuth_userNestedInput
    internal?: internalUpdateOneWithoutAuth_userNestedInput
    publisher?: publisherUpdateOneWithoutAuth_userNestedInput
    reviews?: reviewsUpdateManyWithoutAuth_userNestedInput
    reviews_likes?: reviews_likesUpdateManyWithoutAuth_userNestedInput
  }

  export type auth_userUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    email_verified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    display_username?: NullableStringFieldUpdateOperationsInput | string | null
    two_factor_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    id_customer?: NullableStringFieldUpdateOperationsInput | string | null
    id_author?: NullableStringFieldUpdateOperationsInput | string | null
    id_affiliate?: NullableStringFieldUpdateOperationsInput | string | null
    id_publisher?: NullableStringFieldUpdateOperationsInput | string | null
    id_internal?: NullableStringFieldUpdateOperationsInput | string | null
    auth_account?: auth_accountUncheckedUpdateManyWithoutAuth_userNestedInput
    auth_session?: auth_sessionUncheckedUpdateManyWithoutAuth_userNestedInput
    auth_two_factor?: auth_two_factorUncheckedUpdateManyWithoutAuth_userNestedInput
    reviews?: reviewsUncheckedUpdateManyWithoutAuth_userNestedInput
    reviews_likes?: reviews_likesUncheckedUpdateManyWithoutAuth_userNestedInput
  }

  export type auth_userCreateManyInput = {
    id?: string
    name: string
    email: string
    email_verified?: boolean
    image?: string | null
    created_at?: Date | string
    updated_at?: Date | string | null
    username?: string | null
    display_username?: string | null
    two_factor_enabled?: boolean | null
    id_customer?: string | null
    id_author?: string | null
    id_affiliate?: string | null
    id_publisher?: string | null
    id_internal?: string | null
  }

  export type auth_userUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    email_verified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    display_username?: NullableStringFieldUpdateOperationsInput | string | null
    two_factor_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type auth_userUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    email_verified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    display_username?: NullableStringFieldUpdateOperationsInput | string | null
    two_factor_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    id_customer?: NullableStringFieldUpdateOperationsInput | string | null
    id_author?: NullableStringFieldUpdateOperationsInput | string | null
    id_affiliate?: NullableStringFieldUpdateOperationsInput | string | null
    id_publisher?: NullableStringFieldUpdateOperationsInput | string | null
    id_internal?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type auth_verificationCreateInput = {
    id?: string
    identifier: string
    value: string
    expires_at: Date | string
    created_at?: Date | string
    updated_at?: Date | string | null
  }

  export type auth_verificationUncheckedCreateInput = {
    id?: string
    identifier: string
    value: string
    expires_at: Date | string
    created_at?: Date | string
    updated_at?: Date | string | null
  }

  export type auth_verificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type auth_verificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type auth_verificationCreateManyInput = {
    id?: string
    identifier: string
    value: string
    expires_at: Date | string
    created_at?: Date | string
    updated_at?: Date | string | null
  }

  export type auth_verificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type auth_verificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type authorCreateInput = {
    id?: string
    name: string
    biography?: string | null
    social_media?: string | null
    avatar?: string | null
    auth_user?: auth_userCreateNestedManyWithoutAuthorInput
    auth_account?: auth_accountCreateNestedOneWithoutAuthorInput
    book?: bookCreateNestedManyWithoutAuthorInput
    product?: productCreateNestedManyWithoutAuthorInput
    publisher_author?: publisher_authorCreateNestedManyWithoutAuthorInput
  }

  export type authorUncheckedCreateInput = {
    id?: string
    name: string
    id_account?: string | null
    biography?: string | null
    social_media?: string | null
    avatar?: string | null
    auth_user?: auth_userUncheckedCreateNestedManyWithoutAuthorInput
    book?: bookUncheckedCreateNestedManyWithoutAuthorInput
    product?: productUncheckedCreateNestedManyWithoutAuthorInput
    publisher_author?: publisher_authorUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type authorUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    biography?: NullableStringFieldUpdateOperationsInput | string | null
    social_media?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    auth_user?: auth_userUpdateManyWithoutAuthorNestedInput
    auth_account?: auth_accountUpdateOneWithoutAuthorNestedInput
    book?: bookUpdateManyWithoutAuthorNestedInput
    product?: productUpdateManyWithoutAuthorNestedInput
    publisher_author?: publisher_authorUpdateManyWithoutAuthorNestedInput
  }

  export type authorUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    id_account?: NullableStringFieldUpdateOperationsInput | string | null
    biography?: NullableStringFieldUpdateOperationsInput | string | null
    social_media?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    auth_user?: auth_userUncheckedUpdateManyWithoutAuthorNestedInput
    book?: bookUncheckedUpdateManyWithoutAuthorNestedInput
    product?: productUncheckedUpdateManyWithoutAuthorNestedInput
    publisher_author?: publisher_authorUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type authorCreateManyInput = {
    id?: string
    name: string
    id_account?: string | null
    biography?: string | null
    social_media?: string | null
    avatar?: string | null
  }

  export type authorUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    biography?: NullableStringFieldUpdateOperationsInput | string | null
    social_media?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type authorUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    id_account?: NullableStringFieldUpdateOperationsInput | string | null
    biography?: NullableStringFieldUpdateOperationsInput | string | null
    social_media?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type bannerCreateInput = {
    id?: string
    title: string
    banner_file?: string
    status?: string | null
    deleted_at?: Date | string | null
    link?: string | null
  }

  export type bannerUncheckedCreateInput = {
    id?: string
    title: string
    banner_file?: string
    status?: string | null
    deleted_at?: Date | string | null
    link?: string | null
  }

  export type bannerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    banner_file?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type bannerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    banner_file?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type bannerCreateManyInput = {
    id?: string
    title: string
    banner_file?: string
    status?: string | null
    deleted_at?: Date | string | null
    link?: string | null
  }

  export type bannerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    banner_file?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type bannerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    banner_file?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type bookCreateInput = {
    id?: string
    name: string
    slug: string
    alias?: string
    submitted_price: Decimal | DecimalJsLike | number | string
    desc?: string
    info?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    currency?: string
    deleted_at?: Date | string | null
    img_file?: string
    cover?: string
    product_file?: string
    sku?: string
    published_date?: Date | string
    is_physical?: boolean
    preorder_min_qty?: number | null
    content_type?: string | null
    is_chapter?: boolean
    created_at?: Date | string
    author?: authorCreateNestedOneWithoutBookInput
    product?: productCreateNestedOneWithoutBookInput
    book_approval?: book_approvalCreateNestedManyWithoutBookInput
    book_changes_log?: book_changes_logCreateNestedManyWithoutBookInput
    book_genre?: book_genreCreateNestedManyWithoutBookInput
    book_tags?: book_tagsCreateNestedManyWithoutBookInput
    chapter?: chapterCreateNestedManyWithoutBookInput
    ranking?: rankingCreateNestedManyWithoutBookInput
    reviews?: reviewsCreateNestedManyWithoutBookInput
  }

  export type bookUncheckedCreateInput = {
    id?: string
    name: string
    slug: string
    alias?: string
    submitted_price: Decimal | DecimalJsLike | number | string
    desc?: string
    info?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    currency?: string
    deleted_at?: Date | string | null
    img_file?: string
    cover?: string
    product_file?: string
    sku?: string
    id_author?: string | null
    published_date?: Date | string
    is_physical?: boolean
    preorder_min_qty?: number | null
    content_type?: string | null
    is_chapter?: boolean
    id_product?: string | null
    created_at?: Date | string
    book_approval?: book_approvalUncheckedCreateNestedManyWithoutBookInput
    book_changes_log?: book_changes_logUncheckedCreateNestedManyWithoutBookInput
    book_genre?: book_genreUncheckedCreateNestedManyWithoutBookInput
    book_tags?: book_tagsUncheckedCreateNestedManyWithoutBookInput
    chapter?: chapterUncheckedCreateNestedManyWithoutBookInput
    ranking?: rankingUncheckedCreateNestedManyWithoutBookInput
    reviews?: reviewsUncheckedCreateNestedManyWithoutBookInput
  }

  export type bookUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    alias?: StringFieldUpdateOperationsInput | string
    submitted_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    desc?: StringFieldUpdateOperationsInput | string
    info?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    img_file?: StringFieldUpdateOperationsInput | string
    cover?: StringFieldUpdateOperationsInput | string
    product_file?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    published_date?: DateTimeFieldUpdateOperationsInput | Date | string
    is_physical?: BoolFieldUpdateOperationsInput | boolean
    preorder_min_qty?: NullableIntFieldUpdateOperationsInput | number | null
    content_type?: NullableStringFieldUpdateOperationsInput | string | null
    is_chapter?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: authorUpdateOneWithoutBookNestedInput
    product?: productUpdateOneWithoutBookNestedInput
    book_approval?: book_approvalUpdateManyWithoutBookNestedInput
    book_changes_log?: book_changes_logUpdateManyWithoutBookNestedInput
    book_genre?: book_genreUpdateManyWithoutBookNestedInput
    book_tags?: book_tagsUpdateManyWithoutBookNestedInput
    chapter?: chapterUpdateManyWithoutBookNestedInput
    ranking?: rankingUpdateManyWithoutBookNestedInput
    reviews?: reviewsUpdateManyWithoutBookNestedInput
  }

  export type bookUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    alias?: StringFieldUpdateOperationsInput | string
    submitted_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    desc?: StringFieldUpdateOperationsInput | string
    info?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    img_file?: StringFieldUpdateOperationsInput | string
    cover?: StringFieldUpdateOperationsInput | string
    product_file?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    id_author?: NullableStringFieldUpdateOperationsInput | string | null
    published_date?: DateTimeFieldUpdateOperationsInput | Date | string
    is_physical?: BoolFieldUpdateOperationsInput | boolean
    preorder_min_qty?: NullableIntFieldUpdateOperationsInput | number | null
    content_type?: NullableStringFieldUpdateOperationsInput | string | null
    is_chapter?: BoolFieldUpdateOperationsInput | boolean
    id_product?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    book_approval?: book_approvalUncheckedUpdateManyWithoutBookNestedInput
    book_changes_log?: book_changes_logUncheckedUpdateManyWithoutBookNestedInput
    book_genre?: book_genreUncheckedUpdateManyWithoutBookNestedInput
    book_tags?: book_tagsUncheckedUpdateManyWithoutBookNestedInput
    chapter?: chapterUncheckedUpdateManyWithoutBookNestedInput
    ranking?: rankingUncheckedUpdateManyWithoutBookNestedInput
    reviews?: reviewsUncheckedUpdateManyWithoutBookNestedInput
  }

  export type bookCreateManyInput = {
    id?: string
    name: string
    slug: string
    alias?: string
    submitted_price: Decimal | DecimalJsLike | number | string
    desc?: string
    info?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    currency?: string
    deleted_at?: Date | string | null
    img_file?: string
    cover?: string
    product_file?: string
    sku?: string
    id_author?: string | null
    published_date?: Date | string
    is_physical?: boolean
    preorder_min_qty?: number | null
    content_type?: string | null
    is_chapter?: boolean
    id_product?: string | null
    created_at?: Date | string
  }

  export type bookUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    alias?: StringFieldUpdateOperationsInput | string
    submitted_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    desc?: StringFieldUpdateOperationsInput | string
    info?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    img_file?: StringFieldUpdateOperationsInput | string
    cover?: StringFieldUpdateOperationsInput | string
    product_file?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    published_date?: DateTimeFieldUpdateOperationsInput | Date | string
    is_physical?: BoolFieldUpdateOperationsInput | boolean
    preorder_min_qty?: NullableIntFieldUpdateOperationsInput | number | null
    content_type?: NullableStringFieldUpdateOperationsInput | string | null
    is_chapter?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type bookUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    alias?: StringFieldUpdateOperationsInput | string
    submitted_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    desc?: StringFieldUpdateOperationsInput | string
    info?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    img_file?: StringFieldUpdateOperationsInput | string
    cover?: StringFieldUpdateOperationsInput | string
    product_file?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    id_author?: NullableStringFieldUpdateOperationsInput | string | null
    published_date?: DateTimeFieldUpdateOperationsInput | Date | string
    is_physical?: BoolFieldUpdateOperationsInput | boolean
    preorder_min_qty?: NullableIntFieldUpdateOperationsInput | number | null
    content_type?: NullableStringFieldUpdateOperationsInput | string | null
    is_chapter?: BoolFieldUpdateOperationsInput | boolean
    id_product?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type book_approvalCreateInput = {
    id?: string
    comment?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    created_at?: Date | string
    book: bookCreateNestedOneWithoutBook_approvalInput
    internal?: internalCreateNestedOneWithoutBook_approvalInput
  }

  export type book_approvalUncheckedCreateInput = {
    id?: string
    id_book: string
    id_internal?: string | null
    comment?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    created_at?: Date | string
  }

  export type book_approvalUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    comment?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    book?: bookUpdateOneRequiredWithoutBook_approvalNestedInput
    internal?: internalUpdateOneWithoutBook_approvalNestedInput
  }

  export type book_approvalUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    id_book?: StringFieldUpdateOperationsInput | string
    id_internal?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type book_approvalCreateManyInput = {
    id?: string
    id_book: string
    id_internal?: string | null
    comment?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    created_at?: Date | string
  }

  export type book_approvalUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    comment?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type book_approvalUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    id_book?: StringFieldUpdateOperationsInput | string
    id_internal?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type book_changes_logCreateInput = {
    created_at?: Date | string
    changes?: NullableJsonNullValueInput | InputJsonValue
    book: bookCreateNestedOneWithoutBook_changes_logInput
  }

  export type book_changes_logUncheckedCreateInput = {
    id_book: string
    created_at?: Date | string
    changes?: NullableJsonNullValueInput | InputJsonValue
  }

  export type book_changes_logUpdateInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    changes?: NullableJsonNullValueInput | InputJsonValue
    book?: bookUpdateOneRequiredWithoutBook_changes_logNestedInput
  }

  export type book_changes_logUncheckedUpdateInput = {
    id_book?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    changes?: NullableJsonNullValueInput | InputJsonValue
  }

  export type book_changes_logCreateManyInput = {
    id_book: string
    created_at?: Date | string
    changes?: NullableJsonNullValueInput | InputJsonValue
  }

  export type book_changes_logUpdateManyMutationInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    changes?: NullableJsonNullValueInput | InputJsonValue
  }

  export type book_changes_logUncheckedUpdateManyInput = {
    id_book?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    changes?: NullableJsonNullValueInput | InputJsonValue
  }

  export type book_genreCreateInput = {
    id?: string
    book: bookCreateNestedOneWithoutBook_genreInput
    genre: genreCreateNestedOneWithoutBook_genreInput
  }

  export type book_genreUncheckedCreateInput = {
    id?: string
    id_genre: string
    id_book: string
  }

  export type book_genreUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    book?: bookUpdateOneRequiredWithoutBook_genreNestedInput
    genre?: genreUpdateOneRequiredWithoutBook_genreNestedInput
  }

  export type book_genreUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    id_genre?: StringFieldUpdateOperationsInput | string
    id_book?: StringFieldUpdateOperationsInput | string
  }

  export type book_genreCreateManyInput = {
    id?: string
    id_genre: string
    id_book: string
  }

  export type book_genreUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type book_genreUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    id_genre?: StringFieldUpdateOperationsInput | string
    id_book?: StringFieldUpdateOperationsInput | string
  }

  export type book_tagsCreateInput = {
    id?: string
    book: bookCreateNestedOneWithoutBook_tagsInput
    tags: tagsCreateNestedOneWithoutBook_tagsInput
  }

  export type book_tagsUncheckedCreateInput = {
    id?: string
    id_tags: string
    id_book: string
  }

  export type book_tagsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    book?: bookUpdateOneRequiredWithoutBook_tagsNestedInput
    tags?: tagsUpdateOneRequiredWithoutBook_tagsNestedInput
  }

  export type book_tagsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    id_tags?: StringFieldUpdateOperationsInput | string
    id_book?: StringFieldUpdateOperationsInput | string
  }

  export type book_tagsCreateManyInput = {
    id?: string
    id_tags: string
    id_book: string
  }

  export type book_tagsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type book_tagsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    id_tags?: StringFieldUpdateOperationsInput | string
    id_book?: StringFieldUpdateOperationsInput | string
  }

  export type bundleCreateInput = {
    id?: string
    name: string
    slug: string
    strike_price?: Decimal | DecimalJsLike | number | string | null
    real_price: Decimal | DecimalJsLike | number | string
    currency?: string
    desc?: string
    info?: JsonNullValueInput | InputJsonValue
    deleted_at?: Date | string | null
    status?: string
    img_file?: string
    cover?: string
    sku?: string
    bundle_category?: bundle_categoryCreateNestedManyWithoutBundleInput
    bundle_product?: bundle_productCreateNestedManyWithoutBundleInput
    t_sales_line?: t_sales_lineCreateNestedManyWithoutBundleInput
  }

  export type bundleUncheckedCreateInput = {
    id?: string
    name: string
    slug: string
    strike_price?: Decimal | DecimalJsLike | number | string | null
    real_price: Decimal | DecimalJsLike | number | string
    currency?: string
    desc?: string
    info?: JsonNullValueInput | InputJsonValue
    deleted_at?: Date | string | null
    status?: string
    img_file?: string
    cover?: string
    sku?: string
    bundle_category?: bundle_categoryUncheckedCreateNestedManyWithoutBundleInput
    bundle_product?: bundle_productUncheckedCreateNestedManyWithoutBundleInput
    t_sales_line?: t_sales_lineUncheckedCreateNestedManyWithoutBundleInput
  }

  export type bundleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    strike_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    real_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    desc?: StringFieldUpdateOperationsInput | string
    info?: JsonNullValueInput | InputJsonValue
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    img_file?: StringFieldUpdateOperationsInput | string
    cover?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    bundle_category?: bundle_categoryUpdateManyWithoutBundleNestedInput
    bundle_product?: bundle_productUpdateManyWithoutBundleNestedInput
    t_sales_line?: t_sales_lineUpdateManyWithoutBundleNestedInput
  }

  export type bundleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    strike_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    real_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    desc?: StringFieldUpdateOperationsInput | string
    info?: JsonNullValueInput | InputJsonValue
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    img_file?: StringFieldUpdateOperationsInput | string
    cover?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    bundle_category?: bundle_categoryUncheckedUpdateManyWithoutBundleNestedInput
    bundle_product?: bundle_productUncheckedUpdateManyWithoutBundleNestedInput
    t_sales_line?: t_sales_lineUncheckedUpdateManyWithoutBundleNestedInput
  }

  export type bundleCreateManyInput = {
    id?: string
    name: string
    slug: string
    strike_price?: Decimal | DecimalJsLike | number | string | null
    real_price: Decimal | DecimalJsLike | number | string
    currency?: string
    desc?: string
    info?: JsonNullValueInput | InputJsonValue
    deleted_at?: Date | string | null
    status?: string
    img_file?: string
    cover?: string
    sku?: string
  }

  export type bundleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    strike_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    real_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    desc?: StringFieldUpdateOperationsInput | string
    info?: JsonNullValueInput | InputJsonValue
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    img_file?: StringFieldUpdateOperationsInput | string
    cover?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
  }

  export type bundleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    strike_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    real_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    desc?: StringFieldUpdateOperationsInput | string
    info?: JsonNullValueInput | InputJsonValue
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    img_file?: StringFieldUpdateOperationsInput | string
    cover?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
  }

  export type bundle_categoryCreateInput = {
    id?: string
    bundle: bundleCreateNestedOneWithoutBundle_categoryInput
    category: categoryCreateNestedOneWithoutBundle_categoryInput
  }

  export type bundle_categoryUncheckedCreateInput = {
    id?: string
    id_category: string
    id_bundle: string
  }

  export type bundle_categoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    bundle?: bundleUpdateOneRequiredWithoutBundle_categoryNestedInput
    category?: categoryUpdateOneRequiredWithoutBundle_categoryNestedInput
  }

  export type bundle_categoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    id_category?: StringFieldUpdateOperationsInput | string
    id_bundle?: StringFieldUpdateOperationsInput | string
  }

  export type bundle_categoryCreateManyInput = {
    id?: string
    id_category: string
    id_bundle: string
  }

  export type bundle_categoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type bundle_categoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    id_category?: StringFieldUpdateOperationsInput | string
    id_bundle?: StringFieldUpdateOperationsInput | string
  }

  export type bundle_productCreateInput = {
    id?: string
    qty?: number | null
    bundle: bundleCreateNestedOneWithoutBundle_productInput
    product: productCreateNestedOneWithoutBundle_productInput
  }

  export type bundle_productUncheckedCreateInput = {
    id_bundle: string
    id_product: string
    id?: string
    qty?: number | null
  }

  export type bundle_productUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    qty?: NullableIntFieldUpdateOperationsInput | number | null
    bundle?: bundleUpdateOneRequiredWithoutBundle_productNestedInput
    product?: productUpdateOneRequiredWithoutBundle_productNestedInput
  }

  export type bundle_productUncheckedUpdateInput = {
    id_bundle?: StringFieldUpdateOperationsInput | string
    id_product?: StringFieldUpdateOperationsInput | string
    id?: StringFieldUpdateOperationsInput | string
    qty?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type bundle_productCreateManyInput = {
    id_bundle: string
    id_product: string
    id?: string
    qty?: number | null
  }

  export type bundle_productUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    qty?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type bundle_productUncheckedUpdateManyInput = {
    id_bundle?: StringFieldUpdateOperationsInput | string
    id_product?: StringFieldUpdateOperationsInput | string
    id?: StringFieldUpdateOperationsInput | string
    qty?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type categoryCreateInput = {
    id?: string
    name: string
    deleted_at?: Date | string | null
    slug?: string | null
    img?: string | null
    bundle_category?: bundle_categoryCreateNestedManyWithoutCategoryInput
    category?: categoryCreateNestedOneWithoutOther_categoryInput
    other_category?: categoryCreateNestedManyWithoutCategoryInput
    product_category?: product_categoryCreateNestedManyWithoutCategoryInput
  }

  export type categoryUncheckedCreateInput = {
    id?: string
    name: string
    id_parent?: string | null
    deleted_at?: Date | string | null
    slug?: string | null
    img?: string | null
    bundle_category?: bundle_categoryUncheckedCreateNestedManyWithoutCategoryInput
    other_category?: categoryUncheckedCreateNestedManyWithoutCategoryInput
    product_category?: product_categoryUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type categoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    img?: NullableStringFieldUpdateOperationsInput | string | null
    bundle_category?: bundle_categoryUpdateManyWithoutCategoryNestedInput
    category?: categoryUpdateOneWithoutOther_categoryNestedInput
    other_category?: categoryUpdateManyWithoutCategoryNestedInput
    product_category?: product_categoryUpdateManyWithoutCategoryNestedInput
  }

  export type categoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    id_parent?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    img?: NullableStringFieldUpdateOperationsInput | string | null
    bundle_category?: bundle_categoryUncheckedUpdateManyWithoutCategoryNestedInput
    other_category?: categoryUncheckedUpdateManyWithoutCategoryNestedInput
    product_category?: product_categoryUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type categoryCreateManyInput = {
    id?: string
    name: string
    id_parent?: string | null
    deleted_at?: Date | string | null
    slug?: string | null
    img?: string | null
  }

  export type categoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    img?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type categoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    id_parent?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    img?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type chapterCreateInput = {
    id?: string
    number: number
    name: string
    content?: JsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string | null
    book?: bookCreateNestedOneWithoutChapterInput
    product?: productCreateNestedOneWithoutChapterInput
  }

  export type chapterUncheckedCreateInput = {
    id?: string
    id_product?: string | null
    id_book?: string | null
    number: number
    name: string
    content?: JsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string | null
  }

  export type chapterUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    book?: bookUpdateOneWithoutChapterNestedInput
    product?: productUpdateOneWithoutChapterNestedInput
  }

  export type chapterUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    id_product?: NullableStringFieldUpdateOperationsInput | string | null
    id_book?: NullableStringFieldUpdateOperationsInput | string | null
    number?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type chapterCreateManyInput = {
    id?: string
    id_product?: string | null
    id_book?: string | null
    number: number
    name: string
    content?: JsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string | null
  }

  export type chapterUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type chapterUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    id_product?: NullableStringFieldUpdateOperationsInput | string | null
    id_book?: NullableStringFieldUpdateOperationsInput | string | null
    number?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type customerCreateInput = {
    id?: string
    whatsapp: string
    deleted_at?: Date | string | null
    otp?: number | null
    name: string
    email: string
    auth_user?: auth_userCreateNestedManyWithoutCustomerInput
    auth_account?: auth_accountCreateNestedOneWithoutCustomerInput
    customer_reader?: customer_readerCreateNestedManyWithoutCustomerInput
    customer_track?: customer_trackCreateNestedManyWithoutCustomerInput
    t_sales?: t_salesCreateNestedManyWithoutCustomerInput
    t_sales_download?: t_sales_downloadCreateNestedManyWithoutCustomerInput
  }

  export type customerUncheckedCreateInput = {
    id?: string
    whatsapp: string
    deleted_at?: Date | string | null
    otp?: number | null
    id_account?: string | null
    name: string
    email: string
    auth_user?: auth_userUncheckedCreateNestedManyWithoutCustomerInput
    customer_reader?: customer_readerUncheckedCreateNestedManyWithoutCustomerInput
    customer_track?: customer_trackUncheckedCreateNestedManyWithoutCustomerInput
    t_sales?: t_salesUncheckedCreateNestedManyWithoutCustomerInput
    t_sales_download?: t_sales_downloadUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type customerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    whatsapp?: StringFieldUpdateOperationsInput | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otp?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    auth_user?: auth_userUpdateManyWithoutCustomerNestedInput
    auth_account?: auth_accountUpdateOneWithoutCustomerNestedInput
    customer_reader?: customer_readerUpdateManyWithoutCustomerNestedInput
    customer_track?: customer_trackUpdateManyWithoutCustomerNestedInput
    t_sales?: t_salesUpdateManyWithoutCustomerNestedInput
    t_sales_download?: t_sales_downloadUpdateManyWithoutCustomerNestedInput
  }

  export type customerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    whatsapp?: StringFieldUpdateOperationsInput | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otp?: NullableIntFieldUpdateOperationsInput | number | null
    id_account?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    auth_user?: auth_userUncheckedUpdateManyWithoutCustomerNestedInput
    customer_reader?: customer_readerUncheckedUpdateManyWithoutCustomerNestedInput
    customer_track?: customer_trackUncheckedUpdateManyWithoutCustomerNestedInput
    t_sales?: t_salesUncheckedUpdateManyWithoutCustomerNestedInput
    t_sales_download?: t_sales_downloadUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type customerCreateManyInput = {
    id?: string
    whatsapp: string
    deleted_at?: Date | string | null
    otp?: number | null
    id_account?: string | null
    name: string
    email: string
  }

  export type customerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    whatsapp?: StringFieldUpdateOperationsInput | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otp?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
  }

  export type customerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    whatsapp?: StringFieldUpdateOperationsInput | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otp?: NullableIntFieldUpdateOperationsInput | number | null
    id_account?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
  }

  export type customer_readerCreateInput = {
    id?: string
    last_page: number
    percent: number
    customer: customerCreateNestedOneWithoutCustomer_readerInput
    product: productCreateNestedOneWithoutCustomer_readerInput
  }

  export type customer_readerUncheckedCreateInput = {
    id?: string
    id_customer: string
    id_product: string
    last_page: number
    percent: number
  }

  export type customer_readerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    last_page?: IntFieldUpdateOperationsInput | number
    percent?: IntFieldUpdateOperationsInput | number
    customer?: customerUpdateOneRequiredWithoutCustomer_readerNestedInput
    product?: productUpdateOneRequiredWithoutCustomer_readerNestedInput
  }

  export type customer_readerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    id_customer?: StringFieldUpdateOperationsInput | string
    id_product?: StringFieldUpdateOperationsInput | string
    last_page?: IntFieldUpdateOperationsInput | number
    percent?: IntFieldUpdateOperationsInput | number
  }

  export type customer_readerCreateManyInput = {
    id?: string
    id_customer: string
    id_product: string
    last_page: number
    percent: number
  }

  export type customer_readerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    last_page?: IntFieldUpdateOperationsInput | number
    percent?: IntFieldUpdateOperationsInput | number
  }

  export type customer_readerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    id_customer?: StringFieldUpdateOperationsInput | string
    id_product?: StringFieldUpdateOperationsInput | string
    last_page?: IntFieldUpdateOperationsInput | number
    percent?: IntFieldUpdateOperationsInput | number
  }

  export type customer_trackCreateInput = {
    id?: string
    ts?: Date | string
    path: string
    referrer: string
    info: JsonNullValueInput | InputJsonValue
    ip: string
    customer: customerCreateNestedOneWithoutCustomer_trackInput
  }

  export type customer_trackUncheckedCreateInput = {
    id?: string
    ts?: Date | string
    id_customer: string
    path: string
    referrer: string
    info: JsonNullValueInput | InputJsonValue
    ip: string
  }

  export type customer_trackUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    ts?: DateTimeFieldUpdateOperationsInput | Date | string
    path?: StringFieldUpdateOperationsInput | string
    referrer?: StringFieldUpdateOperationsInput | string
    info?: JsonNullValueInput | InputJsonValue
    ip?: StringFieldUpdateOperationsInput | string
    customer?: customerUpdateOneRequiredWithoutCustomer_trackNestedInput
  }

  export type customer_trackUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    ts?: DateTimeFieldUpdateOperationsInput | Date | string
    id_customer?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    referrer?: StringFieldUpdateOperationsInput | string
    info?: JsonNullValueInput | InputJsonValue
    ip?: StringFieldUpdateOperationsInput | string
  }

  export type customer_trackCreateManyInput = {
    id?: string
    ts?: Date | string
    id_customer: string
    path: string
    referrer: string
    info: JsonNullValueInput | InputJsonValue
    ip: string
  }

  export type customer_trackUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    ts?: DateTimeFieldUpdateOperationsInput | Date | string
    path?: StringFieldUpdateOperationsInput | string
    referrer?: StringFieldUpdateOperationsInput | string
    info?: JsonNullValueInput | InputJsonValue
    ip?: StringFieldUpdateOperationsInput | string
  }

  export type customer_trackUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    ts?: DateTimeFieldUpdateOperationsInput | Date | string
    id_customer?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    referrer?: StringFieldUpdateOperationsInput | string
    info?: JsonNullValueInput | InputJsonValue
    ip?: StringFieldUpdateOperationsInput | string
  }

  export type genreCreateInput = {
    id?: string
    name: string
    slug?: string | null
    img?: string | null
    deleted_at?: Date | string | null
    book_genre?: book_genreCreateNestedManyWithoutGenreInput
    genre?: genreCreateNestedOneWithoutOther_genreInput
    other_genre?: genreCreateNestedManyWithoutGenreInput
  }

  export type genreUncheckedCreateInput = {
    id?: string
    name: string
    id_parent?: string | null
    slug?: string | null
    img?: string | null
    deleted_at?: Date | string | null
    book_genre?: book_genreUncheckedCreateNestedManyWithoutGenreInput
    other_genre?: genreUncheckedCreateNestedManyWithoutGenreInput
  }

  export type genreUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    img?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    book_genre?: book_genreUpdateManyWithoutGenreNestedInput
    genre?: genreUpdateOneWithoutOther_genreNestedInput
    other_genre?: genreUpdateManyWithoutGenreNestedInput
  }

  export type genreUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    id_parent?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    img?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    book_genre?: book_genreUncheckedUpdateManyWithoutGenreNestedInput
    other_genre?: genreUncheckedUpdateManyWithoutGenreNestedInput
  }

  export type genreCreateManyInput = {
    id?: string
    name: string
    id_parent?: string | null
    slug?: string | null
    img?: string | null
    deleted_at?: Date | string | null
  }

  export type genreUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    img?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type genreUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    id_parent?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    img?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type internalCreateInput = {
    id?: string
    name: string
    is_sales_and_marketing?: boolean
    is_support?: boolean
    is_management?: boolean
    is_it?: boolean
    auth_user?: auth_userCreateNestedManyWithoutInternalInput
    book_approval?: book_approvalCreateNestedManyWithoutInternalInput
    auth_account?: auth_accountCreateNestedOneWithoutInternalInput
  }

  export type internalUncheckedCreateInput = {
    id?: string
    id_account?: string | null
    name: string
    is_sales_and_marketing?: boolean
    is_support?: boolean
    is_management?: boolean
    is_it?: boolean
    auth_user?: auth_userUncheckedCreateNestedManyWithoutInternalInput
    book_approval?: book_approvalUncheckedCreateNestedManyWithoutInternalInput
  }

  export type internalUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    is_sales_and_marketing?: BoolFieldUpdateOperationsInput | boolean
    is_support?: BoolFieldUpdateOperationsInput | boolean
    is_management?: BoolFieldUpdateOperationsInput | boolean
    is_it?: BoolFieldUpdateOperationsInput | boolean
    auth_user?: auth_userUpdateManyWithoutInternalNestedInput
    book_approval?: book_approvalUpdateManyWithoutInternalNestedInput
    auth_account?: auth_accountUpdateOneWithoutInternalNestedInput
  }

  export type internalUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    id_account?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    is_sales_and_marketing?: BoolFieldUpdateOperationsInput | boolean
    is_support?: BoolFieldUpdateOperationsInput | boolean
    is_management?: BoolFieldUpdateOperationsInput | boolean
    is_it?: BoolFieldUpdateOperationsInput | boolean
    auth_user?: auth_userUncheckedUpdateManyWithoutInternalNestedInput
    book_approval?: book_approvalUncheckedUpdateManyWithoutInternalNestedInput
  }

  export type internalCreateManyInput = {
    id?: string
    id_account?: string | null
    name: string
    is_sales_and_marketing?: boolean
    is_support?: boolean
    is_management?: boolean
    is_it?: boolean
  }

  export type internalUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    is_sales_and_marketing?: BoolFieldUpdateOperationsInput | boolean
    is_support?: BoolFieldUpdateOperationsInput | boolean
    is_management?: BoolFieldUpdateOperationsInput | boolean
    is_it?: BoolFieldUpdateOperationsInput | boolean
  }

  export type internalUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    id_account?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    is_sales_and_marketing?: BoolFieldUpdateOperationsInput | boolean
    is_support?: BoolFieldUpdateOperationsInput | boolean
    is_management?: BoolFieldUpdateOperationsInput | boolean
    is_it?: BoolFieldUpdateOperationsInput | boolean
  }

  export type landingCreateInput = {
    id?: string
    slug: string
    views: number
    deleted_at?: Date | string | null
    status?: string
    title?: string
    landing_items?: landing_itemsCreateNestedManyWithoutLandingInput
  }

  export type landingUncheckedCreateInput = {
    id?: string
    slug: string
    views: number
    deleted_at?: Date | string | null
    status?: string
    title?: string
    landing_items?: landing_itemsUncheckedCreateNestedManyWithoutLandingInput
  }

  export type landingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    views?: IntFieldUpdateOperationsInput | number
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    landing_items?: landing_itemsUpdateManyWithoutLandingNestedInput
  }

  export type landingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    views?: IntFieldUpdateOperationsInput | number
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    landing_items?: landing_itemsUncheckedUpdateManyWithoutLandingNestedInput
  }

  export type landingCreateManyInput = {
    id?: string
    slug: string
    views: number
    deleted_at?: Date | string | null
    status?: string
    title?: string
  }

  export type landingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    views?: IntFieldUpdateOperationsInput | number
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
  }

  export type landingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    views?: IntFieldUpdateOperationsInput | number
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
  }

  export type landing_itemsCreateInput = {
    id?: string
    desc?: string
    img_file: string
    tag?: string
    link_to: string
    idx?: number
    color?: string
    landing: landingCreateNestedOneWithoutLanding_itemsInput
  }

  export type landing_itemsUncheckedCreateInput = {
    id?: string
    desc?: string
    img_file: string
    tag?: string
    link_to: string
    landing_id: string
    idx?: number
    color?: string
  }

  export type landing_itemsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    desc?: StringFieldUpdateOperationsInput | string
    img_file?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
    link_to?: StringFieldUpdateOperationsInput | string
    idx?: IntFieldUpdateOperationsInput | number
    color?: StringFieldUpdateOperationsInput | string
    landing?: landingUpdateOneRequiredWithoutLanding_itemsNestedInput
  }

  export type landing_itemsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    desc?: StringFieldUpdateOperationsInput | string
    img_file?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
    link_to?: StringFieldUpdateOperationsInput | string
    landing_id?: StringFieldUpdateOperationsInput | string
    idx?: IntFieldUpdateOperationsInput | number
    color?: StringFieldUpdateOperationsInput | string
  }

  export type landing_itemsCreateManyInput = {
    id?: string
    desc?: string
    img_file: string
    tag?: string
    link_to: string
    landing_id: string
    idx?: number
    color?: string
  }

  export type landing_itemsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    desc?: StringFieldUpdateOperationsInput | string
    img_file?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
    link_to?: StringFieldUpdateOperationsInput | string
    idx?: IntFieldUpdateOperationsInput | number
    color?: StringFieldUpdateOperationsInput | string
  }

  export type landing_itemsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    desc?: StringFieldUpdateOperationsInput | string
    img_file?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
    link_to?: StringFieldUpdateOperationsInput | string
    landing_id?: StringFieldUpdateOperationsInput | string
    idx?: IntFieldUpdateOperationsInput | number
    color?: StringFieldUpdateOperationsInput | string
  }

  export type midtrxCreateInput = {
    id?: string
    tz?: Date | string
    type: string
    payload: JsonNullValueInput | InputJsonValue
  }

  export type midtrxUncheckedCreateInput = {
    id?: string
    tz?: Date | string
    type: string
    payload: JsonNullValueInput | InputJsonValue
  }

  export type midtrxUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tz?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    payload?: JsonNullValueInput | InputJsonValue
  }

  export type midtrxUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tz?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    payload?: JsonNullValueInput | InputJsonValue
  }

  export type midtrxCreateManyInput = {
    id?: string
    tz?: Date | string
    type: string
    payload: JsonNullValueInput | InputJsonValue
  }

  export type midtrxUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tz?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    payload?: JsonNullValueInput | InputJsonValue
  }

  export type midtrxUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tz?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    payload?: JsonNullValueInput | InputJsonValue
  }

  export type preorderCreateInput = {
    id?: string
    min_qty: number
    current_qty?: number
    status?: string
    deadline: Date | string
    product: productCreateNestedOneWithoutPreorderInput
  }

  export type preorderUncheckedCreateInput = {
    id?: string
    id_product: string
    min_qty: number
    current_qty?: number
    status?: string
    deadline: Date | string
  }

  export type preorderUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    min_qty?: IntFieldUpdateOperationsInput | number
    current_qty?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    deadline?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: productUpdateOneRequiredWithoutPreorderNestedInput
  }

  export type preorderUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    id_product?: StringFieldUpdateOperationsInput | string
    min_qty?: IntFieldUpdateOperationsInput | number
    current_qty?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    deadline?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type preorderCreateManyInput = {
    id?: string
    id_product: string
    min_qty: number
    current_qty?: number
    status?: string
    deadline: Date | string
  }

  export type preorderUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    min_qty?: IntFieldUpdateOperationsInput | number
    current_qty?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    deadline?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type preorderUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    id_product?: StringFieldUpdateOperationsInput | string
    min_qty?: IntFieldUpdateOperationsInput | number
    current_qty?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    deadline?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type productCreateInput = {
    id?: string
    name: string
    slug: string
    alias?: string
    strike_price?: Decimal | DecimalJsLike | number | string | null
    real_price: Decimal | DecimalJsLike | number | string
    desc?: string
    info?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    currency?: string
    deleted_at?: Date | string | null
    img_file?: string
    cover?: string
    product_file?: string
    sku?: string
    published_date?: Date | string
    is_physical?: boolean
    preorder_min_qty?: number | null
    content_type?: string | null
    is_chapter?: boolean
    book?: bookCreateNestedManyWithoutProductInput
    bundle_product?: bundle_productCreateNestedManyWithoutProductInput
    chapter?: chapterCreateNestedManyWithoutProductInput
    customer_reader?: customer_readerCreateNestedManyWithoutProductInput
    preorder?: preorderCreateNestedManyWithoutProductInput
    author?: authorCreateNestedOneWithoutProductInput
    product_category?: product_categoryCreateNestedManyWithoutProductInput
    t_sales_download?: t_sales_downloadCreateNestedManyWithoutProductInput
    t_sales_line?: t_sales_lineCreateNestedManyWithoutProductInput
  }

  export type productUncheckedCreateInput = {
    id?: string
    name: string
    slug: string
    alias?: string
    strike_price?: Decimal | DecimalJsLike | number | string | null
    real_price: Decimal | DecimalJsLike | number | string
    desc?: string
    info?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    currency?: string
    deleted_at?: Date | string | null
    img_file?: string
    cover?: string
    product_file?: string
    sku?: string
    id_author?: string | null
    published_date?: Date | string
    is_physical?: boolean
    preorder_min_qty?: number | null
    content_type?: string | null
    is_chapter?: boolean
    book?: bookUncheckedCreateNestedManyWithoutProductInput
    bundle_product?: bundle_productUncheckedCreateNestedManyWithoutProductInput
    chapter?: chapterUncheckedCreateNestedManyWithoutProductInput
    customer_reader?: customer_readerUncheckedCreateNestedManyWithoutProductInput
    preorder?: preorderUncheckedCreateNestedManyWithoutProductInput
    product_category?: product_categoryUncheckedCreateNestedManyWithoutProductInput
    t_sales_download?: t_sales_downloadUncheckedCreateNestedManyWithoutProductInput
    t_sales_line?: t_sales_lineUncheckedCreateNestedManyWithoutProductInput
  }

  export type productUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    alias?: StringFieldUpdateOperationsInput | string
    strike_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    real_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    desc?: StringFieldUpdateOperationsInput | string
    info?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    img_file?: StringFieldUpdateOperationsInput | string
    cover?: StringFieldUpdateOperationsInput | string
    product_file?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    published_date?: DateTimeFieldUpdateOperationsInput | Date | string
    is_physical?: BoolFieldUpdateOperationsInput | boolean
    preorder_min_qty?: NullableIntFieldUpdateOperationsInput | number | null
    content_type?: NullableStringFieldUpdateOperationsInput | string | null
    is_chapter?: BoolFieldUpdateOperationsInput | boolean
    book?: bookUpdateManyWithoutProductNestedInput
    bundle_product?: bundle_productUpdateManyWithoutProductNestedInput
    chapter?: chapterUpdateManyWithoutProductNestedInput
    customer_reader?: customer_readerUpdateManyWithoutProductNestedInput
    preorder?: preorderUpdateManyWithoutProductNestedInput
    author?: authorUpdateOneWithoutProductNestedInput
    product_category?: product_categoryUpdateManyWithoutProductNestedInput
    t_sales_download?: t_sales_downloadUpdateManyWithoutProductNestedInput
    t_sales_line?: t_sales_lineUpdateManyWithoutProductNestedInput
  }

  export type productUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    alias?: StringFieldUpdateOperationsInput | string
    strike_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    real_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    desc?: StringFieldUpdateOperationsInput | string
    info?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    img_file?: StringFieldUpdateOperationsInput | string
    cover?: StringFieldUpdateOperationsInput | string
    product_file?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    id_author?: NullableStringFieldUpdateOperationsInput | string | null
    published_date?: DateTimeFieldUpdateOperationsInput | Date | string
    is_physical?: BoolFieldUpdateOperationsInput | boolean
    preorder_min_qty?: NullableIntFieldUpdateOperationsInput | number | null
    content_type?: NullableStringFieldUpdateOperationsInput | string | null
    is_chapter?: BoolFieldUpdateOperationsInput | boolean
    book?: bookUncheckedUpdateManyWithoutProductNestedInput
    bundle_product?: bundle_productUncheckedUpdateManyWithoutProductNestedInput
    chapter?: chapterUncheckedUpdateManyWithoutProductNestedInput
    customer_reader?: customer_readerUncheckedUpdateManyWithoutProductNestedInput
    preorder?: preorderUncheckedUpdateManyWithoutProductNestedInput
    product_category?: product_categoryUncheckedUpdateManyWithoutProductNestedInput
    t_sales_download?: t_sales_downloadUncheckedUpdateManyWithoutProductNestedInput
    t_sales_line?: t_sales_lineUncheckedUpdateManyWithoutProductNestedInput
  }

  export type productCreateManyInput = {
    id?: string
    name: string
    slug: string
    alias?: string
    strike_price?: Decimal | DecimalJsLike | number | string | null
    real_price: Decimal | DecimalJsLike | number | string
    desc?: string
    info?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    currency?: string
    deleted_at?: Date | string | null
    img_file?: string
    cover?: string
    product_file?: string
    sku?: string
    id_author?: string | null
    published_date?: Date | string
    is_physical?: boolean
    preorder_min_qty?: number | null
    content_type?: string | null
    is_chapter?: boolean
  }

  export type productUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    alias?: StringFieldUpdateOperationsInput | string
    strike_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    real_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    desc?: StringFieldUpdateOperationsInput | string
    info?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    img_file?: StringFieldUpdateOperationsInput | string
    cover?: StringFieldUpdateOperationsInput | string
    product_file?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    published_date?: DateTimeFieldUpdateOperationsInput | Date | string
    is_physical?: BoolFieldUpdateOperationsInput | boolean
    preorder_min_qty?: NullableIntFieldUpdateOperationsInput | number | null
    content_type?: NullableStringFieldUpdateOperationsInput | string | null
    is_chapter?: BoolFieldUpdateOperationsInput | boolean
  }

  export type productUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    alias?: StringFieldUpdateOperationsInput | string
    strike_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    real_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    desc?: StringFieldUpdateOperationsInput | string
    info?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    img_file?: StringFieldUpdateOperationsInput | string
    cover?: StringFieldUpdateOperationsInput | string
    product_file?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    id_author?: NullableStringFieldUpdateOperationsInput | string | null
    published_date?: DateTimeFieldUpdateOperationsInput | Date | string
    is_physical?: BoolFieldUpdateOperationsInput | boolean
    preorder_min_qty?: NullableIntFieldUpdateOperationsInput | number | null
    content_type?: NullableStringFieldUpdateOperationsInput | string | null
    is_chapter?: BoolFieldUpdateOperationsInput | boolean
  }

  export type product_categoryCreateInput = {
    id?: string
    category: categoryCreateNestedOneWithoutProduct_categoryInput
    product: productCreateNestedOneWithoutProduct_categoryInput
  }

  export type product_categoryUncheckedCreateInput = {
    id_product: string
    id_category: string
    id?: string
  }

  export type product_categoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: categoryUpdateOneRequiredWithoutProduct_categoryNestedInput
    product?: productUpdateOneRequiredWithoutProduct_categoryNestedInput
  }

  export type product_categoryUncheckedUpdateInput = {
    id_product?: StringFieldUpdateOperationsInput | string
    id_category?: StringFieldUpdateOperationsInput | string
    id?: StringFieldUpdateOperationsInput | string
  }

  export type product_categoryCreateManyInput = {
    id_product: string
    id_category: string
    id?: string
  }

  export type product_categoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type product_categoryUncheckedUpdateManyInput = {
    id_product?: StringFieldUpdateOperationsInput | string
    id_category?: StringFieldUpdateOperationsInput | string
    id?: StringFieldUpdateOperationsInput | string
  }

  export type promo_codeCreateInput = {
    id?: string
    code: string
    discount_type: string
    discount_value: Decimal | DecimalJsLike | number | string
    valid_from: Date | string
    valid_to: Date | string
    usage_limit: number
    used_count?: number
    status?: string
    publisher: publisherCreateNestedOneWithoutPromo_codeInput
  }

  export type promo_codeUncheckedCreateInput = {
    id?: string
    code: string
    discount_type: string
    discount_value: Decimal | DecimalJsLike | number | string
    valid_from: Date | string
    valid_to: Date | string
    usage_limit: number
    used_count?: number
    status?: string
    id_publisher: string
  }

  export type promo_codeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    discount_type?: StringFieldUpdateOperationsInput | string
    discount_value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    valid_from?: DateTimeFieldUpdateOperationsInput | Date | string
    valid_to?: DateTimeFieldUpdateOperationsInput | Date | string
    usage_limit?: IntFieldUpdateOperationsInput | number
    used_count?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    publisher?: publisherUpdateOneRequiredWithoutPromo_codeNestedInput
  }

  export type promo_codeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    discount_type?: StringFieldUpdateOperationsInput | string
    discount_value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    valid_from?: DateTimeFieldUpdateOperationsInput | Date | string
    valid_to?: DateTimeFieldUpdateOperationsInput | Date | string
    usage_limit?: IntFieldUpdateOperationsInput | number
    used_count?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    id_publisher?: StringFieldUpdateOperationsInput | string
  }

  export type promo_codeCreateManyInput = {
    id?: string
    code: string
    discount_type: string
    discount_value: Decimal | DecimalJsLike | number | string
    valid_from: Date | string
    valid_to: Date | string
    usage_limit: number
    used_count?: number
    status?: string
    id_publisher: string
  }

  export type promo_codeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    discount_type?: StringFieldUpdateOperationsInput | string
    discount_value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    valid_from?: DateTimeFieldUpdateOperationsInput | Date | string
    valid_to?: DateTimeFieldUpdateOperationsInput | Date | string
    usage_limit?: IntFieldUpdateOperationsInput | number
    used_count?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
  }

  export type promo_codeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    discount_type?: StringFieldUpdateOperationsInput | string
    discount_value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    valid_from?: DateTimeFieldUpdateOperationsInput | Date | string
    valid_to?: DateTimeFieldUpdateOperationsInput | Date | string
    usage_limit?: IntFieldUpdateOperationsInput | number
    used_count?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    id_publisher?: StringFieldUpdateOperationsInput | string
  }

  export type publisherCreateInput = {
    id?: string
    name: string
    description?: string | null
    website?: string | null
    address?: string | null
    logo?: string | null
    auth_user?: auth_userCreateNestedManyWithoutPublisherInput
    promo_code?: promo_codeCreateNestedManyWithoutPublisherInput
    auth_account?: auth_accountCreateNestedOneWithoutPublisherInput
    publisher_author?: publisher_authorCreateNestedManyWithoutPublisherInput
    t_ai_credit?: t_ai_creditCreateNestedManyWithoutPublisherInput
    transaction?: transactionCreateNestedManyWithoutPublisherInput
    withdrawal?: withdrawalCreateNestedManyWithoutPublisherInput
  }

  export type publisherUncheckedCreateInput = {
    id?: string
    id_account?: string | null
    name: string
    description?: string | null
    website?: string | null
    address?: string | null
    logo?: string | null
    auth_user?: auth_userUncheckedCreateNestedManyWithoutPublisherInput
    promo_code?: promo_codeUncheckedCreateNestedManyWithoutPublisherInput
    publisher_author?: publisher_authorUncheckedCreateNestedManyWithoutPublisherInput
    t_ai_credit?: t_ai_creditUncheckedCreateNestedManyWithoutPublisherInput
    transaction?: transactionUncheckedCreateNestedManyWithoutPublisherInput
    withdrawal?: withdrawalUncheckedCreateNestedManyWithoutPublisherInput
  }

  export type publisherUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    auth_user?: auth_userUpdateManyWithoutPublisherNestedInput
    promo_code?: promo_codeUpdateManyWithoutPublisherNestedInput
    auth_account?: auth_accountUpdateOneWithoutPublisherNestedInput
    publisher_author?: publisher_authorUpdateManyWithoutPublisherNestedInput
    t_ai_credit?: t_ai_creditUpdateManyWithoutPublisherNestedInput
    transaction?: transactionUpdateManyWithoutPublisherNestedInput
    withdrawal?: withdrawalUpdateManyWithoutPublisherNestedInput
  }

  export type publisherUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    id_account?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    auth_user?: auth_userUncheckedUpdateManyWithoutPublisherNestedInput
    promo_code?: promo_codeUncheckedUpdateManyWithoutPublisherNestedInput
    publisher_author?: publisher_authorUncheckedUpdateManyWithoutPublisherNestedInput
    t_ai_credit?: t_ai_creditUncheckedUpdateManyWithoutPublisherNestedInput
    transaction?: transactionUncheckedUpdateManyWithoutPublisherNestedInput
    withdrawal?: withdrawalUncheckedUpdateManyWithoutPublisherNestedInput
  }

  export type publisherCreateManyInput = {
    id?: string
    id_account?: string | null
    name: string
    description?: string | null
    website?: string | null
    address?: string | null
    logo?: string | null
  }

  export type publisherUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type publisherUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    id_account?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type publisher_authorCreateInput = {
    id?: string
    author: authorCreateNestedOneWithoutPublisher_authorInput
    publisher: publisherCreateNestedOneWithoutPublisher_authorInput
  }

  export type publisher_authorUncheckedCreateInput = {
    id?: string
    publisher_id: string
    author_id: string
  }

  export type publisher_authorUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    author?: authorUpdateOneRequiredWithoutPublisher_authorNestedInput
    publisher?: publisherUpdateOneRequiredWithoutPublisher_authorNestedInput
  }

  export type publisher_authorUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    publisher_id?: StringFieldUpdateOperationsInput | string
    author_id?: StringFieldUpdateOperationsInput | string
  }

  export type publisher_authorCreateManyInput = {
    id?: string
    publisher_id: string
    author_id: string
  }

  export type publisher_authorUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type publisher_authorUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    publisher_id?: StringFieldUpdateOperationsInput | string
    author_id?: StringFieldUpdateOperationsInput | string
  }

  export type rankingCreateInput = {
    id?: string
    book: bookCreateNestedOneWithoutRankingInput
  }

  export type rankingUncheckedCreateInput = {
    id?: string
    id_book: string
  }

  export type rankingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    book?: bookUpdateOneRequiredWithoutRankingNestedInput
  }

  export type rankingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    id_book?: StringFieldUpdateOperationsInput | string
  }

  export type rankingCreateManyInput = {
    id?: string
    id_book: string
  }

  export type rankingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type rankingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    id_book?: StringFieldUpdateOperationsInput | string
  }

  export type reviewsCreateInput = {
    id?: string
    comments: string
    rating?: Decimal | DecimalJsLike | number | string | null
    created_at: Date | string
    deleted_at?: Date | string | null
    parent?: string | null
    book: bookCreateNestedOneWithoutReviewsInput
    auth_user: auth_userCreateNestedOneWithoutReviewsInput
    reviews_likes?: reviews_likesCreateNestedManyWithoutReviewsInput
  }

  export type reviewsUncheckedCreateInput = {
    id?: string
    id_book: string
    comments: string
    rating?: Decimal | DecimalJsLike | number | string | null
    created_at: Date | string
    deleted_at?: Date | string | null
    parent?: string | null
    id_user: string
    reviews_likes?: reviews_likesUncheckedCreateNestedManyWithoutReviewsInput
  }

  export type reviewsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    comments?: StringFieldUpdateOperationsInput | string
    rating?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parent?: NullableStringFieldUpdateOperationsInput | string | null
    book?: bookUpdateOneRequiredWithoutReviewsNestedInput
    auth_user?: auth_userUpdateOneRequiredWithoutReviewsNestedInput
    reviews_likes?: reviews_likesUpdateManyWithoutReviewsNestedInput
  }

  export type reviewsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    id_book?: StringFieldUpdateOperationsInput | string
    comments?: StringFieldUpdateOperationsInput | string
    rating?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parent?: NullableStringFieldUpdateOperationsInput | string | null
    id_user?: StringFieldUpdateOperationsInput | string
    reviews_likes?: reviews_likesUncheckedUpdateManyWithoutReviewsNestedInput
  }

  export type reviewsCreateManyInput = {
    id?: string
    id_book: string
    comments: string
    rating?: Decimal | DecimalJsLike | number | string | null
    created_at: Date | string
    deleted_at?: Date | string | null
    parent?: string | null
    id_user: string
  }

  export type reviewsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    comments?: StringFieldUpdateOperationsInput | string
    rating?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type reviewsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    id_book?: StringFieldUpdateOperationsInput | string
    comments?: StringFieldUpdateOperationsInput | string
    rating?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parent?: NullableStringFieldUpdateOperationsInput | string | null
    id_user?: StringFieldUpdateOperationsInput | string
  }

  export type reviews_likesCreateInput = {
    id?: string
    reviews: reviewsCreateNestedOneWithoutReviews_likesInput
    auth_user: auth_userCreateNestedOneWithoutReviews_likesInput
  }

  export type reviews_likesUncheckedCreateInput = {
    id?: string
    id_reviews: string
    id_user: string
  }

  export type reviews_likesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    reviews?: reviewsUpdateOneRequiredWithoutReviews_likesNestedInput
    auth_user?: auth_userUpdateOneRequiredWithoutReviews_likesNestedInput
  }

  export type reviews_likesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    id_reviews?: StringFieldUpdateOperationsInput | string
    id_user?: StringFieldUpdateOperationsInput | string
  }

  export type reviews_likesCreateManyInput = {
    id?: string
    id_reviews: string
    id_user: string
  }

  export type reviews_likesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type reviews_likesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    id_reviews?: StringFieldUpdateOperationsInput | string
    id_user?: StringFieldUpdateOperationsInput | string
  }

  export type t_ai_creditCreateInput = {
    id?: string
    balance?: number
    last_topup_at?: Date | string | null
    publisher: publisherCreateNestedOneWithoutT_ai_creditInput
    t_ai_credit_topup?: t_ai_credit_topupCreateNestedManyWithoutT_ai_creditInput
  }

  export type t_ai_creditUncheckedCreateInput = {
    id?: string
    id_publisher: string
    balance?: number
    last_topup_at?: Date | string | null
    t_ai_credit_topup?: t_ai_credit_topupUncheckedCreateNestedManyWithoutT_ai_creditInput
  }

  export type t_ai_creditUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    balance?: IntFieldUpdateOperationsInput | number
    last_topup_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    publisher?: publisherUpdateOneRequiredWithoutT_ai_creditNestedInput
    t_ai_credit_topup?: t_ai_credit_topupUpdateManyWithoutT_ai_creditNestedInput
  }

  export type t_ai_creditUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    id_publisher?: StringFieldUpdateOperationsInput | string
    balance?: IntFieldUpdateOperationsInput | number
    last_topup_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    t_ai_credit_topup?: t_ai_credit_topupUncheckedUpdateManyWithoutT_ai_creditNestedInput
  }

  export type t_ai_creditCreateManyInput = {
    id?: string
    id_publisher: string
    balance?: number
    last_topup_at?: Date | string | null
  }

  export type t_ai_creditUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    balance?: IntFieldUpdateOperationsInput | number
    last_topup_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type t_ai_creditUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    id_publisher?: StringFieldUpdateOperationsInput | string
    balance?: IntFieldUpdateOperationsInput | number
    last_topup_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type t_ai_credit_topupCreateInput = {
    id?: string
    amount: number
    created_at?: Date | string
    status?: string
    t_ai_credit: t_ai_creditCreateNestedOneWithoutT_ai_credit_topupInput
  }

  export type t_ai_credit_topupUncheckedCreateInput = {
    id?: string
    id_t_ai_credit: string
    amount: number
    created_at?: Date | string
    status?: string
  }

  export type t_ai_credit_topupUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    t_ai_credit?: t_ai_creditUpdateOneRequiredWithoutT_ai_credit_topupNestedInput
  }

  export type t_ai_credit_topupUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    id_t_ai_credit?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
  }

  export type t_ai_credit_topupCreateManyInput = {
    id?: string
    id_t_ai_credit: string
    amount: number
    created_at?: Date | string
    status?: string
  }

  export type t_ai_credit_topupUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
  }

  export type t_ai_credit_topupUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    id_t_ai_credit?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
  }

  export type t_salesCreateInput = {
    id?: string
    status?: string
    total: Decimal | DecimalJsLike | number | string
    currency?: string
    info: JsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    midtrans_order_id?: string
    midtrans_success?: NullableJsonNullValueInput | InputJsonValue
    midtrans_pending?: NullableJsonNullValueInput | InputJsonValue
    midtrans_error?: NullableJsonNullValueInput | InputJsonValue
    customer: customerCreateNestedOneWithoutT_salesInput
    t_sales_line?: t_sales_lineCreateNestedManyWithoutT_salesInput
  }

  export type t_salesUncheckedCreateInput = {
    id?: string
    id_customer: string
    status?: string
    total: Decimal | DecimalJsLike | number | string
    currency?: string
    info: JsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    midtrans_order_id?: string
    midtrans_success?: NullableJsonNullValueInput | InputJsonValue
    midtrans_pending?: NullableJsonNullValueInput | InputJsonValue
    midtrans_error?: NullableJsonNullValueInput | InputJsonValue
    t_sales_line?: t_sales_lineUncheckedCreateNestedManyWithoutT_salesInput
  }

  export type t_salesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    info?: JsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    midtrans_order_id?: StringFieldUpdateOperationsInput | string
    midtrans_success?: NullableJsonNullValueInput | InputJsonValue
    midtrans_pending?: NullableJsonNullValueInput | InputJsonValue
    midtrans_error?: NullableJsonNullValueInput | InputJsonValue
    customer?: customerUpdateOneRequiredWithoutT_salesNestedInput
    t_sales_line?: t_sales_lineUpdateManyWithoutT_salesNestedInput
  }

  export type t_salesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    id_customer?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    info?: JsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    midtrans_order_id?: StringFieldUpdateOperationsInput | string
    midtrans_success?: NullableJsonNullValueInput | InputJsonValue
    midtrans_pending?: NullableJsonNullValueInput | InputJsonValue
    midtrans_error?: NullableJsonNullValueInput | InputJsonValue
    t_sales_line?: t_sales_lineUncheckedUpdateManyWithoutT_salesNestedInput
  }

  export type t_salesCreateManyInput = {
    id?: string
    id_customer: string
    status?: string
    total: Decimal | DecimalJsLike | number | string
    currency?: string
    info: JsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    midtrans_order_id?: string
    midtrans_success?: NullableJsonNullValueInput | InputJsonValue
    midtrans_pending?: NullableJsonNullValueInput | InputJsonValue
    midtrans_error?: NullableJsonNullValueInput | InputJsonValue
  }

  export type t_salesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    info?: JsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    midtrans_order_id?: StringFieldUpdateOperationsInput | string
    midtrans_success?: NullableJsonNullValueInput | InputJsonValue
    midtrans_pending?: NullableJsonNullValueInput | InputJsonValue
    midtrans_error?: NullableJsonNullValueInput | InputJsonValue
  }

  export type t_salesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    id_customer?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    info?: JsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    midtrans_order_id?: StringFieldUpdateOperationsInput | string
    midtrans_success?: NullableJsonNullValueInput | InputJsonValue
    midtrans_pending?: NullableJsonNullValueInput | InputJsonValue
    midtrans_error?: NullableJsonNullValueInput | InputJsonValue
  }

  export type t_sales_downloadCreateInput = {
    id?: string
    downloaded_at?: Date | string | null
    ip_address?: string | null
    download_key?: string
    customer: customerCreateNestedOneWithoutT_sales_downloadInput
    product: productCreateNestedOneWithoutT_sales_downloadInput
  }

  export type t_sales_downloadUncheckedCreateInput = {
    id?: string
    id_product: string
    id_customer: string
    downloaded_at?: Date | string | null
    ip_address?: string | null
    download_key?: string
  }

  export type t_sales_downloadUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    downloaded_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    download_key?: StringFieldUpdateOperationsInput | string
    customer?: customerUpdateOneRequiredWithoutT_sales_downloadNestedInput
    product?: productUpdateOneRequiredWithoutT_sales_downloadNestedInput
  }

  export type t_sales_downloadUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    id_product?: StringFieldUpdateOperationsInput | string
    id_customer?: StringFieldUpdateOperationsInput | string
    downloaded_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    download_key?: StringFieldUpdateOperationsInput | string
  }

  export type t_sales_downloadCreateManyInput = {
    id?: string
    id_product: string
    id_customer: string
    downloaded_at?: Date | string | null
    ip_address?: string | null
    download_key?: string
  }

  export type t_sales_downloadUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    downloaded_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    download_key?: StringFieldUpdateOperationsInput | string
  }

  export type t_sales_downloadUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    id_product?: StringFieldUpdateOperationsInput | string
    id_customer?: StringFieldUpdateOperationsInput | string
    downloaded_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    download_key?: StringFieldUpdateOperationsInput | string
  }

  export type t_sales_lineCreateInput = {
    id?: string
    unit_price: Decimal | DecimalJsLike | number | string
    qty: number
    total_price: Decimal | DecimalJsLike | number | string
    bundle?: bundleCreateNestedOneWithoutT_sales_lineInput
    product?: productCreateNestedOneWithoutT_sales_lineInput
    t_sales: t_salesCreateNestedOneWithoutT_sales_lineInput
  }

  export type t_sales_lineUncheckedCreateInput = {
    id?: string
    id_sales: string
    unit_price: Decimal | DecimalJsLike | number | string
    qty: number
    total_price: Decimal | DecimalJsLike | number | string
    id_product?: string | null
    id_bundle?: string | null
  }

  export type t_sales_lineUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    unit_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    qty?: IntFieldUpdateOperationsInput | number
    total_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bundle?: bundleUpdateOneWithoutT_sales_lineNestedInput
    product?: productUpdateOneWithoutT_sales_lineNestedInput
    t_sales?: t_salesUpdateOneRequiredWithoutT_sales_lineNestedInput
  }

  export type t_sales_lineUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    id_sales?: StringFieldUpdateOperationsInput | string
    unit_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    qty?: IntFieldUpdateOperationsInput | number
    total_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    id_product?: NullableStringFieldUpdateOperationsInput | string | null
    id_bundle?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type t_sales_lineCreateManyInput = {
    id?: string
    id_sales: string
    unit_price: Decimal | DecimalJsLike | number | string
    qty: number
    total_price: Decimal | DecimalJsLike | number | string
    id_product?: string | null
    id_bundle?: string | null
  }

  export type t_sales_lineUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    unit_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    qty?: IntFieldUpdateOperationsInput | number
    total_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type t_sales_lineUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    id_sales?: StringFieldUpdateOperationsInput | string
    unit_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    qty?: IntFieldUpdateOperationsInput | number
    total_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    id_product?: NullableStringFieldUpdateOperationsInput | string | null
    id_bundle?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type tagsCreateInput = {
    id?: string
    name: string
    deleted_at?: Date | string | null
    slug?: string | null
    img?: string | null
    book_tags?: book_tagsCreateNestedManyWithoutTagsInput
    tags?: tagsCreateNestedOneWithoutOther_tagsInput
    other_tags?: tagsCreateNestedManyWithoutTagsInput
  }

  export type tagsUncheckedCreateInput = {
    id?: string
    name: string
    id_parent?: string | null
    deleted_at?: Date | string | null
    slug?: string | null
    img?: string | null
    book_tags?: book_tagsUncheckedCreateNestedManyWithoutTagsInput
    other_tags?: tagsUncheckedCreateNestedManyWithoutTagsInput
  }

  export type tagsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    img?: NullableStringFieldUpdateOperationsInput | string | null
    book_tags?: book_tagsUpdateManyWithoutTagsNestedInput
    tags?: tagsUpdateOneWithoutOther_tagsNestedInput
    other_tags?: tagsUpdateManyWithoutTagsNestedInput
  }

  export type tagsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    id_parent?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    img?: NullableStringFieldUpdateOperationsInput | string | null
    book_tags?: book_tagsUncheckedUpdateManyWithoutTagsNestedInput
    other_tags?: tagsUncheckedUpdateManyWithoutTagsNestedInput
  }

  export type tagsCreateManyInput = {
    id?: string
    name: string
    id_parent?: string | null
    deleted_at?: Date | string | null
    slug?: string | null
    img?: string | null
  }

  export type tagsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    img?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type tagsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    id_parent?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    img?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type transactionCreateInput = {
    id?: string
    type: string
    amount: Decimal | DecimalJsLike | number | string
    created_at?: Date | string
    info?: JsonNullValueInput | InputJsonValue
    publisher: publisherCreateNestedOneWithoutTransactionInput
  }

  export type transactionUncheckedCreateInput = {
    id?: string
    id_publisher: string
    type: string
    amount: Decimal | DecimalJsLike | number | string
    created_at?: Date | string
    info?: JsonNullValueInput | InputJsonValue
  }

  export type transactionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    info?: JsonNullValueInput | InputJsonValue
    publisher?: publisherUpdateOneRequiredWithoutTransactionNestedInput
  }

  export type transactionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    id_publisher?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    info?: JsonNullValueInput | InputJsonValue
  }

  export type transactionCreateManyInput = {
    id?: string
    id_publisher: string
    type: string
    amount: Decimal | DecimalJsLike | number | string
    created_at?: Date | string
    info?: JsonNullValueInput | InputJsonValue
  }

  export type transactionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    info?: JsonNullValueInput | InputJsonValue
  }

  export type transactionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    id_publisher?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    info?: JsonNullValueInput | InputJsonValue
  }

  export type withdrawalCreateInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    status?: string
    requested_at?: Date | string
    processed_at?: Date | string | null
    publisher: publisherCreateNestedOneWithoutWithdrawalInput
  }

  export type withdrawalUncheckedCreateInput = {
    id?: string
    id_publisher: string
    amount: Decimal | DecimalJsLike | number | string
    status?: string
    requested_at?: Date | string
    processed_at?: Date | string | null
  }

  export type withdrawalUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    requested_at?: DateTimeFieldUpdateOperationsInput | Date | string
    processed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    publisher?: publisherUpdateOneRequiredWithoutWithdrawalNestedInput
  }

  export type withdrawalUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    id_publisher?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    requested_at?: DateTimeFieldUpdateOperationsInput | Date | string
    processed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type withdrawalCreateManyInput = {
    id?: string
    id_publisher: string
    amount: Decimal | DecimalJsLike | number | string
    status?: string
    requested_at?: Date | string
    processed_at?: Date | string | null
  }

  export type withdrawalUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    requested_at?: DateTimeFieldUpdateOperationsInput | Date | string
    processed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type withdrawalUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    id_publisher?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    requested_at?: DateTimeFieldUpdateOperationsInput | Date | string
    processed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UuidFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidFilter<$PrismaModel> | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type UuidNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidNullableFilter<$PrismaModel> | string | null
  }

  export type Auth_accountNullableScalarRelationFilter = {
    is?: auth_accountWhereInput | null
    isNot?: auth_accountWhereInput | null
  }

  export type Auth_userListRelationFilter = {
    every?: auth_userWhereInput
    some?: auth_userWhereInput
    none?: auth_userWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type auth_userOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type affiliateCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    id_account?: SortOrder
  }

  export type affiliateMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    id_account?: SortOrder
  }

  export type affiliateMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    id_account?: SortOrder
  }

  export type UuidWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type UuidNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type AffiliateListRelationFilter = {
    every?: affiliateWhereInput
    some?: affiliateWhereInput
    none?: affiliateWhereInput
  }

  export type Auth_userNullableScalarRelationFilter = {
    is?: auth_userWhereInput | null
    isNot?: auth_userWhereInput | null
  }

  export type AuthorListRelationFilter = {
    every?: authorWhereInput
    some?: authorWhereInput
    none?: authorWhereInput
  }

  export type CustomerListRelationFilter = {
    every?: customerWhereInput
    some?: customerWhereInput
    none?: customerWhereInput
  }

  export type InternalListRelationFilter = {
    every?: internalWhereInput
    some?: internalWhereInput
    none?: internalWhereInput
  }

  export type PublisherListRelationFilter = {
    every?: publisherWhereInput
    some?: publisherWhereInput
    none?: publisherWhereInput
  }

  export type affiliateOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type authorOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type customerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type internalOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type publisherOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type auth_accountCountOrderByAggregateInput = {
    id?: SortOrder
    password?: SortOrder
    id_provider?: SortOrder
    access_token?: SortOrder
    refresh_token?: SortOrder
    id_token?: SortOrder
    access_token_expires_at?: SortOrder
    refresh_token_expires_at?: SortOrder
    scope?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    id_user?: SortOrder
    id_account?: SortOrder
  }

  export type auth_accountMaxOrderByAggregateInput = {
    id?: SortOrder
    password?: SortOrder
    id_provider?: SortOrder
    access_token?: SortOrder
    refresh_token?: SortOrder
    id_token?: SortOrder
    access_token_expires_at?: SortOrder
    refresh_token_expires_at?: SortOrder
    scope?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    id_user?: SortOrder
    id_account?: SortOrder
  }

  export type auth_accountMinOrderByAggregateInput = {
    id?: SortOrder
    password?: SortOrder
    id_provider?: SortOrder
    access_token?: SortOrder
    refresh_token?: SortOrder
    id_token?: SortOrder
    access_token_expires_at?: SortOrder
    refresh_token_expires_at?: SortOrder
    scope?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    id_user?: SortOrder
    id_account?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type Auth_userScalarRelationFilter = {
    is?: auth_userWhereInput
    isNot?: auth_userWhereInput
  }

  export type auth_sessionCountOrderByAggregateInput = {
    id?: SortOrder
    expires_at?: SortOrder
    token?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    ip_address?: SortOrder
    user_agent?: SortOrder
    id_user?: SortOrder
  }

  export type auth_sessionMaxOrderByAggregateInput = {
    id?: SortOrder
    expires_at?: SortOrder
    token?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    ip_address?: SortOrder
    user_agent?: SortOrder
    id_user?: SortOrder
  }

  export type auth_sessionMinOrderByAggregateInput = {
    id?: SortOrder
    expires_at?: SortOrder
    token?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    ip_address?: SortOrder
    user_agent?: SortOrder
    id_user?: SortOrder
  }

  export type auth_two_factorCountOrderByAggregateInput = {
    id?: SortOrder
    secret?: SortOrder
    backup_codes?: SortOrder
    id_user?: SortOrder
  }

  export type auth_two_factorMaxOrderByAggregateInput = {
    id?: SortOrder
    secret?: SortOrder
    backup_codes?: SortOrder
    id_user?: SortOrder
  }

  export type auth_two_factorMinOrderByAggregateInput = {
    id?: SortOrder
    secret?: SortOrder
    backup_codes?: SortOrder
    id_user?: SortOrder
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type Auth_accountListRelationFilter = {
    every?: auth_accountWhereInput
    some?: auth_accountWhereInput
    none?: auth_accountWhereInput
  }

  export type Auth_sessionListRelationFilter = {
    every?: auth_sessionWhereInput
    some?: auth_sessionWhereInput
    none?: auth_sessionWhereInput
  }

  export type Auth_two_factorListRelationFilter = {
    every?: auth_two_factorWhereInput
    some?: auth_two_factorWhereInput
    none?: auth_two_factorWhereInput
  }

  export type AffiliateNullableScalarRelationFilter = {
    is?: affiliateWhereInput | null
    isNot?: affiliateWhereInput | null
  }

  export type AuthorNullableScalarRelationFilter = {
    is?: authorWhereInput | null
    isNot?: authorWhereInput | null
  }

  export type CustomerNullableScalarRelationFilter = {
    is?: customerWhereInput | null
    isNot?: customerWhereInput | null
  }

  export type InternalNullableScalarRelationFilter = {
    is?: internalWhereInput | null
    isNot?: internalWhereInput | null
  }

  export type PublisherNullableScalarRelationFilter = {
    is?: publisherWhereInput | null
    isNot?: publisherWhereInput | null
  }

  export type ReviewsListRelationFilter = {
    every?: reviewsWhereInput
    some?: reviewsWhereInput
    none?: reviewsWhereInput
  }

  export type Reviews_likesListRelationFilter = {
    every?: reviews_likesWhereInput
    some?: reviews_likesWhereInput
    none?: reviews_likesWhereInput
  }

  export type auth_accountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type auth_sessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type auth_two_factorOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type reviewsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type reviews_likesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type auth_userCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    email_verified?: SortOrder
    image?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    username?: SortOrder
    display_username?: SortOrder
    two_factor_enabled?: SortOrder
    id_customer?: SortOrder
    id_author?: SortOrder
    id_affiliate?: SortOrder
    id_publisher?: SortOrder
    id_internal?: SortOrder
  }

  export type auth_userMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    email_verified?: SortOrder
    image?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    username?: SortOrder
    display_username?: SortOrder
    two_factor_enabled?: SortOrder
    id_customer?: SortOrder
    id_author?: SortOrder
    id_affiliate?: SortOrder
    id_publisher?: SortOrder
    id_internal?: SortOrder
  }

  export type auth_userMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    email_verified?: SortOrder
    image?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    username?: SortOrder
    display_username?: SortOrder
    two_factor_enabled?: SortOrder
    id_customer?: SortOrder
    id_author?: SortOrder
    id_affiliate?: SortOrder
    id_publisher?: SortOrder
    id_internal?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type auth_verificationCountOrderByAggregateInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expires_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type auth_verificationMaxOrderByAggregateInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expires_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type auth_verificationMinOrderByAggregateInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expires_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type BookListRelationFilter = {
    every?: bookWhereInput
    some?: bookWhereInput
    none?: bookWhereInput
  }

  export type ProductListRelationFilter = {
    every?: productWhereInput
    some?: productWhereInput
    none?: productWhereInput
  }

  export type Publisher_authorListRelationFilter = {
    every?: publisher_authorWhereInput
    some?: publisher_authorWhereInput
    none?: publisher_authorWhereInput
  }

  export type bookOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type productOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type publisher_authorOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type authorCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    id_account?: SortOrder
    biography?: SortOrder
    social_media?: SortOrder
    avatar?: SortOrder
  }

  export type authorMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    id_account?: SortOrder
    biography?: SortOrder
    social_media?: SortOrder
    avatar?: SortOrder
  }

  export type authorMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    id_account?: SortOrder
    biography?: SortOrder
    social_media?: SortOrder
    avatar?: SortOrder
  }

  export type bannerCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    banner_file?: SortOrder
    status?: SortOrder
    deleted_at?: SortOrder
    link?: SortOrder
  }

  export type bannerMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    banner_file?: SortOrder
    status?: SortOrder
    deleted_at?: SortOrder
    link?: SortOrder
  }

  export type bannerMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    banner_file?: SortOrder
    status?: SortOrder
    deleted_at?: SortOrder
    link?: SortOrder
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type ProductNullableScalarRelationFilter = {
    is?: productWhereInput | null
    isNot?: productWhereInput | null
  }

  export type Book_approvalListRelationFilter = {
    every?: book_approvalWhereInput
    some?: book_approvalWhereInput
    none?: book_approvalWhereInput
  }

  export type Book_changes_logListRelationFilter = {
    every?: book_changes_logWhereInput
    some?: book_changes_logWhereInput
    none?: book_changes_logWhereInput
  }

  export type Book_genreListRelationFilter = {
    every?: book_genreWhereInput
    some?: book_genreWhereInput
    none?: book_genreWhereInput
  }

  export type Book_tagsListRelationFilter = {
    every?: book_tagsWhereInput
    some?: book_tagsWhereInput
    none?: book_tagsWhereInput
  }

  export type ChapterListRelationFilter = {
    every?: chapterWhereInput
    some?: chapterWhereInput
    none?: chapterWhereInput
  }

  export type RankingListRelationFilter = {
    every?: rankingWhereInput
    some?: rankingWhereInput
    none?: rankingWhereInput
  }

  export type book_approvalOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type book_changes_logOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type book_genreOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type book_tagsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type chapterOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type rankingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type bookCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    alias?: SortOrder
    submitted_price?: SortOrder
    desc?: SortOrder
    info?: SortOrder
    status?: SortOrder
    currency?: SortOrder
    deleted_at?: SortOrder
    img_file?: SortOrder
    cover?: SortOrder
    product_file?: SortOrder
    sku?: SortOrder
    id_author?: SortOrder
    published_date?: SortOrder
    is_physical?: SortOrder
    preorder_min_qty?: SortOrder
    content_type?: SortOrder
    is_chapter?: SortOrder
    id_product?: SortOrder
    created_at?: SortOrder
  }

  export type bookAvgOrderByAggregateInput = {
    submitted_price?: SortOrder
    preorder_min_qty?: SortOrder
  }

  export type bookMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    alias?: SortOrder
    submitted_price?: SortOrder
    desc?: SortOrder
    status?: SortOrder
    currency?: SortOrder
    deleted_at?: SortOrder
    img_file?: SortOrder
    cover?: SortOrder
    product_file?: SortOrder
    sku?: SortOrder
    id_author?: SortOrder
    published_date?: SortOrder
    is_physical?: SortOrder
    preorder_min_qty?: SortOrder
    content_type?: SortOrder
    is_chapter?: SortOrder
    id_product?: SortOrder
    created_at?: SortOrder
  }

  export type bookMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    alias?: SortOrder
    submitted_price?: SortOrder
    desc?: SortOrder
    status?: SortOrder
    currency?: SortOrder
    deleted_at?: SortOrder
    img_file?: SortOrder
    cover?: SortOrder
    product_file?: SortOrder
    sku?: SortOrder
    id_author?: SortOrder
    published_date?: SortOrder
    is_physical?: SortOrder
    preorder_min_qty?: SortOrder
    content_type?: SortOrder
    is_chapter?: SortOrder
    id_product?: SortOrder
    created_at?: SortOrder
  }

  export type bookSumOrderByAggregateInput = {
    submitted_price?: SortOrder
    preorder_min_qty?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type BookScalarRelationFilter = {
    is?: bookWhereInput
    isNot?: bookWhereInput
  }

  export type book_approvalCountOrderByAggregateInput = {
    id?: SortOrder
    id_book?: SortOrder
    id_internal?: SortOrder
    comment?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
  }

  export type book_approvalMaxOrderByAggregateInput = {
    id?: SortOrder
    id_book?: SortOrder
    id_internal?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
  }

  export type book_approvalMinOrderByAggregateInput = {
    id?: SortOrder
    id_book?: SortOrder
    id_internal?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
  }

  export type book_changes_logId_bookCreated_atCompoundUniqueInput = {
    id_book: string
    created_at: Date | string
  }

  export type book_changes_logCountOrderByAggregateInput = {
    id_book?: SortOrder
    created_at?: SortOrder
    changes?: SortOrder
  }

  export type book_changes_logMaxOrderByAggregateInput = {
    id_book?: SortOrder
    created_at?: SortOrder
  }

  export type book_changes_logMinOrderByAggregateInput = {
    id_book?: SortOrder
    created_at?: SortOrder
  }

  export type GenreScalarRelationFilter = {
    is?: genreWhereInput
    isNot?: genreWhereInput
  }

  export type book_genreCountOrderByAggregateInput = {
    id?: SortOrder
    id_genre?: SortOrder
    id_book?: SortOrder
  }

  export type book_genreMaxOrderByAggregateInput = {
    id?: SortOrder
    id_genre?: SortOrder
    id_book?: SortOrder
  }

  export type book_genreMinOrderByAggregateInput = {
    id?: SortOrder
    id_genre?: SortOrder
    id_book?: SortOrder
  }

  export type TagsScalarRelationFilter = {
    is?: tagsWhereInput
    isNot?: tagsWhereInput
  }

  export type book_tagsCountOrderByAggregateInput = {
    id?: SortOrder
    id_tags?: SortOrder
    id_book?: SortOrder
  }

  export type book_tagsMaxOrderByAggregateInput = {
    id?: SortOrder
    id_tags?: SortOrder
    id_book?: SortOrder
  }

  export type book_tagsMinOrderByAggregateInput = {
    id?: SortOrder
    id_tags?: SortOrder
    id_book?: SortOrder
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type Bundle_categoryListRelationFilter = {
    every?: bundle_categoryWhereInput
    some?: bundle_categoryWhereInput
    none?: bundle_categoryWhereInput
  }

  export type Bundle_productListRelationFilter = {
    every?: bundle_productWhereInput
    some?: bundle_productWhereInput
    none?: bundle_productWhereInput
  }

  export type T_sales_lineListRelationFilter = {
    every?: t_sales_lineWhereInput
    some?: t_sales_lineWhereInput
    none?: t_sales_lineWhereInput
  }

  export type bundle_categoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type bundle_productOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type t_sales_lineOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type bundleCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    strike_price?: SortOrder
    real_price?: SortOrder
    currency?: SortOrder
    desc?: SortOrder
    info?: SortOrder
    deleted_at?: SortOrder
    status?: SortOrder
    img_file?: SortOrder
    cover?: SortOrder
    sku?: SortOrder
  }

  export type bundleAvgOrderByAggregateInput = {
    strike_price?: SortOrder
    real_price?: SortOrder
  }

  export type bundleMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    strike_price?: SortOrder
    real_price?: SortOrder
    currency?: SortOrder
    desc?: SortOrder
    deleted_at?: SortOrder
    status?: SortOrder
    img_file?: SortOrder
    cover?: SortOrder
    sku?: SortOrder
  }

  export type bundleMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    strike_price?: SortOrder
    real_price?: SortOrder
    currency?: SortOrder
    desc?: SortOrder
    deleted_at?: SortOrder
    status?: SortOrder
    img_file?: SortOrder
    cover?: SortOrder
    sku?: SortOrder
  }

  export type bundleSumOrderByAggregateInput = {
    strike_price?: SortOrder
    real_price?: SortOrder
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type BundleScalarRelationFilter = {
    is?: bundleWhereInput
    isNot?: bundleWhereInput
  }

  export type CategoryScalarRelationFilter = {
    is?: categoryWhereInput
    isNot?: categoryWhereInput
  }

  export type bundle_categoryCountOrderByAggregateInput = {
    id?: SortOrder
    id_category?: SortOrder
    id_bundle?: SortOrder
  }

  export type bundle_categoryMaxOrderByAggregateInput = {
    id?: SortOrder
    id_category?: SortOrder
    id_bundle?: SortOrder
  }

  export type bundle_categoryMinOrderByAggregateInput = {
    id?: SortOrder
    id_category?: SortOrder
    id_bundle?: SortOrder
  }

  export type ProductScalarRelationFilter = {
    is?: productWhereInput
    isNot?: productWhereInput
  }

  export type bundle_productCountOrderByAggregateInput = {
    id_bundle?: SortOrder
    id_product?: SortOrder
    id?: SortOrder
    qty?: SortOrder
  }

  export type bundle_productAvgOrderByAggregateInput = {
    qty?: SortOrder
  }

  export type bundle_productMaxOrderByAggregateInput = {
    id_bundle?: SortOrder
    id_product?: SortOrder
    id?: SortOrder
    qty?: SortOrder
  }

  export type bundle_productMinOrderByAggregateInput = {
    id_bundle?: SortOrder
    id_product?: SortOrder
    id?: SortOrder
    qty?: SortOrder
  }

  export type bundle_productSumOrderByAggregateInput = {
    qty?: SortOrder
  }

  export type CategoryNullableScalarRelationFilter = {
    is?: categoryWhereInput | null
    isNot?: categoryWhereInput | null
  }

  export type CategoryListRelationFilter = {
    every?: categoryWhereInput
    some?: categoryWhereInput
    none?: categoryWhereInput
  }

  export type Product_categoryListRelationFilter = {
    every?: product_categoryWhereInput
    some?: product_categoryWhereInput
    none?: product_categoryWhereInput
  }

  export type categoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type product_categoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type categoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    id_parent?: SortOrder
    deleted_at?: SortOrder
    slug?: SortOrder
    img?: SortOrder
  }

  export type categoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    id_parent?: SortOrder
    deleted_at?: SortOrder
    slug?: SortOrder
    img?: SortOrder
  }

  export type categoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    id_parent?: SortOrder
    deleted_at?: SortOrder
    slug?: SortOrder
    img?: SortOrder
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type BookNullableScalarRelationFilter = {
    is?: bookWhereInput | null
    isNot?: bookWhereInput | null
  }

  export type chapterCountOrderByAggregateInput = {
    id?: SortOrder
    id_product?: SortOrder
    id_book?: SortOrder
    number?: SortOrder
    name?: SortOrder
    content?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type chapterAvgOrderByAggregateInput = {
    number?: SortOrder
  }

  export type chapterMaxOrderByAggregateInput = {
    id?: SortOrder
    id_product?: SortOrder
    id_book?: SortOrder
    number?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type chapterMinOrderByAggregateInput = {
    id?: SortOrder
    id_product?: SortOrder
    id_book?: SortOrder
    number?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type chapterSumOrderByAggregateInput = {
    number?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type Customer_readerListRelationFilter = {
    every?: customer_readerWhereInput
    some?: customer_readerWhereInput
    none?: customer_readerWhereInput
  }

  export type Customer_trackListRelationFilter = {
    every?: customer_trackWhereInput
    some?: customer_trackWhereInput
    none?: customer_trackWhereInput
  }

  export type T_salesListRelationFilter = {
    every?: t_salesWhereInput
    some?: t_salesWhereInput
    none?: t_salesWhereInput
  }

  export type T_sales_downloadListRelationFilter = {
    every?: t_sales_downloadWhereInput
    some?: t_sales_downloadWhereInput
    none?: t_sales_downloadWhereInput
  }

  export type customer_readerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type customer_trackOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type t_salesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type t_sales_downloadOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type customerCountOrderByAggregateInput = {
    id?: SortOrder
    whatsapp?: SortOrder
    deleted_at?: SortOrder
    otp?: SortOrder
    id_account?: SortOrder
    name?: SortOrder
    email?: SortOrder
  }

  export type customerAvgOrderByAggregateInput = {
    otp?: SortOrder
  }

  export type customerMaxOrderByAggregateInput = {
    id?: SortOrder
    whatsapp?: SortOrder
    deleted_at?: SortOrder
    otp?: SortOrder
    id_account?: SortOrder
    name?: SortOrder
    email?: SortOrder
  }

  export type customerMinOrderByAggregateInput = {
    id?: SortOrder
    whatsapp?: SortOrder
    deleted_at?: SortOrder
    otp?: SortOrder
    id_account?: SortOrder
    name?: SortOrder
    email?: SortOrder
  }

  export type customerSumOrderByAggregateInput = {
    otp?: SortOrder
  }

  export type CustomerScalarRelationFilter = {
    is?: customerWhereInput
    isNot?: customerWhereInput
  }

  export type customer_readerCountOrderByAggregateInput = {
    id?: SortOrder
    id_customer?: SortOrder
    id_product?: SortOrder
    last_page?: SortOrder
    percent?: SortOrder
  }

  export type customer_readerAvgOrderByAggregateInput = {
    last_page?: SortOrder
    percent?: SortOrder
  }

  export type customer_readerMaxOrderByAggregateInput = {
    id?: SortOrder
    id_customer?: SortOrder
    id_product?: SortOrder
    last_page?: SortOrder
    percent?: SortOrder
  }

  export type customer_readerMinOrderByAggregateInput = {
    id?: SortOrder
    id_customer?: SortOrder
    id_product?: SortOrder
    last_page?: SortOrder
    percent?: SortOrder
  }

  export type customer_readerSumOrderByAggregateInput = {
    last_page?: SortOrder
    percent?: SortOrder
  }

  export type customer_trackCountOrderByAggregateInput = {
    id?: SortOrder
    ts?: SortOrder
    id_customer?: SortOrder
    path?: SortOrder
    referrer?: SortOrder
    info?: SortOrder
    ip?: SortOrder
  }

  export type customer_trackMaxOrderByAggregateInput = {
    id?: SortOrder
    ts?: SortOrder
    id_customer?: SortOrder
    path?: SortOrder
    referrer?: SortOrder
    ip?: SortOrder
  }

  export type customer_trackMinOrderByAggregateInput = {
    id?: SortOrder
    ts?: SortOrder
    id_customer?: SortOrder
    path?: SortOrder
    referrer?: SortOrder
    ip?: SortOrder
  }

  export type GenreNullableScalarRelationFilter = {
    is?: genreWhereInput | null
    isNot?: genreWhereInput | null
  }

  export type GenreListRelationFilter = {
    every?: genreWhereInput
    some?: genreWhereInput
    none?: genreWhereInput
  }

  export type genreOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type genreCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    id_parent?: SortOrder
    slug?: SortOrder
    img?: SortOrder
    deleted_at?: SortOrder
  }

  export type genreMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    id_parent?: SortOrder
    slug?: SortOrder
    img?: SortOrder
    deleted_at?: SortOrder
  }

  export type genreMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    id_parent?: SortOrder
    slug?: SortOrder
    img?: SortOrder
    deleted_at?: SortOrder
  }

  export type internalCountOrderByAggregateInput = {
    id?: SortOrder
    id_account?: SortOrder
    name?: SortOrder
    is_sales_and_marketing?: SortOrder
    is_support?: SortOrder
    is_management?: SortOrder
    is_it?: SortOrder
  }

  export type internalMaxOrderByAggregateInput = {
    id?: SortOrder
    id_account?: SortOrder
    name?: SortOrder
    is_sales_and_marketing?: SortOrder
    is_support?: SortOrder
    is_management?: SortOrder
    is_it?: SortOrder
  }

  export type internalMinOrderByAggregateInput = {
    id?: SortOrder
    id_account?: SortOrder
    name?: SortOrder
    is_sales_and_marketing?: SortOrder
    is_support?: SortOrder
    is_management?: SortOrder
    is_it?: SortOrder
  }

  export type Landing_itemsListRelationFilter = {
    every?: landing_itemsWhereInput
    some?: landing_itemsWhereInput
    none?: landing_itemsWhereInput
  }

  export type landing_itemsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type landingCountOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    views?: SortOrder
    deleted_at?: SortOrder
    status?: SortOrder
    title?: SortOrder
  }

  export type landingAvgOrderByAggregateInput = {
    views?: SortOrder
  }

  export type landingMaxOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    views?: SortOrder
    deleted_at?: SortOrder
    status?: SortOrder
    title?: SortOrder
  }

  export type landingMinOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    views?: SortOrder
    deleted_at?: SortOrder
    status?: SortOrder
    title?: SortOrder
  }

  export type landingSumOrderByAggregateInput = {
    views?: SortOrder
  }

  export type LandingScalarRelationFilter = {
    is?: landingWhereInput
    isNot?: landingWhereInput
  }

  export type landing_itemsCountOrderByAggregateInput = {
    id?: SortOrder
    desc?: SortOrder
    img_file?: SortOrder
    tag?: SortOrder
    link_to?: SortOrder
    landing_id?: SortOrder
    idx?: SortOrder
    color?: SortOrder
  }

  export type landing_itemsAvgOrderByAggregateInput = {
    idx?: SortOrder
  }

  export type landing_itemsMaxOrderByAggregateInput = {
    id?: SortOrder
    desc?: SortOrder
    img_file?: SortOrder
    tag?: SortOrder
    link_to?: SortOrder
    landing_id?: SortOrder
    idx?: SortOrder
    color?: SortOrder
  }

  export type landing_itemsMinOrderByAggregateInput = {
    id?: SortOrder
    desc?: SortOrder
    img_file?: SortOrder
    tag?: SortOrder
    link_to?: SortOrder
    landing_id?: SortOrder
    idx?: SortOrder
    color?: SortOrder
  }

  export type landing_itemsSumOrderByAggregateInput = {
    idx?: SortOrder
  }

  export type midtrxCountOrderByAggregateInput = {
    id?: SortOrder
    tz?: SortOrder
    type?: SortOrder
    payload?: SortOrder
  }

  export type midtrxMaxOrderByAggregateInput = {
    id?: SortOrder
    tz?: SortOrder
    type?: SortOrder
  }

  export type midtrxMinOrderByAggregateInput = {
    id?: SortOrder
    tz?: SortOrder
    type?: SortOrder
  }

  export type preorderCountOrderByAggregateInput = {
    id?: SortOrder
    id_product?: SortOrder
    min_qty?: SortOrder
    current_qty?: SortOrder
    status?: SortOrder
    deadline?: SortOrder
  }

  export type preorderAvgOrderByAggregateInput = {
    min_qty?: SortOrder
    current_qty?: SortOrder
  }

  export type preorderMaxOrderByAggregateInput = {
    id?: SortOrder
    id_product?: SortOrder
    min_qty?: SortOrder
    current_qty?: SortOrder
    status?: SortOrder
    deadline?: SortOrder
  }

  export type preorderMinOrderByAggregateInput = {
    id?: SortOrder
    id_product?: SortOrder
    min_qty?: SortOrder
    current_qty?: SortOrder
    status?: SortOrder
    deadline?: SortOrder
  }

  export type preorderSumOrderByAggregateInput = {
    min_qty?: SortOrder
    current_qty?: SortOrder
  }

  export type PreorderListRelationFilter = {
    every?: preorderWhereInput
    some?: preorderWhereInput
    none?: preorderWhereInput
  }

  export type preorderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type productCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    alias?: SortOrder
    strike_price?: SortOrder
    real_price?: SortOrder
    desc?: SortOrder
    info?: SortOrder
    status?: SortOrder
    currency?: SortOrder
    deleted_at?: SortOrder
    img_file?: SortOrder
    cover?: SortOrder
    product_file?: SortOrder
    sku?: SortOrder
    id_author?: SortOrder
    published_date?: SortOrder
    is_physical?: SortOrder
    preorder_min_qty?: SortOrder
    content_type?: SortOrder
    is_chapter?: SortOrder
  }

  export type productAvgOrderByAggregateInput = {
    strike_price?: SortOrder
    real_price?: SortOrder
    preorder_min_qty?: SortOrder
  }

  export type productMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    alias?: SortOrder
    strike_price?: SortOrder
    real_price?: SortOrder
    desc?: SortOrder
    status?: SortOrder
    currency?: SortOrder
    deleted_at?: SortOrder
    img_file?: SortOrder
    cover?: SortOrder
    product_file?: SortOrder
    sku?: SortOrder
    id_author?: SortOrder
    published_date?: SortOrder
    is_physical?: SortOrder
    preorder_min_qty?: SortOrder
    content_type?: SortOrder
    is_chapter?: SortOrder
  }

  export type productMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    alias?: SortOrder
    strike_price?: SortOrder
    real_price?: SortOrder
    desc?: SortOrder
    status?: SortOrder
    currency?: SortOrder
    deleted_at?: SortOrder
    img_file?: SortOrder
    cover?: SortOrder
    product_file?: SortOrder
    sku?: SortOrder
    id_author?: SortOrder
    published_date?: SortOrder
    is_physical?: SortOrder
    preorder_min_qty?: SortOrder
    content_type?: SortOrder
    is_chapter?: SortOrder
  }

  export type productSumOrderByAggregateInput = {
    strike_price?: SortOrder
    real_price?: SortOrder
    preorder_min_qty?: SortOrder
  }

  export type product_categoryCountOrderByAggregateInput = {
    id_product?: SortOrder
    id_category?: SortOrder
    id?: SortOrder
  }

  export type product_categoryMaxOrderByAggregateInput = {
    id_product?: SortOrder
    id_category?: SortOrder
    id?: SortOrder
  }

  export type product_categoryMinOrderByAggregateInput = {
    id_product?: SortOrder
    id_category?: SortOrder
    id?: SortOrder
  }

  export type PublisherScalarRelationFilter = {
    is?: publisherWhereInput
    isNot?: publisherWhereInput
  }

  export type promo_codeCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    discount_type?: SortOrder
    discount_value?: SortOrder
    valid_from?: SortOrder
    valid_to?: SortOrder
    usage_limit?: SortOrder
    used_count?: SortOrder
    status?: SortOrder
    id_publisher?: SortOrder
  }

  export type promo_codeAvgOrderByAggregateInput = {
    discount_value?: SortOrder
    usage_limit?: SortOrder
    used_count?: SortOrder
  }

  export type promo_codeMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    discount_type?: SortOrder
    discount_value?: SortOrder
    valid_from?: SortOrder
    valid_to?: SortOrder
    usage_limit?: SortOrder
    used_count?: SortOrder
    status?: SortOrder
    id_publisher?: SortOrder
  }

  export type promo_codeMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    discount_type?: SortOrder
    discount_value?: SortOrder
    valid_from?: SortOrder
    valid_to?: SortOrder
    usage_limit?: SortOrder
    used_count?: SortOrder
    status?: SortOrder
    id_publisher?: SortOrder
  }

  export type promo_codeSumOrderByAggregateInput = {
    discount_value?: SortOrder
    usage_limit?: SortOrder
    used_count?: SortOrder
  }

  export type Promo_codeListRelationFilter = {
    every?: promo_codeWhereInput
    some?: promo_codeWhereInput
    none?: promo_codeWhereInput
  }

  export type T_ai_creditListRelationFilter = {
    every?: t_ai_creditWhereInput
    some?: t_ai_creditWhereInput
    none?: t_ai_creditWhereInput
  }

  export type TransactionListRelationFilter = {
    every?: transactionWhereInput
    some?: transactionWhereInput
    none?: transactionWhereInput
  }

  export type WithdrawalListRelationFilter = {
    every?: withdrawalWhereInput
    some?: withdrawalWhereInput
    none?: withdrawalWhereInput
  }

  export type promo_codeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type t_ai_creditOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type transactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type withdrawalOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type publisherCountOrderByAggregateInput = {
    id?: SortOrder
    id_account?: SortOrder
    name?: SortOrder
    description?: SortOrder
    website?: SortOrder
    address?: SortOrder
    logo?: SortOrder
  }

  export type publisherMaxOrderByAggregateInput = {
    id?: SortOrder
    id_account?: SortOrder
    name?: SortOrder
    description?: SortOrder
    website?: SortOrder
    address?: SortOrder
    logo?: SortOrder
  }

  export type publisherMinOrderByAggregateInput = {
    id?: SortOrder
    id_account?: SortOrder
    name?: SortOrder
    description?: SortOrder
    website?: SortOrder
    address?: SortOrder
    logo?: SortOrder
  }

  export type AuthorScalarRelationFilter = {
    is?: authorWhereInput
    isNot?: authorWhereInput
  }

  export type publisher_authorPublisher_idAuthor_idCompoundUniqueInput = {
    publisher_id: string
    author_id: string
  }

  export type publisher_authorCountOrderByAggregateInput = {
    id?: SortOrder
    publisher_id?: SortOrder
    author_id?: SortOrder
  }

  export type publisher_authorMaxOrderByAggregateInput = {
    id?: SortOrder
    publisher_id?: SortOrder
    author_id?: SortOrder
  }

  export type publisher_authorMinOrderByAggregateInput = {
    id?: SortOrder
    publisher_id?: SortOrder
    author_id?: SortOrder
  }

  export type rankingCountOrderByAggregateInput = {
    id?: SortOrder
    id_book?: SortOrder
  }

  export type rankingMaxOrderByAggregateInput = {
    id?: SortOrder
    id_book?: SortOrder
  }

  export type rankingMinOrderByAggregateInput = {
    id?: SortOrder
    id_book?: SortOrder
  }

  export type reviewsCountOrderByAggregateInput = {
    id?: SortOrder
    id_book?: SortOrder
    comments?: SortOrder
    rating?: SortOrder
    created_at?: SortOrder
    deleted_at?: SortOrder
    parent?: SortOrder
    id_user?: SortOrder
  }

  export type reviewsAvgOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type reviewsMaxOrderByAggregateInput = {
    id?: SortOrder
    id_book?: SortOrder
    comments?: SortOrder
    rating?: SortOrder
    created_at?: SortOrder
    deleted_at?: SortOrder
    parent?: SortOrder
    id_user?: SortOrder
  }

  export type reviewsMinOrderByAggregateInput = {
    id?: SortOrder
    id_book?: SortOrder
    comments?: SortOrder
    rating?: SortOrder
    created_at?: SortOrder
    deleted_at?: SortOrder
    parent?: SortOrder
    id_user?: SortOrder
  }

  export type reviewsSumOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type ReviewsScalarRelationFilter = {
    is?: reviewsWhereInput
    isNot?: reviewsWhereInput
  }

  export type reviews_likesCountOrderByAggregateInput = {
    id?: SortOrder
    id_reviews?: SortOrder
    id_user?: SortOrder
  }

  export type reviews_likesMaxOrderByAggregateInput = {
    id?: SortOrder
    id_reviews?: SortOrder
    id_user?: SortOrder
  }

  export type reviews_likesMinOrderByAggregateInput = {
    id?: SortOrder
    id_reviews?: SortOrder
    id_user?: SortOrder
  }

  export type T_ai_credit_topupListRelationFilter = {
    every?: t_ai_credit_topupWhereInput
    some?: t_ai_credit_topupWhereInput
    none?: t_ai_credit_topupWhereInput
  }

  export type t_ai_credit_topupOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type t_ai_creditCountOrderByAggregateInput = {
    id?: SortOrder
    id_publisher?: SortOrder
    balance?: SortOrder
    last_topup_at?: SortOrder
  }

  export type t_ai_creditAvgOrderByAggregateInput = {
    balance?: SortOrder
  }

  export type t_ai_creditMaxOrderByAggregateInput = {
    id?: SortOrder
    id_publisher?: SortOrder
    balance?: SortOrder
    last_topup_at?: SortOrder
  }

  export type t_ai_creditMinOrderByAggregateInput = {
    id?: SortOrder
    id_publisher?: SortOrder
    balance?: SortOrder
    last_topup_at?: SortOrder
  }

  export type t_ai_creditSumOrderByAggregateInput = {
    balance?: SortOrder
  }

  export type T_ai_creditScalarRelationFilter = {
    is?: t_ai_creditWhereInput
    isNot?: t_ai_creditWhereInput
  }

  export type t_ai_credit_topupCountOrderByAggregateInput = {
    id?: SortOrder
    id_t_ai_credit?: SortOrder
    amount?: SortOrder
    created_at?: SortOrder
    status?: SortOrder
  }

  export type t_ai_credit_topupAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type t_ai_credit_topupMaxOrderByAggregateInput = {
    id?: SortOrder
    id_t_ai_credit?: SortOrder
    amount?: SortOrder
    created_at?: SortOrder
    status?: SortOrder
  }

  export type t_ai_credit_topupMinOrderByAggregateInput = {
    id?: SortOrder
    id_t_ai_credit?: SortOrder
    amount?: SortOrder
    created_at?: SortOrder
    status?: SortOrder
  }

  export type t_ai_credit_topupSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type t_salesCountOrderByAggregateInput = {
    id?: SortOrder
    id_customer?: SortOrder
    status?: SortOrder
    total?: SortOrder
    currency?: SortOrder
    info?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
    midtrans_order_id?: SortOrder
    midtrans_success?: SortOrder
    midtrans_pending?: SortOrder
    midtrans_error?: SortOrder
  }

  export type t_salesAvgOrderByAggregateInput = {
    total?: SortOrder
  }

  export type t_salesMaxOrderByAggregateInput = {
    id?: SortOrder
    id_customer?: SortOrder
    status?: SortOrder
    total?: SortOrder
    currency?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
    midtrans_order_id?: SortOrder
  }

  export type t_salesMinOrderByAggregateInput = {
    id?: SortOrder
    id_customer?: SortOrder
    status?: SortOrder
    total?: SortOrder
    currency?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
    midtrans_order_id?: SortOrder
  }

  export type t_salesSumOrderByAggregateInput = {
    total?: SortOrder
  }

  export type t_sales_downloadCountOrderByAggregateInput = {
    id?: SortOrder
    id_product?: SortOrder
    id_customer?: SortOrder
    downloaded_at?: SortOrder
    ip_address?: SortOrder
    download_key?: SortOrder
  }

  export type t_sales_downloadMaxOrderByAggregateInput = {
    id?: SortOrder
    id_product?: SortOrder
    id_customer?: SortOrder
    downloaded_at?: SortOrder
    ip_address?: SortOrder
    download_key?: SortOrder
  }

  export type t_sales_downloadMinOrderByAggregateInput = {
    id?: SortOrder
    id_product?: SortOrder
    id_customer?: SortOrder
    downloaded_at?: SortOrder
    ip_address?: SortOrder
    download_key?: SortOrder
  }

  export type BundleNullableScalarRelationFilter = {
    is?: bundleWhereInput | null
    isNot?: bundleWhereInput | null
  }

  export type T_salesScalarRelationFilter = {
    is?: t_salesWhereInput
    isNot?: t_salesWhereInput
  }

  export type t_sales_lineCountOrderByAggregateInput = {
    id?: SortOrder
    id_sales?: SortOrder
    unit_price?: SortOrder
    qty?: SortOrder
    total_price?: SortOrder
    id_product?: SortOrder
    id_bundle?: SortOrder
  }

  export type t_sales_lineAvgOrderByAggregateInput = {
    unit_price?: SortOrder
    qty?: SortOrder
    total_price?: SortOrder
  }

  export type t_sales_lineMaxOrderByAggregateInput = {
    id?: SortOrder
    id_sales?: SortOrder
    unit_price?: SortOrder
    qty?: SortOrder
    total_price?: SortOrder
    id_product?: SortOrder
    id_bundle?: SortOrder
  }

  export type t_sales_lineMinOrderByAggregateInput = {
    id?: SortOrder
    id_sales?: SortOrder
    unit_price?: SortOrder
    qty?: SortOrder
    total_price?: SortOrder
    id_product?: SortOrder
    id_bundle?: SortOrder
  }

  export type t_sales_lineSumOrderByAggregateInput = {
    unit_price?: SortOrder
    qty?: SortOrder
    total_price?: SortOrder
  }

  export type TagsNullableScalarRelationFilter = {
    is?: tagsWhereInput | null
    isNot?: tagsWhereInput | null
  }

  export type TagsListRelationFilter = {
    every?: tagsWhereInput
    some?: tagsWhereInput
    none?: tagsWhereInput
  }

  export type tagsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type tagsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    id_parent?: SortOrder
    deleted_at?: SortOrder
    slug?: SortOrder
    img?: SortOrder
  }

  export type tagsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    id_parent?: SortOrder
    deleted_at?: SortOrder
    slug?: SortOrder
    img?: SortOrder
  }

  export type tagsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    id_parent?: SortOrder
    deleted_at?: SortOrder
    slug?: SortOrder
    img?: SortOrder
  }

  export type transactionCountOrderByAggregateInput = {
    id?: SortOrder
    id_publisher?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    created_at?: SortOrder
    info?: SortOrder
  }

  export type transactionAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type transactionMaxOrderByAggregateInput = {
    id?: SortOrder
    id_publisher?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    created_at?: SortOrder
  }

  export type transactionMinOrderByAggregateInput = {
    id?: SortOrder
    id_publisher?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    created_at?: SortOrder
  }

  export type transactionSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type withdrawalCountOrderByAggregateInput = {
    id?: SortOrder
    id_publisher?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    requested_at?: SortOrder
    processed_at?: SortOrder
  }

  export type withdrawalAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type withdrawalMaxOrderByAggregateInput = {
    id?: SortOrder
    id_publisher?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    requested_at?: SortOrder
    processed_at?: SortOrder
  }

  export type withdrawalMinOrderByAggregateInput = {
    id?: SortOrder
    id_publisher?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    requested_at?: SortOrder
    processed_at?: SortOrder
  }

  export type withdrawalSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type auth_accountCreateNestedOneWithoutAffiliateInput = {
    create?: XOR<auth_accountCreateWithoutAffiliateInput, auth_accountUncheckedCreateWithoutAffiliateInput>
    connectOrCreate?: auth_accountCreateOrConnectWithoutAffiliateInput
    connect?: auth_accountWhereUniqueInput
  }

  export type auth_userCreateNestedManyWithoutAffiliateInput = {
    create?: XOR<auth_userCreateWithoutAffiliateInput, auth_userUncheckedCreateWithoutAffiliateInput> | auth_userCreateWithoutAffiliateInput[] | auth_userUncheckedCreateWithoutAffiliateInput[]
    connectOrCreate?: auth_userCreateOrConnectWithoutAffiliateInput | auth_userCreateOrConnectWithoutAffiliateInput[]
    createMany?: auth_userCreateManyAffiliateInputEnvelope
    connect?: auth_userWhereUniqueInput | auth_userWhereUniqueInput[]
  }

  export type auth_userUncheckedCreateNestedManyWithoutAffiliateInput = {
    create?: XOR<auth_userCreateWithoutAffiliateInput, auth_userUncheckedCreateWithoutAffiliateInput> | auth_userCreateWithoutAffiliateInput[] | auth_userUncheckedCreateWithoutAffiliateInput[]
    connectOrCreate?: auth_userCreateOrConnectWithoutAffiliateInput | auth_userCreateOrConnectWithoutAffiliateInput[]
    createMany?: auth_userCreateManyAffiliateInputEnvelope
    connect?: auth_userWhereUniqueInput | auth_userWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type auth_accountUpdateOneWithoutAffiliateNestedInput = {
    create?: XOR<auth_accountCreateWithoutAffiliateInput, auth_accountUncheckedCreateWithoutAffiliateInput>
    connectOrCreate?: auth_accountCreateOrConnectWithoutAffiliateInput
    upsert?: auth_accountUpsertWithoutAffiliateInput
    disconnect?: auth_accountWhereInput | boolean
    delete?: auth_accountWhereInput | boolean
    connect?: auth_accountWhereUniqueInput
    update?: XOR<XOR<auth_accountUpdateToOneWithWhereWithoutAffiliateInput, auth_accountUpdateWithoutAffiliateInput>, auth_accountUncheckedUpdateWithoutAffiliateInput>
  }

  export type auth_userUpdateManyWithoutAffiliateNestedInput = {
    create?: XOR<auth_userCreateWithoutAffiliateInput, auth_userUncheckedCreateWithoutAffiliateInput> | auth_userCreateWithoutAffiliateInput[] | auth_userUncheckedCreateWithoutAffiliateInput[]
    connectOrCreate?: auth_userCreateOrConnectWithoutAffiliateInput | auth_userCreateOrConnectWithoutAffiliateInput[]
    upsert?: auth_userUpsertWithWhereUniqueWithoutAffiliateInput | auth_userUpsertWithWhereUniqueWithoutAffiliateInput[]
    createMany?: auth_userCreateManyAffiliateInputEnvelope
    set?: auth_userWhereUniqueInput | auth_userWhereUniqueInput[]
    disconnect?: auth_userWhereUniqueInput | auth_userWhereUniqueInput[]
    delete?: auth_userWhereUniqueInput | auth_userWhereUniqueInput[]
    connect?: auth_userWhereUniqueInput | auth_userWhereUniqueInput[]
    update?: auth_userUpdateWithWhereUniqueWithoutAffiliateInput | auth_userUpdateWithWhereUniqueWithoutAffiliateInput[]
    updateMany?: auth_userUpdateManyWithWhereWithoutAffiliateInput | auth_userUpdateManyWithWhereWithoutAffiliateInput[]
    deleteMany?: auth_userScalarWhereInput | auth_userScalarWhereInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type auth_userUncheckedUpdateManyWithoutAffiliateNestedInput = {
    create?: XOR<auth_userCreateWithoutAffiliateInput, auth_userUncheckedCreateWithoutAffiliateInput> | auth_userCreateWithoutAffiliateInput[] | auth_userUncheckedCreateWithoutAffiliateInput[]
    connectOrCreate?: auth_userCreateOrConnectWithoutAffiliateInput | auth_userCreateOrConnectWithoutAffiliateInput[]
    upsert?: auth_userUpsertWithWhereUniqueWithoutAffiliateInput | auth_userUpsertWithWhereUniqueWithoutAffiliateInput[]
    createMany?: auth_userCreateManyAffiliateInputEnvelope
    set?: auth_userWhereUniqueInput | auth_userWhereUniqueInput[]
    disconnect?: auth_userWhereUniqueInput | auth_userWhereUniqueInput[]
    delete?: auth_userWhereUniqueInput | auth_userWhereUniqueInput[]
    connect?: auth_userWhereUniqueInput | auth_userWhereUniqueInput[]
    update?: auth_userUpdateWithWhereUniqueWithoutAffiliateInput | auth_userUpdateWithWhereUniqueWithoutAffiliateInput[]
    updateMany?: auth_userUpdateManyWithWhereWithoutAffiliateInput | auth_userUpdateManyWithWhereWithoutAffiliateInput[]
    deleteMany?: auth_userScalarWhereInput | auth_userScalarWhereInput[]
  }

  export type affiliateCreateNestedManyWithoutAuth_accountInput = {
    create?: XOR<affiliateCreateWithoutAuth_accountInput, affiliateUncheckedCreateWithoutAuth_accountInput> | affiliateCreateWithoutAuth_accountInput[] | affiliateUncheckedCreateWithoutAuth_accountInput[]
    connectOrCreate?: affiliateCreateOrConnectWithoutAuth_accountInput | affiliateCreateOrConnectWithoutAuth_accountInput[]
    createMany?: affiliateCreateManyAuth_accountInputEnvelope
    connect?: affiliateWhereUniqueInput | affiliateWhereUniqueInput[]
  }

  export type auth_userCreateNestedOneWithoutAuth_accountInput = {
    create?: XOR<auth_userCreateWithoutAuth_accountInput, auth_userUncheckedCreateWithoutAuth_accountInput>
    connectOrCreate?: auth_userCreateOrConnectWithoutAuth_accountInput
    connect?: auth_userWhereUniqueInput
  }

  export type authorCreateNestedManyWithoutAuth_accountInput = {
    create?: XOR<authorCreateWithoutAuth_accountInput, authorUncheckedCreateWithoutAuth_accountInput> | authorCreateWithoutAuth_accountInput[] | authorUncheckedCreateWithoutAuth_accountInput[]
    connectOrCreate?: authorCreateOrConnectWithoutAuth_accountInput | authorCreateOrConnectWithoutAuth_accountInput[]
    createMany?: authorCreateManyAuth_accountInputEnvelope
    connect?: authorWhereUniqueInput | authorWhereUniqueInput[]
  }

  export type customerCreateNestedManyWithoutAuth_accountInput = {
    create?: XOR<customerCreateWithoutAuth_accountInput, customerUncheckedCreateWithoutAuth_accountInput> | customerCreateWithoutAuth_accountInput[] | customerUncheckedCreateWithoutAuth_accountInput[]
    connectOrCreate?: customerCreateOrConnectWithoutAuth_accountInput | customerCreateOrConnectWithoutAuth_accountInput[]
    createMany?: customerCreateManyAuth_accountInputEnvelope
    connect?: customerWhereUniqueInput | customerWhereUniqueInput[]
  }

  export type internalCreateNestedManyWithoutAuth_accountInput = {
    create?: XOR<internalCreateWithoutAuth_accountInput, internalUncheckedCreateWithoutAuth_accountInput> | internalCreateWithoutAuth_accountInput[] | internalUncheckedCreateWithoutAuth_accountInput[]
    connectOrCreate?: internalCreateOrConnectWithoutAuth_accountInput | internalCreateOrConnectWithoutAuth_accountInput[]
    createMany?: internalCreateManyAuth_accountInputEnvelope
    connect?: internalWhereUniqueInput | internalWhereUniqueInput[]
  }

  export type publisherCreateNestedManyWithoutAuth_accountInput = {
    create?: XOR<publisherCreateWithoutAuth_accountInput, publisherUncheckedCreateWithoutAuth_accountInput> | publisherCreateWithoutAuth_accountInput[] | publisherUncheckedCreateWithoutAuth_accountInput[]
    connectOrCreate?: publisherCreateOrConnectWithoutAuth_accountInput | publisherCreateOrConnectWithoutAuth_accountInput[]
    createMany?: publisherCreateManyAuth_accountInputEnvelope
    connect?: publisherWhereUniqueInput | publisherWhereUniqueInput[]
  }

  export type affiliateUncheckedCreateNestedManyWithoutAuth_accountInput = {
    create?: XOR<affiliateCreateWithoutAuth_accountInput, affiliateUncheckedCreateWithoutAuth_accountInput> | affiliateCreateWithoutAuth_accountInput[] | affiliateUncheckedCreateWithoutAuth_accountInput[]
    connectOrCreate?: affiliateCreateOrConnectWithoutAuth_accountInput | affiliateCreateOrConnectWithoutAuth_accountInput[]
    createMany?: affiliateCreateManyAuth_accountInputEnvelope
    connect?: affiliateWhereUniqueInput | affiliateWhereUniqueInput[]
  }

  export type authorUncheckedCreateNestedManyWithoutAuth_accountInput = {
    create?: XOR<authorCreateWithoutAuth_accountInput, authorUncheckedCreateWithoutAuth_accountInput> | authorCreateWithoutAuth_accountInput[] | authorUncheckedCreateWithoutAuth_accountInput[]
    connectOrCreate?: authorCreateOrConnectWithoutAuth_accountInput | authorCreateOrConnectWithoutAuth_accountInput[]
    createMany?: authorCreateManyAuth_accountInputEnvelope
    connect?: authorWhereUniqueInput | authorWhereUniqueInput[]
  }

  export type customerUncheckedCreateNestedManyWithoutAuth_accountInput = {
    create?: XOR<customerCreateWithoutAuth_accountInput, customerUncheckedCreateWithoutAuth_accountInput> | customerCreateWithoutAuth_accountInput[] | customerUncheckedCreateWithoutAuth_accountInput[]
    connectOrCreate?: customerCreateOrConnectWithoutAuth_accountInput | customerCreateOrConnectWithoutAuth_accountInput[]
    createMany?: customerCreateManyAuth_accountInputEnvelope
    connect?: customerWhereUniqueInput | customerWhereUniqueInput[]
  }

  export type internalUncheckedCreateNestedManyWithoutAuth_accountInput = {
    create?: XOR<internalCreateWithoutAuth_accountInput, internalUncheckedCreateWithoutAuth_accountInput> | internalCreateWithoutAuth_accountInput[] | internalUncheckedCreateWithoutAuth_accountInput[]
    connectOrCreate?: internalCreateOrConnectWithoutAuth_accountInput | internalCreateOrConnectWithoutAuth_accountInput[]
    createMany?: internalCreateManyAuth_accountInputEnvelope
    connect?: internalWhereUniqueInput | internalWhereUniqueInput[]
  }

  export type publisherUncheckedCreateNestedManyWithoutAuth_accountInput = {
    create?: XOR<publisherCreateWithoutAuth_accountInput, publisherUncheckedCreateWithoutAuth_accountInput> | publisherCreateWithoutAuth_accountInput[] | publisherUncheckedCreateWithoutAuth_accountInput[]
    connectOrCreate?: publisherCreateOrConnectWithoutAuth_accountInput | publisherCreateOrConnectWithoutAuth_accountInput[]
    createMany?: publisherCreateManyAuth_accountInputEnvelope
    connect?: publisherWhereUniqueInput | publisherWhereUniqueInput[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type affiliateUpdateManyWithoutAuth_accountNestedInput = {
    create?: XOR<affiliateCreateWithoutAuth_accountInput, affiliateUncheckedCreateWithoutAuth_accountInput> | affiliateCreateWithoutAuth_accountInput[] | affiliateUncheckedCreateWithoutAuth_accountInput[]
    connectOrCreate?: affiliateCreateOrConnectWithoutAuth_accountInput | affiliateCreateOrConnectWithoutAuth_accountInput[]
    upsert?: affiliateUpsertWithWhereUniqueWithoutAuth_accountInput | affiliateUpsertWithWhereUniqueWithoutAuth_accountInput[]
    createMany?: affiliateCreateManyAuth_accountInputEnvelope
    set?: affiliateWhereUniqueInput | affiliateWhereUniqueInput[]
    disconnect?: affiliateWhereUniqueInput | affiliateWhereUniqueInput[]
    delete?: affiliateWhereUniqueInput | affiliateWhereUniqueInput[]
    connect?: affiliateWhereUniqueInput | affiliateWhereUniqueInput[]
    update?: affiliateUpdateWithWhereUniqueWithoutAuth_accountInput | affiliateUpdateWithWhereUniqueWithoutAuth_accountInput[]
    updateMany?: affiliateUpdateManyWithWhereWithoutAuth_accountInput | affiliateUpdateManyWithWhereWithoutAuth_accountInput[]
    deleteMany?: affiliateScalarWhereInput | affiliateScalarWhereInput[]
  }

  export type auth_userUpdateOneWithoutAuth_accountNestedInput = {
    create?: XOR<auth_userCreateWithoutAuth_accountInput, auth_userUncheckedCreateWithoutAuth_accountInput>
    connectOrCreate?: auth_userCreateOrConnectWithoutAuth_accountInput
    upsert?: auth_userUpsertWithoutAuth_accountInput
    disconnect?: auth_userWhereInput | boolean
    delete?: auth_userWhereInput | boolean
    connect?: auth_userWhereUniqueInput
    update?: XOR<XOR<auth_userUpdateToOneWithWhereWithoutAuth_accountInput, auth_userUpdateWithoutAuth_accountInput>, auth_userUncheckedUpdateWithoutAuth_accountInput>
  }

  export type authorUpdateManyWithoutAuth_accountNestedInput = {
    create?: XOR<authorCreateWithoutAuth_accountInput, authorUncheckedCreateWithoutAuth_accountInput> | authorCreateWithoutAuth_accountInput[] | authorUncheckedCreateWithoutAuth_accountInput[]
    connectOrCreate?: authorCreateOrConnectWithoutAuth_accountInput | authorCreateOrConnectWithoutAuth_accountInput[]
    upsert?: authorUpsertWithWhereUniqueWithoutAuth_accountInput | authorUpsertWithWhereUniqueWithoutAuth_accountInput[]
    createMany?: authorCreateManyAuth_accountInputEnvelope
    set?: authorWhereUniqueInput | authorWhereUniqueInput[]
    disconnect?: authorWhereUniqueInput | authorWhereUniqueInput[]
    delete?: authorWhereUniqueInput | authorWhereUniqueInput[]
    connect?: authorWhereUniqueInput | authorWhereUniqueInput[]
    update?: authorUpdateWithWhereUniqueWithoutAuth_accountInput | authorUpdateWithWhereUniqueWithoutAuth_accountInput[]
    updateMany?: authorUpdateManyWithWhereWithoutAuth_accountInput | authorUpdateManyWithWhereWithoutAuth_accountInput[]
    deleteMany?: authorScalarWhereInput | authorScalarWhereInput[]
  }

  export type customerUpdateManyWithoutAuth_accountNestedInput = {
    create?: XOR<customerCreateWithoutAuth_accountInput, customerUncheckedCreateWithoutAuth_accountInput> | customerCreateWithoutAuth_accountInput[] | customerUncheckedCreateWithoutAuth_accountInput[]
    connectOrCreate?: customerCreateOrConnectWithoutAuth_accountInput | customerCreateOrConnectWithoutAuth_accountInput[]
    upsert?: customerUpsertWithWhereUniqueWithoutAuth_accountInput | customerUpsertWithWhereUniqueWithoutAuth_accountInput[]
    createMany?: customerCreateManyAuth_accountInputEnvelope
    set?: customerWhereUniqueInput | customerWhereUniqueInput[]
    disconnect?: customerWhereUniqueInput | customerWhereUniqueInput[]
    delete?: customerWhereUniqueInput | customerWhereUniqueInput[]
    connect?: customerWhereUniqueInput | customerWhereUniqueInput[]
    update?: customerUpdateWithWhereUniqueWithoutAuth_accountInput | customerUpdateWithWhereUniqueWithoutAuth_accountInput[]
    updateMany?: customerUpdateManyWithWhereWithoutAuth_accountInput | customerUpdateManyWithWhereWithoutAuth_accountInput[]
    deleteMany?: customerScalarWhereInput | customerScalarWhereInput[]
  }

  export type internalUpdateManyWithoutAuth_accountNestedInput = {
    create?: XOR<internalCreateWithoutAuth_accountInput, internalUncheckedCreateWithoutAuth_accountInput> | internalCreateWithoutAuth_accountInput[] | internalUncheckedCreateWithoutAuth_accountInput[]
    connectOrCreate?: internalCreateOrConnectWithoutAuth_accountInput | internalCreateOrConnectWithoutAuth_accountInput[]
    upsert?: internalUpsertWithWhereUniqueWithoutAuth_accountInput | internalUpsertWithWhereUniqueWithoutAuth_accountInput[]
    createMany?: internalCreateManyAuth_accountInputEnvelope
    set?: internalWhereUniqueInput | internalWhereUniqueInput[]
    disconnect?: internalWhereUniqueInput | internalWhereUniqueInput[]
    delete?: internalWhereUniqueInput | internalWhereUniqueInput[]
    connect?: internalWhereUniqueInput | internalWhereUniqueInput[]
    update?: internalUpdateWithWhereUniqueWithoutAuth_accountInput | internalUpdateWithWhereUniqueWithoutAuth_accountInput[]
    updateMany?: internalUpdateManyWithWhereWithoutAuth_accountInput | internalUpdateManyWithWhereWithoutAuth_accountInput[]
    deleteMany?: internalScalarWhereInput | internalScalarWhereInput[]
  }

  export type publisherUpdateManyWithoutAuth_accountNestedInput = {
    create?: XOR<publisherCreateWithoutAuth_accountInput, publisherUncheckedCreateWithoutAuth_accountInput> | publisherCreateWithoutAuth_accountInput[] | publisherUncheckedCreateWithoutAuth_accountInput[]
    connectOrCreate?: publisherCreateOrConnectWithoutAuth_accountInput | publisherCreateOrConnectWithoutAuth_accountInput[]
    upsert?: publisherUpsertWithWhereUniqueWithoutAuth_accountInput | publisherUpsertWithWhereUniqueWithoutAuth_accountInput[]
    createMany?: publisherCreateManyAuth_accountInputEnvelope
    set?: publisherWhereUniqueInput | publisherWhereUniqueInput[]
    disconnect?: publisherWhereUniqueInput | publisherWhereUniqueInput[]
    delete?: publisherWhereUniqueInput | publisherWhereUniqueInput[]
    connect?: publisherWhereUniqueInput | publisherWhereUniqueInput[]
    update?: publisherUpdateWithWhereUniqueWithoutAuth_accountInput | publisherUpdateWithWhereUniqueWithoutAuth_accountInput[]
    updateMany?: publisherUpdateManyWithWhereWithoutAuth_accountInput | publisherUpdateManyWithWhereWithoutAuth_accountInput[]
    deleteMany?: publisherScalarWhereInput | publisherScalarWhereInput[]
  }

  export type affiliateUncheckedUpdateManyWithoutAuth_accountNestedInput = {
    create?: XOR<affiliateCreateWithoutAuth_accountInput, affiliateUncheckedCreateWithoutAuth_accountInput> | affiliateCreateWithoutAuth_accountInput[] | affiliateUncheckedCreateWithoutAuth_accountInput[]
    connectOrCreate?: affiliateCreateOrConnectWithoutAuth_accountInput | affiliateCreateOrConnectWithoutAuth_accountInput[]
    upsert?: affiliateUpsertWithWhereUniqueWithoutAuth_accountInput | affiliateUpsertWithWhereUniqueWithoutAuth_accountInput[]
    createMany?: affiliateCreateManyAuth_accountInputEnvelope
    set?: affiliateWhereUniqueInput | affiliateWhereUniqueInput[]
    disconnect?: affiliateWhereUniqueInput | affiliateWhereUniqueInput[]
    delete?: affiliateWhereUniqueInput | affiliateWhereUniqueInput[]
    connect?: affiliateWhereUniqueInput | affiliateWhereUniqueInput[]
    update?: affiliateUpdateWithWhereUniqueWithoutAuth_accountInput | affiliateUpdateWithWhereUniqueWithoutAuth_accountInput[]
    updateMany?: affiliateUpdateManyWithWhereWithoutAuth_accountInput | affiliateUpdateManyWithWhereWithoutAuth_accountInput[]
    deleteMany?: affiliateScalarWhereInput | affiliateScalarWhereInput[]
  }

  export type authorUncheckedUpdateManyWithoutAuth_accountNestedInput = {
    create?: XOR<authorCreateWithoutAuth_accountInput, authorUncheckedCreateWithoutAuth_accountInput> | authorCreateWithoutAuth_accountInput[] | authorUncheckedCreateWithoutAuth_accountInput[]
    connectOrCreate?: authorCreateOrConnectWithoutAuth_accountInput | authorCreateOrConnectWithoutAuth_accountInput[]
    upsert?: authorUpsertWithWhereUniqueWithoutAuth_accountInput | authorUpsertWithWhereUniqueWithoutAuth_accountInput[]
    createMany?: authorCreateManyAuth_accountInputEnvelope
    set?: authorWhereUniqueInput | authorWhereUniqueInput[]
    disconnect?: authorWhereUniqueInput | authorWhereUniqueInput[]
    delete?: authorWhereUniqueInput | authorWhereUniqueInput[]
    connect?: authorWhereUniqueInput | authorWhereUniqueInput[]
    update?: authorUpdateWithWhereUniqueWithoutAuth_accountInput | authorUpdateWithWhereUniqueWithoutAuth_accountInput[]
    updateMany?: authorUpdateManyWithWhereWithoutAuth_accountInput | authorUpdateManyWithWhereWithoutAuth_accountInput[]
    deleteMany?: authorScalarWhereInput | authorScalarWhereInput[]
  }

  export type customerUncheckedUpdateManyWithoutAuth_accountNestedInput = {
    create?: XOR<customerCreateWithoutAuth_accountInput, customerUncheckedCreateWithoutAuth_accountInput> | customerCreateWithoutAuth_accountInput[] | customerUncheckedCreateWithoutAuth_accountInput[]
    connectOrCreate?: customerCreateOrConnectWithoutAuth_accountInput | customerCreateOrConnectWithoutAuth_accountInput[]
    upsert?: customerUpsertWithWhereUniqueWithoutAuth_accountInput | customerUpsertWithWhereUniqueWithoutAuth_accountInput[]
    createMany?: customerCreateManyAuth_accountInputEnvelope
    set?: customerWhereUniqueInput | customerWhereUniqueInput[]
    disconnect?: customerWhereUniqueInput | customerWhereUniqueInput[]
    delete?: customerWhereUniqueInput | customerWhereUniqueInput[]
    connect?: customerWhereUniqueInput | customerWhereUniqueInput[]
    update?: customerUpdateWithWhereUniqueWithoutAuth_accountInput | customerUpdateWithWhereUniqueWithoutAuth_accountInput[]
    updateMany?: customerUpdateManyWithWhereWithoutAuth_accountInput | customerUpdateManyWithWhereWithoutAuth_accountInput[]
    deleteMany?: customerScalarWhereInput | customerScalarWhereInput[]
  }

  export type internalUncheckedUpdateManyWithoutAuth_accountNestedInput = {
    create?: XOR<internalCreateWithoutAuth_accountInput, internalUncheckedCreateWithoutAuth_accountInput> | internalCreateWithoutAuth_accountInput[] | internalUncheckedCreateWithoutAuth_accountInput[]
    connectOrCreate?: internalCreateOrConnectWithoutAuth_accountInput | internalCreateOrConnectWithoutAuth_accountInput[]
    upsert?: internalUpsertWithWhereUniqueWithoutAuth_accountInput | internalUpsertWithWhereUniqueWithoutAuth_accountInput[]
    createMany?: internalCreateManyAuth_accountInputEnvelope
    set?: internalWhereUniqueInput | internalWhereUniqueInput[]
    disconnect?: internalWhereUniqueInput | internalWhereUniqueInput[]
    delete?: internalWhereUniqueInput | internalWhereUniqueInput[]
    connect?: internalWhereUniqueInput | internalWhereUniqueInput[]
    update?: internalUpdateWithWhereUniqueWithoutAuth_accountInput | internalUpdateWithWhereUniqueWithoutAuth_accountInput[]
    updateMany?: internalUpdateManyWithWhereWithoutAuth_accountInput | internalUpdateManyWithWhereWithoutAuth_accountInput[]
    deleteMany?: internalScalarWhereInput | internalScalarWhereInput[]
  }

  export type publisherUncheckedUpdateManyWithoutAuth_accountNestedInput = {
    create?: XOR<publisherCreateWithoutAuth_accountInput, publisherUncheckedCreateWithoutAuth_accountInput> | publisherCreateWithoutAuth_accountInput[] | publisherUncheckedCreateWithoutAuth_accountInput[]
    connectOrCreate?: publisherCreateOrConnectWithoutAuth_accountInput | publisherCreateOrConnectWithoutAuth_accountInput[]
    upsert?: publisherUpsertWithWhereUniqueWithoutAuth_accountInput | publisherUpsertWithWhereUniqueWithoutAuth_accountInput[]
    createMany?: publisherCreateManyAuth_accountInputEnvelope
    set?: publisherWhereUniqueInput | publisherWhereUniqueInput[]
    disconnect?: publisherWhereUniqueInput | publisherWhereUniqueInput[]
    delete?: publisherWhereUniqueInput | publisherWhereUniqueInput[]
    connect?: publisherWhereUniqueInput | publisherWhereUniqueInput[]
    update?: publisherUpdateWithWhereUniqueWithoutAuth_accountInput | publisherUpdateWithWhereUniqueWithoutAuth_accountInput[]
    updateMany?: publisherUpdateManyWithWhereWithoutAuth_accountInput | publisherUpdateManyWithWhereWithoutAuth_accountInput[]
    deleteMany?: publisherScalarWhereInput | publisherScalarWhereInput[]
  }

  export type auth_userCreateNestedOneWithoutAuth_sessionInput = {
    create?: XOR<auth_userCreateWithoutAuth_sessionInput, auth_userUncheckedCreateWithoutAuth_sessionInput>
    connectOrCreate?: auth_userCreateOrConnectWithoutAuth_sessionInput
    connect?: auth_userWhereUniqueInput
  }

  export type auth_userUpdateOneRequiredWithoutAuth_sessionNestedInput = {
    create?: XOR<auth_userCreateWithoutAuth_sessionInput, auth_userUncheckedCreateWithoutAuth_sessionInput>
    connectOrCreate?: auth_userCreateOrConnectWithoutAuth_sessionInput
    upsert?: auth_userUpsertWithoutAuth_sessionInput
    connect?: auth_userWhereUniqueInput
    update?: XOR<XOR<auth_userUpdateToOneWithWhereWithoutAuth_sessionInput, auth_userUpdateWithoutAuth_sessionInput>, auth_userUncheckedUpdateWithoutAuth_sessionInput>
  }

  export type auth_userCreateNestedOneWithoutAuth_two_factorInput = {
    create?: XOR<auth_userCreateWithoutAuth_two_factorInput, auth_userUncheckedCreateWithoutAuth_two_factorInput>
    connectOrCreate?: auth_userCreateOrConnectWithoutAuth_two_factorInput
    connect?: auth_userWhereUniqueInput
  }

  export type auth_userUpdateOneRequiredWithoutAuth_two_factorNestedInput = {
    create?: XOR<auth_userCreateWithoutAuth_two_factorInput, auth_userUncheckedCreateWithoutAuth_two_factorInput>
    connectOrCreate?: auth_userCreateOrConnectWithoutAuth_two_factorInput
    upsert?: auth_userUpsertWithoutAuth_two_factorInput
    connect?: auth_userWhereUniqueInput
    update?: XOR<XOR<auth_userUpdateToOneWithWhereWithoutAuth_two_factorInput, auth_userUpdateWithoutAuth_two_factorInput>, auth_userUncheckedUpdateWithoutAuth_two_factorInput>
  }

  export type auth_accountCreateNestedManyWithoutAuth_userInput = {
    create?: XOR<auth_accountCreateWithoutAuth_userInput, auth_accountUncheckedCreateWithoutAuth_userInput> | auth_accountCreateWithoutAuth_userInput[] | auth_accountUncheckedCreateWithoutAuth_userInput[]
    connectOrCreate?: auth_accountCreateOrConnectWithoutAuth_userInput | auth_accountCreateOrConnectWithoutAuth_userInput[]
    createMany?: auth_accountCreateManyAuth_userInputEnvelope
    connect?: auth_accountWhereUniqueInput | auth_accountWhereUniqueInput[]
  }

  export type auth_sessionCreateNestedManyWithoutAuth_userInput = {
    create?: XOR<auth_sessionCreateWithoutAuth_userInput, auth_sessionUncheckedCreateWithoutAuth_userInput> | auth_sessionCreateWithoutAuth_userInput[] | auth_sessionUncheckedCreateWithoutAuth_userInput[]
    connectOrCreate?: auth_sessionCreateOrConnectWithoutAuth_userInput | auth_sessionCreateOrConnectWithoutAuth_userInput[]
    createMany?: auth_sessionCreateManyAuth_userInputEnvelope
    connect?: auth_sessionWhereUniqueInput | auth_sessionWhereUniqueInput[]
  }

  export type auth_two_factorCreateNestedManyWithoutAuth_userInput = {
    create?: XOR<auth_two_factorCreateWithoutAuth_userInput, auth_two_factorUncheckedCreateWithoutAuth_userInput> | auth_two_factorCreateWithoutAuth_userInput[] | auth_two_factorUncheckedCreateWithoutAuth_userInput[]
    connectOrCreate?: auth_two_factorCreateOrConnectWithoutAuth_userInput | auth_two_factorCreateOrConnectWithoutAuth_userInput[]
    createMany?: auth_two_factorCreateManyAuth_userInputEnvelope
    connect?: auth_two_factorWhereUniqueInput | auth_two_factorWhereUniqueInput[]
  }

  export type affiliateCreateNestedOneWithoutAuth_userInput = {
    create?: XOR<affiliateCreateWithoutAuth_userInput, affiliateUncheckedCreateWithoutAuth_userInput>
    connectOrCreate?: affiliateCreateOrConnectWithoutAuth_userInput
    connect?: affiliateWhereUniqueInput
  }

  export type authorCreateNestedOneWithoutAuth_userInput = {
    create?: XOR<authorCreateWithoutAuth_userInput, authorUncheckedCreateWithoutAuth_userInput>
    connectOrCreate?: authorCreateOrConnectWithoutAuth_userInput
    connect?: authorWhereUniqueInput
  }

  export type customerCreateNestedOneWithoutAuth_userInput = {
    create?: XOR<customerCreateWithoutAuth_userInput, customerUncheckedCreateWithoutAuth_userInput>
    connectOrCreate?: customerCreateOrConnectWithoutAuth_userInput
    connect?: customerWhereUniqueInput
  }

  export type internalCreateNestedOneWithoutAuth_userInput = {
    create?: XOR<internalCreateWithoutAuth_userInput, internalUncheckedCreateWithoutAuth_userInput>
    connectOrCreate?: internalCreateOrConnectWithoutAuth_userInput
    connect?: internalWhereUniqueInput
  }

  export type publisherCreateNestedOneWithoutAuth_userInput = {
    create?: XOR<publisherCreateWithoutAuth_userInput, publisherUncheckedCreateWithoutAuth_userInput>
    connectOrCreate?: publisherCreateOrConnectWithoutAuth_userInput
    connect?: publisherWhereUniqueInput
  }

  export type reviewsCreateNestedManyWithoutAuth_userInput = {
    create?: XOR<reviewsCreateWithoutAuth_userInput, reviewsUncheckedCreateWithoutAuth_userInput> | reviewsCreateWithoutAuth_userInput[] | reviewsUncheckedCreateWithoutAuth_userInput[]
    connectOrCreate?: reviewsCreateOrConnectWithoutAuth_userInput | reviewsCreateOrConnectWithoutAuth_userInput[]
    createMany?: reviewsCreateManyAuth_userInputEnvelope
    connect?: reviewsWhereUniqueInput | reviewsWhereUniqueInput[]
  }

  export type reviews_likesCreateNestedManyWithoutAuth_userInput = {
    create?: XOR<reviews_likesCreateWithoutAuth_userInput, reviews_likesUncheckedCreateWithoutAuth_userInput> | reviews_likesCreateWithoutAuth_userInput[] | reviews_likesUncheckedCreateWithoutAuth_userInput[]
    connectOrCreate?: reviews_likesCreateOrConnectWithoutAuth_userInput | reviews_likesCreateOrConnectWithoutAuth_userInput[]
    createMany?: reviews_likesCreateManyAuth_userInputEnvelope
    connect?: reviews_likesWhereUniqueInput | reviews_likesWhereUniqueInput[]
  }

  export type auth_accountUncheckedCreateNestedManyWithoutAuth_userInput = {
    create?: XOR<auth_accountCreateWithoutAuth_userInput, auth_accountUncheckedCreateWithoutAuth_userInput> | auth_accountCreateWithoutAuth_userInput[] | auth_accountUncheckedCreateWithoutAuth_userInput[]
    connectOrCreate?: auth_accountCreateOrConnectWithoutAuth_userInput | auth_accountCreateOrConnectWithoutAuth_userInput[]
    createMany?: auth_accountCreateManyAuth_userInputEnvelope
    connect?: auth_accountWhereUniqueInput | auth_accountWhereUniqueInput[]
  }

  export type auth_sessionUncheckedCreateNestedManyWithoutAuth_userInput = {
    create?: XOR<auth_sessionCreateWithoutAuth_userInput, auth_sessionUncheckedCreateWithoutAuth_userInput> | auth_sessionCreateWithoutAuth_userInput[] | auth_sessionUncheckedCreateWithoutAuth_userInput[]
    connectOrCreate?: auth_sessionCreateOrConnectWithoutAuth_userInput | auth_sessionCreateOrConnectWithoutAuth_userInput[]
    createMany?: auth_sessionCreateManyAuth_userInputEnvelope
    connect?: auth_sessionWhereUniqueInput | auth_sessionWhereUniqueInput[]
  }

  export type auth_two_factorUncheckedCreateNestedManyWithoutAuth_userInput = {
    create?: XOR<auth_two_factorCreateWithoutAuth_userInput, auth_two_factorUncheckedCreateWithoutAuth_userInput> | auth_two_factorCreateWithoutAuth_userInput[] | auth_two_factorUncheckedCreateWithoutAuth_userInput[]
    connectOrCreate?: auth_two_factorCreateOrConnectWithoutAuth_userInput | auth_two_factorCreateOrConnectWithoutAuth_userInput[]
    createMany?: auth_two_factorCreateManyAuth_userInputEnvelope
    connect?: auth_two_factorWhereUniqueInput | auth_two_factorWhereUniqueInput[]
  }

  export type reviewsUncheckedCreateNestedManyWithoutAuth_userInput = {
    create?: XOR<reviewsCreateWithoutAuth_userInput, reviewsUncheckedCreateWithoutAuth_userInput> | reviewsCreateWithoutAuth_userInput[] | reviewsUncheckedCreateWithoutAuth_userInput[]
    connectOrCreate?: reviewsCreateOrConnectWithoutAuth_userInput | reviewsCreateOrConnectWithoutAuth_userInput[]
    createMany?: reviewsCreateManyAuth_userInputEnvelope
    connect?: reviewsWhereUniqueInput | reviewsWhereUniqueInput[]
  }

  export type reviews_likesUncheckedCreateNestedManyWithoutAuth_userInput = {
    create?: XOR<reviews_likesCreateWithoutAuth_userInput, reviews_likesUncheckedCreateWithoutAuth_userInput> | reviews_likesCreateWithoutAuth_userInput[] | reviews_likesUncheckedCreateWithoutAuth_userInput[]
    connectOrCreate?: reviews_likesCreateOrConnectWithoutAuth_userInput | reviews_likesCreateOrConnectWithoutAuth_userInput[]
    createMany?: reviews_likesCreateManyAuth_userInputEnvelope
    connect?: reviews_likesWhereUniqueInput | reviews_likesWhereUniqueInput[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type auth_accountUpdateManyWithoutAuth_userNestedInput = {
    create?: XOR<auth_accountCreateWithoutAuth_userInput, auth_accountUncheckedCreateWithoutAuth_userInput> | auth_accountCreateWithoutAuth_userInput[] | auth_accountUncheckedCreateWithoutAuth_userInput[]
    connectOrCreate?: auth_accountCreateOrConnectWithoutAuth_userInput | auth_accountCreateOrConnectWithoutAuth_userInput[]
    upsert?: auth_accountUpsertWithWhereUniqueWithoutAuth_userInput | auth_accountUpsertWithWhereUniqueWithoutAuth_userInput[]
    createMany?: auth_accountCreateManyAuth_userInputEnvelope
    set?: auth_accountWhereUniqueInput | auth_accountWhereUniqueInput[]
    disconnect?: auth_accountWhereUniqueInput | auth_accountWhereUniqueInput[]
    delete?: auth_accountWhereUniqueInput | auth_accountWhereUniqueInput[]
    connect?: auth_accountWhereUniqueInput | auth_accountWhereUniqueInput[]
    update?: auth_accountUpdateWithWhereUniqueWithoutAuth_userInput | auth_accountUpdateWithWhereUniqueWithoutAuth_userInput[]
    updateMany?: auth_accountUpdateManyWithWhereWithoutAuth_userInput | auth_accountUpdateManyWithWhereWithoutAuth_userInput[]
    deleteMany?: auth_accountScalarWhereInput | auth_accountScalarWhereInput[]
  }

  export type auth_sessionUpdateManyWithoutAuth_userNestedInput = {
    create?: XOR<auth_sessionCreateWithoutAuth_userInput, auth_sessionUncheckedCreateWithoutAuth_userInput> | auth_sessionCreateWithoutAuth_userInput[] | auth_sessionUncheckedCreateWithoutAuth_userInput[]
    connectOrCreate?: auth_sessionCreateOrConnectWithoutAuth_userInput | auth_sessionCreateOrConnectWithoutAuth_userInput[]
    upsert?: auth_sessionUpsertWithWhereUniqueWithoutAuth_userInput | auth_sessionUpsertWithWhereUniqueWithoutAuth_userInput[]
    createMany?: auth_sessionCreateManyAuth_userInputEnvelope
    set?: auth_sessionWhereUniqueInput | auth_sessionWhereUniqueInput[]
    disconnect?: auth_sessionWhereUniqueInput | auth_sessionWhereUniqueInput[]
    delete?: auth_sessionWhereUniqueInput | auth_sessionWhereUniqueInput[]
    connect?: auth_sessionWhereUniqueInput | auth_sessionWhereUniqueInput[]
    update?: auth_sessionUpdateWithWhereUniqueWithoutAuth_userInput | auth_sessionUpdateWithWhereUniqueWithoutAuth_userInput[]
    updateMany?: auth_sessionUpdateManyWithWhereWithoutAuth_userInput | auth_sessionUpdateManyWithWhereWithoutAuth_userInput[]
    deleteMany?: auth_sessionScalarWhereInput | auth_sessionScalarWhereInput[]
  }

  export type auth_two_factorUpdateManyWithoutAuth_userNestedInput = {
    create?: XOR<auth_two_factorCreateWithoutAuth_userInput, auth_two_factorUncheckedCreateWithoutAuth_userInput> | auth_two_factorCreateWithoutAuth_userInput[] | auth_two_factorUncheckedCreateWithoutAuth_userInput[]
    connectOrCreate?: auth_two_factorCreateOrConnectWithoutAuth_userInput | auth_two_factorCreateOrConnectWithoutAuth_userInput[]
    upsert?: auth_two_factorUpsertWithWhereUniqueWithoutAuth_userInput | auth_two_factorUpsertWithWhereUniqueWithoutAuth_userInput[]
    createMany?: auth_two_factorCreateManyAuth_userInputEnvelope
    set?: auth_two_factorWhereUniqueInput | auth_two_factorWhereUniqueInput[]
    disconnect?: auth_two_factorWhereUniqueInput | auth_two_factorWhereUniqueInput[]
    delete?: auth_two_factorWhereUniqueInput | auth_two_factorWhereUniqueInput[]
    connect?: auth_two_factorWhereUniqueInput | auth_two_factorWhereUniqueInput[]
    update?: auth_two_factorUpdateWithWhereUniqueWithoutAuth_userInput | auth_two_factorUpdateWithWhereUniqueWithoutAuth_userInput[]
    updateMany?: auth_two_factorUpdateManyWithWhereWithoutAuth_userInput | auth_two_factorUpdateManyWithWhereWithoutAuth_userInput[]
    deleteMany?: auth_two_factorScalarWhereInput | auth_two_factorScalarWhereInput[]
  }

  export type affiliateUpdateOneWithoutAuth_userNestedInput = {
    create?: XOR<affiliateCreateWithoutAuth_userInput, affiliateUncheckedCreateWithoutAuth_userInput>
    connectOrCreate?: affiliateCreateOrConnectWithoutAuth_userInput
    upsert?: affiliateUpsertWithoutAuth_userInput
    disconnect?: affiliateWhereInput | boolean
    delete?: affiliateWhereInput | boolean
    connect?: affiliateWhereUniqueInput
    update?: XOR<XOR<affiliateUpdateToOneWithWhereWithoutAuth_userInput, affiliateUpdateWithoutAuth_userInput>, affiliateUncheckedUpdateWithoutAuth_userInput>
  }

  export type authorUpdateOneWithoutAuth_userNestedInput = {
    create?: XOR<authorCreateWithoutAuth_userInput, authorUncheckedCreateWithoutAuth_userInput>
    connectOrCreate?: authorCreateOrConnectWithoutAuth_userInput
    upsert?: authorUpsertWithoutAuth_userInput
    disconnect?: authorWhereInput | boolean
    delete?: authorWhereInput | boolean
    connect?: authorWhereUniqueInput
    update?: XOR<XOR<authorUpdateToOneWithWhereWithoutAuth_userInput, authorUpdateWithoutAuth_userInput>, authorUncheckedUpdateWithoutAuth_userInput>
  }

  export type customerUpdateOneWithoutAuth_userNestedInput = {
    create?: XOR<customerCreateWithoutAuth_userInput, customerUncheckedCreateWithoutAuth_userInput>
    connectOrCreate?: customerCreateOrConnectWithoutAuth_userInput
    upsert?: customerUpsertWithoutAuth_userInput
    disconnect?: customerWhereInput | boolean
    delete?: customerWhereInput | boolean
    connect?: customerWhereUniqueInput
    update?: XOR<XOR<customerUpdateToOneWithWhereWithoutAuth_userInput, customerUpdateWithoutAuth_userInput>, customerUncheckedUpdateWithoutAuth_userInput>
  }

  export type internalUpdateOneWithoutAuth_userNestedInput = {
    create?: XOR<internalCreateWithoutAuth_userInput, internalUncheckedCreateWithoutAuth_userInput>
    connectOrCreate?: internalCreateOrConnectWithoutAuth_userInput
    upsert?: internalUpsertWithoutAuth_userInput
    disconnect?: internalWhereInput | boolean
    delete?: internalWhereInput | boolean
    connect?: internalWhereUniqueInput
    update?: XOR<XOR<internalUpdateToOneWithWhereWithoutAuth_userInput, internalUpdateWithoutAuth_userInput>, internalUncheckedUpdateWithoutAuth_userInput>
  }

  export type publisherUpdateOneWithoutAuth_userNestedInput = {
    create?: XOR<publisherCreateWithoutAuth_userInput, publisherUncheckedCreateWithoutAuth_userInput>
    connectOrCreate?: publisherCreateOrConnectWithoutAuth_userInput
    upsert?: publisherUpsertWithoutAuth_userInput
    disconnect?: publisherWhereInput | boolean
    delete?: publisherWhereInput | boolean
    connect?: publisherWhereUniqueInput
    update?: XOR<XOR<publisherUpdateToOneWithWhereWithoutAuth_userInput, publisherUpdateWithoutAuth_userInput>, publisherUncheckedUpdateWithoutAuth_userInput>
  }

  export type reviewsUpdateManyWithoutAuth_userNestedInput = {
    create?: XOR<reviewsCreateWithoutAuth_userInput, reviewsUncheckedCreateWithoutAuth_userInput> | reviewsCreateWithoutAuth_userInput[] | reviewsUncheckedCreateWithoutAuth_userInput[]
    connectOrCreate?: reviewsCreateOrConnectWithoutAuth_userInput | reviewsCreateOrConnectWithoutAuth_userInput[]
    upsert?: reviewsUpsertWithWhereUniqueWithoutAuth_userInput | reviewsUpsertWithWhereUniqueWithoutAuth_userInput[]
    createMany?: reviewsCreateManyAuth_userInputEnvelope
    set?: reviewsWhereUniqueInput | reviewsWhereUniqueInput[]
    disconnect?: reviewsWhereUniqueInput | reviewsWhereUniqueInput[]
    delete?: reviewsWhereUniqueInput | reviewsWhereUniqueInput[]
    connect?: reviewsWhereUniqueInput | reviewsWhereUniqueInput[]
    update?: reviewsUpdateWithWhereUniqueWithoutAuth_userInput | reviewsUpdateWithWhereUniqueWithoutAuth_userInput[]
    updateMany?: reviewsUpdateManyWithWhereWithoutAuth_userInput | reviewsUpdateManyWithWhereWithoutAuth_userInput[]
    deleteMany?: reviewsScalarWhereInput | reviewsScalarWhereInput[]
  }

  export type reviews_likesUpdateManyWithoutAuth_userNestedInput = {
    create?: XOR<reviews_likesCreateWithoutAuth_userInput, reviews_likesUncheckedCreateWithoutAuth_userInput> | reviews_likesCreateWithoutAuth_userInput[] | reviews_likesUncheckedCreateWithoutAuth_userInput[]
    connectOrCreate?: reviews_likesCreateOrConnectWithoutAuth_userInput | reviews_likesCreateOrConnectWithoutAuth_userInput[]
    upsert?: reviews_likesUpsertWithWhereUniqueWithoutAuth_userInput | reviews_likesUpsertWithWhereUniqueWithoutAuth_userInput[]
    createMany?: reviews_likesCreateManyAuth_userInputEnvelope
    set?: reviews_likesWhereUniqueInput | reviews_likesWhereUniqueInput[]
    disconnect?: reviews_likesWhereUniqueInput | reviews_likesWhereUniqueInput[]
    delete?: reviews_likesWhereUniqueInput | reviews_likesWhereUniqueInput[]
    connect?: reviews_likesWhereUniqueInput | reviews_likesWhereUniqueInput[]
    update?: reviews_likesUpdateWithWhereUniqueWithoutAuth_userInput | reviews_likesUpdateWithWhereUniqueWithoutAuth_userInput[]
    updateMany?: reviews_likesUpdateManyWithWhereWithoutAuth_userInput | reviews_likesUpdateManyWithWhereWithoutAuth_userInput[]
    deleteMany?: reviews_likesScalarWhereInput | reviews_likesScalarWhereInput[]
  }

  export type auth_accountUncheckedUpdateManyWithoutAuth_userNestedInput = {
    create?: XOR<auth_accountCreateWithoutAuth_userInput, auth_accountUncheckedCreateWithoutAuth_userInput> | auth_accountCreateWithoutAuth_userInput[] | auth_accountUncheckedCreateWithoutAuth_userInput[]
    connectOrCreate?: auth_accountCreateOrConnectWithoutAuth_userInput | auth_accountCreateOrConnectWithoutAuth_userInput[]
    upsert?: auth_accountUpsertWithWhereUniqueWithoutAuth_userInput | auth_accountUpsertWithWhereUniqueWithoutAuth_userInput[]
    createMany?: auth_accountCreateManyAuth_userInputEnvelope
    set?: auth_accountWhereUniqueInput | auth_accountWhereUniqueInput[]
    disconnect?: auth_accountWhereUniqueInput | auth_accountWhereUniqueInput[]
    delete?: auth_accountWhereUniqueInput | auth_accountWhereUniqueInput[]
    connect?: auth_accountWhereUniqueInput | auth_accountWhereUniqueInput[]
    update?: auth_accountUpdateWithWhereUniqueWithoutAuth_userInput | auth_accountUpdateWithWhereUniqueWithoutAuth_userInput[]
    updateMany?: auth_accountUpdateManyWithWhereWithoutAuth_userInput | auth_accountUpdateManyWithWhereWithoutAuth_userInput[]
    deleteMany?: auth_accountScalarWhereInput | auth_accountScalarWhereInput[]
  }

  export type auth_sessionUncheckedUpdateManyWithoutAuth_userNestedInput = {
    create?: XOR<auth_sessionCreateWithoutAuth_userInput, auth_sessionUncheckedCreateWithoutAuth_userInput> | auth_sessionCreateWithoutAuth_userInput[] | auth_sessionUncheckedCreateWithoutAuth_userInput[]
    connectOrCreate?: auth_sessionCreateOrConnectWithoutAuth_userInput | auth_sessionCreateOrConnectWithoutAuth_userInput[]
    upsert?: auth_sessionUpsertWithWhereUniqueWithoutAuth_userInput | auth_sessionUpsertWithWhereUniqueWithoutAuth_userInput[]
    createMany?: auth_sessionCreateManyAuth_userInputEnvelope
    set?: auth_sessionWhereUniqueInput | auth_sessionWhereUniqueInput[]
    disconnect?: auth_sessionWhereUniqueInput | auth_sessionWhereUniqueInput[]
    delete?: auth_sessionWhereUniqueInput | auth_sessionWhereUniqueInput[]
    connect?: auth_sessionWhereUniqueInput | auth_sessionWhereUniqueInput[]
    update?: auth_sessionUpdateWithWhereUniqueWithoutAuth_userInput | auth_sessionUpdateWithWhereUniqueWithoutAuth_userInput[]
    updateMany?: auth_sessionUpdateManyWithWhereWithoutAuth_userInput | auth_sessionUpdateManyWithWhereWithoutAuth_userInput[]
    deleteMany?: auth_sessionScalarWhereInput | auth_sessionScalarWhereInput[]
  }

  export type auth_two_factorUncheckedUpdateManyWithoutAuth_userNestedInput = {
    create?: XOR<auth_two_factorCreateWithoutAuth_userInput, auth_two_factorUncheckedCreateWithoutAuth_userInput> | auth_two_factorCreateWithoutAuth_userInput[] | auth_two_factorUncheckedCreateWithoutAuth_userInput[]
    connectOrCreate?: auth_two_factorCreateOrConnectWithoutAuth_userInput | auth_two_factorCreateOrConnectWithoutAuth_userInput[]
    upsert?: auth_two_factorUpsertWithWhereUniqueWithoutAuth_userInput | auth_two_factorUpsertWithWhereUniqueWithoutAuth_userInput[]
    createMany?: auth_two_factorCreateManyAuth_userInputEnvelope
    set?: auth_two_factorWhereUniqueInput | auth_two_factorWhereUniqueInput[]
    disconnect?: auth_two_factorWhereUniqueInput | auth_two_factorWhereUniqueInput[]
    delete?: auth_two_factorWhereUniqueInput | auth_two_factorWhereUniqueInput[]
    connect?: auth_two_factorWhereUniqueInput | auth_two_factorWhereUniqueInput[]
    update?: auth_two_factorUpdateWithWhereUniqueWithoutAuth_userInput | auth_two_factorUpdateWithWhereUniqueWithoutAuth_userInput[]
    updateMany?: auth_two_factorUpdateManyWithWhereWithoutAuth_userInput | auth_two_factorUpdateManyWithWhereWithoutAuth_userInput[]
    deleteMany?: auth_two_factorScalarWhereInput | auth_two_factorScalarWhereInput[]
  }

  export type reviewsUncheckedUpdateManyWithoutAuth_userNestedInput = {
    create?: XOR<reviewsCreateWithoutAuth_userInput, reviewsUncheckedCreateWithoutAuth_userInput> | reviewsCreateWithoutAuth_userInput[] | reviewsUncheckedCreateWithoutAuth_userInput[]
    connectOrCreate?: reviewsCreateOrConnectWithoutAuth_userInput | reviewsCreateOrConnectWithoutAuth_userInput[]
    upsert?: reviewsUpsertWithWhereUniqueWithoutAuth_userInput | reviewsUpsertWithWhereUniqueWithoutAuth_userInput[]
    createMany?: reviewsCreateManyAuth_userInputEnvelope
    set?: reviewsWhereUniqueInput | reviewsWhereUniqueInput[]
    disconnect?: reviewsWhereUniqueInput | reviewsWhereUniqueInput[]
    delete?: reviewsWhereUniqueInput | reviewsWhereUniqueInput[]
    connect?: reviewsWhereUniqueInput | reviewsWhereUniqueInput[]
    update?: reviewsUpdateWithWhereUniqueWithoutAuth_userInput | reviewsUpdateWithWhereUniqueWithoutAuth_userInput[]
    updateMany?: reviewsUpdateManyWithWhereWithoutAuth_userInput | reviewsUpdateManyWithWhereWithoutAuth_userInput[]
    deleteMany?: reviewsScalarWhereInput | reviewsScalarWhereInput[]
  }

  export type reviews_likesUncheckedUpdateManyWithoutAuth_userNestedInput = {
    create?: XOR<reviews_likesCreateWithoutAuth_userInput, reviews_likesUncheckedCreateWithoutAuth_userInput> | reviews_likesCreateWithoutAuth_userInput[] | reviews_likesUncheckedCreateWithoutAuth_userInput[]
    connectOrCreate?: reviews_likesCreateOrConnectWithoutAuth_userInput | reviews_likesCreateOrConnectWithoutAuth_userInput[]
    upsert?: reviews_likesUpsertWithWhereUniqueWithoutAuth_userInput | reviews_likesUpsertWithWhereUniqueWithoutAuth_userInput[]
    createMany?: reviews_likesCreateManyAuth_userInputEnvelope
    set?: reviews_likesWhereUniqueInput | reviews_likesWhereUniqueInput[]
    disconnect?: reviews_likesWhereUniqueInput | reviews_likesWhereUniqueInput[]
    delete?: reviews_likesWhereUniqueInput | reviews_likesWhereUniqueInput[]
    connect?: reviews_likesWhereUniqueInput | reviews_likesWhereUniqueInput[]
    update?: reviews_likesUpdateWithWhereUniqueWithoutAuth_userInput | reviews_likesUpdateWithWhereUniqueWithoutAuth_userInput[]
    updateMany?: reviews_likesUpdateManyWithWhereWithoutAuth_userInput | reviews_likesUpdateManyWithWhereWithoutAuth_userInput[]
    deleteMany?: reviews_likesScalarWhereInput | reviews_likesScalarWhereInput[]
  }

  export type auth_userCreateNestedManyWithoutAuthorInput = {
    create?: XOR<auth_userCreateWithoutAuthorInput, auth_userUncheckedCreateWithoutAuthorInput> | auth_userCreateWithoutAuthorInput[] | auth_userUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: auth_userCreateOrConnectWithoutAuthorInput | auth_userCreateOrConnectWithoutAuthorInput[]
    createMany?: auth_userCreateManyAuthorInputEnvelope
    connect?: auth_userWhereUniqueInput | auth_userWhereUniqueInput[]
  }

  export type auth_accountCreateNestedOneWithoutAuthorInput = {
    create?: XOR<auth_accountCreateWithoutAuthorInput, auth_accountUncheckedCreateWithoutAuthorInput>
    connectOrCreate?: auth_accountCreateOrConnectWithoutAuthorInput
    connect?: auth_accountWhereUniqueInput
  }

  export type bookCreateNestedManyWithoutAuthorInput = {
    create?: XOR<bookCreateWithoutAuthorInput, bookUncheckedCreateWithoutAuthorInput> | bookCreateWithoutAuthorInput[] | bookUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: bookCreateOrConnectWithoutAuthorInput | bookCreateOrConnectWithoutAuthorInput[]
    createMany?: bookCreateManyAuthorInputEnvelope
    connect?: bookWhereUniqueInput | bookWhereUniqueInput[]
  }

  export type productCreateNestedManyWithoutAuthorInput = {
    create?: XOR<productCreateWithoutAuthorInput, productUncheckedCreateWithoutAuthorInput> | productCreateWithoutAuthorInput[] | productUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: productCreateOrConnectWithoutAuthorInput | productCreateOrConnectWithoutAuthorInput[]
    createMany?: productCreateManyAuthorInputEnvelope
    connect?: productWhereUniqueInput | productWhereUniqueInput[]
  }

  export type publisher_authorCreateNestedManyWithoutAuthorInput = {
    create?: XOR<publisher_authorCreateWithoutAuthorInput, publisher_authorUncheckedCreateWithoutAuthorInput> | publisher_authorCreateWithoutAuthorInput[] | publisher_authorUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: publisher_authorCreateOrConnectWithoutAuthorInput | publisher_authorCreateOrConnectWithoutAuthorInput[]
    createMany?: publisher_authorCreateManyAuthorInputEnvelope
    connect?: publisher_authorWhereUniqueInput | publisher_authorWhereUniqueInput[]
  }

  export type auth_userUncheckedCreateNestedManyWithoutAuthorInput = {
    create?: XOR<auth_userCreateWithoutAuthorInput, auth_userUncheckedCreateWithoutAuthorInput> | auth_userCreateWithoutAuthorInput[] | auth_userUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: auth_userCreateOrConnectWithoutAuthorInput | auth_userCreateOrConnectWithoutAuthorInput[]
    createMany?: auth_userCreateManyAuthorInputEnvelope
    connect?: auth_userWhereUniqueInput | auth_userWhereUniqueInput[]
  }

  export type bookUncheckedCreateNestedManyWithoutAuthorInput = {
    create?: XOR<bookCreateWithoutAuthorInput, bookUncheckedCreateWithoutAuthorInput> | bookCreateWithoutAuthorInput[] | bookUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: bookCreateOrConnectWithoutAuthorInput | bookCreateOrConnectWithoutAuthorInput[]
    createMany?: bookCreateManyAuthorInputEnvelope
    connect?: bookWhereUniqueInput | bookWhereUniqueInput[]
  }

  export type productUncheckedCreateNestedManyWithoutAuthorInput = {
    create?: XOR<productCreateWithoutAuthorInput, productUncheckedCreateWithoutAuthorInput> | productCreateWithoutAuthorInput[] | productUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: productCreateOrConnectWithoutAuthorInput | productCreateOrConnectWithoutAuthorInput[]
    createMany?: productCreateManyAuthorInputEnvelope
    connect?: productWhereUniqueInput | productWhereUniqueInput[]
  }

  export type publisher_authorUncheckedCreateNestedManyWithoutAuthorInput = {
    create?: XOR<publisher_authorCreateWithoutAuthorInput, publisher_authorUncheckedCreateWithoutAuthorInput> | publisher_authorCreateWithoutAuthorInput[] | publisher_authorUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: publisher_authorCreateOrConnectWithoutAuthorInput | publisher_authorCreateOrConnectWithoutAuthorInput[]
    createMany?: publisher_authorCreateManyAuthorInputEnvelope
    connect?: publisher_authorWhereUniqueInput | publisher_authorWhereUniqueInput[]
  }

  export type auth_userUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<auth_userCreateWithoutAuthorInput, auth_userUncheckedCreateWithoutAuthorInput> | auth_userCreateWithoutAuthorInput[] | auth_userUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: auth_userCreateOrConnectWithoutAuthorInput | auth_userCreateOrConnectWithoutAuthorInput[]
    upsert?: auth_userUpsertWithWhereUniqueWithoutAuthorInput | auth_userUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: auth_userCreateManyAuthorInputEnvelope
    set?: auth_userWhereUniqueInput | auth_userWhereUniqueInput[]
    disconnect?: auth_userWhereUniqueInput | auth_userWhereUniqueInput[]
    delete?: auth_userWhereUniqueInput | auth_userWhereUniqueInput[]
    connect?: auth_userWhereUniqueInput | auth_userWhereUniqueInput[]
    update?: auth_userUpdateWithWhereUniqueWithoutAuthorInput | auth_userUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: auth_userUpdateManyWithWhereWithoutAuthorInput | auth_userUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: auth_userScalarWhereInput | auth_userScalarWhereInput[]
  }

  export type auth_accountUpdateOneWithoutAuthorNestedInput = {
    create?: XOR<auth_accountCreateWithoutAuthorInput, auth_accountUncheckedCreateWithoutAuthorInput>
    connectOrCreate?: auth_accountCreateOrConnectWithoutAuthorInput
    upsert?: auth_accountUpsertWithoutAuthorInput
    disconnect?: auth_accountWhereInput | boolean
    delete?: auth_accountWhereInput | boolean
    connect?: auth_accountWhereUniqueInput
    update?: XOR<XOR<auth_accountUpdateToOneWithWhereWithoutAuthorInput, auth_accountUpdateWithoutAuthorInput>, auth_accountUncheckedUpdateWithoutAuthorInput>
  }

  export type bookUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<bookCreateWithoutAuthorInput, bookUncheckedCreateWithoutAuthorInput> | bookCreateWithoutAuthorInput[] | bookUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: bookCreateOrConnectWithoutAuthorInput | bookCreateOrConnectWithoutAuthorInput[]
    upsert?: bookUpsertWithWhereUniqueWithoutAuthorInput | bookUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: bookCreateManyAuthorInputEnvelope
    set?: bookWhereUniqueInput | bookWhereUniqueInput[]
    disconnect?: bookWhereUniqueInput | bookWhereUniqueInput[]
    delete?: bookWhereUniqueInput | bookWhereUniqueInput[]
    connect?: bookWhereUniqueInput | bookWhereUniqueInput[]
    update?: bookUpdateWithWhereUniqueWithoutAuthorInput | bookUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: bookUpdateManyWithWhereWithoutAuthorInput | bookUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: bookScalarWhereInput | bookScalarWhereInput[]
  }

  export type productUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<productCreateWithoutAuthorInput, productUncheckedCreateWithoutAuthorInput> | productCreateWithoutAuthorInput[] | productUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: productCreateOrConnectWithoutAuthorInput | productCreateOrConnectWithoutAuthorInput[]
    upsert?: productUpsertWithWhereUniqueWithoutAuthorInput | productUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: productCreateManyAuthorInputEnvelope
    set?: productWhereUniqueInput | productWhereUniqueInput[]
    disconnect?: productWhereUniqueInput | productWhereUniqueInput[]
    delete?: productWhereUniqueInput | productWhereUniqueInput[]
    connect?: productWhereUniqueInput | productWhereUniqueInput[]
    update?: productUpdateWithWhereUniqueWithoutAuthorInput | productUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: productUpdateManyWithWhereWithoutAuthorInput | productUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: productScalarWhereInput | productScalarWhereInput[]
  }

  export type publisher_authorUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<publisher_authorCreateWithoutAuthorInput, publisher_authorUncheckedCreateWithoutAuthorInput> | publisher_authorCreateWithoutAuthorInput[] | publisher_authorUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: publisher_authorCreateOrConnectWithoutAuthorInput | publisher_authorCreateOrConnectWithoutAuthorInput[]
    upsert?: publisher_authorUpsertWithWhereUniqueWithoutAuthorInput | publisher_authorUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: publisher_authorCreateManyAuthorInputEnvelope
    set?: publisher_authorWhereUniqueInput | publisher_authorWhereUniqueInput[]
    disconnect?: publisher_authorWhereUniqueInput | publisher_authorWhereUniqueInput[]
    delete?: publisher_authorWhereUniqueInput | publisher_authorWhereUniqueInput[]
    connect?: publisher_authorWhereUniqueInput | publisher_authorWhereUniqueInput[]
    update?: publisher_authorUpdateWithWhereUniqueWithoutAuthorInput | publisher_authorUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: publisher_authorUpdateManyWithWhereWithoutAuthorInput | publisher_authorUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: publisher_authorScalarWhereInput | publisher_authorScalarWhereInput[]
  }

  export type auth_userUncheckedUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<auth_userCreateWithoutAuthorInput, auth_userUncheckedCreateWithoutAuthorInput> | auth_userCreateWithoutAuthorInput[] | auth_userUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: auth_userCreateOrConnectWithoutAuthorInput | auth_userCreateOrConnectWithoutAuthorInput[]
    upsert?: auth_userUpsertWithWhereUniqueWithoutAuthorInput | auth_userUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: auth_userCreateManyAuthorInputEnvelope
    set?: auth_userWhereUniqueInput | auth_userWhereUniqueInput[]
    disconnect?: auth_userWhereUniqueInput | auth_userWhereUniqueInput[]
    delete?: auth_userWhereUniqueInput | auth_userWhereUniqueInput[]
    connect?: auth_userWhereUniqueInput | auth_userWhereUniqueInput[]
    update?: auth_userUpdateWithWhereUniqueWithoutAuthorInput | auth_userUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: auth_userUpdateManyWithWhereWithoutAuthorInput | auth_userUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: auth_userScalarWhereInput | auth_userScalarWhereInput[]
  }

  export type bookUncheckedUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<bookCreateWithoutAuthorInput, bookUncheckedCreateWithoutAuthorInput> | bookCreateWithoutAuthorInput[] | bookUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: bookCreateOrConnectWithoutAuthorInput | bookCreateOrConnectWithoutAuthorInput[]
    upsert?: bookUpsertWithWhereUniqueWithoutAuthorInput | bookUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: bookCreateManyAuthorInputEnvelope
    set?: bookWhereUniqueInput | bookWhereUniqueInput[]
    disconnect?: bookWhereUniqueInput | bookWhereUniqueInput[]
    delete?: bookWhereUniqueInput | bookWhereUniqueInput[]
    connect?: bookWhereUniqueInput | bookWhereUniqueInput[]
    update?: bookUpdateWithWhereUniqueWithoutAuthorInput | bookUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: bookUpdateManyWithWhereWithoutAuthorInput | bookUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: bookScalarWhereInput | bookScalarWhereInput[]
  }

  export type productUncheckedUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<productCreateWithoutAuthorInput, productUncheckedCreateWithoutAuthorInput> | productCreateWithoutAuthorInput[] | productUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: productCreateOrConnectWithoutAuthorInput | productCreateOrConnectWithoutAuthorInput[]
    upsert?: productUpsertWithWhereUniqueWithoutAuthorInput | productUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: productCreateManyAuthorInputEnvelope
    set?: productWhereUniqueInput | productWhereUniqueInput[]
    disconnect?: productWhereUniqueInput | productWhereUniqueInput[]
    delete?: productWhereUniqueInput | productWhereUniqueInput[]
    connect?: productWhereUniqueInput | productWhereUniqueInput[]
    update?: productUpdateWithWhereUniqueWithoutAuthorInput | productUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: productUpdateManyWithWhereWithoutAuthorInput | productUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: productScalarWhereInput | productScalarWhereInput[]
  }

  export type publisher_authorUncheckedUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<publisher_authorCreateWithoutAuthorInput, publisher_authorUncheckedCreateWithoutAuthorInput> | publisher_authorCreateWithoutAuthorInput[] | publisher_authorUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: publisher_authorCreateOrConnectWithoutAuthorInput | publisher_authorCreateOrConnectWithoutAuthorInput[]
    upsert?: publisher_authorUpsertWithWhereUniqueWithoutAuthorInput | publisher_authorUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: publisher_authorCreateManyAuthorInputEnvelope
    set?: publisher_authorWhereUniqueInput | publisher_authorWhereUniqueInput[]
    disconnect?: publisher_authorWhereUniqueInput | publisher_authorWhereUniqueInput[]
    delete?: publisher_authorWhereUniqueInput | publisher_authorWhereUniqueInput[]
    connect?: publisher_authorWhereUniqueInput | publisher_authorWhereUniqueInput[]
    update?: publisher_authorUpdateWithWhereUniqueWithoutAuthorInput | publisher_authorUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: publisher_authorUpdateManyWithWhereWithoutAuthorInput | publisher_authorUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: publisher_authorScalarWhereInput | publisher_authorScalarWhereInput[]
  }

  export type authorCreateNestedOneWithoutBookInput = {
    create?: XOR<authorCreateWithoutBookInput, authorUncheckedCreateWithoutBookInput>
    connectOrCreate?: authorCreateOrConnectWithoutBookInput
    connect?: authorWhereUniqueInput
  }

  export type productCreateNestedOneWithoutBookInput = {
    create?: XOR<productCreateWithoutBookInput, productUncheckedCreateWithoutBookInput>
    connectOrCreate?: productCreateOrConnectWithoutBookInput
    connect?: productWhereUniqueInput
  }

  export type book_approvalCreateNestedManyWithoutBookInput = {
    create?: XOR<book_approvalCreateWithoutBookInput, book_approvalUncheckedCreateWithoutBookInput> | book_approvalCreateWithoutBookInput[] | book_approvalUncheckedCreateWithoutBookInput[]
    connectOrCreate?: book_approvalCreateOrConnectWithoutBookInput | book_approvalCreateOrConnectWithoutBookInput[]
    createMany?: book_approvalCreateManyBookInputEnvelope
    connect?: book_approvalWhereUniqueInput | book_approvalWhereUniqueInput[]
  }

  export type book_changes_logCreateNestedManyWithoutBookInput = {
    create?: XOR<book_changes_logCreateWithoutBookInput, book_changes_logUncheckedCreateWithoutBookInput> | book_changes_logCreateWithoutBookInput[] | book_changes_logUncheckedCreateWithoutBookInput[]
    connectOrCreate?: book_changes_logCreateOrConnectWithoutBookInput | book_changes_logCreateOrConnectWithoutBookInput[]
    createMany?: book_changes_logCreateManyBookInputEnvelope
    connect?: book_changes_logWhereUniqueInput | book_changes_logWhereUniqueInput[]
  }

  export type book_genreCreateNestedManyWithoutBookInput = {
    create?: XOR<book_genreCreateWithoutBookInput, book_genreUncheckedCreateWithoutBookInput> | book_genreCreateWithoutBookInput[] | book_genreUncheckedCreateWithoutBookInput[]
    connectOrCreate?: book_genreCreateOrConnectWithoutBookInput | book_genreCreateOrConnectWithoutBookInput[]
    createMany?: book_genreCreateManyBookInputEnvelope
    connect?: book_genreWhereUniqueInput | book_genreWhereUniqueInput[]
  }

  export type book_tagsCreateNestedManyWithoutBookInput = {
    create?: XOR<book_tagsCreateWithoutBookInput, book_tagsUncheckedCreateWithoutBookInput> | book_tagsCreateWithoutBookInput[] | book_tagsUncheckedCreateWithoutBookInput[]
    connectOrCreate?: book_tagsCreateOrConnectWithoutBookInput | book_tagsCreateOrConnectWithoutBookInput[]
    createMany?: book_tagsCreateManyBookInputEnvelope
    connect?: book_tagsWhereUniqueInput | book_tagsWhereUniqueInput[]
  }

  export type chapterCreateNestedManyWithoutBookInput = {
    create?: XOR<chapterCreateWithoutBookInput, chapterUncheckedCreateWithoutBookInput> | chapterCreateWithoutBookInput[] | chapterUncheckedCreateWithoutBookInput[]
    connectOrCreate?: chapterCreateOrConnectWithoutBookInput | chapterCreateOrConnectWithoutBookInput[]
    createMany?: chapterCreateManyBookInputEnvelope
    connect?: chapterWhereUniqueInput | chapterWhereUniqueInput[]
  }

  export type rankingCreateNestedManyWithoutBookInput = {
    create?: XOR<rankingCreateWithoutBookInput, rankingUncheckedCreateWithoutBookInput> | rankingCreateWithoutBookInput[] | rankingUncheckedCreateWithoutBookInput[]
    connectOrCreate?: rankingCreateOrConnectWithoutBookInput | rankingCreateOrConnectWithoutBookInput[]
    createMany?: rankingCreateManyBookInputEnvelope
    connect?: rankingWhereUniqueInput | rankingWhereUniqueInput[]
  }

  export type reviewsCreateNestedManyWithoutBookInput = {
    create?: XOR<reviewsCreateWithoutBookInput, reviewsUncheckedCreateWithoutBookInput> | reviewsCreateWithoutBookInput[] | reviewsUncheckedCreateWithoutBookInput[]
    connectOrCreate?: reviewsCreateOrConnectWithoutBookInput | reviewsCreateOrConnectWithoutBookInput[]
    createMany?: reviewsCreateManyBookInputEnvelope
    connect?: reviewsWhereUniqueInput | reviewsWhereUniqueInput[]
  }

  export type book_approvalUncheckedCreateNestedManyWithoutBookInput = {
    create?: XOR<book_approvalCreateWithoutBookInput, book_approvalUncheckedCreateWithoutBookInput> | book_approvalCreateWithoutBookInput[] | book_approvalUncheckedCreateWithoutBookInput[]
    connectOrCreate?: book_approvalCreateOrConnectWithoutBookInput | book_approvalCreateOrConnectWithoutBookInput[]
    createMany?: book_approvalCreateManyBookInputEnvelope
    connect?: book_approvalWhereUniqueInput | book_approvalWhereUniqueInput[]
  }

  export type book_changes_logUncheckedCreateNestedManyWithoutBookInput = {
    create?: XOR<book_changes_logCreateWithoutBookInput, book_changes_logUncheckedCreateWithoutBookInput> | book_changes_logCreateWithoutBookInput[] | book_changes_logUncheckedCreateWithoutBookInput[]
    connectOrCreate?: book_changes_logCreateOrConnectWithoutBookInput | book_changes_logCreateOrConnectWithoutBookInput[]
    createMany?: book_changes_logCreateManyBookInputEnvelope
    connect?: book_changes_logWhereUniqueInput | book_changes_logWhereUniqueInput[]
  }

  export type book_genreUncheckedCreateNestedManyWithoutBookInput = {
    create?: XOR<book_genreCreateWithoutBookInput, book_genreUncheckedCreateWithoutBookInput> | book_genreCreateWithoutBookInput[] | book_genreUncheckedCreateWithoutBookInput[]
    connectOrCreate?: book_genreCreateOrConnectWithoutBookInput | book_genreCreateOrConnectWithoutBookInput[]
    createMany?: book_genreCreateManyBookInputEnvelope
    connect?: book_genreWhereUniqueInput | book_genreWhereUniqueInput[]
  }

  export type book_tagsUncheckedCreateNestedManyWithoutBookInput = {
    create?: XOR<book_tagsCreateWithoutBookInput, book_tagsUncheckedCreateWithoutBookInput> | book_tagsCreateWithoutBookInput[] | book_tagsUncheckedCreateWithoutBookInput[]
    connectOrCreate?: book_tagsCreateOrConnectWithoutBookInput | book_tagsCreateOrConnectWithoutBookInput[]
    createMany?: book_tagsCreateManyBookInputEnvelope
    connect?: book_tagsWhereUniqueInput | book_tagsWhereUniqueInput[]
  }

  export type chapterUncheckedCreateNestedManyWithoutBookInput = {
    create?: XOR<chapterCreateWithoutBookInput, chapterUncheckedCreateWithoutBookInput> | chapterCreateWithoutBookInput[] | chapterUncheckedCreateWithoutBookInput[]
    connectOrCreate?: chapterCreateOrConnectWithoutBookInput | chapterCreateOrConnectWithoutBookInput[]
    createMany?: chapterCreateManyBookInputEnvelope
    connect?: chapterWhereUniqueInput | chapterWhereUniqueInput[]
  }

  export type rankingUncheckedCreateNestedManyWithoutBookInput = {
    create?: XOR<rankingCreateWithoutBookInput, rankingUncheckedCreateWithoutBookInput> | rankingCreateWithoutBookInput[] | rankingUncheckedCreateWithoutBookInput[]
    connectOrCreate?: rankingCreateOrConnectWithoutBookInput | rankingCreateOrConnectWithoutBookInput[]
    createMany?: rankingCreateManyBookInputEnvelope
    connect?: rankingWhereUniqueInput | rankingWhereUniqueInput[]
  }

  export type reviewsUncheckedCreateNestedManyWithoutBookInput = {
    create?: XOR<reviewsCreateWithoutBookInput, reviewsUncheckedCreateWithoutBookInput> | reviewsCreateWithoutBookInput[] | reviewsUncheckedCreateWithoutBookInput[]
    connectOrCreate?: reviewsCreateOrConnectWithoutBookInput | reviewsCreateOrConnectWithoutBookInput[]
    createMany?: reviewsCreateManyBookInputEnvelope
    connect?: reviewsWhereUniqueInput | reviewsWhereUniqueInput[]
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type authorUpdateOneWithoutBookNestedInput = {
    create?: XOR<authorCreateWithoutBookInput, authorUncheckedCreateWithoutBookInput>
    connectOrCreate?: authorCreateOrConnectWithoutBookInput
    upsert?: authorUpsertWithoutBookInput
    disconnect?: authorWhereInput | boolean
    delete?: authorWhereInput | boolean
    connect?: authorWhereUniqueInput
    update?: XOR<XOR<authorUpdateToOneWithWhereWithoutBookInput, authorUpdateWithoutBookInput>, authorUncheckedUpdateWithoutBookInput>
  }

  export type productUpdateOneWithoutBookNestedInput = {
    create?: XOR<productCreateWithoutBookInput, productUncheckedCreateWithoutBookInput>
    connectOrCreate?: productCreateOrConnectWithoutBookInput
    upsert?: productUpsertWithoutBookInput
    disconnect?: productWhereInput | boolean
    delete?: productWhereInput | boolean
    connect?: productWhereUniqueInput
    update?: XOR<XOR<productUpdateToOneWithWhereWithoutBookInput, productUpdateWithoutBookInput>, productUncheckedUpdateWithoutBookInput>
  }

  export type book_approvalUpdateManyWithoutBookNestedInput = {
    create?: XOR<book_approvalCreateWithoutBookInput, book_approvalUncheckedCreateWithoutBookInput> | book_approvalCreateWithoutBookInput[] | book_approvalUncheckedCreateWithoutBookInput[]
    connectOrCreate?: book_approvalCreateOrConnectWithoutBookInput | book_approvalCreateOrConnectWithoutBookInput[]
    upsert?: book_approvalUpsertWithWhereUniqueWithoutBookInput | book_approvalUpsertWithWhereUniqueWithoutBookInput[]
    createMany?: book_approvalCreateManyBookInputEnvelope
    set?: book_approvalWhereUniqueInput | book_approvalWhereUniqueInput[]
    disconnect?: book_approvalWhereUniqueInput | book_approvalWhereUniqueInput[]
    delete?: book_approvalWhereUniqueInput | book_approvalWhereUniqueInput[]
    connect?: book_approvalWhereUniqueInput | book_approvalWhereUniqueInput[]
    update?: book_approvalUpdateWithWhereUniqueWithoutBookInput | book_approvalUpdateWithWhereUniqueWithoutBookInput[]
    updateMany?: book_approvalUpdateManyWithWhereWithoutBookInput | book_approvalUpdateManyWithWhereWithoutBookInput[]
    deleteMany?: book_approvalScalarWhereInput | book_approvalScalarWhereInput[]
  }

  export type book_changes_logUpdateManyWithoutBookNestedInput = {
    create?: XOR<book_changes_logCreateWithoutBookInput, book_changes_logUncheckedCreateWithoutBookInput> | book_changes_logCreateWithoutBookInput[] | book_changes_logUncheckedCreateWithoutBookInput[]
    connectOrCreate?: book_changes_logCreateOrConnectWithoutBookInput | book_changes_logCreateOrConnectWithoutBookInput[]
    upsert?: book_changes_logUpsertWithWhereUniqueWithoutBookInput | book_changes_logUpsertWithWhereUniqueWithoutBookInput[]
    createMany?: book_changes_logCreateManyBookInputEnvelope
    set?: book_changes_logWhereUniqueInput | book_changes_logWhereUniqueInput[]
    disconnect?: book_changes_logWhereUniqueInput | book_changes_logWhereUniqueInput[]
    delete?: book_changes_logWhereUniqueInput | book_changes_logWhereUniqueInput[]
    connect?: book_changes_logWhereUniqueInput | book_changes_logWhereUniqueInput[]
    update?: book_changes_logUpdateWithWhereUniqueWithoutBookInput | book_changes_logUpdateWithWhereUniqueWithoutBookInput[]
    updateMany?: book_changes_logUpdateManyWithWhereWithoutBookInput | book_changes_logUpdateManyWithWhereWithoutBookInput[]
    deleteMany?: book_changes_logScalarWhereInput | book_changes_logScalarWhereInput[]
  }

  export type book_genreUpdateManyWithoutBookNestedInput = {
    create?: XOR<book_genreCreateWithoutBookInput, book_genreUncheckedCreateWithoutBookInput> | book_genreCreateWithoutBookInput[] | book_genreUncheckedCreateWithoutBookInput[]
    connectOrCreate?: book_genreCreateOrConnectWithoutBookInput | book_genreCreateOrConnectWithoutBookInput[]
    upsert?: book_genreUpsertWithWhereUniqueWithoutBookInput | book_genreUpsertWithWhereUniqueWithoutBookInput[]
    createMany?: book_genreCreateManyBookInputEnvelope
    set?: book_genreWhereUniqueInput | book_genreWhereUniqueInput[]
    disconnect?: book_genreWhereUniqueInput | book_genreWhereUniqueInput[]
    delete?: book_genreWhereUniqueInput | book_genreWhereUniqueInput[]
    connect?: book_genreWhereUniqueInput | book_genreWhereUniqueInput[]
    update?: book_genreUpdateWithWhereUniqueWithoutBookInput | book_genreUpdateWithWhereUniqueWithoutBookInput[]
    updateMany?: book_genreUpdateManyWithWhereWithoutBookInput | book_genreUpdateManyWithWhereWithoutBookInput[]
    deleteMany?: book_genreScalarWhereInput | book_genreScalarWhereInput[]
  }

  export type book_tagsUpdateManyWithoutBookNestedInput = {
    create?: XOR<book_tagsCreateWithoutBookInput, book_tagsUncheckedCreateWithoutBookInput> | book_tagsCreateWithoutBookInput[] | book_tagsUncheckedCreateWithoutBookInput[]
    connectOrCreate?: book_tagsCreateOrConnectWithoutBookInput | book_tagsCreateOrConnectWithoutBookInput[]
    upsert?: book_tagsUpsertWithWhereUniqueWithoutBookInput | book_tagsUpsertWithWhereUniqueWithoutBookInput[]
    createMany?: book_tagsCreateManyBookInputEnvelope
    set?: book_tagsWhereUniqueInput | book_tagsWhereUniqueInput[]
    disconnect?: book_tagsWhereUniqueInput | book_tagsWhereUniqueInput[]
    delete?: book_tagsWhereUniqueInput | book_tagsWhereUniqueInput[]
    connect?: book_tagsWhereUniqueInput | book_tagsWhereUniqueInput[]
    update?: book_tagsUpdateWithWhereUniqueWithoutBookInput | book_tagsUpdateWithWhereUniqueWithoutBookInput[]
    updateMany?: book_tagsUpdateManyWithWhereWithoutBookInput | book_tagsUpdateManyWithWhereWithoutBookInput[]
    deleteMany?: book_tagsScalarWhereInput | book_tagsScalarWhereInput[]
  }

  export type chapterUpdateManyWithoutBookNestedInput = {
    create?: XOR<chapterCreateWithoutBookInput, chapterUncheckedCreateWithoutBookInput> | chapterCreateWithoutBookInput[] | chapterUncheckedCreateWithoutBookInput[]
    connectOrCreate?: chapterCreateOrConnectWithoutBookInput | chapterCreateOrConnectWithoutBookInput[]
    upsert?: chapterUpsertWithWhereUniqueWithoutBookInput | chapterUpsertWithWhereUniqueWithoutBookInput[]
    createMany?: chapterCreateManyBookInputEnvelope
    set?: chapterWhereUniqueInput | chapterWhereUniqueInput[]
    disconnect?: chapterWhereUniqueInput | chapterWhereUniqueInput[]
    delete?: chapterWhereUniqueInput | chapterWhereUniqueInput[]
    connect?: chapterWhereUniqueInput | chapterWhereUniqueInput[]
    update?: chapterUpdateWithWhereUniqueWithoutBookInput | chapterUpdateWithWhereUniqueWithoutBookInput[]
    updateMany?: chapterUpdateManyWithWhereWithoutBookInput | chapterUpdateManyWithWhereWithoutBookInput[]
    deleteMany?: chapterScalarWhereInput | chapterScalarWhereInput[]
  }

  export type rankingUpdateManyWithoutBookNestedInput = {
    create?: XOR<rankingCreateWithoutBookInput, rankingUncheckedCreateWithoutBookInput> | rankingCreateWithoutBookInput[] | rankingUncheckedCreateWithoutBookInput[]
    connectOrCreate?: rankingCreateOrConnectWithoutBookInput | rankingCreateOrConnectWithoutBookInput[]
    upsert?: rankingUpsertWithWhereUniqueWithoutBookInput | rankingUpsertWithWhereUniqueWithoutBookInput[]
    createMany?: rankingCreateManyBookInputEnvelope
    set?: rankingWhereUniqueInput | rankingWhereUniqueInput[]
    disconnect?: rankingWhereUniqueInput | rankingWhereUniqueInput[]
    delete?: rankingWhereUniqueInput | rankingWhereUniqueInput[]
    connect?: rankingWhereUniqueInput | rankingWhereUniqueInput[]
    update?: rankingUpdateWithWhereUniqueWithoutBookInput | rankingUpdateWithWhereUniqueWithoutBookInput[]
    updateMany?: rankingUpdateManyWithWhereWithoutBookInput | rankingUpdateManyWithWhereWithoutBookInput[]
    deleteMany?: rankingScalarWhereInput | rankingScalarWhereInput[]
  }

  export type reviewsUpdateManyWithoutBookNestedInput = {
    create?: XOR<reviewsCreateWithoutBookInput, reviewsUncheckedCreateWithoutBookInput> | reviewsCreateWithoutBookInput[] | reviewsUncheckedCreateWithoutBookInput[]
    connectOrCreate?: reviewsCreateOrConnectWithoutBookInput | reviewsCreateOrConnectWithoutBookInput[]
    upsert?: reviewsUpsertWithWhereUniqueWithoutBookInput | reviewsUpsertWithWhereUniqueWithoutBookInput[]
    createMany?: reviewsCreateManyBookInputEnvelope
    set?: reviewsWhereUniqueInput | reviewsWhereUniqueInput[]
    disconnect?: reviewsWhereUniqueInput | reviewsWhereUniqueInput[]
    delete?: reviewsWhereUniqueInput | reviewsWhereUniqueInput[]
    connect?: reviewsWhereUniqueInput | reviewsWhereUniqueInput[]
    update?: reviewsUpdateWithWhereUniqueWithoutBookInput | reviewsUpdateWithWhereUniqueWithoutBookInput[]
    updateMany?: reviewsUpdateManyWithWhereWithoutBookInput | reviewsUpdateManyWithWhereWithoutBookInput[]
    deleteMany?: reviewsScalarWhereInput | reviewsScalarWhereInput[]
  }

  export type book_approvalUncheckedUpdateManyWithoutBookNestedInput = {
    create?: XOR<book_approvalCreateWithoutBookInput, book_approvalUncheckedCreateWithoutBookInput> | book_approvalCreateWithoutBookInput[] | book_approvalUncheckedCreateWithoutBookInput[]
    connectOrCreate?: book_approvalCreateOrConnectWithoutBookInput | book_approvalCreateOrConnectWithoutBookInput[]
    upsert?: book_approvalUpsertWithWhereUniqueWithoutBookInput | book_approvalUpsertWithWhereUniqueWithoutBookInput[]
    createMany?: book_approvalCreateManyBookInputEnvelope
    set?: book_approvalWhereUniqueInput | book_approvalWhereUniqueInput[]
    disconnect?: book_approvalWhereUniqueInput | book_approvalWhereUniqueInput[]
    delete?: book_approvalWhereUniqueInput | book_approvalWhereUniqueInput[]
    connect?: book_approvalWhereUniqueInput | book_approvalWhereUniqueInput[]
    update?: book_approvalUpdateWithWhereUniqueWithoutBookInput | book_approvalUpdateWithWhereUniqueWithoutBookInput[]
    updateMany?: book_approvalUpdateManyWithWhereWithoutBookInput | book_approvalUpdateManyWithWhereWithoutBookInput[]
    deleteMany?: book_approvalScalarWhereInput | book_approvalScalarWhereInput[]
  }

  export type book_changes_logUncheckedUpdateManyWithoutBookNestedInput = {
    create?: XOR<book_changes_logCreateWithoutBookInput, book_changes_logUncheckedCreateWithoutBookInput> | book_changes_logCreateWithoutBookInput[] | book_changes_logUncheckedCreateWithoutBookInput[]
    connectOrCreate?: book_changes_logCreateOrConnectWithoutBookInput | book_changes_logCreateOrConnectWithoutBookInput[]
    upsert?: book_changes_logUpsertWithWhereUniqueWithoutBookInput | book_changes_logUpsertWithWhereUniqueWithoutBookInput[]
    createMany?: book_changes_logCreateManyBookInputEnvelope
    set?: book_changes_logWhereUniqueInput | book_changes_logWhereUniqueInput[]
    disconnect?: book_changes_logWhereUniqueInput | book_changes_logWhereUniqueInput[]
    delete?: book_changes_logWhereUniqueInput | book_changes_logWhereUniqueInput[]
    connect?: book_changes_logWhereUniqueInput | book_changes_logWhereUniqueInput[]
    update?: book_changes_logUpdateWithWhereUniqueWithoutBookInput | book_changes_logUpdateWithWhereUniqueWithoutBookInput[]
    updateMany?: book_changes_logUpdateManyWithWhereWithoutBookInput | book_changes_logUpdateManyWithWhereWithoutBookInput[]
    deleteMany?: book_changes_logScalarWhereInput | book_changes_logScalarWhereInput[]
  }

  export type book_genreUncheckedUpdateManyWithoutBookNestedInput = {
    create?: XOR<book_genreCreateWithoutBookInput, book_genreUncheckedCreateWithoutBookInput> | book_genreCreateWithoutBookInput[] | book_genreUncheckedCreateWithoutBookInput[]
    connectOrCreate?: book_genreCreateOrConnectWithoutBookInput | book_genreCreateOrConnectWithoutBookInput[]
    upsert?: book_genreUpsertWithWhereUniqueWithoutBookInput | book_genreUpsertWithWhereUniqueWithoutBookInput[]
    createMany?: book_genreCreateManyBookInputEnvelope
    set?: book_genreWhereUniqueInput | book_genreWhereUniqueInput[]
    disconnect?: book_genreWhereUniqueInput | book_genreWhereUniqueInput[]
    delete?: book_genreWhereUniqueInput | book_genreWhereUniqueInput[]
    connect?: book_genreWhereUniqueInput | book_genreWhereUniqueInput[]
    update?: book_genreUpdateWithWhereUniqueWithoutBookInput | book_genreUpdateWithWhereUniqueWithoutBookInput[]
    updateMany?: book_genreUpdateManyWithWhereWithoutBookInput | book_genreUpdateManyWithWhereWithoutBookInput[]
    deleteMany?: book_genreScalarWhereInput | book_genreScalarWhereInput[]
  }

  export type book_tagsUncheckedUpdateManyWithoutBookNestedInput = {
    create?: XOR<book_tagsCreateWithoutBookInput, book_tagsUncheckedCreateWithoutBookInput> | book_tagsCreateWithoutBookInput[] | book_tagsUncheckedCreateWithoutBookInput[]
    connectOrCreate?: book_tagsCreateOrConnectWithoutBookInput | book_tagsCreateOrConnectWithoutBookInput[]
    upsert?: book_tagsUpsertWithWhereUniqueWithoutBookInput | book_tagsUpsertWithWhereUniqueWithoutBookInput[]
    createMany?: book_tagsCreateManyBookInputEnvelope
    set?: book_tagsWhereUniqueInput | book_tagsWhereUniqueInput[]
    disconnect?: book_tagsWhereUniqueInput | book_tagsWhereUniqueInput[]
    delete?: book_tagsWhereUniqueInput | book_tagsWhereUniqueInput[]
    connect?: book_tagsWhereUniqueInput | book_tagsWhereUniqueInput[]
    update?: book_tagsUpdateWithWhereUniqueWithoutBookInput | book_tagsUpdateWithWhereUniqueWithoutBookInput[]
    updateMany?: book_tagsUpdateManyWithWhereWithoutBookInput | book_tagsUpdateManyWithWhereWithoutBookInput[]
    deleteMany?: book_tagsScalarWhereInput | book_tagsScalarWhereInput[]
  }

  export type chapterUncheckedUpdateManyWithoutBookNestedInput = {
    create?: XOR<chapterCreateWithoutBookInput, chapterUncheckedCreateWithoutBookInput> | chapterCreateWithoutBookInput[] | chapterUncheckedCreateWithoutBookInput[]
    connectOrCreate?: chapterCreateOrConnectWithoutBookInput | chapterCreateOrConnectWithoutBookInput[]
    upsert?: chapterUpsertWithWhereUniqueWithoutBookInput | chapterUpsertWithWhereUniqueWithoutBookInput[]
    createMany?: chapterCreateManyBookInputEnvelope
    set?: chapterWhereUniqueInput | chapterWhereUniqueInput[]
    disconnect?: chapterWhereUniqueInput | chapterWhereUniqueInput[]
    delete?: chapterWhereUniqueInput | chapterWhereUniqueInput[]
    connect?: chapterWhereUniqueInput | chapterWhereUniqueInput[]
    update?: chapterUpdateWithWhereUniqueWithoutBookInput | chapterUpdateWithWhereUniqueWithoutBookInput[]
    updateMany?: chapterUpdateManyWithWhereWithoutBookInput | chapterUpdateManyWithWhereWithoutBookInput[]
    deleteMany?: chapterScalarWhereInput | chapterScalarWhereInput[]
  }

  export type rankingUncheckedUpdateManyWithoutBookNestedInput = {
    create?: XOR<rankingCreateWithoutBookInput, rankingUncheckedCreateWithoutBookInput> | rankingCreateWithoutBookInput[] | rankingUncheckedCreateWithoutBookInput[]
    connectOrCreate?: rankingCreateOrConnectWithoutBookInput | rankingCreateOrConnectWithoutBookInput[]
    upsert?: rankingUpsertWithWhereUniqueWithoutBookInput | rankingUpsertWithWhereUniqueWithoutBookInput[]
    createMany?: rankingCreateManyBookInputEnvelope
    set?: rankingWhereUniqueInput | rankingWhereUniqueInput[]
    disconnect?: rankingWhereUniqueInput | rankingWhereUniqueInput[]
    delete?: rankingWhereUniqueInput | rankingWhereUniqueInput[]
    connect?: rankingWhereUniqueInput | rankingWhereUniqueInput[]
    update?: rankingUpdateWithWhereUniqueWithoutBookInput | rankingUpdateWithWhereUniqueWithoutBookInput[]
    updateMany?: rankingUpdateManyWithWhereWithoutBookInput | rankingUpdateManyWithWhereWithoutBookInput[]
    deleteMany?: rankingScalarWhereInput | rankingScalarWhereInput[]
  }

  export type reviewsUncheckedUpdateManyWithoutBookNestedInput = {
    create?: XOR<reviewsCreateWithoutBookInput, reviewsUncheckedCreateWithoutBookInput> | reviewsCreateWithoutBookInput[] | reviewsUncheckedCreateWithoutBookInput[]
    connectOrCreate?: reviewsCreateOrConnectWithoutBookInput | reviewsCreateOrConnectWithoutBookInput[]
    upsert?: reviewsUpsertWithWhereUniqueWithoutBookInput | reviewsUpsertWithWhereUniqueWithoutBookInput[]
    createMany?: reviewsCreateManyBookInputEnvelope
    set?: reviewsWhereUniqueInput | reviewsWhereUniqueInput[]
    disconnect?: reviewsWhereUniqueInput | reviewsWhereUniqueInput[]
    delete?: reviewsWhereUniqueInput | reviewsWhereUniqueInput[]
    connect?: reviewsWhereUniqueInput | reviewsWhereUniqueInput[]
    update?: reviewsUpdateWithWhereUniqueWithoutBookInput | reviewsUpdateWithWhereUniqueWithoutBookInput[]
    updateMany?: reviewsUpdateManyWithWhereWithoutBookInput | reviewsUpdateManyWithWhereWithoutBookInput[]
    deleteMany?: reviewsScalarWhereInput | reviewsScalarWhereInput[]
  }

  export type bookCreateNestedOneWithoutBook_approvalInput = {
    create?: XOR<bookCreateWithoutBook_approvalInput, bookUncheckedCreateWithoutBook_approvalInput>
    connectOrCreate?: bookCreateOrConnectWithoutBook_approvalInput
    connect?: bookWhereUniqueInput
  }

  export type internalCreateNestedOneWithoutBook_approvalInput = {
    create?: XOR<internalCreateWithoutBook_approvalInput, internalUncheckedCreateWithoutBook_approvalInput>
    connectOrCreate?: internalCreateOrConnectWithoutBook_approvalInput
    connect?: internalWhereUniqueInput
  }

  export type bookUpdateOneRequiredWithoutBook_approvalNestedInput = {
    create?: XOR<bookCreateWithoutBook_approvalInput, bookUncheckedCreateWithoutBook_approvalInput>
    connectOrCreate?: bookCreateOrConnectWithoutBook_approvalInput
    upsert?: bookUpsertWithoutBook_approvalInput
    connect?: bookWhereUniqueInput
    update?: XOR<XOR<bookUpdateToOneWithWhereWithoutBook_approvalInput, bookUpdateWithoutBook_approvalInput>, bookUncheckedUpdateWithoutBook_approvalInput>
  }

  export type internalUpdateOneWithoutBook_approvalNestedInput = {
    create?: XOR<internalCreateWithoutBook_approvalInput, internalUncheckedCreateWithoutBook_approvalInput>
    connectOrCreate?: internalCreateOrConnectWithoutBook_approvalInput
    upsert?: internalUpsertWithoutBook_approvalInput
    disconnect?: internalWhereInput | boolean
    delete?: internalWhereInput | boolean
    connect?: internalWhereUniqueInput
    update?: XOR<XOR<internalUpdateToOneWithWhereWithoutBook_approvalInput, internalUpdateWithoutBook_approvalInput>, internalUncheckedUpdateWithoutBook_approvalInput>
  }

  export type bookCreateNestedOneWithoutBook_changes_logInput = {
    create?: XOR<bookCreateWithoutBook_changes_logInput, bookUncheckedCreateWithoutBook_changes_logInput>
    connectOrCreate?: bookCreateOrConnectWithoutBook_changes_logInput
    connect?: bookWhereUniqueInput
  }

  export type bookUpdateOneRequiredWithoutBook_changes_logNestedInput = {
    create?: XOR<bookCreateWithoutBook_changes_logInput, bookUncheckedCreateWithoutBook_changes_logInput>
    connectOrCreate?: bookCreateOrConnectWithoutBook_changes_logInput
    upsert?: bookUpsertWithoutBook_changes_logInput
    connect?: bookWhereUniqueInput
    update?: XOR<XOR<bookUpdateToOneWithWhereWithoutBook_changes_logInput, bookUpdateWithoutBook_changes_logInput>, bookUncheckedUpdateWithoutBook_changes_logInput>
  }

  export type bookCreateNestedOneWithoutBook_genreInput = {
    create?: XOR<bookCreateWithoutBook_genreInput, bookUncheckedCreateWithoutBook_genreInput>
    connectOrCreate?: bookCreateOrConnectWithoutBook_genreInput
    connect?: bookWhereUniqueInput
  }

  export type genreCreateNestedOneWithoutBook_genreInput = {
    create?: XOR<genreCreateWithoutBook_genreInput, genreUncheckedCreateWithoutBook_genreInput>
    connectOrCreate?: genreCreateOrConnectWithoutBook_genreInput
    connect?: genreWhereUniqueInput
  }

  export type bookUpdateOneRequiredWithoutBook_genreNestedInput = {
    create?: XOR<bookCreateWithoutBook_genreInput, bookUncheckedCreateWithoutBook_genreInput>
    connectOrCreate?: bookCreateOrConnectWithoutBook_genreInput
    upsert?: bookUpsertWithoutBook_genreInput
    connect?: bookWhereUniqueInput
    update?: XOR<XOR<bookUpdateToOneWithWhereWithoutBook_genreInput, bookUpdateWithoutBook_genreInput>, bookUncheckedUpdateWithoutBook_genreInput>
  }

  export type genreUpdateOneRequiredWithoutBook_genreNestedInput = {
    create?: XOR<genreCreateWithoutBook_genreInput, genreUncheckedCreateWithoutBook_genreInput>
    connectOrCreate?: genreCreateOrConnectWithoutBook_genreInput
    upsert?: genreUpsertWithoutBook_genreInput
    connect?: genreWhereUniqueInput
    update?: XOR<XOR<genreUpdateToOneWithWhereWithoutBook_genreInput, genreUpdateWithoutBook_genreInput>, genreUncheckedUpdateWithoutBook_genreInput>
  }

  export type bookCreateNestedOneWithoutBook_tagsInput = {
    create?: XOR<bookCreateWithoutBook_tagsInput, bookUncheckedCreateWithoutBook_tagsInput>
    connectOrCreate?: bookCreateOrConnectWithoutBook_tagsInput
    connect?: bookWhereUniqueInput
  }

  export type tagsCreateNestedOneWithoutBook_tagsInput = {
    create?: XOR<tagsCreateWithoutBook_tagsInput, tagsUncheckedCreateWithoutBook_tagsInput>
    connectOrCreate?: tagsCreateOrConnectWithoutBook_tagsInput
    connect?: tagsWhereUniqueInput
  }

  export type bookUpdateOneRequiredWithoutBook_tagsNestedInput = {
    create?: XOR<bookCreateWithoutBook_tagsInput, bookUncheckedCreateWithoutBook_tagsInput>
    connectOrCreate?: bookCreateOrConnectWithoutBook_tagsInput
    upsert?: bookUpsertWithoutBook_tagsInput
    connect?: bookWhereUniqueInput
    update?: XOR<XOR<bookUpdateToOneWithWhereWithoutBook_tagsInput, bookUpdateWithoutBook_tagsInput>, bookUncheckedUpdateWithoutBook_tagsInput>
  }

  export type tagsUpdateOneRequiredWithoutBook_tagsNestedInput = {
    create?: XOR<tagsCreateWithoutBook_tagsInput, tagsUncheckedCreateWithoutBook_tagsInput>
    connectOrCreate?: tagsCreateOrConnectWithoutBook_tagsInput
    upsert?: tagsUpsertWithoutBook_tagsInput
    connect?: tagsWhereUniqueInput
    update?: XOR<XOR<tagsUpdateToOneWithWhereWithoutBook_tagsInput, tagsUpdateWithoutBook_tagsInput>, tagsUncheckedUpdateWithoutBook_tagsInput>
  }

  export type bundle_categoryCreateNestedManyWithoutBundleInput = {
    create?: XOR<bundle_categoryCreateWithoutBundleInput, bundle_categoryUncheckedCreateWithoutBundleInput> | bundle_categoryCreateWithoutBundleInput[] | bundle_categoryUncheckedCreateWithoutBundleInput[]
    connectOrCreate?: bundle_categoryCreateOrConnectWithoutBundleInput | bundle_categoryCreateOrConnectWithoutBundleInput[]
    createMany?: bundle_categoryCreateManyBundleInputEnvelope
    connect?: bundle_categoryWhereUniqueInput | bundle_categoryWhereUniqueInput[]
  }

  export type bundle_productCreateNestedManyWithoutBundleInput = {
    create?: XOR<bundle_productCreateWithoutBundleInput, bundle_productUncheckedCreateWithoutBundleInput> | bundle_productCreateWithoutBundleInput[] | bundle_productUncheckedCreateWithoutBundleInput[]
    connectOrCreate?: bundle_productCreateOrConnectWithoutBundleInput | bundle_productCreateOrConnectWithoutBundleInput[]
    createMany?: bundle_productCreateManyBundleInputEnvelope
    connect?: bundle_productWhereUniqueInput | bundle_productWhereUniqueInput[]
  }

  export type t_sales_lineCreateNestedManyWithoutBundleInput = {
    create?: XOR<t_sales_lineCreateWithoutBundleInput, t_sales_lineUncheckedCreateWithoutBundleInput> | t_sales_lineCreateWithoutBundleInput[] | t_sales_lineUncheckedCreateWithoutBundleInput[]
    connectOrCreate?: t_sales_lineCreateOrConnectWithoutBundleInput | t_sales_lineCreateOrConnectWithoutBundleInput[]
    createMany?: t_sales_lineCreateManyBundleInputEnvelope
    connect?: t_sales_lineWhereUniqueInput | t_sales_lineWhereUniqueInput[]
  }

  export type bundle_categoryUncheckedCreateNestedManyWithoutBundleInput = {
    create?: XOR<bundle_categoryCreateWithoutBundleInput, bundle_categoryUncheckedCreateWithoutBundleInput> | bundle_categoryCreateWithoutBundleInput[] | bundle_categoryUncheckedCreateWithoutBundleInput[]
    connectOrCreate?: bundle_categoryCreateOrConnectWithoutBundleInput | bundle_categoryCreateOrConnectWithoutBundleInput[]
    createMany?: bundle_categoryCreateManyBundleInputEnvelope
    connect?: bundle_categoryWhereUniqueInput | bundle_categoryWhereUniqueInput[]
  }

  export type bundle_productUncheckedCreateNestedManyWithoutBundleInput = {
    create?: XOR<bundle_productCreateWithoutBundleInput, bundle_productUncheckedCreateWithoutBundleInput> | bundle_productCreateWithoutBundleInput[] | bundle_productUncheckedCreateWithoutBundleInput[]
    connectOrCreate?: bundle_productCreateOrConnectWithoutBundleInput | bundle_productCreateOrConnectWithoutBundleInput[]
    createMany?: bundle_productCreateManyBundleInputEnvelope
    connect?: bundle_productWhereUniqueInput | bundle_productWhereUniqueInput[]
  }

  export type t_sales_lineUncheckedCreateNestedManyWithoutBundleInput = {
    create?: XOR<t_sales_lineCreateWithoutBundleInput, t_sales_lineUncheckedCreateWithoutBundleInput> | t_sales_lineCreateWithoutBundleInput[] | t_sales_lineUncheckedCreateWithoutBundleInput[]
    connectOrCreate?: t_sales_lineCreateOrConnectWithoutBundleInput | t_sales_lineCreateOrConnectWithoutBundleInput[]
    createMany?: t_sales_lineCreateManyBundleInputEnvelope
    connect?: t_sales_lineWhereUniqueInput | t_sales_lineWhereUniqueInput[]
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type bundle_categoryUpdateManyWithoutBundleNestedInput = {
    create?: XOR<bundle_categoryCreateWithoutBundleInput, bundle_categoryUncheckedCreateWithoutBundleInput> | bundle_categoryCreateWithoutBundleInput[] | bundle_categoryUncheckedCreateWithoutBundleInput[]
    connectOrCreate?: bundle_categoryCreateOrConnectWithoutBundleInput | bundle_categoryCreateOrConnectWithoutBundleInput[]
    upsert?: bundle_categoryUpsertWithWhereUniqueWithoutBundleInput | bundle_categoryUpsertWithWhereUniqueWithoutBundleInput[]
    createMany?: bundle_categoryCreateManyBundleInputEnvelope
    set?: bundle_categoryWhereUniqueInput | bundle_categoryWhereUniqueInput[]
    disconnect?: bundle_categoryWhereUniqueInput | bundle_categoryWhereUniqueInput[]
    delete?: bundle_categoryWhereUniqueInput | bundle_categoryWhereUniqueInput[]
    connect?: bundle_categoryWhereUniqueInput | bundle_categoryWhereUniqueInput[]
    update?: bundle_categoryUpdateWithWhereUniqueWithoutBundleInput | bundle_categoryUpdateWithWhereUniqueWithoutBundleInput[]
    updateMany?: bundle_categoryUpdateManyWithWhereWithoutBundleInput | bundle_categoryUpdateManyWithWhereWithoutBundleInput[]
    deleteMany?: bundle_categoryScalarWhereInput | bundle_categoryScalarWhereInput[]
  }

  export type bundle_productUpdateManyWithoutBundleNestedInput = {
    create?: XOR<bundle_productCreateWithoutBundleInput, bundle_productUncheckedCreateWithoutBundleInput> | bundle_productCreateWithoutBundleInput[] | bundle_productUncheckedCreateWithoutBundleInput[]
    connectOrCreate?: bundle_productCreateOrConnectWithoutBundleInput | bundle_productCreateOrConnectWithoutBundleInput[]
    upsert?: bundle_productUpsertWithWhereUniqueWithoutBundleInput | bundle_productUpsertWithWhereUniqueWithoutBundleInput[]
    createMany?: bundle_productCreateManyBundleInputEnvelope
    set?: bundle_productWhereUniqueInput | bundle_productWhereUniqueInput[]
    disconnect?: bundle_productWhereUniqueInput | bundle_productWhereUniqueInput[]
    delete?: bundle_productWhereUniqueInput | bundle_productWhereUniqueInput[]
    connect?: bundle_productWhereUniqueInput | bundle_productWhereUniqueInput[]
    update?: bundle_productUpdateWithWhereUniqueWithoutBundleInput | bundle_productUpdateWithWhereUniqueWithoutBundleInput[]
    updateMany?: bundle_productUpdateManyWithWhereWithoutBundleInput | bundle_productUpdateManyWithWhereWithoutBundleInput[]
    deleteMany?: bundle_productScalarWhereInput | bundle_productScalarWhereInput[]
  }

  export type t_sales_lineUpdateManyWithoutBundleNestedInput = {
    create?: XOR<t_sales_lineCreateWithoutBundleInput, t_sales_lineUncheckedCreateWithoutBundleInput> | t_sales_lineCreateWithoutBundleInput[] | t_sales_lineUncheckedCreateWithoutBundleInput[]
    connectOrCreate?: t_sales_lineCreateOrConnectWithoutBundleInput | t_sales_lineCreateOrConnectWithoutBundleInput[]
    upsert?: t_sales_lineUpsertWithWhereUniqueWithoutBundleInput | t_sales_lineUpsertWithWhereUniqueWithoutBundleInput[]
    createMany?: t_sales_lineCreateManyBundleInputEnvelope
    set?: t_sales_lineWhereUniqueInput | t_sales_lineWhereUniqueInput[]
    disconnect?: t_sales_lineWhereUniqueInput | t_sales_lineWhereUniqueInput[]
    delete?: t_sales_lineWhereUniqueInput | t_sales_lineWhereUniqueInput[]
    connect?: t_sales_lineWhereUniqueInput | t_sales_lineWhereUniqueInput[]
    update?: t_sales_lineUpdateWithWhereUniqueWithoutBundleInput | t_sales_lineUpdateWithWhereUniqueWithoutBundleInput[]
    updateMany?: t_sales_lineUpdateManyWithWhereWithoutBundleInput | t_sales_lineUpdateManyWithWhereWithoutBundleInput[]
    deleteMany?: t_sales_lineScalarWhereInput | t_sales_lineScalarWhereInput[]
  }

  export type bundle_categoryUncheckedUpdateManyWithoutBundleNestedInput = {
    create?: XOR<bundle_categoryCreateWithoutBundleInput, bundle_categoryUncheckedCreateWithoutBundleInput> | bundle_categoryCreateWithoutBundleInput[] | bundle_categoryUncheckedCreateWithoutBundleInput[]
    connectOrCreate?: bundle_categoryCreateOrConnectWithoutBundleInput | bundle_categoryCreateOrConnectWithoutBundleInput[]
    upsert?: bundle_categoryUpsertWithWhereUniqueWithoutBundleInput | bundle_categoryUpsertWithWhereUniqueWithoutBundleInput[]
    createMany?: bundle_categoryCreateManyBundleInputEnvelope
    set?: bundle_categoryWhereUniqueInput | bundle_categoryWhereUniqueInput[]
    disconnect?: bundle_categoryWhereUniqueInput | bundle_categoryWhereUniqueInput[]
    delete?: bundle_categoryWhereUniqueInput | bundle_categoryWhereUniqueInput[]
    connect?: bundle_categoryWhereUniqueInput | bundle_categoryWhereUniqueInput[]
    update?: bundle_categoryUpdateWithWhereUniqueWithoutBundleInput | bundle_categoryUpdateWithWhereUniqueWithoutBundleInput[]
    updateMany?: bundle_categoryUpdateManyWithWhereWithoutBundleInput | bundle_categoryUpdateManyWithWhereWithoutBundleInput[]
    deleteMany?: bundle_categoryScalarWhereInput | bundle_categoryScalarWhereInput[]
  }

  export type bundle_productUncheckedUpdateManyWithoutBundleNestedInput = {
    create?: XOR<bundle_productCreateWithoutBundleInput, bundle_productUncheckedCreateWithoutBundleInput> | bundle_productCreateWithoutBundleInput[] | bundle_productUncheckedCreateWithoutBundleInput[]
    connectOrCreate?: bundle_productCreateOrConnectWithoutBundleInput | bundle_productCreateOrConnectWithoutBundleInput[]
    upsert?: bundle_productUpsertWithWhereUniqueWithoutBundleInput | bundle_productUpsertWithWhereUniqueWithoutBundleInput[]
    createMany?: bundle_productCreateManyBundleInputEnvelope
    set?: bundle_productWhereUniqueInput | bundle_productWhereUniqueInput[]
    disconnect?: bundle_productWhereUniqueInput | bundle_productWhereUniqueInput[]
    delete?: bundle_productWhereUniqueInput | bundle_productWhereUniqueInput[]
    connect?: bundle_productWhereUniqueInput | bundle_productWhereUniqueInput[]
    update?: bundle_productUpdateWithWhereUniqueWithoutBundleInput | bundle_productUpdateWithWhereUniqueWithoutBundleInput[]
    updateMany?: bundle_productUpdateManyWithWhereWithoutBundleInput | bundle_productUpdateManyWithWhereWithoutBundleInput[]
    deleteMany?: bundle_productScalarWhereInput | bundle_productScalarWhereInput[]
  }

  export type t_sales_lineUncheckedUpdateManyWithoutBundleNestedInput = {
    create?: XOR<t_sales_lineCreateWithoutBundleInput, t_sales_lineUncheckedCreateWithoutBundleInput> | t_sales_lineCreateWithoutBundleInput[] | t_sales_lineUncheckedCreateWithoutBundleInput[]
    connectOrCreate?: t_sales_lineCreateOrConnectWithoutBundleInput | t_sales_lineCreateOrConnectWithoutBundleInput[]
    upsert?: t_sales_lineUpsertWithWhereUniqueWithoutBundleInput | t_sales_lineUpsertWithWhereUniqueWithoutBundleInput[]
    createMany?: t_sales_lineCreateManyBundleInputEnvelope
    set?: t_sales_lineWhereUniqueInput | t_sales_lineWhereUniqueInput[]
    disconnect?: t_sales_lineWhereUniqueInput | t_sales_lineWhereUniqueInput[]
    delete?: t_sales_lineWhereUniqueInput | t_sales_lineWhereUniqueInput[]
    connect?: t_sales_lineWhereUniqueInput | t_sales_lineWhereUniqueInput[]
    update?: t_sales_lineUpdateWithWhereUniqueWithoutBundleInput | t_sales_lineUpdateWithWhereUniqueWithoutBundleInput[]
    updateMany?: t_sales_lineUpdateManyWithWhereWithoutBundleInput | t_sales_lineUpdateManyWithWhereWithoutBundleInput[]
    deleteMany?: t_sales_lineScalarWhereInput | t_sales_lineScalarWhereInput[]
  }

  export type bundleCreateNestedOneWithoutBundle_categoryInput = {
    create?: XOR<bundleCreateWithoutBundle_categoryInput, bundleUncheckedCreateWithoutBundle_categoryInput>
    connectOrCreate?: bundleCreateOrConnectWithoutBundle_categoryInput
    connect?: bundleWhereUniqueInput
  }

  export type categoryCreateNestedOneWithoutBundle_categoryInput = {
    create?: XOR<categoryCreateWithoutBundle_categoryInput, categoryUncheckedCreateWithoutBundle_categoryInput>
    connectOrCreate?: categoryCreateOrConnectWithoutBundle_categoryInput
    connect?: categoryWhereUniqueInput
  }

  export type bundleUpdateOneRequiredWithoutBundle_categoryNestedInput = {
    create?: XOR<bundleCreateWithoutBundle_categoryInput, bundleUncheckedCreateWithoutBundle_categoryInput>
    connectOrCreate?: bundleCreateOrConnectWithoutBundle_categoryInput
    upsert?: bundleUpsertWithoutBundle_categoryInput
    connect?: bundleWhereUniqueInput
    update?: XOR<XOR<bundleUpdateToOneWithWhereWithoutBundle_categoryInput, bundleUpdateWithoutBundle_categoryInput>, bundleUncheckedUpdateWithoutBundle_categoryInput>
  }

  export type categoryUpdateOneRequiredWithoutBundle_categoryNestedInput = {
    create?: XOR<categoryCreateWithoutBundle_categoryInput, categoryUncheckedCreateWithoutBundle_categoryInput>
    connectOrCreate?: categoryCreateOrConnectWithoutBundle_categoryInput
    upsert?: categoryUpsertWithoutBundle_categoryInput
    connect?: categoryWhereUniqueInput
    update?: XOR<XOR<categoryUpdateToOneWithWhereWithoutBundle_categoryInput, categoryUpdateWithoutBundle_categoryInput>, categoryUncheckedUpdateWithoutBundle_categoryInput>
  }

  export type bundleCreateNestedOneWithoutBundle_productInput = {
    create?: XOR<bundleCreateWithoutBundle_productInput, bundleUncheckedCreateWithoutBundle_productInput>
    connectOrCreate?: bundleCreateOrConnectWithoutBundle_productInput
    connect?: bundleWhereUniqueInput
  }

  export type productCreateNestedOneWithoutBundle_productInput = {
    create?: XOR<productCreateWithoutBundle_productInput, productUncheckedCreateWithoutBundle_productInput>
    connectOrCreate?: productCreateOrConnectWithoutBundle_productInput
    connect?: productWhereUniqueInput
  }

  export type bundleUpdateOneRequiredWithoutBundle_productNestedInput = {
    create?: XOR<bundleCreateWithoutBundle_productInput, bundleUncheckedCreateWithoutBundle_productInput>
    connectOrCreate?: bundleCreateOrConnectWithoutBundle_productInput
    upsert?: bundleUpsertWithoutBundle_productInput
    connect?: bundleWhereUniqueInput
    update?: XOR<XOR<bundleUpdateToOneWithWhereWithoutBundle_productInput, bundleUpdateWithoutBundle_productInput>, bundleUncheckedUpdateWithoutBundle_productInput>
  }

  export type productUpdateOneRequiredWithoutBundle_productNestedInput = {
    create?: XOR<productCreateWithoutBundle_productInput, productUncheckedCreateWithoutBundle_productInput>
    connectOrCreate?: productCreateOrConnectWithoutBundle_productInput
    upsert?: productUpsertWithoutBundle_productInput
    connect?: productWhereUniqueInput
    update?: XOR<XOR<productUpdateToOneWithWhereWithoutBundle_productInput, productUpdateWithoutBundle_productInput>, productUncheckedUpdateWithoutBundle_productInput>
  }

  export type bundle_categoryCreateNestedManyWithoutCategoryInput = {
    create?: XOR<bundle_categoryCreateWithoutCategoryInput, bundle_categoryUncheckedCreateWithoutCategoryInput> | bundle_categoryCreateWithoutCategoryInput[] | bundle_categoryUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: bundle_categoryCreateOrConnectWithoutCategoryInput | bundle_categoryCreateOrConnectWithoutCategoryInput[]
    createMany?: bundle_categoryCreateManyCategoryInputEnvelope
    connect?: bundle_categoryWhereUniqueInput | bundle_categoryWhereUniqueInput[]
  }

  export type categoryCreateNestedOneWithoutOther_categoryInput = {
    create?: XOR<categoryCreateWithoutOther_categoryInput, categoryUncheckedCreateWithoutOther_categoryInput>
    connectOrCreate?: categoryCreateOrConnectWithoutOther_categoryInput
    connect?: categoryWhereUniqueInput
  }

  export type categoryCreateNestedManyWithoutCategoryInput = {
    create?: XOR<categoryCreateWithoutCategoryInput, categoryUncheckedCreateWithoutCategoryInput> | categoryCreateWithoutCategoryInput[] | categoryUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: categoryCreateOrConnectWithoutCategoryInput | categoryCreateOrConnectWithoutCategoryInput[]
    createMany?: categoryCreateManyCategoryInputEnvelope
    connect?: categoryWhereUniqueInput | categoryWhereUniqueInput[]
  }

  export type product_categoryCreateNestedManyWithoutCategoryInput = {
    create?: XOR<product_categoryCreateWithoutCategoryInput, product_categoryUncheckedCreateWithoutCategoryInput> | product_categoryCreateWithoutCategoryInput[] | product_categoryUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: product_categoryCreateOrConnectWithoutCategoryInput | product_categoryCreateOrConnectWithoutCategoryInput[]
    createMany?: product_categoryCreateManyCategoryInputEnvelope
    connect?: product_categoryWhereUniqueInput | product_categoryWhereUniqueInput[]
  }

  export type bundle_categoryUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<bundle_categoryCreateWithoutCategoryInput, bundle_categoryUncheckedCreateWithoutCategoryInput> | bundle_categoryCreateWithoutCategoryInput[] | bundle_categoryUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: bundle_categoryCreateOrConnectWithoutCategoryInput | bundle_categoryCreateOrConnectWithoutCategoryInput[]
    createMany?: bundle_categoryCreateManyCategoryInputEnvelope
    connect?: bundle_categoryWhereUniqueInput | bundle_categoryWhereUniqueInput[]
  }

  export type categoryUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<categoryCreateWithoutCategoryInput, categoryUncheckedCreateWithoutCategoryInput> | categoryCreateWithoutCategoryInput[] | categoryUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: categoryCreateOrConnectWithoutCategoryInput | categoryCreateOrConnectWithoutCategoryInput[]
    createMany?: categoryCreateManyCategoryInputEnvelope
    connect?: categoryWhereUniqueInput | categoryWhereUniqueInput[]
  }

  export type product_categoryUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<product_categoryCreateWithoutCategoryInput, product_categoryUncheckedCreateWithoutCategoryInput> | product_categoryCreateWithoutCategoryInput[] | product_categoryUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: product_categoryCreateOrConnectWithoutCategoryInput | product_categoryCreateOrConnectWithoutCategoryInput[]
    createMany?: product_categoryCreateManyCategoryInputEnvelope
    connect?: product_categoryWhereUniqueInput | product_categoryWhereUniqueInput[]
  }

  export type bundle_categoryUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<bundle_categoryCreateWithoutCategoryInput, bundle_categoryUncheckedCreateWithoutCategoryInput> | bundle_categoryCreateWithoutCategoryInput[] | bundle_categoryUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: bundle_categoryCreateOrConnectWithoutCategoryInput | bundle_categoryCreateOrConnectWithoutCategoryInput[]
    upsert?: bundle_categoryUpsertWithWhereUniqueWithoutCategoryInput | bundle_categoryUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: bundle_categoryCreateManyCategoryInputEnvelope
    set?: bundle_categoryWhereUniqueInput | bundle_categoryWhereUniqueInput[]
    disconnect?: bundle_categoryWhereUniqueInput | bundle_categoryWhereUniqueInput[]
    delete?: bundle_categoryWhereUniqueInput | bundle_categoryWhereUniqueInput[]
    connect?: bundle_categoryWhereUniqueInput | bundle_categoryWhereUniqueInput[]
    update?: bundle_categoryUpdateWithWhereUniqueWithoutCategoryInput | bundle_categoryUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: bundle_categoryUpdateManyWithWhereWithoutCategoryInput | bundle_categoryUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: bundle_categoryScalarWhereInput | bundle_categoryScalarWhereInput[]
  }

  export type categoryUpdateOneWithoutOther_categoryNestedInput = {
    create?: XOR<categoryCreateWithoutOther_categoryInput, categoryUncheckedCreateWithoutOther_categoryInput>
    connectOrCreate?: categoryCreateOrConnectWithoutOther_categoryInput
    upsert?: categoryUpsertWithoutOther_categoryInput
    disconnect?: categoryWhereInput | boolean
    delete?: categoryWhereInput | boolean
    connect?: categoryWhereUniqueInput
    update?: XOR<XOR<categoryUpdateToOneWithWhereWithoutOther_categoryInput, categoryUpdateWithoutOther_categoryInput>, categoryUncheckedUpdateWithoutOther_categoryInput>
  }

  export type categoryUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<categoryCreateWithoutCategoryInput, categoryUncheckedCreateWithoutCategoryInput> | categoryCreateWithoutCategoryInput[] | categoryUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: categoryCreateOrConnectWithoutCategoryInput | categoryCreateOrConnectWithoutCategoryInput[]
    upsert?: categoryUpsertWithWhereUniqueWithoutCategoryInput | categoryUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: categoryCreateManyCategoryInputEnvelope
    set?: categoryWhereUniqueInput | categoryWhereUniqueInput[]
    disconnect?: categoryWhereUniqueInput | categoryWhereUniqueInput[]
    delete?: categoryWhereUniqueInput | categoryWhereUniqueInput[]
    connect?: categoryWhereUniqueInput | categoryWhereUniqueInput[]
    update?: categoryUpdateWithWhereUniqueWithoutCategoryInput | categoryUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: categoryUpdateManyWithWhereWithoutCategoryInput | categoryUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: categoryScalarWhereInput | categoryScalarWhereInput[]
  }

  export type product_categoryUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<product_categoryCreateWithoutCategoryInput, product_categoryUncheckedCreateWithoutCategoryInput> | product_categoryCreateWithoutCategoryInput[] | product_categoryUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: product_categoryCreateOrConnectWithoutCategoryInput | product_categoryCreateOrConnectWithoutCategoryInput[]
    upsert?: product_categoryUpsertWithWhereUniqueWithoutCategoryInput | product_categoryUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: product_categoryCreateManyCategoryInputEnvelope
    set?: product_categoryWhereUniqueInput | product_categoryWhereUniqueInput[]
    disconnect?: product_categoryWhereUniqueInput | product_categoryWhereUniqueInput[]
    delete?: product_categoryWhereUniqueInput | product_categoryWhereUniqueInput[]
    connect?: product_categoryWhereUniqueInput | product_categoryWhereUniqueInput[]
    update?: product_categoryUpdateWithWhereUniqueWithoutCategoryInput | product_categoryUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: product_categoryUpdateManyWithWhereWithoutCategoryInput | product_categoryUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: product_categoryScalarWhereInput | product_categoryScalarWhereInput[]
  }

  export type bundle_categoryUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<bundle_categoryCreateWithoutCategoryInput, bundle_categoryUncheckedCreateWithoutCategoryInput> | bundle_categoryCreateWithoutCategoryInput[] | bundle_categoryUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: bundle_categoryCreateOrConnectWithoutCategoryInput | bundle_categoryCreateOrConnectWithoutCategoryInput[]
    upsert?: bundle_categoryUpsertWithWhereUniqueWithoutCategoryInput | bundle_categoryUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: bundle_categoryCreateManyCategoryInputEnvelope
    set?: bundle_categoryWhereUniqueInput | bundle_categoryWhereUniqueInput[]
    disconnect?: bundle_categoryWhereUniqueInput | bundle_categoryWhereUniqueInput[]
    delete?: bundle_categoryWhereUniqueInput | bundle_categoryWhereUniqueInput[]
    connect?: bundle_categoryWhereUniqueInput | bundle_categoryWhereUniqueInput[]
    update?: bundle_categoryUpdateWithWhereUniqueWithoutCategoryInput | bundle_categoryUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: bundle_categoryUpdateManyWithWhereWithoutCategoryInput | bundle_categoryUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: bundle_categoryScalarWhereInput | bundle_categoryScalarWhereInput[]
  }

  export type categoryUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<categoryCreateWithoutCategoryInput, categoryUncheckedCreateWithoutCategoryInput> | categoryCreateWithoutCategoryInput[] | categoryUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: categoryCreateOrConnectWithoutCategoryInput | categoryCreateOrConnectWithoutCategoryInput[]
    upsert?: categoryUpsertWithWhereUniqueWithoutCategoryInput | categoryUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: categoryCreateManyCategoryInputEnvelope
    set?: categoryWhereUniqueInput | categoryWhereUniqueInput[]
    disconnect?: categoryWhereUniqueInput | categoryWhereUniqueInput[]
    delete?: categoryWhereUniqueInput | categoryWhereUniqueInput[]
    connect?: categoryWhereUniqueInput | categoryWhereUniqueInput[]
    update?: categoryUpdateWithWhereUniqueWithoutCategoryInput | categoryUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: categoryUpdateManyWithWhereWithoutCategoryInput | categoryUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: categoryScalarWhereInput | categoryScalarWhereInput[]
  }

  export type product_categoryUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<product_categoryCreateWithoutCategoryInput, product_categoryUncheckedCreateWithoutCategoryInput> | product_categoryCreateWithoutCategoryInput[] | product_categoryUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: product_categoryCreateOrConnectWithoutCategoryInput | product_categoryCreateOrConnectWithoutCategoryInput[]
    upsert?: product_categoryUpsertWithWhereUniqueWithoutCategoryInput | product_categoryUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: product_categoryCreateManyCategoryInputEnvelope
    set?: product_categoryWhereUniqueInput | product_categoryWhereUniqueInput[]
    disconnect?: product_categoryWhereUniqueInput | product_categoryWhereUniqueInput[]
    delete?: product_categoryWhereUniqueInput | product_categoryWhereUniqueInput[]
    connect?: product_categoryWhereUniqueInput | product_categoryWhereUniqueInput[]
    update?: product_categoryUpdateWithWhereUniqueWithoutCategoryInput | product_categoryUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: product_categoryUpdateManyWithWhereWithoutCategoryInput | product_categoryUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: product_categoryScalarWhereInput | product_categoryScalarWhereInput[]
  }

  export type bookCreateNestedOneWithoutChapterInput = {
    create?: XOR<bookCreateWithoutChapterInput, bookUncheckedCreateWithoutChapterInput>
    connectOrCreate?: bookCreateOrConnectWithoutChapterInput
    connect?: bookWhereUniqueInput
  }

  export type productCreateNestedOneWithoutChapterInput = {
    create?: XOR<productCreateWithoutChapterInput, productUncheckedCreateWithoutChapterInput>
    connectOrCreate?: productCreateOrConnectWithoutChapterInput
    connect?: productWhereUniqueInput
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type bookUpdateOneWithoutChapterNestedInput = {
    create?: XOR<bookCreateWithoutChapterInput, bookUncheckedCreateWithoutChapterInput>
    connectOrCreate?: bookCreateOrConnectWithoutChapterInput
    upsert?: bookUpsertWithoutChapterInput
    disconnect?: bookWhereInput | boolean
    delete?: bookWhereInput | boolean
    connect?: bookWhereUniqueInput
    update?: XOR<XOR<bookUpdateToOneWithWhereWithoutChapterInput, bookUpdateWithoutChapterInput>, bookUncheckedUpdateWithoutChapterInput>
  }

  export type productUpdateOneWithoutChapterNestedInput = {
    create?: XOR<productCreateWithoutChapterInput, productUncheckedCreateWithoutChapterInput>
    connectOrCreate?: productCreateOrConnectWithoutChapterInput
    upsert?: productUpsertWithoutChapterInput
    disconnect?: productWhereInput | boolean
    delete?: productWhereInput | boolean
    connect?: productWhereUniqueInput
    update?: XOR<XOR<productUpdateToOneWithWhereWithoutChapterInput, productUpdateWithoutChapterInput>, productUncheckedUpdateWithoutChapterInput>
  }

  export type auth_userCreateNestedManyWithoutCustomerInput = {
    create?: XOR<auth_userCreateWithoutCustomerInput, auth_userUncheckedCreateWithoutCustomerInput> | auth_userCreateWithoutCustomerInput[] | auth_userUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: auth_userCreateOrConnectWithoutCustomerInput | auth_userCreateOrConnectWithoutCustomerInput[]
    createMany?: auth_userCreateManyCustomerInputEnvelope
    connect?: auth_userWhereUniqueInput | auth_userWhereUniqueInput[]
  }

  export type auth_accountCreateNestedOneWithoutCustomerInput = {
    create?: XOR<auth_accountCreateWithoutCustomerInput, auth_accountUncheckedCreateWithoutCustomerInput>
    connectOrCreate?: auth_accountCreateOrConnectWithoutCustomerInput
    connect?: auth_accountWhereUniqueInput
  }

  export type customer_readerCreateNestedManyWithoutCustomerInput = {
    create?: XOR<customer_readerCreateWithoutCustomerInput, customer_readerUncheckedCreateWithoutCustomerInput> | customer_readerCreateWithoutCustomerInput[] | customer_readerUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: customer_readerCreateOrConnectWithoutCustomerInput | customer_readerCreateOrConnectWithoutCustomerInput[]
    createMany?: customer_readerCreateManyCustomerInputEnvelope
    connect?: customer_readerWhereUniqueInput | customer_readerWhereUniqueInput[]
  }

  export type customer_trackCreateNestedManyWithoutCustomerInput = {
    create?: XOR<customer_trackCreateWithoutCustomerInput, customer_trackUncheckedCreateWithoutCustomerInput> | customer_trackCreateWithoutCustomerInput[] | customer_trackUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: customer_trackCreateOrConnectWithoutCustomerInput | customer_trackCreateOrConnectWithoutCustomerInput[]
    createMany?: customer_trackCreateManyCustomerInputEnvelope
    connect?: customer_trackWhereUniqueInput | customer_trackWhereUniqueInput[]
  }

  export type t_salesCreateNestedManyWithoutCustomerInput = {
    create?: XOR<t_salesCreateWithoutCustomerInput, t_salesUncheckedCreateWithoutCustomerInput> | t_salesCreateWithoutCustomerInput[] | t_salesUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: t_salesCreateOrConnectWithoutCustomerInput | t_salesCreateOrConnectWithoutCustomerInput[]
    createMany?: t_salesCreateManyCustomerInputEnvelope
    connect?: t_salesWhereUniqueInput | t_salesWhereUniqueInput[]
  }

  export type t_sales_downloadCreateNestedManyWithoutCustomerInput = {
    create?: XOR<t_sales_downloadCreateWithoutCustomerInput, t_sales_downloadUncheckedCreateWithoutCustomerInput> | t_sales_downloadCreateWithoutCustomerInput[] | t_sales_downloadUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: t_sales_downloadCreateOrConnectWithoutCustomerInput | t_sales_downloadCreateOrConnectWithoutCustomerInput[]
    createMany?: t_sales_downloadCreateManyCustomerInputEnvelope
    connect?: t_sales_downloadWhereUniqueInput | t_sales_downloadWhereUniqueInput[]
  }

  export type auth_userUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<auth_userCreateWithoutCustomerInput, auth_userUncheckedCreateWithoutCustomerInput> | auth_userCreateWithoutCustomerInput[] | auth_userUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: auth_userCreateOrConnectWithoutCustomerInput | auth_userCreateOrConnectWithoutCustomerInput[]
    createMany?: auth_userCreateManyCustomerInputEnvelope
    connect?: auth_userWhereUniqueInput | auth_userWhereUniqueInput[]
  }

  export type customer_readerUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<customer_readerCreateWithoutCustomerInput, customer_readerUncheckedCreateWithoutCustomerInput> | customer_readerCreateWithoutCustomerInput[] | customer_readerUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: customer_readerCreateOrConnectWithoutCustomerInput | customer_readerCreateOrConnectWithoutCustomerInput[]
    createMany?: customer_readerCreateManyCustomerInputEnvelope
    connect?: customer_readerWhereUniqueInput | customer_readerWhereUniqueInput[]
  }

  export type customer_trackUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<customer_trackCreateWithoutCustomerInput, customer_trackUncheckedCreateWithoutCustomerInput> | customer_trackCreateWithoutCustomerInput[] | customer_trackUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: customer_trackCreateOrConnectWithoutCustomerInput | customer_trackCreateOrConnectWithoutCustomerInput[]
    createMany?: customer_trackCreateManyCustomerInputEnvelope
    connect?: customer_trackWhereUniqueInput | customer_trackWhereUniqueInput[]
  }

  export type t_salesUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<t_salesCreateWithoutCustomerInput, t_salesUncheckedCreateWithoutCustomerInput> | t_salesCreateWithoutCustomerInput[] | t_salesUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: t_salesCreateOrConnectWithoutCustomerInput | t_salesCreateOrConnectWithoutCustomerInput[]
    createMany?: t_salesCreateManyCustomerInputEnvelope
    connect?: t_salesWhereUniqueInput | t_salesWhereUniqueInput[]
  }

  export type t_sales_downloadUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<t_sales_downloadCreateWithoutCustomerInput, t_sales_downloadUncheckedCreateWithoutCustomerInput> | t_sales_downloadCreateWithoutCustomerInput[] | t_sales_downloadUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: t_sales_downloadCreateOrConnectWithoutCustomerInput | t_sales_downloadCreateOrConnectWithoutCustomerInput[]
    createMany?: t_sales_downloadCreateManyCustomerInputEnvelope
    connect?: t_sales_downloadWhereUniqueInput | t_sales_downloadWhereUniqueInput[]
  }

  export type auth_userUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<auth_userCreateWithoutCustomerInput, auth_userUncheckedCreateWithoutCustomerInput> | auth_userCreateWithoutCustomerInput[] | auth_userUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: auth_userCreateOrConnectWithoutCustomerInput | auth_userCreateOrConnectWithoutCustomerInput[]
    upsert?: auth_userUpsertWithWhereUniqueWithoutCustomerInput | auth_userUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: auth_userCreateManyCustomerInputEnvelope
    set?: auth_userWhereUniqueInput | auth_userWhereUniqueInput[]
    disconnect?: auth_userWhereUniqueInput | auth_userWhereUniqueInput[]
    delete?: auth_userWhereUniqueInput | auth_userWhereUniqueInput[]
    connect?: auth_userWhereUniqueInput | auth_userWhereUniqueInput[]
    update?: auth_userUpdateWithWhereUniqueWithoutCustomerInput | auth_userUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: auth_userUpdateManyWithWhereWithoutCustomerInput | auth_userUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: auth_userScalarWhereInput | auth_userScalarWhereInput[]
  }

  export type auth_accountUpdateOneWithoutCustomerNestedInput = {
    create?: XOR<auth_accountCreateWithoutCustomerInput, auth_accountUncheckedCreateWithoutCustomerInput>
    connectOrCreate?: auth_accountCreateOrConnectWithoutCustomerInput
    upsert?: auth_accountUpsertWithoutCustomerInput
    disconnect?: auth_accountWhereInput | boolean
    delete?: auth_accountWhereInput | boolean
    connect?: auth_accountWhereUniqueInput
    update?: XOR<XOR<auth_accountUpdateToOneWithWhereWithoutCustomerInput, auth_accountUpdateWithoutCustomerInput>, auth_accountUncheckedUpdateWithoutCustomerInput>
  }

  export type customer_readerUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<customer_readerCreateWithoutCustomerInput, customer_readerUncheckedCreateWithoutCustomerInput> | customer_readerCreateWithoutCustomerInput[] | customer_readerUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: customer_readerCreateOrConnectWithoutCustomerInput | customer_readerCreateOrConnectWithoutCustomerInput[]
    upsert?: customer_readerUpsertWithWhereUniqueWithoutCustomerInput | customer_readerUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: customer_readerCreateManyCustomerInputEnvelope
    set?: customer_readerWhereUniqueInput | customer_readerWhereUniqueInput[]
    disconnect?: customer_readerWhereUniqueInput | customer_readerWhereUniqueInput[]
    delete?: customer_readerWhereUniqueInput | customer_readerWhereUniqueInput[]
    connect?: customer_readerWhereUniqueInput | customer_readerWhereUniqueInput[]
    update?: customer_readerUpdateWithWhereUniqueWithoutCustomerInput | customer_readerUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: customer_readerUpdateManyWithWhereWithoutCustomerInput | customer_readerUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: customer_readerScalarWhereInput | customer_readerScalarWhereInput[]
  }

  export type customer_trackUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<customer_trackCreateWithoutCustomerInput, customer_trackUncheckedCreateWithoutCustomerInput> | customer_trackCreateWithoutCustomerInput[] | customer_trackUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: customer_trackCreateOrConnectWithoutCustomerInput | customer_trackCreateOrConnectWithoutCustomerInput[]
    upsert?: customer_trackUpsertWithWhereUniqueWithoutCustomerInput | customer_trackUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: customer_trackCreateManyCustomerInputEnvelope
    set?: customer_trackWhereUniqueInput | customer_trackWhereUniqueInput[]
    disconnect?: customer_trackWhereUniqueInput | customer_trackWhereUniqueInput[]
    delete?: customer_trackWhereUniqueInput | customer_trackWhereUniqueInput[]
    connect?: customer_trackWhereUniqueInput | customer_trackWhereUniqueInput[]
    update?: customer_trackUpdateWithWhereUniqueWithoutCustomerInput | customer_trackUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: customer_trackUpdateManyWithWhereWithoutCustomerInput | customer_trackUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: customer_trackScalarWhereInput | customer_trackScalarWhereInput[]
  }

  export type t_salesUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<t_salesCreateWithoutCustomerInput, t_salesUncheckedCreateWithoutCustomerInput> | t_salesCreateWithoutCustomerInput[] | t_salesUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: t_salesCreateOrConnectWithoutCustomerInput | t_salesCreateOrConnectWithoutCustomerInput[]
    upsert?: t_salesUpsertWithWhereUniqueWithoutCustomerInput | t_salesUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: t_salesCreateManyCustomerInputEnvelope
    set?: t_salesWhereUniqueInput | t_salesWhereUniqueInput[]
    disconnect?: t_salesWhereUniqueInput | t_salesWhereUniqueInput[]
    delete?: t_salesWhereUniqueInput | t_salesWhereUniqueInput[]
    connect?: t_salesWhereUniqueInput | t_salesWhereUniqueInput[]
    update?: t_salesUpdateWithWhereUniqueWithoutCustomerInput | t_salesUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: t_salesUpdateManyWithWhereWithoutCustomerInput | t_salesUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: t_salesScalarWhereInput | t_salesScalarWhereInput[]
  }

  export type t_sales_downloadUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<t_sales_downloadCreateWithoutCustomerInput, t_sales_downloadUncheckedCreateWithoutCustomerInput> | t_sales_downloadCreateWithoutCustomerInput[] | t_sales_downloadUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: t_sales_downloadCreateOrConnectWithoutCustomerInput | t_sales_downloadCreateOrConnectWithoutCustomerInput[]
    upsert?: t_sales_downloadUpsertWithWhereUniqueWithoutCustomerInput | t_sales_downloadUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: t_sales_downloadCreateManyCustomerInputEnvelope
    set?: t_sales_downloadWhereUniqueInput | t_sales_downloadWhereUniqueInput[]
    disconnect?: t_sales_downloadWhereUniqueInput | t_sales_downloadWhereUniqueInput[]
    delete?: t_sales_downloadWhereUniqueInput | t_sales_downloadWhereUniqueInput[]
    connect?: t_sales_downloadWhereUniqueInput | t_sales_downloadWhereUniqueInput[]
    update?: t_sales_downloadUpdateWithWhereUniqueWithoutCustomerInput | t_sales_downloadUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: t_sales_downloadUpdateManyWithWhereWithoutCustomerInput | t_sales_downloadUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: t_sales_downloadScalarWhereInput | t_sales_downloadScalarWhereInput[]
  }

  export type auth_userUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<auth_userCreateWithoutCustomerInput, auth_userUncheckedCreateWithoutCustomerInput> | auth_userCreateWithoutCustomerInput[] | auth_userUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: auth_userCreateOrConnectWithoutCustomerInput | auth_userCreateOrConnectWithoutCustomerInput[]
    upsert?: auth_userUpsertWithWhereUniqueWithoutCustomerInput | auth_userUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: auth_userCreateManyCustomerInputEnvelope
    set?: auth_userWhereUniqueInput | auth_userWhereUniqueInput[]
    disconnect?: auth_userWhereUniqueInput | auth_userWhereUniqueInput[]
    delete?: auth_userWhereUniqueInput | auth_userWhereUniqueInput[]
    connect?: auth_userWhereUniqueInput | auth_userWhereUniqueInput[]
    update?: auth_userUpdateWithWhereUniqueWithoutCustomerInput | auth_userUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: auth_userUpdateManyWithWhereWithoutCustomerInput | auth_userUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: auth_userScalarWhereInput | auth_userScalarWhereInput[]
  }

  export type customer_readerUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<customer_readerCreateWithoutCustomerInput, customer_readerUncheckedCreateWithoutCustomerInput> | customer_readerCreateWithoutCustomerInput[] | customer_readerUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: customer_readerCreateOrConnectWithoutCustomerInput | customer_readerCreateOrConnectWithoutCustomerInput[]
    upsert?: customer_readerUpsertWithWhereUniqueWithoutCustomerInput | customer_readerUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: customer_readerCreateManyCustomerInputEnvelope
    set?: customer_readerWhereUniqueInput | customer_readerWhereUniqueInput[]
    disconnect?: customer_readerWhereUniqueInput | customer_readerWhereUniqueInput[]
    delete?: customer_readerWhereUniqueInput | customer_readerWhereUniqueInput[]
    connect?: customer_readerWhereUniqueInput | customer_readerWhereUniqueInput[]
    update?: customer_readerUpdateWithWhereUniqueWithoutCustomerInput | customer_readerUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: customer_readerUpdateManyWithWhereWithoutCustomerInput | customer_readerUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: customer_readerScalarWhereInput | customer_readerScalarWhereInput[]
  }

  export type customer_trackUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<customer_trackCreateWithoutCustomerInput, customer_trackUncheckedCreateWithoutCustomerInput> | customer_trackCreateWithoutCustomerInput[] | customer_trackUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: customer_trackCreateOrConnectWithoutCustomerInput | customer_trackCreateOrConnectWithoutCustomerInput[]
    upsert?: customer_trackUpsertWithWhereUniqueWithoutCustomerInput | customer_trackUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: customer_trackCreateManyCustomerInputEnvelope
    set?: customer_trackWhereUniqueInput | customer_trackWhereUniqueInput[]
    disconnect?: customer_trackWhereUniqueInput | customer_trackWhereUniqueInput[]
    delete?: customer_trackWhereUniqueInput | customer_trackWhereUniqueInput[]
    connect?: customer_trackWhereUniqueInput | customer_trackWhereUniqueInput[]
    update?: customer_trackUpdateWithWhereUniqueWithoutCustomerInput | customer_trackUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: customer_trackUpdateManyWithWhereWithoutCustomerInput | customer_trackUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: customer_trackScalarWhereInput | customer_trackScalarWhereInput[]
  }

  export type t_salesUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<t_salesCreateWithoutCustomerInput, t_salesUncheckedCreateWithoutCustomerInput> | t_salesCreateWithoutCustomerInput[] | t_salesUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: t_salesCreateOrConnectWithoutCustomerInput | t_salesCreateOrConnectWithoutCustomerInput[]
    upsert?: t_salesUpsertWithWhereUniqueWithoutCustomerInput | t_salesUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: t_salesCreateManyCustomerInputEnvelope
    set?: t_salesWhereUniqueInput | t_salesWhereUniqueInput[]
    disconnect?: t_salesWhereUniqueInput | t_salesWhereUniqueInput[]
    delete?: t_salesWhereUniqueInput | t_salesWhereUniqueInput[]
    connect?: t_salesWhereUniqueInput | t_salesWhereUniqueInput[]
    update?: t_salesUpdateWithWhereUniqueWithoutCustomerInput | t_salesUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: t_salesUpdateManyWithWhereWithoutCustomerInput | t_salesUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: t_salesScalarWhereInput | t_salesScalarWhereInput[]
  }

  export type t_sales_downloadUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<t_sales_downloadCreateWithoutCustomerInput, t_sales_downloadUncheckedCreateWithoutCustomerInput> | t_sales_downloadCreateWithoutCustomerInput[] | t_sales_downloadUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: t_sales_downloadCreateOrConnectWithoutCustomerInput | t_sales_downloadCreateOrConnectWithoutCustomerInput[]
    upsert?: t_sales_downloadUpsertWithWhereUniqueWithoutCustomerInput | t_sales_downloadUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: t_sales_downloadCreateManyCustomerInputEnvelope
    set?: t_sales_downloadWhereUniqueInput | t_sales_downloadWhereUniqueInput[]
    disconnect?: t_sales_downloadWhereUniqueInput | t_sales_downloadWhereUniqueInput[]
    delete?: t_sales_downloadWhereUniqueInput | t_sales_downloadWhereUniqueInput[]
    connect?: t_sales_downloadWhereUniqueInput | t_sales_downloadWhereUniqueInput[]
    update?: t_sales_downloadUpdateWithWhereUniqueWithoutCustomerInput | t_sales_downloadUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: t_sales_downloadUpdateManyWithWhereWithoutCustomerInput | t_sales_downloadUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: t_sales_downloadScalarWhereInput | t_sales_downloadScalarWhereInput[]
  }

  export type customerCreateNestedOneWithoutCustomer_readerInput = {
    create?: XOR<customerCreateWithoutCustomer_readerInput, customerUncheckedCreateWithoutCustomer_readerInput>
    connectOrCreate?: customerCreateOrConnectWithoutCustomer_readerInput
    connect?: customerWhereUniqueInput
  }

  export type productCreateNestedOneWithoutCustomer_readerInput = {
    create?: XOR<productCreateWithoutCustomer_readerInput, productUncheckedCreateWithoutCustomer_readerInput>
    connectOrCreate?: productCreateOrConnectWithoutCustomer_readerInput
    connect?: productWhereUniqueInput
  }

  export type customerUpdateOneRequiredWithoutCustomer_readerNestedInput = {
    create?: XOR<customerCreateWithoutCustomer_readerInput, customerUncheckedCreateWithoutCustomer_readerInput>
    connectOrCreate?: customerCreateOrConnectWithoutCustomer_readerInput
    upsert?: customerUpsertWithoutCustomer_readerInput
    connect?: customerWhereUniqueInput
    update?: XOR<XOR<customerUpdateToOneWithWhereWithoutCustomer_readerInput, customerUpdateWithoutCustomer_readerInput>, customerUncheckedUpdateWithoutCustomer_readerInput>
  }

  export type productUpdateOneRequiredWithoutCustomer_readerNestedInput = {
    create?: XOR<productCreateWithoutCustomer_readerInput, productUncheckedCreateWithoutCustomer_readerInput>
    connectOrCreate?: productCreateOrConnectWithoutCustomer_readerInput
    upsert?: productUpsertWithoutCustomer_readerInput
    connect?: productWhereUniqueInput
    update?: XOR<XOR<productUpdateToOneWithWhereWithoutCustomer_readerInput, productUpdateWithoutCustomer_readerInput>, productUncheckedUpdateWithoutCustomer_readerInput>
  }

  export type customerCreateNestedOneWithoutCustomer_trackInput = {
    create?: XOR<customerCreateWithoutCustomer_trackInput, customerUncheckedCreateWithoutCustomer_trackInput>
    connectOrCreate?: customerCreateOrConnectWithoutCustomer_trackInput
    connect?: customerWhereUniqueInput
  }

  export type customerUpdateOneRequiredWithoutCustomer_trackNestedInput = {
    create?: XOR<customerCreateWithoutCustomer_trackInput, customerUncheckedCreateWithoutCustomer_trackInput>
    connectOrCreate?: customerCreateOrConnectWithoutCustomer_trackInput
    upsert?: customerUpsertWithoutCustomer_trackInput
    connect?: customerWhereUniqueInput
    update?: XOR<XOR<customerUpdateToOneWithWhereWithoutCustomer_trackInput, customerUpdateWithoutCustomer_trackInput>, customerUncheckedUpdateWithoutCustomer_trackInput>
  }

  export type book_genreCreateNestedManyWithoutGenreInput = {
    create?: XOR<book_genreCreateWithoutGenreInput, book_genreUncheckedCreateWithoutGenreInput> | book_genreCreateWithoutGenreInput[] | book_genreUncheckedCreateWithoutGenreInput[]
    connectOrCreate?: book_genreCreateOrConnectWithoutGenreInput | book_genreCreateOrConnectWithoutGenreInput[]
    createMany?: book_genreCreateManyGenreInputEnvelope
    connect?: book_genreWhereUniqueInput | book_genreWhereUniqueInput[]
  }

  export type genreCreateNestedOneWithoutOther_genreInput = {
    create?: XOR<genreCreateWithoutOther_genreInput, genreUncheckedCreateWithoutOther_genreInput>
    connectOrCreate?: genreCreateOrConnectWithoutOther_genreInput
    connect?: genreWhereUniqueInput
  }

  export type genreCreateNestedManyWithoutGenreInput = {
    create?: XOR<genreCreateWithoutGenreInput, genreUncheckedCreateWithoutGenreInput> | genreCreateWithoutGenreInput[] | genreUncheckedCreateWithoutGenreInput[]
    connectOrCreate?: genreCreateOrConnectWithoutGenreInput | genreCreateOrConnectWithoutGenreInput[]
    createMany?: genreCreateManyGenreInputEnvelope
    connect?: genreWhereUniqueInput | genreWhereUniqueInput[]
  }

  export type book_genreUncheckedCreateNestedManyWithoutGenreInput = {
    create?: XOR<book_genreCreateWithoutGenreInput, book_genreUncheckedCreateWithoutGenreInput> | book_genreCreateWithoutGenreInput[] | book_genreUncheckedCreateWithoutGenreInput[]
    connectOrCreate?: book_genreCreateOrConnectWithoutGenreInput | book_genreCreateOrConnectWithoutGenreInput[]
    createMany?: book_genreCreateManyGenreInputEnvelope
    connect?: book_genreWhereUniqueInput | book_genreWhereUniqueInput[]
  }

  export type genreUncheckedCreateNestedManyWithoutGenreInput = {
    create?: XOR<genreCreateWithoutGenreInput, genreUncheckedCreateWithoutGenreInput> | genreCreateWithoutGenreInput[] | genreUncheckedCreateWithoutGenreInput[]
    connectOrCreate?: genreCreateOrConnectWithoutGenreInput | genreCreateOrConnectWithoutGenreInput[]
    createMany?: genreCreateManyGenreInputEnvelope
    connect?: genreWhereUniqueInput | genreWhereUniqueInput[]
  }

  export type book_genreUpdateManyWithoutGenreNestedInput = {
    create?: XOR<book_genreCreateWithoutGenreInput, book_genreUncheckedCreateWithoutGenreInput> | book_genreCreateWithoutGenreInput[] | book_genreUncheckedCreateWithoutGenreInput[]
    connectOrCreate?: book_genreCreateOrConnectWithoutGenreInput | book_genreCreateOrConnectWithoutGenreInput[]
    upsert?: book_genreUpsertWithWhereUniqueWithoutGenreInput | book_genreUpsertWithWhereUniqueWithoutGenreInput[]
    createMany?: book_genreCreateManyGenreInputEnvelope
    set?: book_genreWhereUniqueInput | book_genreWhereUniqueInput[]
    disconnect?: book_genreWhereUniqueInput | book_genreWhereUniqueInput[]
    delete?: book_genreWhereUniqueInput | book_genreWhereUniqueInput[]
    connect?: book_genreWhereUniqueInput | book_genreWhereUniqueInput[]
    update?: book_genreUpdateWithWhereUniqueWithoutGenreInput | book_genreUpdateWithWhereUniqueWithoutGenreInput[]
    updateMany?: book_genreUpdateManyWithWhereWithoutGenreInput | book_genreUpdateManyWithWhereWithoutGenreInput[]
    deleteMany?: book_genreScalarWhereInput | book_genreScalarWhereInput[]
  }

  export type genreUpdateOneWithoutOther_genreNestedInput = {
    create?: XOR<genreCreateWithoutOther_genreInput, genreUncheckedCreateWithoutOther_genreInput>
    connectOrCreate?: genreCreateOrConnectWithoutOther_genreInput
    upsert?: genreUpsertWithoutOther_genreInput
    disconnect?: genreWhereInput | boolean
    delete?: genreWhereInput | boolean
    connect?: genreWhereUniqueInput
    update?: XOR<XOR<genreUpdateToOneWithWhereWithoutOther_genreInput, genreUpdateWithoutOther_genreInput>, genreUncheckedUpdateWithoutOther_genreInput>
  }

  export type genreUpdateManyWithoutGenreNestedInput = {
    create?: XOR<genreCreateWithoutGenreInput, genreUncheckedCreateWithoutGenreInput> | genreCreateWithoutGenreInput[] | genreUncheckedCreateWithoutGenreInput[]
    connectOrCreate?: genreCreateOrConnectWithoutGenreInput | genreCreateOrConnectWithoutGenreInput[]
    upsert?: genreUpsertWithWhereUniqueWithoutGenreInput | genreUpsertWithWhereUniqueWithoutGenreInput[]
    createMany?: genreCreateManyGenreInputEnvelope
    set?: genreWhereUniqueInput | genreWhereUniqueInput[]
    disconnect?: genreWhereUniqueInput | genreWhereUniqueInput[]
    delete?: genreWhereUniqueInput | genreWhereUniqueInput[]
    connect?: genreWhereUniqueInput | genreWhereUniqueInput[]
    update?: genreUpdateWithWhereUniqueWithoutGenreInput | genreUpdateWithWhereUniqueWithoutGenreInput[]
    updateMany?: genreUpdateManyWithWhereWithoutGenreInput | genreUpdateManyWithWhereWithoutGenreInput[]
    deleteMany?: genreScalarWhereInput | genreScalarWhereInput[]
  }

  export type book_genreUncheckedUpdateManyWithoutGenreNestedInput = {
    create?: XOR<book_genreCreateWithoutGenreInput, book_genreUncheckedCreateWithoutGenreInput> | book_genreCreateWithoutGenreInput[] | book_genreUncheckedCreateWithoutGenreInput[]
    connectOrCreate?: book_genreCreateOrConnectWithoutGenreInput | book_genreCreateOrConnectWithoutGenreInput[]
    upsert?: book_genreUpsertWithWhereUniqueWithoutGenreInput | book_genreUpsertWithWhereUniqueWithoutGenreInput[]
    createMany?: book_genreCreateManyGenreInputEnvelope
    set?: book_genreWhereUniqueInput | book_genreWhereUniqueInput[]
    disconnect?: book_genreWhereUniqueInput | book_genreWhereUniqueInput[]
    delete?: book_genreWhereUniqueInput | book_genreWhereUniqueInput[]
    connect?: book_genreWhereUniqueInput | book_genreWhereUniqueInput[]
    update?: book_genreUpdateWithWhereUniqueWithoutGenreInput | book_genreUpdateWithWhereUniqueWithoutGenreInput[]
    updateMany?: book_genreUpdateManyWithWhereWithoutGenreInput | book_genreUpdateManyWithWhereWithoutGenreInput[]
    deleteMany?: book_genreScalarWhereInput | book_genreScalarWhereInput[]
  }

  export type genreUncheckedUpdateManyWithoutGenreNestedInput = {
    create?: XOR<genreCreateWithoutGenreInput, genreUncheckedCreateWithoutGenreInput> | genreCreateWithoutGenreInput[] | genreUncheckedCreateWithoutGenreInput[]
    connectOrCreate?: genreCreateOrConnectWithoutGenreInput | genreCreateOrConnectWithoutGenreInput[]
    upsert?: genreUpsertWithWhereUniqueWithoutGenreInput | genreUpsertWithWhereUniqueWithoutGenreInput[]
    createMany?: genreCreateManyGenreInputEnvelope
    set?: genreWhereUniqueInput | genreWhereUniqueInput[]
    disconnect?: genreWhereUniqueInput | genreWhereUniqueInput[]
    delete?: genreWhereUniqueInput | genreWhereUniqueInput[]
    connect?: genreWhereUniqueInput | genreWhereUniqueInput[]
    update?: genreUpdateWithWhereUniqueWithoutGenreInput | genreUpdateWithWhereUniqueWithoutGenreInput[]
    updateMany?: genreUpdateManyWithWhereWithoutGenreInput | genreUpdateManyWithWhereWithoutGenreInput[]
    deleteMany?: genreScalarWhereInput | genreScalarWhereInput[]
  }

  export type auth_userCreateNestedManyWithoutInternalInput = {
    create?: XOR<auth_userCreateWithoutInternalInput, auth_userUncheckedCreateWithoutInternalInput> | auth_userCreateWithoutInternalInput[] | auth_userUncheckedCreateWithoutInternalInput[]
    connectOrCreate?: auth_userCreateOrConnectWithoutInternalInput | auth_userCreateOrConnectWithoutInternalInput[]
    createMany?: auth_userCreateManyInternalInputEnvelope
    connect?: auth_userWhereUniqueInput | auth_userWhereUniqueInput[]
  }

  export type book_approvalCreateNestedManyWithoutInternalInput = {
    create?: XOR<book_approvalCreateWithoutInternalInput, book_approvalUncheckedCreateWithoutInternalInput> | book_approvalCreateWithoutInternalInput[] | book_approvalUncheckedCreateWithoutInternalInput[]
    connectOrCreate?: book_approvalCreateOrConnectWithoutInternalInput | book_approvalCreateOrConnectWithoutInternalInput[]
    createMany?: book_approvalCreateManyInternalInputEnvelope
    connect?: book_approvalWhereUniqueInput | book_approvalWhereUniqueInput[]
  }

  export type auth_accountCreateNestedOneWithoutInternalInput = {
    create?: XOR<auth_accountCreateWithoutInternalInput, auth_accountUncheckedCreateWithoutInternalInput>
    connectOrCreate?: auth_accountCreateOrConnectWithoutInternalInput
    connect?: auth_accountWhereUniqueInput
  }

  export type auth_userUncheckedCreateNestedManyWithoutInternalInput = {
    create?: XOR<auth_userCreateWithoutInternalInput, auth_userUncheckedCreateWithoutInternalInput> | auth_userCreateWithoutInternalInput[] | auth_userUncheckedCreateWithoutInternalInput[]
    connectOrCreate?: auth_userCreateOrConnectWithoutInternalInput | auth_userCreateOrConnectWithoutInternalInput[]
    createMany?: auth_userCreateManyInternalInputEnvelope
    connect?: auth_userWhereUniqueInput | auth_userWhereUniqueInput[]
  }

  export type book_approvalUncheckedCreateNestedManyWithoutInternalInput = {
    create?: XOR<book_approvalCreateWithoutInternalInput, book_approvalUncheckedCreateWithoutInternalInput> | book_approvalCreateWithoutInternalInput[] | book_approvalUncheckedCreateWithoutInternalInput[]
    connectOrCreate?: book_approvalCreateOrConnectWithoutInternalInput | book_approvalCreateOrConnectWithoutInternalInput[]
    createMany?: book_approvalCreateManyInternalInputEnvelope
    connect?: book_approvalWhereUniqueInput | book_approvalWhereUniqueInput[]
  }

  export type auth_userUpdateManyWithoutInternalNestedInput = {
    create?: XOR<auth_userCreateWithoutInternalInput, auth_userUncheckedCreateWithoutInternalInput> | auth_userCreateWithoutInternalInput[] | auth_userUncheckedCreateWithoutInternalInput[]
    connectOrCreate?: auth_userCreateOrConnectWithoutInternalInput | auth_userCreateOrConnectWithoutInternalInput[]
    upsert?: auth_userUpsertWithWhereUniqueWithoutInternalInput | auth_userUpsertWithWhereUniqueWithoutInternalInput[]
    createMany?: auth_userCreateManyInternalInputEnvelope
    set?: auth_userWhereUniqueInput | auth_userWhereUniqueInput[]
    disconnect?: auth_userWhereUniqueInput | auth_userWhereUniqueInput[]
    delete?: auth_userWhereUniqueInput | auth_userWhereUniqueInput[]
    connect?: auth_userWhereUniqueInput | auth_userWhereUniqueInput[]
    update?: auth_userUpdateWithWhereUniqueWithoutInternalInput | auth_userUpdateWithWhereUniqueWithoutInternalInput[]
    updateMany?: auth_userUpdateManyWithWhereWithoutInternalInput | auth_userUpdateManyWithWhereWithoutInternalInput[]
    deleteMany?: auth_userScalarWhereInput | auth_userScalarWhereInput[]
  }

  export type book_approvalUpdateManyWithoutInternalNestedInput = {
    create?: XOR<book_approvalCreateWithoutInternalInput, book_approvalUncheckedCreateWithoutInternalInput> | book_approvalCreateWithoutInternalInput[] | book_approvalUncheckedCreateWithoutInternalInput[]
    connectOrCreate?: book_approvalCreateOrConnectWithoutInternalInput | book_approvalCreateOrConnectWithoutInternalInput[]
    upsert?: book_approvalUpsertWithWhereUniqueWithoutInternalInput | book_approvalUpsertWithWhereUniqueWithoutInternalInput[]
    createMany?: book_approvalCreateManyInternalInputEnvelope
    set?: book_approvalWhereUniqueInput | book_approvalWhereUniqueInput[]
    disconnect?: book_approvalWhereUniqueInput | book_approvalWhereUniqueInput[]
    delete?: book_approvalWhereUniqueInput | book_approvalWhereUniqueInput[]
    connect?: book_approvalWhereUniqueInput | book_approvalWhereUniqueInput[]
    update?: book_approvalUpdateWithWhereUniqueWithoutInternalInput | book_approvalUpdateWithWhereUniqueWithoutInternalInput[]
    updateMany?: book_approvalUpdateManyWithWhereWithoutInternalInput | book_approvalUpdateManyWithWhereWithoutInternalInput[]
    deleteMany?: book_approvalScalarWhereInput | book_approvalScalarWhereInput[]
  }

  export type auth_accountUpdateOneWithoutInternalNestedInput = {
    create?: XOR<auth_accountCreateWithoutInternalInput, auth_accountUncheckedCreateWithoutInternalInput>
    connectOrCreate?: auth_accountCreateOrConnectWithoutInternalInput
    upsert?: auth_accountUpsertWithoutInternalInput
    disconnect?: auth_accountWhereInput | boolean
    delete?: auth_accountWhereInput | boolean
    connect?: auth_accountWhereUniqueInput
    update?: XOR<XOR<auth_accountUpdateToOneWithWhereWithoutInternalInput, auth_accountUpdateWithoutInternalInput>, auth_accountUncheckedUpdateWithoutInternalInput>
  }

  export type auth_userUncheckedUpdateManyWithoutInternalNestedInput = {
    create?: XOR<auth_userCreateWithoutInternalInput, auth_userUncheckedCreateWithoutInternalInput> | auth_userCreateWithoutInternalInput[] | auth_userUncheckedCreateWithoutInternalInput[]
    connectOrCreate?: auth_userCreateOrConnectWithoutInternalInput | auth_userCreateOrConnectWithoutInternalInput[]
    upsert?: auth_userUpsertWithWhereUniqueWithoutInternalInput | auth_userUpsertWithWhereUniqueWithoutInternalInput[]
    createMany?: auth_userCreateManyInternalInputEnvelope
    set?: auth_userWhereUniqueInput | auth_userWhereUniqueInput[]
    disconnect?: auth_userWhereUniqueInput | auth_userWhereUniqueInput[]
    delete?: auth_userWhereUniqueInput | auth_userWhereUniqueInput[]
    connect?: auth_userWhereUniqueInput | auth_userWhereUniqueInput[]
    update?: auth_userUpdateWithWhereUniqueWithoutInternalInput | auth_userUpdateWithWhereUniqueWithoutInternalInput[]
    updateMany?: auth_userUpdateManyWithWhereWithoutInternalInput | auth_userUpdateManyWithWhereWithoutInternalInput[]
    deleteMany?: auth_userScalarWhereInput | auth_userScalarWhereInput[]
  }

  export type book_approvalUncheckedUpdateManyWithoutInternalNestedInput = {
    create?: XOR<book_approvalCreateWithoutInternalInput, book_approvalUncheckedCreateWithoutInternalInput> | book_approvalCreateWithoutInternalInput[] | book_approvalUncheckedCreateWithoutInternalInput[]
    connectOrCreate?: book_approvalCreateOrConnectWithoutInternalInput | book_approvalCreateOrConnectWithoutInternalInput[]
    upsert?: book_approvalUpsertWithWhereUniqueWithoutInternalInput | book_approvalUpsertWithWhereUniqueWithoutInternalInput[]
    createMany?: book_approvalCreateManyInternalInputEnvelope
    set?: book_approvalWhereUniqueInput | book_approvalWhereUniqueInput[]
    disconnect?: book_approvalWhereUniqueInput | book_approvalWhereUniqueInput[]
    delete?: book_approvalWhereUniqueInput | book_approvalWhereUniqueInput[]
    connect?: book_approvalWhereUniqueInput | book_approvalWhereUniqueInput[]
    update?: book_approvalUpdateWithWhereUniqueWithoutInternalInput | book_approvalUpdateWithWhereUniqueWithoutInternalInput[]
    updateMany?: book_approvalUpdateManyWithWhereWithoutInternalInput | book_approvalUpdateManyWithWhereWithoutInternalInput[]
    deleteMany?: book_approvalScalarWhereInput | book_approvalScalarWhereInput[]
  }

  export type landing_itemsCreateNestedManyWithoutLandingInput = {
    create?: XOR<landing_itemsCreateWithoutLandingInput, landing_itemsUncheckedCreateWithoutLandingInput> | landing_itemsCreateWithoutLandingInput[] | landing_itemsUncheckedCreateWithoutLandingInput[]
    connectOrCreate?: landing_itemsCreateOrConnectWithoutLandingInput | landing_itemsCreateOrConnectWithoutLandingInput[]
    createMany?: landing_itemsCreateManyLandingInputEnvelope
    connect?: landing_itemsWhereUniqueInput | landing_itemsWhereUniqueInput[]
  }

  export type landing_itemsUncheckedCreateNestedManyWithoutLandingInput = {
    create?: XOR<landing_itemsCreateWithoutLandingInput, landing_itemsUncheckedCreateWithoutLandingInput> | landing_itemsCreateWithoutLandingInput[] | landing_itemsUncheckedCreateWithoutLandingInput[]
    connectOrCreate?: landing_itemsCreateOrConnectWithoutLandingInput | landing_itemsCreateOrConnectWithoutLandingInput[]
    createMany?: landing_itemsCreateManyLandingInputEnvelope
    connect?: landing_itemsWhereUniqueInput | landing_itemsWhereUniqueInput[]
  }

  export type landing_itemsUpdateManyWithoutLandingNestedInput = {
    create?: XOR<landing_itemsCreateWithoutLandingInput, landing_itemsUncheckedCreateWithoutLandingInput> | landing_itemsCreateWithoutLandingInput[] | landing_itemsUncheckedCreateWithoutLandingInput[]
    connectOrCreate?: landing_itemsCreateOrConnectWithoutLandingInput | landing_itemsCreateOrConnectWithoutLandingInput[]
    upsert?: landing_itemsUpsertWithWhereUniqueWithoutLandingInput | landing_itemsUpsertWithWhereUniqueWithoutLandingInput[]
    createMany?: landing_itemsCreateManyLandingInputEnvelope
    set?: landing_itemsWhereUniqueInput | landing_itemsWhereUniqueInput[]
    disconnect?: landing_itemsWhereUniqueInput | landing_itemsWhereUniqueInput[]
    delete?: landing_itemsWhereUniqueInput | landing_itemsWhereUniqueInput[]
    connect?: landing_itemsWhereUniqueInput | landing_itemsWhereUniqueInput[]
    update?: landing_itemsUpdateWithWhereUniqueWithoutLandingInput | landing_itemsUpdateWithWhereUniqueWithoutLandingInput[]
    updateMany?: landing_itemsUpdateManyWithWhereWithoutLandingInput | landing_itemsUpdateManyWithWhereWithoutLandingInput[]
    deleteMany?: landing_itemsScalarWhereInput | landing_itemsScalarWhereInput[]
  }

  export type landing_itemsUncheckedUpdateManyWithoutLandingNestedInput = {
    create?: XOR<landing_itemsCreateWithoutLandingInput, landing_itemsUncheckedCreateWithoutLandingInput> | landing_itemsCreateWithoutLandingInput[] | landing_itemsUncheckedCreateWithoutLandingInput[]
    connectOrCreate?: landing_itemsCreateOrConnectWithoutLandingInput | landing_itemsCreateOrConnectWithoutLandingInput[]
    upsert?: landing_itemsUpsertWithWhereUniqueWithoutLandingInput | landing_itemsUpsertWithWhereUniqueWithoutLandingInput[]
    createMany?: landing_itemsCreateManyLandingInputEnvelope
    set?: landing_itemsWhereUniqueInput | landing_itemsWhereUniqueInput[]
    disconnect?: landing_itemsWhereUniqueInput | landing_itemsWhereUniqueInput[]
    delete?: landing_itemsWhereUniqueInput | landing_itemsWhereUniqueInput[]
    connect?: landing_itemsWhereUniqueInput | landing_itemsWhereUniqueInput[]
    update?: landing_itemsUpdateWithWhereUniqueWithoutLandingInput | landing_itemsUpdateWithWhereUniqueWithoutLandingInput[]
    updateMany?: landing_itemsUpdateManyWithWhereWithoutLandingInput | landing_itemsUpdateManyWithWhereWithoutLandingInput[]
    deleteMany?: landing_itemsScalarWhereInput | landing_itemsScalarWhereInput[]
  }

  export type landingCreateNestedOneWithoutLanding_itemsInput = {
    create?: XOR<landingCreateWithoutLanding_itemsInput, landingUncheckedCreateWithoutLanding_itemsInput>
    connectOrCreate?: landingCreateOrConnectWithoutLanding_itemsInput
    connect?: landingWhereUniqueInput
  }

  export type landingUpdateOneRequiredWithoutLanding_itemsNestedInput = {
    create?: XOR<landingCreateWithoutLanding_itemsInput, landingUncheckedCreateWithoutLanding_itemsInput>
    connectOrCreate?: landingCreateOrConnectWithoutLanding_itemsInput
    upsert?: landingUpsertWithoutLanding_itemsInput
    connect?: landingWhereUniqueInput
    update?: XOR<XOR<landingUpdateToOneWithWhereWithoutLanding_itemsInput, landingUpdateWithoutLanding_itemsInput>, landingUncheckedUpdateWithoutLanding_itemsInput>
  }

  export type productCreateNestedOneWithoutPreorderInput = {
    create?: XOR<productCreateWithoutPreorderInput, productUncheckedCreateWithoutPreorderInput>
    connectOrCreate?: productCreateOrConnectWithoutPreorderInput
    connect?: productWhereUniqueInput
  }

  export type productUpdateOneRequiredWithoutPreorderNestedInput = {
    create?: XOR<productCreateWithoutPreorderInput, productUncheckedCreateWithoutPreorderInput>
    connectOrCreate?: productCreateOrConnectWithoutPreorderInput
    upsert?: productUpsertWithoutPreorderInput
    connect?: productWhereUniqueInput
    update?: XOR<XOR<productUpdateToOneWithWhereWithoutPreorderInput, productUpdateWithoutPreorderInput>, productUncheckedUpdateWithoutPreorderInput>
  }

  export type bookCreateNestedManyWithoutProductInput = {
    create?: XOR<bookCreateWithoutProductInput, bookUncheckedCreateWithoutProductInput> | bookCreateWithoutProductInput[] | bookUncheckedCreateWithoutProductInput[]
    connectOrCreate?: bookCreateOrConnectWithoutProductInput | bookCreateOrConnectWithoutProductInput[]
    createMany?: bookCreateManyProductInputEnvelope
    connect?: bookWhereUniqueInput | bookWhereUniqueInput[]
  }

  export type bundle_productCreateNestedManyWithoutProductInput = {
    create?: XOR<bundle_productCreateWithoutProductInput, bundle_productUncheckedCreateWithoutProductInput> | bundle_productCreateWithoutProductInput[] | bundle_productUncheckedCreateWithoutProductInput[]
    connectOrCreate?: bundle_productCreateOrConnectWithoutProductInput | bundle_productCreateOrConnectWithoutProductInput[]
    createMany?: bundle_productCreateManyProductInputEnvelope
    connect?: bundle_productWhereUniqueInput | bundle_productWhereUniqueInput[]
  }

  export type chapterCreateNestedManyWithoutProductInput = {
    create?: XOR<chapterCreateWithoutProductInput, chapterUncheckedCreateWithoutProductInput> | chapterCreateWithoutProductInput[] | chapterUncheckedCreateWithoutProductInput[]
    connectOrCreate?: chapterCreateOrConnectWithoutProductInput | chapterCreateOrConnectWithoutProductInput[]
    createMany?: chapterCreateManyProductInputEnvelope
    connect?: chapterWhereUniqueInput | chapterWhereUniqueInput[]
  }

  export type customer_readerCreateNestedManyWithoutProductInput = {
    create?: XOR<customer_readerCreateWithoutProductInput, customer_readerUncheckedCreateWithoutProductInput> | customer_readerCreateWithoutProductInput[] | customer_readerUncheckedCreateWithoutProductInput[]
    connectOrCreate?: customer_readerCreateOrConnectWithoutProductInput | customer_readerCreateOrConnectWithoutProductInput[]
    createMany?: customer_readerCreateManyProductInputEnvelope
    connect?: customer_readerWhereUniqueInput | customer_readerWhereUniqueInput[]
  }

  export type preorderCreateNestedManyWithoutProductInput = {
    create?: XOR<preorderCreateWithoutProductInput, preorderUncheckedCreateWithoutProductInput> | preorderCreateWithoutProductInput[] | preorderUncheckedCreateWithoutProductInput[]
    connectOrCreate?: preorderCreateOrConnectWithoutProductInput | preorderCreateOrConnectWithoutProductInput[]
    createMany?: preorderCreateManyProductInputEnvelope
    connect?: preorderWhereUniqueInput | preorderWhereUniqueInput[]
  }

  export type authorCreateNestedOneWithoutProductInput = {
    create?: XOR<authorCreateWithoutProductInput, authorUncheckedCreateWithoutProductInput>
    connectOrCreate?: authorCreateOrConnectWithoutProductInput
    connect?: authorWhereUniqueInput
  }

  export type product_categoryCreateNestedManyWithoutProductInput = {
    create?: XOR<product_categoryCreateWithoutProductInput, product_categoryUncheckedCreateWithoutProductInput> | product_categoryCreateWithoutProductInput[] | product_categoryUncheckedCreateWithoutProductInput[]
    connectOrCreate?: product_categoryCreateOrConnectWithoutProductInput | product_categoryCreateOrConnectWithoutProductInput[]
    createMany?: product_categoryCreateManyProductInputEnvelope
    connect?: product_categoryWhereUniqueInput | product_categoryWhereUniqueInput[]
  }

  export type t_sales_downloadCreateNestedManyWithoutProductInput = {
    create?: XOR<t_sales_downloadCreateWithoutProductInput, t_sales_downloadUncheckedCreateWithoutProductInput> | t_sales_downloadCreateWithoutProductInput[] | t_sales_downloadUncheckedCreateWithoutProductInput[]
    connectOrCreate?: t_sales_downloadCreateOrConnectWithoutProductInput | t_sales_downloadCreateOrConnectWithoutProductInput[]
    createMany?: t_sales_downloadCreateManyProductInputEnvelope
    connect?: t_sales_downloadWhereUniqueInput | t_sales_downloadWhereUniqueInput[]
  }

  export type t_sales_lineCreateNestedManyWithoutProductInput = {
    create?: XOR<t_sales_lineCreateWithoutProductInput, t_sales_lineUncheckedCreateWithoutProductInput> | t_sales_lineCreateWithoutProductInput[] | t_sales_lineUncheckedCreateWithoutProductInput[]
    connectOrCreate?: t_sales_lineCreateOrConnectWithoutProductInput | t_sales_lineCreateOrConnectWithoutProductInput[]
    createMany?: t_sales_lineCreateManyProductInputEnvelope
    connect?: t_sales_lineWhereUniqueInput | t_sales_lineWhereUniqueInput[]
  }

  export type bookUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<bookCreateWithoutProductInput, bookUncheckedCreateWithoutProductInput> | bookCreateWithoutProductInput[] | bookUncheckedCreateWithoutProductInput[]
    connectOrCreate?: bookCreateOrConnectWithoutProductInput | bookCreateOrConnectWithoutProductInput[]
    createMany?: bookCreateManyProductInputEnvelope
    connect?: bookWhereUniqueInput | bookWhereUniqueInput[]
  }

  export type bundle_productUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<bundle_productCreateWithoutProductInput, bundle_productUncheckedCreateWithoutProductInput> | bundle_productCreateWithoutProductInput[] | bundle_productUncheckedCreateWithoutProductInput[]
    connectOrCreate?: bundle_productCreateOrConnectWithoutProductInput | bundle_productCreateOrConnectWithoutProductInput[]
    createMany?: bundle_productCreateManyProductInputEnvelope
    connect?: bundle_productWhereUniqueInput | bundle_productWhereUniqueInput[]
  }

  export type chapterUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<chapterCreateWithoutProductInput, chapterUncheckedCreateWithoutProductInput> | chapterCreateWithoutProductInput[] | chapterUncheckedCreateWithoutProductInput[]
    connectOrCreate?: chapterCreateOrConnectWithoutProductInput | chapterCreateOrConnectWithoutProductInput[]
    createMany?: chapterCreateManyProductInputEnvelope
    connect?: chapterWhereUniqueInput | chapterWhereUniqueInput[]
  }

  export type customer_readerUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<customer_readerCreateWithoutProductInput, customer_readerUncheckedCreateWithoutProductInput> | customer_readerCreateWithoutProductInput[] | customer_readerUncheckedCreateWithoutProductInput[]
    connectOrCreate?: customer_readerCreateOrConnectWithoutProductInput | customer_readerCreateOrConnectWithoutProductInput[]
    createMany?: customer_readerCreateManyProductInputEnvelope
    connect?: customer_readerWhereUniqueInput | customer_readerWhereUniqueInput[]
  }

  export type preorderUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<preorderCreateWithoutProductInput, preorderUncheckedCreateWithoutProductInput> | preorderCreateWithoutProductInput[] | preorderUncheckedCreateWithoutProductInput[]
    connectOrCreate?: preorderCreateOrConnectWithoutProductInput | preorderCreateOrConnectWithoutProductInput[]
    createMany?: preorderCreateManyProductInputEnvelope
    connect?: preorderWhereUniqueInput | preorderWhereUniqueInput[]
  }

  export type product_categoryUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<product_categoryCreateWithoutProductInput, product_categoryUncheckedCreateWithoutProductInput> | product_categoryCreateWithoutProductInput[] | product_categoryUncheckedCreateWithoutProductInput[]
    connectOrCreate?: product_categoryCreateOrConnectWithoutProductInput | product_categoryCreateOrConnectWithoutProductInput[]
    createMany?: product_categoryCreateManyProductInputEnvelope
    connect?: product_categoryWhereUniqueInput | product_categoryWhereUniqueInput[]
  }

  export type t_sales_downloadUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<t_sales_downloadCreateWithoutProductInput, t_sales_downloadUncheckedCreateWithoutProductInput> | t_sales_downloadCreateWithoutProductInput[] | t_sales_downloadUncheckedCreateWithoutProductInput[]
    connectOrCreate?: t_sales_downloadCreateOrConnectWithoutProductInput | t_sales_downloadCreateOrConnectWithoutProductInput[]
    createMany?: t_sales_downloadCreateManyProductInputEnvelope
    connect?: t_sales_downloadWhereUniqueInput | t_sales_downloadWhereUniqueInput[]
  }

  export type t_sales_lineUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<t_sales_lineCreateWithoutProductInput, t_sales_lineUncheckedCreateWithoutProductInput> | t_sales_lineCreateWithoutProductInput[] | t_sales_lineUncheckedCreateWithoutProductInput[]
    connectOrCreate?: t_sales_lineCreateOrConnectWithoutProductInput | t_sales_lineCreateOrConnectWithoutProductInput[]
    createMany?: t_sales_lineCreateManyProductInputEnvelope
    connect?: t_sales_lineWhereUniqueInput | t_sales_lineWhereUniqueInput[]
  }

  export type bookUpdateManyWithoutProductNestedInput = {
    create?: XOR<bookCreateWithoutProductInput, bookUncheckedCreateWithoutProductInput> | bookCreateWithoutProductInput[] | bookUncheckedCreateWithoutProductInput[]
    connectOrCreate?: bookCreateOrConnectWithoutProductInput | bookCreateOrConnectWithoutProductInput[]
    upsert?: bookUpsertWithWhereUniqueWithoutProductInput | bookUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: bookCreateManyProductInputEnvelope
    set?: bookWhereUniqueInput | bookWhereUniqueInput[]
    disconnect?: bookWhereUniqueInput | bookWhereUniqueInput[]
    delete?: bookWhereUniqueInput | bookWhereUniqueInput[]
    connect?: bookWhereUniqueInput | bookWhereUniqueInput[]
    update?: bookUpdateWithWhereUniqueWithoutProductInput | bookUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: bookUpdateManyWithWhereWithoutProductInput | bookUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: bookScalarWhereInput | bookScalarWhereInput[]
  }

  export type bundle_productUpdateManyWithoutProductNestedInput = {
    create?: XOR<bundle_productCreateWithoutProductInput, bundle_productUncheckedCreateWithoutProductInput> | bundle_productCreateWithoutProductInput[] | bundle_productUncheckedCreateWithoutProductInput[]
    connectOrCreate?: bundle_productCreateOrConnectWithoutProductInput | bundle_productCreateOrConnectWithoutProductInput[]
    upsert?: bundle_productUpsertWithWhereUniqueWithoutProductInput | bundle_productUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: bundle_productCreateManyProductInputEnvelope
    set?: bundle_productWhereUniqueInput | bundle_productWhereUniqueInput[]
    disconnect?: bundle_productWhereUniqueInput | bundle_productWhereUniqueInput[]
    delete?: bundle_productWhereUniqueInput | bundle_productWhereUniqueInput[]
    connect?: bundle_productWhereUniqueInput | bundle_productWhereUniqueInput[]
    update?: bundle_productUpdateWithWhereUniqueWithoutProductInput | bundle_productUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: bundle_productUpdateManyWithWhereWithoutProductInput | bundle_productUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: bundle_productScalarWhereInput | bundle_productScalarWhereInput[]
  }

  export type chapterUpdateManyWithoutProductNestedInput = {
    create?: XOR<chapterCreateWithoutProductInput, chapterUncheckedCreateWithoutProductInput> | chapterCreateWithoutProductInput[] | chapterUncheckedCreateWithoutProductInput[]
    connectOrCreate?: chapterCreateOrConnectWithoutProductInput | chapterCreateOrConnectWithoutProductInput[]
    upsert?: chapterUpsertWithWhereUniqueWithoutProductInput | chapterUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: chapterCreateManyProductInputEnvelope
    set?: chapterWhereUniqueInput | chapterWhereUniqueInput[]
    disconnect?: chapterWhereUniqueInput | chapterWhereUniqueInput[]
    delete?: chapterWhereUniqueInput | chapterWhereUniqueInput[]
    connect?: chapterWhereUniqueInput | chapterWhereUniqueInput[]
    update?: chapterUpdateWithWhereUniqueWithoutProductInput | chapterUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: chapterUpdateManyWithWhereWithoutProductInput | chapterUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: chapterScalarWhereInput | chapterScalarWhereInput[]
  }

  export type customer_readerUpdateManyWithoutProductNestedInput = {
    create?: XOR<customer_readerCreateWithoutProductInput, customer_readerUncheckedCreateWithoutProductInput> | customer_readerCreateWithoutProductInput[] | customer_readerUncheckedCreateWithoutProductInput[]
    connectOrCreate?: customer_readerCreateOrConnectWithoutProductInput | customer_readerCreateOrConnectWithoutProductInput[]
    upsert?: customer_readerUpsertWithWhereUniqueWithoutProductInput | customer_readerUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: customer_readerCreateManyProductInputEnvelope
    set?: customer_readerWhereUniqueInput | customer_readerWhereUniqueInput[]
    disconnect?: customer_readerWhereUniqueInput | customer_readerWhereUniqueInput[]
    delete?: customer_readerWhereUniqueInput | customer_readerWhereUniqueInput[]
    connect?: customer_readerWhereUniqueInput | customer_readerWhereUniqueInput[]
    update?: customer_readerUpdateWithWhereUniqueWithoutProductInput | customer_readerUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: customer_readerUpdateManyWithWhereWithoutProductInput | customer_readerUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: customer_readerScalarWhereInput | customer_readerScalarWhereInput[]
  }

  export type preorderUpdateManyWithoutProductNestedInput = {
    create?: XOR<preorderCreateWithoutProductInput, preorderUncheckedCreateWithoutProductInput> | preorderCreateWithoutProductInput[] | preorderUncheckedCreateWithoutProductInput[]
    connectOrCreate?: preorderCreateOrConnectWithoutProductInput | preorderCreateOrConnectWithoutProductInput[]
    upsert?: preorderUpsertWithWhereUniqueWithoutProductInput | preorderUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: preorderCreateManyProductInputEnvelope
    set?: preorderWhereUniqueInput | preorderWhereUniqueInput[]
    disconnect?: preorderWhereUniqueInput | preorderWhereUniqueInput[]
    delete?: preorderWhereUniqueInput | preorderWhereUniqueInput[]
    connect?: preorderWhereUniqueInput | preorderWhereUniqueInput[]
    update?: preorderUpdateWithWhereUniqueWithoutProductInput | preorderUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: preorderUpdateManyWithWhereWithoutProductInput | preorderUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: preorderScalarWhereInput | preorderScalarWhereInput[]
  }

  export type authorUpdateOneWithoutProductNestedInput = {
    create?: XOR<authorCreateWithoutProductInput, authorUncheckedCreateWithoutProductInput>
    connectOrCreate?: authorCreateOrConnectWithoutProductInput
    upsert?: authorUpsertWithoutProductInput
    disconnect?: authorWhereInput | boolean
    delete?: authorWhereInput | boolean
    connect?: authorWhereUniqueInput
    update?: XOR<XOR<authorUpdateToOneWithWhereWithoutProductInput, authorUpdateWithoutProductInput>, authorUncheckedUpdateWithoutProductInput>
  }

  export type product_categoryUpdateManyWithoutProductNestedInput = {
    create?: XOR<product_categoryCreateWithoutProductInput, product_categoryUncheckedCreateWithoutProductInput> | product_categoryCreateWithoutProductInput[] | product_categoryUncheckedCreateWithoutProductInput[]
    connectOrCreate?: product_categoryCreateOrConnectWithoutProductInput | product_categoryCreateOrConnectWithoutProductInput[]
    upsert?: product_categoryUpsertWithWhereUniqueWithoutProductInput | product_categoryUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: product_categoryCreateManyProductInputEnvelope
    set?: product_categoryWhereUniqueInput | product_categoryWhereUniqueInput[]
    disconnect?: product_categoryWhereUniqueInput | product_categoryWhereUniqueInput[]
    delete?: product_categoryWhereUniqueInput | product_categoryWhereUniqueInput[]
    connect?: product_categoryWhereUniqueInput | product_categoryWhereUniqueInput[]
    update?: product_categoryUpdateWithWhereUniqueWithoutProductInput | product_categoryUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: product_categoryUpdateManyWithWhereWithoutProductInput | product_categoryUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: product_categoryScalarWhereInput | product_categoryScalarWhereInput[]
  }

  export type t_sales_downloadUpdateManyWithoutProductNestedInput = {
    create?: XOR<t_sales_downloadCreateWithoutProductInput, t_sales_downloadUncheckedCreateWithoutProductInput> | t_sales_downloadCreateWithoutProductInput[] | t_sales_downloadUncheckedCreateWithoutProductInput[]
    connectOrCreate?: t_sales_downloadCreateOrConnectWithoutProductInput | t_sales_downloadCreateOrConnectWithoutProductInput[]
    upsert?: t_sales_downloadUpsertWithWhereUniqueWithoutProductInput | t_sales_downloadUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: t_sales_downloadCreateManyProductInputEnvelope
    set?: t_sales_downloadWhereUniqueInput | t_sales_downloadWhereUniqueInput[]
    disconnect?: t_sales_downloadWhereUniqueInput | t_sales_downloadWhereUniqueInput[]
    delete?: t_sales_downloadWhereUniqueInput | t_sales_downloadWhereUniqueInput[]
    connect?: t_sales_downloadWhereUniqueInput | t_sales_downloadWhereUniqueInput[]
    update?: t_sales_downloadUpdateWithWhereUniqueWithoutProductInput | t_sales_downloadUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: t_sales_downloadUpdateManyWithWhereWithoutProductInput | t_sales_downloadUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: t_sales_downloadScalarWhereInput | t_sales_downloadScalarWhereInput[]
  }

  export type t_sales_lineUpdateManyWithoutProductNestedInput = {
    create?: XOR<t_sales_lineCreateWithoutProductInput, t_sales_lineUncheckedCreateWithoutProductInput> | t_sales_lineCreateWithoutProductInput[] | t_sales_lineUncheckedCreateWithoutProductInput[]
    connectOrCreate?: t_sales_lineCreateOrConnectWithoutProductInput | t_sales_lineCreateOrConnectWithoutProductInput[]
    upsert?: t_sales_lineUpsertWithWhereUniqueWithoutProductInput | t_sales_lineUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: t_sales_lineCreateManyProductInputEnvelope
    set?: t_sales_lineWhereUniqueInput | t_sales_lineWhereUniqueInput[]
    disconnect?: t_sales_lineWhereUniqueInput | t_sales_lineWhereUniqueInput[]
    delete?: t_sales_lineWhereUniqueInput | t_sales_lineWhereUniqueInput[]
    connect?: t_sales_lineWhereUniqueInput | t_sales_lineWhereUniqueInput[]
    update?: t_sales_lineUpdateWithWhereUniqueWithoutProductInput | t_sales_lineUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: t_sales_lineUpdateManyWithWhereWithoutProductInput | t_sales_lineUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: t_sales_lineScalarWhereInput | t_sales_lineScalarWhereInput[]
  }

  export type bookUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<bookCreateWithoutProductInput, bookUncheckedCreateWithoutProductInput> | bookCreateWithoutProductInput[] | bookUncheckedCreateWithoutProductInput[]
    connectOrCreate?: bookCreateOrConnectWithoutProductInput | bookCreateOrConnectWithoutProductInput[]
    upsert?: bookUpsertWithWhereUniqueWithoutProductInput | bookUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: bookCreateManyProductInputEnvelope
    set?: bookWhereUniqueInput | bookWhereUniqueInput[]
    disconnect?: bookWhereUniqueInput | bookWhereUniqueInput[]
    delete?: bookWhereUniqueInput | bookWhereUniqueInput[]
    connect?: bookWhereUniqueInput | bookWhereUniqueInput[]
    update?: bookUpdateWithWhereUniqueWithoutProductInput | bookUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: bookUpdateManyWithWhereWithoutProductInput | bookUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: bookScalarWhereInput | bookScalarWhereInput[]
  }

  export type bundle_productUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<bundle_productCreateWithoutProductInput, bundle_productUncheckedCreateWithoutProductInput> | bundle_productCreateWithoutProductInput[] | bundle_productUncheckedCreateWithoutProductInput[]
    connectOrCreate?: bundle_productCreateOrConnectWithoutProductInput | bundle_productCreateOrConnectWithoutProductInput[]
    upsert?: bundle_productUpsertWithWhereUniqueWithoutProductInput | bundle_productUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: bundle_productCreateManyProductInputEnvelope
    set?: bundle_productWhereUniqueInput | bundle_productWhereUniqueInput[]
    disconnect?: bundle_productWhereUniqueInput | bundle_productWhereUniqueInput[]
    delete?: bundle_productWhereUniqueInput | bundle_productWhereUniqueInput[]
    connect?: bundle_productWhereUniqueInput | bundle_productWhereUniqueInput[]
    update?: bundle_productUpdateWithWhereUniqueWithoutProductInput | bundle_productUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: bundle_productUpdateManyWithWhereWithoutProductInput | bundle_productUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: bundle_productScalarWhereInput | bundle_productScalarWhereInput[]
  }

  export type chapterUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<chapterCreateWithoutProductInput, chapterUncheckedCreateWithoutProductInput> | chapterCreateWithoutProductInput[] | chapterUncheckedCreateWithoutProductInput[]
    connectOrCreate?: chapterCreateOrConnectWithoutProductInput | chapterCreateOrConnectWithoutProductInput[]
    upsert?: chapterUpsertWithWhereUniqueWithoutProductInput | chapterUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: chapterCreateManyProductInputEnvelope
    set?: chapterWhereUniqueInput | chapterWhereUniqueInput[]
    disconnect?: chapterWhereUniqueInput | chapterWhereUniqueInput[]
    delete?: chapterWhereUniqueInput | chapterWhereUniqueInput[]
    connect?: chapterWhereUniqueInput | chapterWhereUniqueInput[]
    update?: chapterUpdateWithWhereUniqueWithoutProductInput | chapterUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: chapterUpdateManyWithWhereWithoutProductInput | chapterUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: chapterScalarWhereInput | chapterScalarWhereInput[]
  }

  export type customer_readerUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<customer_readerCreateWithoutProductInput, customer_readerUncheckedCreateWithoutProductInput> | customer_readerCreateWithoutProductInput[] | customer_readerUncheckedCreateWithoutProductInput[]
    connectOrCreate?: customer_readerCreateOrConnectWithoutProductInput | customer_readerCreateOrConnectWithoutProductInput[]
    upsert?: customer_readerUpsertWithWhereUniqueWithoutProductInput | customer_readerUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: customer_readerCreateManyProductInputEnvelope
    set?: customer_readerWhereUniqueInput | customer_readerWhereUniqueInput[]
    disconnect?: customer_readerWhereUniqueInput | customer_readerWhereUniqueInput[]
    delete?: customer_readerWhereUniqueInput | customer_readerWhereUniqueInput[]
    connect?: customer_readerWhereUniqueInput | customer_readerWhereUniqueInput[]
    update?: customer_readerUpdateWithWhereUniqueWithoutProductInput | customer_readerUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: customer_readerUpdateManyWithWhereWithoutProductInput | customer_readerUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: customer_readerScalarWhereInput | customer_readerScalarWhereInput[]
  }

  export type preorderUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<preorderCreateWithoutProductInput, preorderUncheckedCreateWithoutProductInput> | preorderCreateWithoutProductInput[] | preorderUncheckedCreateWithoutProductInput[]
    connectOrCreate?: preorderCreateOrConnectWithoutProductInput | preorderCreateOrConnectWithoutProductInput[]
    upsert?: preorderUpsertWithWhereUniqueWithoutProductInput | preorderUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: preorderCreateManyProductInputEnvelope
    set?: preorderWhereUniqueInput | preorderWhereUniqueInput[]
    disconnect?: preorderWhereUniqueInput | preorderWhereUniqueInput[]
    delete?: preorderWhereUniqueInput | preorderWhereUniqueInput[]
    connect?: preorderWhereUniqueInput | preorderWhereUniqueInput[]
    update?: preorderUpdateWithWhereUniqueWithoutProductInput | preorderUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: preorderUpdateManyWithWhereWithoutProductInput | preorderUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: preorderScalarWhereInput | preorderScalarWhereInput[]
  }

  export type product_categoryUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<product_categoryCreateWithoutProductInput, product_categoryUncheckedCreateWithoutProductInput> | product_categoryCreateWithoutProductInput[] | product_categoryUncheckedCreateWithoutProductInput[]
    connectOrCreate?: product_categoryCreateOrConnectWithoutProductInput | product_categoryCreateOrConnectWithoutProductInput[]
    upsert?: product_categoryUpsertWithWhereUniqueWithoutProductInput | product_categoryUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: product_categoryCreateManyProductInputEnvelope
    set?: product_categoryWhereUniqueInput | product_categoryWhereUniqueInput[]
    disconnect?: product_categoryWhereUniqueInput | product_categoryWhereUniqueInput[]
    delete?: product_categoryWhereUniqueInput | product_categoryWhereUniqueInput[]
    connect?: product_categoryWhereUniqueInput | product_categoryWhereUniqueInput[]
    update?: product_categoryUpdateWithWhereUniqueWithoutProductInput | product_categoryUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: product_categoryUpdateManyWithWhereWithoutProductInput | product_categoryUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: product_categoryScalarWhereInput | product_categoryScalarWhereInput[]
  }

  export type t_sales_downloadUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<t_sales_downloadCreateWithoutProductInput, t_sales_downloadUncheckedCreateWithoutProductInput> | t_sales_downloadCreateWithoutProductInput[] | t_sales_downloadUncheckedCreateWithoutProductInput[]
    connectOrCreate?: t_sales_downloadCreateOrConnectWithoutProductInput | t_sales_downloadCreateOrConnectWithoutProductInput[]
    upsert?: t_sales_downloadUpsertWithWhereUniqueWithoutProductInput | t_sales_downloadUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: t_sales_downloadCreateManyProductInputEnvelope
    set?: t_sales_downloadWhereUniqueInput | t_sales_downloadWhereUniqueInput[]
    disconnect?: t_sales_downloadWhereUniqueInput | t_sales_downloadWhereUniqueInput[]
    delete?: t_sales_downloadWhereUniqueInput | t_sales_downloadWhereUniqueInput[]
    connect?: t_sales_downloadWhereUniqueInput | t_sales_downloadWhereUniqueInput[]
    update?: t_sales_downloadUpdateWithWhereUniqueWithoutProductInput | t_sales_downloadUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: t_sales_downloadUpdateManyWithWhereWithoutProductInput | t_sales_downloadUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: t_sales_downloadScalarWhereInput | t_sales_downloadScalarWhereInput[]
  }

  export type t_sales_lineUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<t_sales_lineCreateWithoutProductInput, t_sales_lineUncheckedCreateWithoutProductInput> | t_sales_lineCreateWithoutProductInput[] | t_sales_lineUncheckedCreateWithoutProductInput[]
    connectOrCreate?: t_sales_lineCreateOrConnectWithoutProductInput | t_sales_lineCreateOrConnectWithoutProductInput[]
    upsert?: t_sales_lineUpsertWithWhereUniqueWithoutProductInput | t_sales_lineUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: t_sales_lineCreateManyProductInputEnvelope
    set?: t_sales_lineWhereUniqueInput | t_sales_lineWhereUniqueInput[]
    disconnect?: t_sales_lineWhereUniqueInput | t_sales_lineWhereUniqueInput[]
    delete?: t_sales_lineWhereUniqueInput | t_sales_lineWhereUniqueInput[]
    connect?: t_sales_lineWhereUniqueInput | t_sales_lineWhereUniqueInput[]
    update?: t_sales_lineUpdateWithWhereUniqueWithoutProductInput | t_sales_lineUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: t_sales_lineUpdateManyWithWhereWithoutProductInput | t_sales_lineUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: t_sales_lineScalarWhereInput | t_sales_lineScalarWhereInput[]
  }

  export type categoryCreateNestedOneWithoutProduct_categoryInput = {
    create?: XOR<categoryCreateWithoutProduct_categoryInput, categoryUncheckedCreateWithoutProduct_categoryInput>
    connectOrCreate?: categoryCreateOrConnectWithoutProduct_categoryInput
    connect?: categoryWhereUniqueInput
  }

  export type productCreateNestedOneWithoutProduct_categoryInput = {
    create?: XOR<productCreateWithoutProduct_categoryInput, productUncheckedCreateWithoutProduct_categoryInput>
    connectOrCreate?: productCreateOrConnectWithoutProduct_categoryInput
    connect?: productWhereUniqueInput
  }

  export type categoryUpdateOneRequiredWithoutProduct_categoryNestedInput = {
    create?: XOR<categoryCreateWithoutProduct_categoryInput, categoryUncheckedCreateWithoutProduct_categoryInput>
    connectOrCreate?: categoryCreateOrConnectWithoutProduct_categoryInput
    upsert?: categoryUpsertWithoutProduct_categoryInput
    connect?: categoryWhereUniqueInput
    update?: XOR<XOR<categoryUpdateToOneWithWhereWithoutProduct_categoryInput, categoryUpdateWithoutProduct_categoryInput>, categoryUncheckedUpdateWithoutProduct_categoryInput>
  }

  export type productUpdateOneRequiredWithoutProduct_categoryNestedInput = {
    create?: XOR<productCreateWithoutProduct_categoryInput, productUncheckedCreateWithoutProduct_categoryInput>
    connectOrCreate?: productCreateOrConnectWithoutProduct_categoryInput
    upsert?: productUpsertWithoutProduct_categoryInput
    connect?: productWhereUniqueInput
    update?: XOR<XOR<productUpdateToOneWithWhereWithoutProduct_categoryInput, productUpdateWithoutProduct_categoryInput>, productUncheckedUpdateWithoutProduct_categoryInput>
  }

  export type publisherCreateNestedOneWithoutPromo_codeInput = {
    create?: XOR<publisherCreateWithoutPromo_codeInput, publisherUncheckedCreateWithoutPromo_codeInput>
    connectOrCreate?: publisherCreateOrConnectWithoutPromo_codeInput
    connect?: publisherWhereUniqueInput
  }

  export type publisherUpdateOneRequiredWithoutPromo_codeNestedInput = {
    create?: XOR<publisherCreateWithoutPromo_codeInput, publisherUncheckedCreateWithoutPromo_codeInput>
    connectOrCreate?: publisherCreateOrConnectWithoutPromo_codeInput
    upsert?: publisherUpsertWithoutPromo_codeInput
    connect?: publisherWhereUniqueInput
    update?: XOR<XOR<publisherUpdateToOneWithWhereWithoutPromo_codeInput, publisherUpdateWithoutPromo_codeInput>, publisherUncheckedUpdateWithoutPromo_codeInput>
  }

  export type auth_userCreateNestedManyWithoutPublisherInput = {
    create?: XOR<auth_userCreateWithoutPublisherInput, auth_userUncheckedCreateWithoutPublisherInput> | auth_userCreateWithoutPublisherInput[] | auth_userUncheckedCreateWithoutPublisherInput[]
    connectOrCreate?: auth_userCreateOrConnectWithoutPublisherInput | auth_userCreateOrConnectWithoutPublisherInput[]
    createMany?: auth_userCreateManyPublisherInputEnvelope
    connect?: auth_userWhereUniqueInput | auth_userWhereUniqueInput[]
  }

  export type promo_codeCreateNestedManyWithoutPublisherInput = {
    create?: XOR<promo_codeCreateWithoutPublisherInput, promo_codeUncheckedCreateWithoutPublisherInput> | promo_codeCreateWithoutPublisherInput[] | promo_codeUncheckedCreateWithoutPublisherInput[]
    connectOrCreate?: promo_codeCreateOrConnectWithoutPublisherInput | promo_codeCreateOrConnectWithoutPublisherInput[]
    createMany?: promo_codeCreateManyPublisherInputEnvelope
    connect?: promo_codeWhereUniqueInput | promo_codeWhereUniqueInput[]
  }

  export type auth_accountCreateNestedOneWithoutPublisherInput = {
    create?: XOR<auth_accountCreateWithoutPublisherInput, auth_accountUncheckedCreateWithoutPublisherInput>
    connectOrCreate?: auth_accountCreateOrConnectWithoutPublisherInput
    connect?: auth_accountWhereUniqueInput
  }

  export type publisher_authorCreateNestedManyWithoutPublisherInput = {
    create?: XOR<publisher_authorCreateWithoutPublisherInput, publisher_authorUncheckedCreateWithoutPublisherInput> | publisher_authorCreateWithoutPublisherInput[] | publisher_authorUncheckedCreateWithoutPublisherInput[]
    connectOrCreate?: publisher_authorCreateOrConnectWithoutPublisherInput | publisher_authorCreateOrConnectWithoutPublisherInput[]
    createMany?: publisher_authorCreateManyPublisherInputEnvelope
    connect?: publisher_authorWhereUniqueInput | publisher_authorWhereUniqueInput[]
  }

  export type t_ai_creditCreateNestedManyWithoutPublisherInput = {
    create?: XOR<t_ai_creditCreateWithoutPublisherInput, t_ai_creditUncheckedCreateWithoutPublisherInput> | t_ai_creditCreateWithoutPublisherInput[] | t_ai_creditUncheckedCreateWithoutPublisherInput[]
    connectOrCreate?: t_ai_creditCreateOrConnectWithoutPublisherInput | t_ai_creditCreateOrConnectWithoutPublisherInput[]
    createMany?: t_ai_creditCreateManyPublisherInputEnvelope
    connect?: t_ai_creditWhereUniqueInput | t_ai_creditWhereUniqueInput[]
  }

  export type transactionCreateNestedManyWithoutPublisherInput = {
    create?: XOR<transactionCreateWithoutPublisherInput, transactionUncheckedCreateWithoutPublisherInput> | transactionCreateWithoutPublisherInput[] | transactionUncheckedCreateWithoutPublisherInput[]
    connectOrCreate?: transactionCreateOrConnectWithoutPublisherInput | transactionCreateOrConnectWithoutPublisherInput[]
    createMany?: transactionCreateManyPublisherInputEnvelope
    connect?: transactionWhereUniqueInput | transactionWhereUniqueInput[]
  }

  export type withdrawalCreateNestedManyWithoutPublisherInput = {
    create?: XOR<withdrawalCreateWithoutPublisherInput, withdrawalUncheckedCreateWithoutPublisherInput> | withdrawalCreateWithoutPublisherInput[] | withdrawalUncheckedCreateWithoutPublisherInput[]
    connectOrCreate?: withdrawalCreateOrConnectWithoutPublisherInput | withdrawalCreateOrConnectWithoutPublisherInput[]
    createMany?: withdrawalCreateManyPublisherInputEnvelope
    connect?: withdrawalWhereUniqueInput | withdrawalWhereUniqueInput[]
  }

  export type auth_userUncheckedCreateNestedManyWithoutPublisherInput = {
    create?: XOR<auth_userCreateWithoutPublisherInput, auth_userUncheckedCreateWithoutPublisherInput> | auth_userCreateWithoutPublisherInput[] | auth_userUncheckedCreateWithoutPublisherInput[]
    connectOrCreate?: auth_userCreateOrConnectWithoutPublisherInput | auth_userCreateOrConnectWithoutPublisherInput[]
    createMany?: auth_userCreateManyPublisherInputEnvelope
    connect?: auth_userWhereUniqueInput | auth_userWhereUniqueInput[]
  }

  export type promo_codeUncheckedCreateNestedManyWithoutPublisherInput = {
    create?: XOR<promo_codeCreateWithoutPublisherInput, promo_codeUncheckedCreateWithoutPublisherInput> | promo_codeCreateWithoutPublisherInput[] | promo_codeUncheckedCreateWithoutPublisherInput[]
    connectOrCreate?: promo_codeCreateOrConnectWithoutPublisherInput | promo_codeCreateOrConnectWithoutPublisherInput[]
    createMany?: promo_codeCreateManyPublisherInputEnvelope
    connect?: promo_codeWhereUniqueInput | promo_codeWhereUniqueInput[]
  }

  export type publisher_authorUncheckedCreateNestedManyWithoutPublisherInput = {
    create?: XOR<publisher_authorCreateWithoutPublisherInput, publisher_authorUncheckedCreateWithoutPublisherInput> | publisher_authorCreateWithoutPublisherInput[] | publisher_authorUncheckedCreateWithoutPublisherInput[]
    connectOrCreate?: publisher_authorCreateOrConnectWithoutPublisherInput | publisher_authorCreateOrConnectWithoutPublisherInput[]
    createMany?: publisher_authorCreateManyPublisherInputEnvelope
    connect?: publisher_authorWhereUniqueInput | publisher_authorWhereUniqueInput[]
  }

  export type t_ai_creditUncheckedCreateNestedManyWithoutPublisherInput = {
    create?: XOR<t_ai_creditCreateWithoutPublisherInput, t_ai_creditUncheckedCreateWithoutPublisherInput> | t_ai_creditCreateWithoutPublisherInput[] | t_ai_creditUncheckedCreateWithoutPublisherInput[]
    connectOrCreate?: t_ai_creditCreateOrConnectWithoutPublisherInput | t_ai_creditCreateOrConnectWithoutPublisherInput[]
    createMany?: t_ai_creditCreateManyPublisherInputEnvelope
    connect?: t_ai_creditWhereUniqueInput | t_ai_creditWhereUniqueInput[]
  }

  export type transactionUncheckedCreateNestedManyWithoutPublisherInput = {
    create?: XOR<transactionCreateWithoutPublisherInput, transactionUncheckedCreateWithoutPublisherInput> | transactionCreateWithoutPublisherInput[] | transactionUncheckedCreateWithoutPublisherInput[]
    connectOrCreate?: transactionCreateOrConnectWithoutPublisherInput | transactionCreateOrConnectWithoutPublisherInput[]
    createMany?: transactionCreateManyPublisherInputEnvelope
    connect?: transactionWhereUniqueInput | transactionWhereUniqueInput[]
  }

  export type withdrawalUncheckedCreateNestedManyWithoutPublisherInput = {
    create?: XOR<withdrawalCreateWithoutPublisherInput, withdrawalUncheckedCreateWithoutPublisherInput> | withdrawalCreateWithoutPublisherInput[] | withdrawalUncheckedCreateWithoutPublisherInput[]
    connectOrCreate?: withdrawalCreateOrConnectWithoutPublisherInput | withdrawalCreateOrConnectWithoutPublisherInput[]
    createMany?: withdrawalCreateManyPublisherInputEnvelope
    connect?: withdrawalWhereUniqueInput | withdrawalWhereUniqueInput[]
  }

  export type auth_userUpdateManyWithoutPublisherNestedInput = {
    create?: XOR<auth_userCreateWithoutPublisherInput, auth_userUncheckedCreateWithoutPublisherInput> | auth_userCreateWithoutPublisherInput[] | auth_userUncheckedCreateWithoutPublisherInput[]
    connectOrCreate?: auth_userCreateOrConnectWithoutPublisherInput | auth_userCreateOrConnectWithoutPublisherInput[]
    upsert?: auth_userUpsertWithWhereUniqueWithoutPublisherInput | auth_userUpsertWithWhereUniqueWithoutPublisherInput[]
    createMany?: auth_userCreateManyPublisherInputEnvelope
    set?: auth_userWhereUniqueInput | auth_userWhereUniqueInput[]
    disconnect?: auth_userWhereUniqueInput | auth_userWhereUniqueInput[]
    delete?: auth_userWhereUniqueInput | auth_userWhereUniqueInput[]
    connect?: auth_userWhereUniqueInput | auth_userWhereUniqueInput[]
    update?: auth_userUpdateWithWhereUniqueWithoutPublisherInput | auth_userUpdateWithWhereUniqueWithoutPublisherInput[]
    updateMany?: auth_userUpdateManyWithWhereWithoutPublisherInput | auth_userUpdateManyWithWhereWithoutPublisherInput[]
    deleteMany?: auth_userScalarWhereInput | auth_userScalarWhereInput[]
  }

  export type promo_codeUpdateManyWithoutPublisherNestedInput = {
    create?: XOR<promo_codeCreateWithoutPublisherInput, promo_codeUncheckedCreateWithoutPublisherInput> | promo_codeCreateWithoutPublisherInput[] | promo_codeUncheckedCreateWithoutPublisherInput[]
    connectOrCreate?: promo_codeCreateOrConnectWithoutPublisherInput | promo_codeCreateOrConnectWithoutPublisherInput[]
    upsert?: promo_codeUpsertWithWhereUniqueWithoutPublisherInput | promo_codeUpsertWithWhereUniqueWithoutPublisherInput[]
    createMany?: promo_codeCreateManyPublisherInputEnvelope
    set?: promo_codeWhereUniqueInput | promo_codeWhereUniqueInput[]
    disconnect?: promo_codeWhereUniqueInput | promo_codeWhereUniqueInput[]
    delete?: promo_codeWhereUniqueInput | promo_codeWhereUniqueInput[]
    connect?: promo_codeWhereUniqueInput | promo_codeWhereUniqueInput[]
    update?: promo_codeUpdateWithWhereUniqueWithoutPublisherInput | promo_codeUpdateWithWhereUniqueWithoutPublisherInput[]
    updateMany?: promo_codeUpdateManyWithWhereWithoutPublisherInput | promo_codeUpdateManyWithWhereWithoutPublisherInput[]
    deleteMany?: promo_codeScalarWhereInput | promo_codeScalarWhereInput[]
  }

  export type auth_accountUpdateOneWithoutPublisherNestedInput = {
    create?: XOR<auth_accountCreateWithoutPublisherInput, auth_accountUncheckedCreateWithoutPublisherInput>
    connectOrCreate?: auth_accountCreateOrConnectWithoutPublisherInput
    upsert?: auth_accountUpsertWithoutPublisherInput
    disconnect?: auth_accountWhereInput | boolean
    delete?: auth_accountWhereInput | boolean
    connect?: auth_accountWhereUniqueInput
    update?: XOR<XOR<auth_accountUpdateToOneWithWhereWithoutPublisherInput, auth_accountUpdateWithoutPublisherInput>, auth_accountUncheckedUpdateWithoutPublisherInput>
  }

  export type publisher_authorUpdateManyWithoutPublisherNestedInput = {
    create?: XOR<publisher_authorCreateWithoutPublisherInput, publisher_authorUncheckedCreateWithoutPublisherInput> | publisher_authorCreateWithoutPublisherInput[] | publisher_authorUncheckedCreateWithoutPublisherInput[]
    connectOrCreate?: publisher_authorCreateOrConnectWithoutPublisherInput | publisher_authorCreateOrConnectWithoutPublisherInput[]
    upsert?: publisher_authorUpsertWithWhereUniqueWithoutPublisherInput | publisher_authorUpsertWithWhereUniqueWithoutPublisherInput[]
    createMany?: publisher_authorCreateManyPublisherInputEnvelope
    set?: publisher_authorWhereUniqueInput | publisher_authorWhereUniqueInput[]
    disconnect?: publisher_authorWhereUniqueInput | publisher_authorWhereUniqueInput[]
    delete?: publisher_authorWhereUniqueInput | publisher_authorWhereUniqueInput[]
    connect?: publisher_authorWhereUniqueInput | publisher_authorWhereUniqueInput[]
    update?: publisher_authorUpdateWithWhereUniqueWithoutPublisherInput | publisher_authorUpdateWithWhereUniqueWithoutPublisherInput[]
    updateMany?: publisher_authorUpdateManyWithWhereWithoutPublisherInput | publisher_authorUpdateManyWithWhereWithoutPublisherInput[]
    deleteMany?: publisher_authorScalarWhereInput | publisher_authorScalarWhereInput[]
  }

  export type t_ai_creditUpdateManyWithoutPublisherNestedInput = {
    create?: XOR<t_ai_creditCreateWithoutPublisherInput, t_ai_creditUncheckedCreateWithoutPublisherInput> | t_ai_creditCreateWithoutPublisherInput[] | t_ai_creditUncheckedCreateWithoutPublisherInput[]
    connectOrCreate?: t_ai_creditCreateOrConnectWithoutPublisherInput | t_ai_creditCreateOrConnectWithoutPublisherInput[]
    upsert?: t_ai_creditUpsertWithWhereUniqueWithoutPublisherInput | t_ai_creditUpsertWithWhereUniqueWithoutPublisherInput[]
    createMany?: t_ai_creditCreateManyPublisherInputEnvelope
    set?: t_ai_creditWhereUniqueInput | t_ai_creditWhereUniqueInput[]
    disconnect?: t_ai_creditWhereUniqueInput | t_ai_creditWhereUniqueInput[]
    delete?: t_ai_creditWhereUniqueInput | t_ai_creditWhereUniqueInput[]
    connect?: t_ai_creditWhereUniqueInput | t_ai_creditWhereUniqueInput[]
    update?: t_ai_creditUpdateWithWhereUniqueWithoutPublisherInput | t_ai_creditUpdateWithWhereUniqueWithoutPublisherInput[]
    updateMany?: t_ai_creditUpdateManyWithWhereWithoutPublisherInput | t_ai_creditUpdateManyWithWhereWithoutPublisherInput[]
    deleteMany?: t_ai_creditScalarWhereInput | t_ai_creditScalarWhereInput[]
  }

  export type transactionUpdateManyWithoutPublisherNestedInput = {
    create?: XOR<transactionCreateWithoutPublisherInput, transactionUncheckedCreateWithoutPublisherInput> | transactionCreateWithoutPublisherInput[] | transactionUncheckedCreateWithoutPublisherInput[]
    connectOrCreate?: transactionCreateOrConnectWithoutPublisherInput | transactionCreateOrConnectWithoutPublisherInput[]
    upsert?: transactionUpsertWithWhereUniqueWithoutPublisherInput | transactionUpsertWithWhereUniqueWithoutPublisherInput[]
    createMany?: transactionCreateManyPublisherInputEnvelope
    set?: transactionWhereUniqueInput | transactionWhereUniqueInput[]
    disconnect?: transactionWhereUniqueInput | transactionWhereUniqueInput[]
    delete?: transactionWhereUniqueInput | transactionWhereUniqueInput[]
    connect?: transactionWhereUniqueInput | transactionWhereUniqueInput[]
    update?: transactionUpdateWithWhereUniqueWithoutPublisherInput | transactionUpdateWithWhereUniqueWithoutPublisherInput[]
    updateMany?: transactionUpdateManyWithWhereWithoutPublisherInput | transactionUpdateManyWithWhereWithoutPublisherInput[]
    deleteMany?: transactionScalarWhereInput | transactionScalarWhereInput[]
  }

  export type withdrawalUpdateManyWithoutPublisherNestedInput = {
    create?: XOR<withdrawalCreateWithoutPublisherInput, withdrawalUncheckedCreateWithoutPublisherInput> | withdrawalCreateWithoutPublisherInput[] | withdrawalUncheckedCreateWithoutPublisherInput[]
    connectOrCreate?: withdrawalCreateOrConnectWithoutPublisherInput | withdrawalCreateOrConnectWithoutPublisherInput[]
    upsert?: withdrawalUpsertWithWhereUniqueWithoutPublisherInput | withdrawalUpsertWithWhereUniqueWithoutPublisherInput[]
    createMany?: withdrawalCreateManyPublisherInputEnvelope
    set?: withdrawalWhereUniqueInput | withdrawalWhereUniqueInput[]
    disconnect?: withdrawalWhereUniqueInput | withdrawalWhereUniqueInput[]
    delete?: withdrawalWhereUniqueInput | withdrawalWhereUniqueInput[]
    connect?: withdrawalWhereUniqueInput | withdrawalWhereUniqueInput[]
    update?: withdrawalUpdateWithWhereUniqueWithoutPublisherInput | withdrawalUpdateWithWhereUniqueWithoutPublisherInput[]
    updateMany?: withdrawalUpdateManyWithWhereWithoutPublisherInput | withdrawalUpdateManyWithWhereWithoutPublisherInput[]
    deleteMany?: withdrawalScalarWhereInput | withdrawalScalarWhereInput[]
  }

  export type auth_userUncheckedUpdateManyWithoutPublisherNestedInput = {
    create?: XOR<auth_userCreateWithoutPublisherInput, auth_userUncheckedCreateWithoutPublisherInput> | auth_userCreateWithoutPublisherInput[] | auth_userUncheckedCreateWithoutPublisherInput[]
    connectOrCreate?: auth_userCreateOrConnectWithoutPublisherInput | auth_userCreateOrConnectWithoutPublisherInput[]
    upsert?: auth_userUpsertWithWhereUniqueWithoutPublisherInput | auth_userUpsertWithWhereUniqueWithoutPublisherInput[]
    createMany?: auth_userCreateManyPublisherInputEnvelope
    set?: auth_userWhereUniqueInput | auth_userWhereUniqueInput[]
    disconnect?: auth_userWhereUniqueInput | auth_userWhereUniqueInput[]
    delete?: auth_userWhereUniqueInput | auth_userWhereUniqueInput[]
    connect?: auth_userWhereUniqueInput | auth_userWhereUniqueInput[]
    update?: auth_userUpdateWithWhereUniqueWithoutPublisherInput | auth_userUpdateWithWhereUniqueWithoutPublisherInput[]
    updateMany?: auth_userUpdateManyWithWhereWithoutPublisherInput | auth_userUpdateManyWithWhereWithoutPublisherInput[]
    deleteMany?: auth_userScalarWhereInput | auth_userScalarWhereInput[]
  }

  export type promo_codeUncheckedUpdateManyWithoutPublisherNestedInput = {
    create?: XOR<promo_codeCreateWithoutPublisherInput, promo_codeUncheckedCreateWithoutPublisherInput> | promo_codeCreateWithoutPublisherInput[] | promo_codeUncheckedCreateWithoutPublisherInput[]
    connectOrCreate?: promo_codeCreateOrConnectWithoutPublisherInput | promo_codeCreateOrConnectWithoutPublisherInput[]
    upsert?: promo_codeUpsertWithWhereUniqueWithoutPublisherInput | promo_codeUpsertWithWhereUniqueWithoutPublisherInput[]
    createMany?: promo_codeCreateManyPublisherInputEnvelope
    set?: promo_codeWhereUniqueInput | promo_codeWhereUniqueInput[]
    disconnect?: promo_codeWhereUniqueInput | promo_codeWhereUniqueInput[]
    delete?: promo_codeWhereUniqueInput | promo_codeWhereUniqueInput[]
    connect?: promo_codeWhereUniqueInput | promo_codeWhereUniqueInput[]
    update?: promo_codeUpdateWithWhereUniqueWithoutPublisherInput | promo_codeUpdateWithWhereUniqueWithoutPublisherInput[]
    updateMany?: promo_codeUpdateManyWithWhereWithoutPublisherInput | promo_codeUpdateManyWithWhereWithoutPublisherInput[]
    deleteMany?: promo_codeScalarWhereInput | promo_codeScalarWhereInput[]
  }

  export type publisher_authorUncheckedUpdateManyWithoutPublisherNestedInput = {
    create?: XOR<publisher_authorCreateWithoutPublisherInput, publisher_authorUncheckedCreateWithoutPublisherInput> | publisher_authorCreateWithoutPublisherInput[] | publisher_authorUncheckedCreateWithoutPublisherInput[]
    connectOrCreate?: publisher_authorCreateOrConnectWithoutPublisherInput | publisher_authorCreateOrConnectWithoutPublisherInput[]
    upsert?: publisher_authorUpsertWithWhereUniqueWithoutPublisherInput | publisher_authorUpsertWithWhereUniqueWithoutPublisherInput[]
    createMany?: publisher_authorCreateManyPublisherInputEnvelope
    set?: publisher_authorWhereUniqueInput | publisher_authorWhereUniqueInput[]
    disconnect?: publisher_authorWhereUniqueInput | publisher_authorWhereUniqueInput[]
    delete?: publisher_authorWhereUniqueInput | publisher_authorWhereUniqueInput[]
    connect?: publisher_authorWhereUniqueInput | publisher_authorWhereUniqueInput[]
    update?: publisher_authorUpdateWithWhereUniqueWithoutPublisherInput | publisher_authorUpdateWithWhereUniqueWithoutPublisherInput[]
    updateMany?: publisher_authorUpdateManyWithWhereWithoutPublisherInput | publisher_authorUpdateManyWithWhereWithoutPublisherInput[]
    deleteMany?: publisher_authorScalarWhereInput | publisher_authorScalarWhereInput[]
  }

  export type t_ai_creditUncheckedUpdateManyWithoutPublisherNestedInput = {
    create?: XOR<t_ai_creditCreateWithoutPublisherInput, t_ai_creditUncheckedCreateWithoutPublisherInput> | t_ai_creditCreateWithoutPublisherInput[] | t_ai_creditUncheckedCreateWithoutPublisherInput[]
    connectOrCreate?: t_ai_creditCreateOrConnectWithoutPublisherInput | t_ai_creditCreateOrConnectWithoutPublisherInput[]
    upsert?: t_ai_creditUpsertWithWhereUniqueWithoutPublisherInput | t_ai_creditUpsertWithWhereUniqueWithoutPublisherInput[]
    createMany?: t_ai_creditCreateManyPublisherInputEnvelope
    set?: t_ai_creditWhereUniqueInput | t_ai_creditWhereUniqueInput[]
    disconnect?: t_ai_creditWhereUniqueInput | t_ai_creditWhereUniqueInput[]
    delete?: t_ai_creditWhereUniqueInput | t_ai_creditWhereUniqueInput[]
    connect?: t_ai_creditWhereUniqueInput | t_ai_creditWhereUniqueInput[]
    update?: t_ai_creditUpdateWithWhereUniqueWithoutPublisherInput | t_ai_creditUpdateWithWhereUniqueWithoutPublisherInput[]
    updateMany?: t_ai_creditUpdateManyWithWhereWithoutPublisherInput | t_ai_creditUpdateManyWithWhereWithoutPublisherInput[]
    deleteMany?: t_ai_creditScalarWhereInput | t_ai_creditScalarWhereInput[]
  }

  export type transactionUncheckedUpdateManyWithoutPublisherNestedInput = {
    create?: XOR<transactionCreateWithoutPublisherInput, transactionUncheckedCreateWithoutPublisherInput> | transactionCreateWithoutPublisherInput[] | transactionUncheckedCreateWithoutPublisherInput[]
    connectOrCreate?: transactionCreateOrConnectWithoutPublisherInput | transactionCreateOrConnectWithoutPublisherInput[]
    upsert?: transactionUpsertWithWhereUniqueWithoutPublisherInput | transactionUpsertWithWhereUniqueWithoutPublisherInput[]
    createMany?: transactionCreateManyPublisherInputEnvelope
    set?: transactionWhereUniqueInput | transactionWhereUniqueInput[]
    disconnect?: transactionWhereUniqueInput | transactionWhereUniqueInput[]
    delete?: transactionWhereUniqueInput | transactionWhereUniqueInput[]
    connect?: transactionWhereUniqueInput | transactionWhereUniqueInput[]
    update?: transactionUpdateWithWhereUniqueWithoutPublisherInput | transactionUpdateWithWhereUniqueWithoutPublisherInput[]
    updateMany?: transactionUpdateManyWithWhereWithoutPublisherInput | transactionUpdateManyWithWhereWithoutPublisherInput[]
    deleteMany?: transactionScalarWhereInput | transactionScalarWhereInput[]
  }

  export type withdrawalUncheckedUpdateManyWithoutPublisherNestedInput = {
    create?: XOR<withdrawalCreateWithoutPublisherInput, withdrawalUncheckedCreateWithoutPublisherInput> | withdrawalCreateWithoutPublisherInput[] | withdrawalUncheckedCreateWithoutPublisherInput[]
    connectOrCreate?: withdrawalCreateOrConnectWithoutPublisherInput | withdrawalCreateOrConnectWithoutPublisherInput[]
    upsert?: withdrawalUpsertWithWhereUniqueWithoutPublisherInput | withdrawalUpsertWithWhereUniqueWithoutPublisherInput[]
    createMany?: withdrawalCreateManyPublisherInputEnvelope
    set?: withdrawalWhereUniqueInput | withdrawalWhereUniqueInput[]
    disconnect?: withdrawalWhereUniqueInput | withdrawalWhereUniqueInput[]
    delete?: withdrawalWhereUniqueInput | withdrawalWhereUniqueInput[]
    connect?: withdrawalWhereUniqueInput | withdrawalWhereUniqueInput[]
    update?: withdrawalUpdateWithWhereUniqueWithoutPublisherInput | withdrawalUpdateWithWhereUniqueWithoutPublisherInput[]
    updateMany?: withdrawalUpdateManyWithWhereWithoutPublisherInput | withdrawalUpdateManyWithWhereWithoutPublisherInput[]
    deleteMany?: withdrawalScalarWhereInput | withdrawalScalarWhereInput[]
  }

  export type authorCreateNestedOneWithoutPublisher_authorInput = {
    create?: XOR<authorCreateWithoutPublisher_authorInput, authorUncheckedCreateWithoutPublisher_authorInput>
    connectOrCreate?: authorCreateOrConnectWithoutPublisher_authorInput
    connect?: authorWhereUniqueInput
  }

  export type publisherCreateNestedOneWithoutPublisher_authorInput = {
    create?: XOR<publisherCreateWithoutPublisher_authorInput, publisherUncheckedCreateWithoutPublisher_authorInput>
    connectOrCreate?: publisherCreateOrConnectWithoutPublisher_authorInput
    connect?: publisherWhereUniqueInput
  }

  export type authorUpdateOneRequiredWithoutPublisher_authorNestedInput = {
    create?: XOR<authorCreateWithoutPublisher_authorInput, authorUncheckedCreateWithoutPublisher_authorInput>
    connectOrCreate?: authorCreateOrConnectWithoutPublisher_authorInput
    upsert?: authorUpsertWithoutPublisher_authorInput
    connect?: authorWhereUniqueInput
    update?: XOR<XOR<authorUpdateToOneWithWhereWithoutPublisher_authorInput, authorUpdateWithoutPublisher_authorInput>, authorUncheckedUpdateWithoutPublisher_authorInput>
  }

  export type publisherUpdateOneRequiredWithoutPublisher_authorNestedInput = {
    create?: XOR<publisherCreateWithoutPublisher_authorInput, publisherUncheckedCreateWithoutPublisher_authorInput>
    connectOrCreate?: publisherCreateOrConnectWithoutPublisher_authorInput
    upsert?: publisherUpsertWithoutPublisher_authorInput
    connect?: publisherWhereUniqueInput
    update?: XOR<XOR<publisherUpdateToOneWithWhereWithoutPublisher_authorInput, publisherUpdateWithoutPublisher_authorInput>, publisherUncheckedUpdateWithoutPublisher_authorInput>
  }

  export type bookCreateNestedOneWithoutRankingInput = {
    create?: XOR<bookCreateWithoutRankingInput, bookUncheckedCreateWithoutRankingInput>
    connectOrCreate?: bookCreateOrConnectWithoutRankingInput
    connect?: bookWhereUniqueInput
  }

  export type bookUpdateOneRequiredWithoutRankingNestedInput = {
    create?: XOR<bookCreateWithoutRankingInput, bookUncheckedCreateWithoutRankingInput>
    connectOrCreate?: bookCreateOrConnectWithoutRankingInput
    upsert?: bookUpsertWithoutRankingInput
    connect?: bookWhereUniqueInput
    update?: XOR<XOR<bookUpdateToOneWithWhereWithoutRankingInput, bookUpdateWithoutRankingInput>, bookUncheckedUpdateWithoutRankingInput>
  }

  export type bookCreateNestedOneWithoutReviewsInput = {
    create?: XOR<bookCreateWithoutReviewsInput, bookUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: bookCreateOrConnectWithoutReviewsInput
    connect?: bookWhereUniqueInput
  }

  export type auth_userCreateNestedOneWithoutReviewsInput = {
    create?: XOR<auth_userCreateWithoutReviewsInput, auth_userUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: auth_userCreateOrConnectWithoutReviewsInput
    connect?: auth_userWhereUniqueInput
  }

  export type reviews_likesCreateNestedManyWithoutReviewsInput = {
    create?: XOR<reviews_likesCreateWithoutReviewsInput, reviews_likesUncheckedCreateWithoutReviewsInput> | reviews_likesCreateWithoutReviewsInput[] | reviews_likesUncheckedCreateWithoutReviewsInput[]
    connectOrCreate?: reviews_likesCreateOrConnectWithoutReviewsInput | reviews_likesCreateOrConnectWithoutReviewsInput[]
    createMany?: reviews_likesCreateManyReviewsInputEnvelope
    connect?: reviews_likesWhereUniqueInput | reviews_likesWhereUniqueInput[]
  }

  export type reviews_likesUncheckedCreateNestedManyWithoutReviewsInput = {
    create?: XOR<reviews_likesCreateWithoutReviewsInput, reviews_likesUncheckedCreateWithoutReviewsInput> | reviews_likesCreateWithoutReviewsInput[] | reviews_likesUncheckedCreateWithoutReviewsInput[]
    connectOrCreate?: reviews_likesCreateOrConnectWithoutReviewsInput | reviews_likesCreateOrConnectWithoutReviewsInput[]
    createMany?: reviews_likesCreateManyReviewsInputEnvelope
    connect?: reviews_likesWhereUniqueInput | reviews_likesWhereUniqueInput[]
  }

  export type bookUpdateOneRequiredWithoutReviewsNestedInput = {
    create?: XOR<bookCreateWithoutReviewsInput, bookUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: bookCreateOrConnectWithoutReviewsInput
    upsert?: bookUpsertWithoutReviewsInput
    connect?: bookWhereUniqueInput
    update?: XOR<XOR<bookUpdateToOneWithWhereWithoutReviewsInput, bookUpdateWithoutReviewsInput>, bookUncheckedUpdateWithoutReviewsInput>
  }

  export type auth_userUpdateOneRequiredWithoutReviewsNestedInput = {
    create?: XOR<auth_userCreateWithoutReviewsInput, auth_userUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: auth_userCreateOrConnectWithoutReviewsInput
    upsert?: auth_userUpsertWithoutReviewsInput
    connect?: auth_userWhereUniqueInput
    update?: XOR<XOR<auth_userUpdateToOneWithWhereWithoutReviewsInput, auth_userUpdateWithoutReviewsInput>, auth_userUncheckedUpdateWithoutReviewsInput>
  }

  export type reviews_likesUpdateManyWithoutReviewsNestedInput = {
    create?: XOR<reviews_likesCreateWithoutReviewsInput, reviews_likesUncheckedCreateWithoutReviewsInput> | reviews_likesCreateWithoutReviewsInput[] | reviews_likesUncheckedCreateWithoutReviewsInput[]
    connectOrCreate?: reviews_likesCreateOrConnectWithoutReviewsInput | reviews_likesCreateOrConnectWithoutReviewsInput[]
    upsert?: reviews_likesUpsertWithWhereUniqueWithoutReviewsInput | reviews_likesUpsertWithWhereUniqueWithoutReviewsInput[]
    createMany?: reviews_likesCreateManyReviewsInputEnvelope
    set?: reviews_likesWhereUniqueInput | reviews_likesWhereUniqueInput[]
    disconnect?: reviews_likesWhereUniqueInput | reviews_likesWhereUniqueInput[]
    delete?: reviews_likesWhereUniqueInput | reviews_likesWhereUniqueInput[]
    connect?: reviews_likesWhereUniqueInput | reviews_likesWhereUniqueInput[]
    update?: reviews_likesUpdateWithWhereUniqueWithoutReviewsInput | reviews_likesUpdateWithWhereUniqueWithoutReviewsInput[]
    updateMany?: reviews_likesUpdateManyWithWhereWithoutReviewsInput | reviews_likesUpdateManyWithWhereWithoutReviewsInput[]
    deleteMany?: reviews_likesScalarWhereInput | reviews_likesScalarWhereInput[]
  }

  export type reviews_likesUncheckedUpdateManyWithoutReviewsNestedInput = {
    create?: XOR<reviews_likesCreateWithoutReviewsInput, reviews_likesUncheckedCreateWithoutReviewsInput> | reviews_likesCreateWithoutReviewsInput[] | reviews_likesUncheckedCreateWithoutReviewsInput[]
    connectOrCreate?: reviews_likesCreateOrConnectWithoutReviewsInput | reviews_likesCreateOrConnectWithoutReviewsInput[]
    upsert?: reviews_likesUpsertWithWhereUniqueWithoutReviewsInput | reviews_likesUpsertWithWhereUniqueWithoutReviewsInput[]
    createMany?: reviews_likesCreateManyReviewsInputEnvelope
    set?: reviews_likesWhereUniqueInput | reviews_likesWhereUniqueInput[]
    disconnect?: reviews_likesWhereUniqueInput | reviews_likesWhereUniqueInput[]
    delete?: reviews_likesWhereUniqueInput | reviews_likesWhereUniqueInput[]
    connect?: reviews_likesWhereUniqueInput | reviews_likesWhereUniqueInput[]
    update?: reviews_likesUpdateWithWhereUniqueWithoutReviewsInput | reviews_likesUpdateWithWhereUniqueWithoutReviewsInput[]
    updateMany?: reviews_likesUpdateManyWithWhereWithoutReviewsInput | reviews_likesUpdateManyWithWhereWithoutReviewsInput[]
    deleteMany?: reviews_likesScalarWhereInput | reviews_likesScalarWhereInput[]
  }

  export type reviewsCreateNestedOneWithoutReviews_likesInput = {
    create?: XOR<reviewsCreateWithoutReviews_likesInput, reviewsUncheckedCreateWithoutReviews_likesInput>
    connectOrCreate?: reviewsCreateOrConnectWithoutReviews_likesInput
    connect?: reviewsWhereUniqueInput
  }

  export type auth_userCreateNestedOneWithoutReviews_likesInput = {
    create?: XOR<auth_userCreateWithoutReviews_likesInput, auth_userUncheckedCreateWithoutReviews_likesInput>
    connectOrCreate?: auth_userCreateOrConnectWithoutReviews_likesInput
    connect?: auth_userWhereUniqueInput
  }

  export type reviewsUpdateOneRequiredWithoutReviews_likesNestedInput = {
    create?: XOR<reviewsCreateWithoutReviews_likesInput, reviewsUncheckedCreateWithoutReviews_likesInput>
    connectOrCreate?: reviewsCreateOrConnectWithoutReviews_likesInput
    upsert?: reviewsUpsertWithoutReviews_likesInput
    connect?: reviewsWhereUniqueInput
    update?: XOR<XOR<reviewsUpdateToOneWithWhereWithoutReviews_likesInput, reviewsUpdateWithoutReviews_likesInput>, reviewsUncheckedUpdateWithoutReviews_likesInput>
  }

  export type auth_userUpdateOneRequiredWithoutReviews_likesNestedInput = {
    create?: XOR<auth_userCreateWithoutReviews_likesInput, auth_userUncheckedCreateWithoutReviews_likesInput>
    connectOrCreate?: auth_userCreateOrConnectWithoutReviews_likesInput
    upsert?: auth_userUpsertWithoutReviews_likesInput
    connect?: auth_userWhereUniqueInput
    update?: XOR<XOR<auth_userUpdateToOneWithWhereWithoutReviews_likesInput, auth_userUpdateWithoutReviews_likesInput>, auth_userUncheckedUpdateWithoutReviews_likesInput>
  }

  export type publisherCreateNestedOneWithoutT_ai_creditInput = {
    create?: XOR<publisherCreateWithoutT_ai_creditInput, publisherUncheckedCreateWithoutT_ai_creditInput>
    connectOrCreate?: publisherCreateOrConnectWithoutT_ai_creditInput
    connect?: publisherWhereUniqueInput
  }

  export type t_ai_credit_topupCreateNestedManyWithoutT_ai_creditInput = {
    create?: XOR<t_ai_credit_topupCreateWithoutT_ai_creditInput, t_ai_credit_topupUncheckedCreateWithoutT_ai_creditInput> | t_ai_credit_topupCreateWithoutT_ai_creditInput[] | t_ai_credit_topupUncheckedCreateWithoutT_ai_creditInput[]
    connectOrCreate?: t_ai_credit_topupCreateOrConnectWithoutT_ai_creditInput | t_ai_credit_topupCreateOrConnectWithoutT_ai_creditInput[]
    createMany?: t_ai_credit_topupCreateManyT_ai_creditInputEnvelope
    connect?: t_ai_credit_topupWhereUniqueInput | t_ai_credit_topupWhereUniqueInput[]
  }

  export type t_ai_credit_topupUncheckedCreateNestedManyWithoutT_ai_creditInput = {
    create?: XOR<t_ai_credit_topupCreateWithoutT_ai_creditInput, t_ai_credit_topupUncheckedCreateWithoutT_ai_creditInput> | t_ai_credit_topupCreateWithoutT_ai_creditInput[] | t_ai_credit_topupUncheckedCreateWithoutT_ai_creditInput[]
    connectOrCreate?: t_ai_credit_topupCreateOrConnectWithoutT_ai_creditInput | t_ai_credit_topupCreateOrConnectWithoutT_ai_creditInput[]
    createMany?: t_ai_credit_topupCreateManyT_ai_creditInputEnvelope
    connect?: t_ai_credit_topupWhereUniqueInput | t_ai_credit_topupWhereUniqueInput[]
  }

  export type publisherUpdateOneRequiredWithoutT_ai_creditNestedInput = {
    create?: XOR<publisherCreateWithoutT_ai_creditInput, publisherUncheckedCreateWithoutT_ai_creditInput>
    connectOrCreate?: publisherCreateOrConnectWithoutT_ai_creditInput
    upsert?: publisherUpsertWithoutT_ai_creditInput
    connect?: publisherWhereUniqueInput
    update?: XOR<XOR<publisherUpdateToOneWithWhereWithoutT_ai_creditInput, publisherUpdateWithoutT_ai_creditInput>, publisherUncheckedUpdateWithoutT_ai_creditInput>
  }

  export type t_ai_credit_topupUpdateManyWithoutT_ai_creditNestedInput = {
    create?: XOR<t_ai_credit_topupCreateWithoutT_ai_creditInput, t_ai_credit_topupUncheckedCreateWithoutT_ai_creditInput> | t_ai_credit_topupCreateWithoutT_ai_creditInput[] | t_ai_credit_topupUncheckedCreateWithoutT_ai_creditInput[]
    connectOrCreate?: t_ai_credit_topupCreateOrConnectWithoutT_ai_creditInput | t_ai_credit_topupCreateOrConnectWithoutT_ai_creditInput[]
    upsert?: t_ai_credit_topupUpsertWithWhereUniqueWithoutT_ai_creditInput | t_ai_credit_topupUpsertWithWhereUniqueWithoutT_ai_creditInput[]
    createMany?: t_ai_credit_topupCreateManyT_ai_creditInputEnvelope
    set?: t_ai_credit_topupWhereUniqueInput | t_ai_credit_topupWhereUniqueInput[]
    disconnect?: t_ai_credit_topupWhereUniqueInput | t_ai_credit_topupWhereUniqueInput[]
    delete?: t_ai_credit_topupWhereUniqueInput | t_ai_credit_topupWhereUniqueInput[]
    connect?: t_ai_credit_topupWhereUniqueInput | t_ai_credit_topupWhereUniqueInput[]
    update?: t_ai_credit_topupUpdateWithWhereUniqueWithoutT_ai_creditInput | t_ai_credit_topupUpdateWithWhereUniqueWithoutT_ai_creditInput[]
    updateMany?: t_ai_credit_topupUpdateManyWithWhereWithoutT_ai_creditInput | t_ai_credit_topupUpdateManyWithWhereWithoutT_ai_creditInput[]
    deleteMany?: t_ai_credit_topupScalarWhereInput | t_ai_credit_topupScalarWhereInput[]
  }

  export type t_ai_credit_topupUncheckedUpdateManyWithoutT_ai_creditNestedInput = {
    create?: XOR<t_ai_credit_topupCreateWithoutT_ai_creditInput, t_ai_credit_topupUncheckedCreateWithoutT_ai_creditInput> | t_ai_credit_topupCreateWithoutT_ai_creditInput[] | t_ai_credit_topupUncheckedCreateWithoutT_ai_creditInput[]
    connectOrCreate?: t_ai_credit_topupCreateOrConnectWithoutT_ai_creditInput | t_ai_credit_topupCreateOrConnectWithoutT_ai_creditInput[]
    upsert?: t_ai_credit_topupUpsertWithWhereUniqueWithoutT_ai_creditInput | t_ai_credit_topupUpsertWithWhereUniqueWithoutT_ai_creditInput[]
    createMany?: t_ai_credit_topupCreateManyT_ai_creditInputEnvelope
    set?: t_ai_credit_topupWhereUniqueInput | t_ai_credit_topupWhereUniqueInput[]
    disconnect?: t_ai_credit_topupWhereUniqueInput | t_ai_credit_topupWhereUniqueInput[]
    delete?: t_ai_credit_topupWhereUniqueInput | t_ai_credit_topupWhereUniqueInput[]
    connect?: t_ai_credit_topupWhereUniqueInput | t_ai_credit_topupWhereUniqueInput[]
    update?: t_ai_credit_topupUpdateWithWhereUniqueWithoutT_ai_creditInput | t_ai_credit_topupUpdateWithWhereUniqueWithoutT_ai_creditInput[]
    updateMany?: t_ai_credit_topupUpdateManyWithWhereWithoutT_ai_creditInput | t_ai_credit_topupUpdateManyWithWhereWithoutT_ai_creditInput[]
    deleteMany?: t_ai_credit_topupScalarWhereInput | t_ai_credit_topupScalarWhereInput[]
  }

  export type t_ai_creditCreateNestedOneWithoutT_ai_credit_topupInput = {
    create?: XOR<t_ai_creditCreateWithoutT_ai_credit_topupInput, t_ai_creditUncheckedCreateWithoutT_ai_credit_topupInput>
    connectOrCreate?: t_ai_creditCreateOrConnectWithoutT_ai_credit_topupInput
    connect?: t_ai_creditWhereUniqueInput
  }

  export type t_ai_creditUpdateOneRequiredWithoutT_ai_credit_topupNestedInput = {
    create?: XOR<t_ai_creditCreateWithoutT_ai_credit_topupInput, t_ai_creditUncheckedCreateWithoutT_ai_credit_topupInput>
    connectOrCreate?: t_ai_creditCreateOrConnectWithoutT_ai_credit_topupInput
    upsert?: t_ai_creditUpsertWithoutT_ai_credit_topupInput
    connect?: t_ai_creditWhereUniqueInput
    update?: XOR<XOR<t_ai_creditUpdateToOneWithWhereWithoutT_ai_credit_topupInput, t_ai_creditUpdateWithoutT_ai_credit_topupInput>, t_ai_creditUncheckedUpdateWithoutT_ai_credit_topupInput>
  }

  export type customerCreateNestedOneWithoutT_salesInput = {
    create?: XOR<customerCreateWithoutT_salesInput, customerUncheckedCreateWithoutT_salesInput>
    connectOrCreate?: customerCreateOrConnectWithoutT_salesInput
    connect?: customerWhereUniqueInput
  }

  export type t_sales_lineCreateNestedManyWithoutT_salesInput = {
    create?: XOR<t_sales_lineCreateWithoutT_salesInput, t_sales_lineUncheckedCreateWithoutT_salesInput> | t_sales_lineCreateWithoutT_salesInput[] | t_sales_lineUncheckedCreateWithoutT_salesInput[]
    connectOrCreate?: t_sales_lineCreateOrConnectWithoutT_salesInput | t_sales_lineCreateOrConnectWithoutT_salesInput[]
    createMany?: t_sales_lineCreateManyT_salesInputEnvelope
    connect?: t_sales_lineWhereUniqueInput | t_sales_lineWhereUniqueInput[]
  }

  export type t_sales_lineUncheckedCreateNestedManyWithoutT_salesInput = {
    create?: XOR<t_sales_lineCreateWithoutT_salesInput, t_sales_lineUncheckedCreateWithoutT_salesInput> | t_sales_lineCreateWithoutT_salesInput[] | t_sales_lineUncheckedCreateWithoutT_salesInput[]
    connectOrCreate?: t_sales_lineCreateOrConnectWithoutT_salesInput | t_sales_lineCreateOrConnectWithoutT_salesInput[]
    createMany?: t_sales_lineCreateManyT_salesInputEnvelope
    connect?: t_sales_lineWhereUniqueInput | t_sales_lineWhereUniqueInput[]
  }

  export type customerUpdateOneRequiredWithoutT_salesNestedInput = {
    create?: XOR<customerCreateWithoutT_salesInput, customerUncheckedCreateWithoutT_salesInput>
    connectOrCreate?: customerCreateOrConnectWithoutT_salesInput
    upsert?: customerUpsertWithoutT_salesInput
    connect?: customerWhereUniqueInput
    update?: XOR<XOR<customerUpdateToOneWithWhereWithoutT_salesInput, customerUpdateWithoutT_salesInput>, customerUncheckedUpdateWithoutT_salesInput>
  }

  export type t_sales_lineUpdateManyWithoutT_salesNestedInput = {
    create?: XOR<t_sales_lineCreateWithoutT_salesInput, t_sales_lineUncheckedCreateWithoutT_salesInput> | t_sales_lineCreateWithoutT_salesInput[] | t_sales_lineUncheckedCreateWithoutT_salesInput[]
    connectOrCreate?: t_sales_lineCreateOrConnectWithoutT_salesInput | t_sales_lineCreateOrConnectWithoutT_salesInput[]
    upsert?: t_sales_lineUpsertWithWhereUniqueWithoutT_salesInput | t_sales_lineUpsertWithWhereUniqueWithoutT_salesInput[]
    createMany?: t_sales_lineCreateManyT_salesInputEnvelope
    set?: t_sales_lineWhereUniqueInput | t_sales_lineWhereUniqueInput[]
    disconnect?: t_sales_lineWhereUniqueInput | t_sales_lineWhereUniqueInput[]
    delete?: t_sales_lineWhereUniqueInput | t_sales_lineWhereUniqueInput[]
    connect?: t_sales_lineWhereUniqueInput | t_sales_lineWhereUniqueInput[]
    update?: t_sales_lineUpdateWithWhereUniqueWithoutT_salesInput | t_sales_lineUpdateWithWhereUniqueWithoutT_salesInput[]
    updateMany?: t_sales_lineUpdateManyWithWhereWithoutT_salesInput | t_sales_lineUpdateManyWithWhereWithoutT_salesInput[]
    deleteMany?: t_sales_lineScalarWhereInput | t_sales_lineScalarWhereInput[]
  }

  export type t_sales_lineUncheckedUpdateManyWithoutT_salesNestedInput = {
    create?: XOR<t_sales_lineCreateWithoutT_salesInput, t_sales_lineUncheckedCreateWithoutT_salesInput> | t_sales_lineCreateWithoutT_salesInput[] | t_sales_lineUncheckedCreateWithoutT_salesInput[]
    connectOrCreate?: t_sales_lineCreateOrConnectWithoutT_salesInput | t_sales_lineCreateOrConnectWithoutT_salesInput[]
    upsert?: t_sales_lineUpsertWithWhereUniqueWithoutT_salesInput | t_sales_lineUpsertWithWhereUniqueWithoutT_salesInput[]
    createMany?: t_sales_lineCreateManyT_salesInputEnvelope
    set?: t_sales_lineWhereUniqueInput | t_sales_lineWhereUniqueInput[]
    disconnect?: t_sales_lineWhereUniqueInput | t_sales_lineWhereUniqueInput[]
    delete?: t_sales_lineWhereUniqueInput | t_sales_lineWhereUniqueInput[]
    connect?: t_sales_lineWhereUniqueInput | t_sales_lineWhereUniqueInput[]
    update?: t_sales_lineUpdateWithWhereUniqueWithoutT_salesInput | t_sales_lineUpdateWithWhereUniqueWithoutT_salesInput[]
    updateMany?: t_sales_lineUpdateManyWithWhereWithoutT_salesInput | t_sales_lineUpdateManyWithWhereWithoutT_salesInput[]
    deleteMany?: t_sales_lineScalarWhereInput | t_sales_lineScalarWhereInput[]
  }

  export type customerCreateNestedOneWithoutT_sales_downloadInput = {
    create?: XOR<customerCreateWithoutT_sales_downloadInput, customerUncheckedCreateWithoutT_sales_downloadInput>
    connectOrCreate?: customerCreateOrConnectWithoutT_sales_downloadInput
    connect?: customerWhereUniqueInput
  }

  export type productCreateNestedOneWithoutT_sales_downloadInput = {
    create?: XOR<productCreateWithoutT_sales_downloadInput, productUncheckedCreateWithoutT_sales_downloadInput>
    connectOrCreate?: productCreateOrConnectWithoutT_sales_downloadInput
    connect?: productWhereUniqueInput
  }

  export type customerUpdateOneRequiredWithoutT_sales_downloadNestedInput = {
    create?: XOR<customerCreateWithoutT_sales_downloadInput, customerUncheckedCreateWithoutT_sales_downloadInput>
    connectOrCreate?: customerCreateOrConnectWithoutT_sales_downloadInput
    upsert?: customerUpsertWithoutT_sales_downloadInput
    connect?: customerWhereUniqueInput
    update?: XOR<XOR<customerUpdateToOneWithWhereWithoutT_sales_downloadInput, customerUpdateWithoutT_sales_downloadInput>, customerUncheckedUpdateWithoutT_sales_downloadInput>
  }

  export type productUpdateOneRequiredWithoutT_sales_downloadNestedInput = {
    create?: XOR<productCreateWithoutT_sales_downloadInput, productUncheckedCreateWithoutT_sales_downloadInput>
    connectOrCreate?: productCreateOrConnectWithoutT_sales_downloadInput
    upsert?: productUpsertWithoutT_sales_downloadInput
    connect?: productWhereUniqueInput
    update?: XOR<XOR<productUpdateToOneWithWhereWithoutT_sales_downloadInput, productUpdateWithoutT_sales_downloadInput>, productUncheckedUpdateWithoutT_sales_downloadInput>
  }

  export type bundleCreateNestedOneWithoutT_sales_lineInput = {
    create?: XOR<bundleCreateWithoutT_sales_lineInput, bundleUncheckedCreateWithoutT_sales_lineInput>
    connectOrCreate?: bundleCreateOrConnectWithoutT_sales_lineInput
    connect?: bundleWhereUniqueInput
  }

  export type productCreateNestedOneWithoutT_sales_lineInput = {
    create?: XOR<productCreateWithoutT_sales_lineInput, productUncheckedCreateWithoutT_sales_lineInput>
    connectOrCreate?: productCreateOrConnectWithoutT_sales_lineInput
    connect?: productWhereUniqueInput
  }

  export type t_salesCreateNestedOneWithoutT_sales_lineInput = {
    create?: XOR<t_salesCreateWithoutT_sales_lineInput, t_salesUncheckedCreateWithoutT_sales_lineInput>
    connectOrCreate?: t_salesCreateOrConnectWithoutT_sales_lineInput
    connect?: t_salesWhereUniqueInput
  }

  export type bundleUpdateOneWithoutT_sales_lineNestedInput = {
    create?: XOR<bundleCreateWithoutT_sales_lineInput, bundleUncheckedCreateWithoutT_sales_lineInput>
    connectOrCreate?: bundleCreateOrConnectWithoutT_sales_lineInput
    upsert?: bundleUpsertWithoutT_sales_lineInput
    disconnect?: bundleWhereInput | boolean
    delete?: bundleWhereInput | boolean
    connect?: bundleWhereUniqueInput
    update?: XOR<XOR<bundleUpdateToOneWithWhereWithoutT_sales_lineInput, bundleUpdateWithoutT_sales_lineInput>, bundleUncheckedUpdateWithoutT_sales_lineInput>
  }

  export type productUpdateOneWithoutT_sales_lineNestedInput = {
    create?: XOR<productCreateWithoutT_sales_lineInput, productUncheckedCreateWithoutT_sales_lineInput>
    connectOrCreate?: productCreateOrConnectWithoutT_sales_lineInput
    upsert?: productUpsertWithoutT_sales_lineInput
    disconnect?: productWhereInput | boolean
    delete?: productWhereInput | boolean
    connect?: productWhereUniqueInput
    update?: XOR<XOR<productUpdateToOneWithWhereWithoutT_sales_lineInput, productUpdateWithoutT_sales_lineInput>, productUncheckedUpdateWithoutT_sales_lineInput>
  }

  export type t_salesUpdateOneRequiredWithoutT_sales_lineNestedInput = {
    create?: XOR<t_salesCreateWithoutT_sales_lineInput, t_salesUncheckedCreateWithoutT_sales_lineInput>
    connectOrCreate?: t_salesCreateOrConnectWithoutT_sales_lineInput
    upsert?: t_salesUpsertWithoutT_sales_lineInput
    connect?: t_salesWhereUniqueInput
    update?: XOR<XOR<t_salesUpdateToOneWithWhereWithoutT_sales_lineInput, t_salesUpdateWithoutT_sales_lineInput>, t_salesUncheckedUpdateWithoutT_sales_lineInput>
  }

  export type book_tagsCreateNestedManyWithoutTagsInput = {
    create?: XOR<book_tagsCreateWithoutTagsInput, book_tagsUncheckedCreateWithoutTagsInput> | book_tagsCreateWithoutTagsInput[] | book_tagsUncheckedCreateWithoutTagsInput[]
    connectOrCreate?: book_tagsCreateOrConnectWithoutTagsInput | book_tagsCreateOrConnectWithoutTagsInput[]
    createMany?: book_tagsCreateManyTagsInputEnvelope
    connect?: book_tagsWhereUniqueInput | book_tagsWhereUniqueInput[]
  }

  export type tagsCreateNestedOneWithoutOther_tagsInput = {
    create?: XOR<tagsCreateWithoutOther_tagsInput, tagsUncheckedCreateWithoutOther_tagsInput>
    connectOrCreate?: tagsCreateOrConnectWithoutOther_tagsInput
    connect?: tagsWhereUniqueInput
  }

  export type tagsCreateNestedManyWithoutTagsInput = {
    create?: XOR<tagsCreateWithoutTagsInput, tagsUncheckedCreateWithoutTagsInput> | tagsCreateWithoutTagsInput[] | tagsUncheckedCreateWithoutTagsInput[]
    connectOrCreate?: tagsCreateOrConnectWithoutTagsInput | tagsCreateOrConnectWithoutTagsInput[]
    createMany?: tagsCreateManyTagsInputEnvelope
    connect?: tagsWhereUniqueInput | tagsWhereUniqueInput[]
  }

  export type book_tagsUncheckedCreateNestedManyWithoutTagsInput = {
    create?: XOR<book_tagsCreateWithoutTagsInput, book_tagsUncheckedCreateWithoutTagsInput> | book_tagsCreateWithoutTagsInput[] | book_tagsUncheckedCreateWithoutTagsInput[]
    connectOrCreate?: book_tagsCreateOrConnectWithoutTagsInput | book_tagsCreateOrConnectWithoutTagsInput[]
    createMany?: book_tagsCreateManyTagsInputEnvelope
    connect?: book_tagsWhereUniqueInput | book_tagsWhereUniqueInput[]
  }

  export type tagsUncheckedCreateNestedManyWithoutTagsInput = {
    create?: XOR<tagsCreateWithoutTagsInput, tagsUncheckedCreateWithoutTagsInput> | tagsCreateWithoutTagsInput[] | tagsUncheckedCreateWithoutTagsInput[]
    connectOrCreate?: tagsCreateOrConnectWithoutTagsInput | tagsCreateOrConnectWithoutTagsInput[]
    createMany?: tagsCreateManyTagsInputEnvelope
    connect?: tagsWhereUniqueInput | tagsWhereUniqueInput[]
  }

  export type book_tagsUpdateManyWithoutTagsNestedInput = {
    create?: XOR<book_tagsCreateWithoutTagsInput, book_tagsUncheckedCreateWithoutTagsInput> | book_tagsCreateWithoutTagsInput[] | book_tagsUncheckedCreateWithoutTagsInput[]
    connectOrCreate?: book_tagsCreateOrConnectWithoutTagsInput | book_tagsCreateOrConnectWithoutTagsInput[]
    upsert?: book_tagsUpsertWithWhereUniqueWithoutTagsInput | book_tagsUpsertWithWhereUniqueWithoutTagsInput[]
    createMany?: book_tagsCreateManyTagsInputEnvelope
    set?: book_tagsWhereUniqueInput | book_tagsWhereUniqueInput[]
    disconnect?: book_tagsWhereUniqueInput | book_tagsWhereUniqueInput[]
    delete?: book_tagsWhereUniqueInput | book_tagsWhereUniqueInput[]
    connect?: book_tagsWhereUniqueInput | book_tagsWhereUniqueInput[]
    update?: book_tagsUpdateWithWhereUniqueWithoutTagsInput | book_tagsUpdateWithWhereUniqueWithoutTagsInput[]
    updateMany?: book_tagsUpdateManyWithWhereWithoutTagsInput | book_tagsUpdateManyWithWhereWithoutTagsInput[]
    deleteMany?: book_tagsScalarWhereInput | book_tagsScalarWhereInput[]
  }

  export type tagsUpdateOneWithoutOther_tagsNestedInput = {
    create?: XOR<tagsCreateWithoutOther_tagsInput, tagsUncheckedCreateWithoutOther_tagsInput>
    connectOrCreate?: tagsCreateOrConnectWithoutOther_tagsInput
    upsert?: tagsUpsertWithoutOther_tagsInput
    disconnect?: tagsWhereInput | boolean
    delete?: tagsWhereInput | boolean
    connect?: tagsWhereUniqueInput
    update?: XOR<XOR<tagsUpdateToOneWithWhereWithoutOther_tagsInput, tagsUpdateWithoutOther_tagsInput>, tagsUncheckedUpdateWithoutOther_tagsInput>
  }

  export type tagsUpdateManyWithoutTagsNestedInput = {
    create?: XOR<tagsCreateWithoutTagsInput, tagsUncheckedCreateWithoutTagsInput> | tagsCreateWithoutTagsInput[] | tagsUncheckedCreateWithoutTagsInput[]
    connectOrCreate?: tagsCreateOrConnectWithoutTagsInput | tagsCreateOrConnectWithoutTagsInput[]
    upsert?: tagsUpsertWithWhereUniqueWithoutTagsInput | tagsUpsertWithWhereUniqueWithoutTagsInput[]
    createMany?: tagsCreateManyTagsInputEnvelope
    set?: tagsWhereUniqueInput | tagsWhereUniqueInput[]
    disconnect?: tagsWhereUniqueInput | tagsWhereUniqueInput[]
    delete?: tagsWhereUniqueInput | tagsWhereUniqueInput[]
    connect?: tagsWhereUniqueInput | tagsWhereUniqueInput[]
    update?: tagsUpdateWithWhereUniqueWithoutTagsInput | tagsUpdateWithWhereUniqueWithoutTagsInput[]
    updateMany?: tagsUpdateManyWithWhereWithoutTagsInput | tagsUpdateManyWithWhereWithoutTagsInput[]
    deleteMany?: tagsScalarWhereInput | tagsScalarWhereInput[]
  }

  export type book_tagsUncheckedUpdateManyWithoutTagsNestedInput = {
    create?: XOR<book_tagsCreateWithoutTagsInput, book_tagsUncheckedCreateWithoutTagsInput> | book_tagsCreateWithoutTagsInput[] | book_tagsUncheckedCreateWithoutTagsInput[]
    connectOrCreate?: book_tagsCreateOrConnectWithoutTagsInput | book_tagsCreateOrConnectWithoutTagsInput[]
    upsert?: book_tagsUpsertWithWhereUniqueWithoutTagsInput | book_tagsUpsertWithWhereUniqueWithoutTagsInput[]
    createMany?: book_tagsCreateManyTagsInputEnvelope
    set?: book_tagsWhereUniqueInput | book_tagsWhereUniqueInput[]
    disconnect?: book_tagsWhereUniqueInput | book_tagsWhereUniqueInput[]
    delete?: book_tagsWhereUniqueInput | book_tagsWhereUniqueInput[]
    connect?: book_tagsWhereUniqueInput | book_tagsWhereUniqueInput[]
    update?: book_tagsUpdateWithWhereUniqueWithoutTagsInput | book_tagsUpdateWithWhereUniqueWithoutTagsInput[]
    updateMany?: book_tagsUpdateManyWithWhereWithoutTagsInput | book_tagsUpdateManyWithWhereWithoutTagsInput[]
    deleteMany?: book_tagsScalarWhereInput | book_tagsScalarWhereInput[]
  }

  export type tagsUncheckedUpdateManyWithoutTagsNestedInput = {
    create?: XOR<tagsCreateWithoutTagsInput, tagsUncheckedCreateWithoutTagsInput> | tagsCreateWithoutTagsInput[] | tagsUncheckedCreateWithoutTagsInput[]
    connectOrCreate?: tagsCreateOrConnectWithoutTagsInput | tagsCreateOrConnectWithoutTagsInput[]
    upsert?: tagsUpsertWithWhereUniqueWithoutTagsInput | tagsUpsertWithWhereUniqueWithoutTagsInput[]
    createMany?: tagsCreateManyTagsInputEnvelope
    set?: tagsWhereUniqueInput | tagsWhereUniqueInput[]
    disconnect?: tagsWhereUniqueInput | tagsWhereUniqueInput[]
    delete?: tagsWhereUniqueInput | tagsWhereUniqueInput[]
    connect?: tagsWhereUniqueInput | tagsWhereUniqueInput[]
    update?: tagsUpdateWithWhereUniqueWithoutTagsInput | tagsUpdateWithWhereUniqueWithoutTagsInput[]
    updateMany?: tagsUpdateManyWithWhereWithoutTagsInput | tagsUpdateManyWithWhereWithoutTagsInput[]
    deleteMany?: tagsScalarWhereInput | tagsScalarWhereInput[]
  }

  export type publisherCreateNestedOneWithoutTransactionInput = {
    create?: XOR<publisherCreateWithoutTransactionInput, publisherUncheckedCreateWithoutTransactionInput>
    connectOrCreate?: publisherCreateOrConnectWithoutTransactionInput
    connect?: publisherWhereUniqueInput
  }

  export type publisherUpdateOneRequiredWithoutTransactionNestedInput = {
    create?: XOR<publisherCreateWithoutTransactionInput, publisherUncheckedCreateWithoutTransactionInput>
    connectOrCreate?: publisherCreateOrConnectWithoutTransactionInput
    upsert?: publisherUpsertWithoutTransactionInput
    connect?: publisherWhereUniqueInput
    update?: XOR<XOR<publisherUpdateToOneWithWhereWithoutTransactionInput, publisherUpdateWithoutTransactionInput>, publisherUncheckedUpdateWithoutTransactionInput>
  }

  export type publisherCreateNestedOneWithoutWithdrawalInput = {
    create?: XOR<publisherCreateWithoutWithdrawalInput, publisherUncheckedCreateWithoutWithdrawalInput>
    connectOrCreate?: publisherCreateOrConnectWithoutWithdrawalInput
    connect?: publisherWhereUniqueInput
  }

  export type publisherUpdateOneRequiredWithoutWithdrawalNestedInput = {
    create?: XOR<publisherCreateWithoutWithdrawalInput, publisherUncheckedCreateWithoutWithdrawalInput>
    connectOrCreate?: publisherCreateOrConnectWithoutWithdrawalInput
    upsert?: publisherUpsertWithoutWithdrawalInput
    connect?: publisherWhereUniqueInput
    update?: XOR<XOR<publisherUpdateToOneWithWhereWithoutWithdrawalInput, publisherUpdateWithoutWithdrawalInput>, publisherUncheckedUpdateWithoutWithdrawalInput>
  }

  export type NestedUuidFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidFilter<$PrismaModel> | string
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedUuidNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidNullableFilter<$PrismaModel> | string | null
  }

  export type NestedUuidWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedUuidNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type auth_accountCreateWithoutAffiliateInput = {
    id?: string
    password?: string | null
    id_provider?: string | null
    access_token?: string | null
    refresh_token?: string | null
    id_token?: string | null
    access_token_expires_at?: Date | string | null
    refresh_token_expires_at?: Date | string | null
    scope?: string | null
    created_at?: Date | string
    updated_at?: Date | string | null
    id_account?: string | null
    auth_user?: auth_userCreateNestedOneWithoutAuth_accountInput
    author?: authorCreateNestedManyWithoutAuth_accountInput
    customer?: customerCreateNestedManyWithoutAuth_accountInput
    internal?: internalCreateNestedManyWithoutAuth_accountInput
    publisher?: publisherCreateNestedManyWithoutAuth_accountInput
  }

  export type auth_accountUncheckedCreateWithoutAffiliateInput = {
    id?: string
    password?: string | null
    id_provider?: string | null
    access_token?: string | null
    refresh_token?: string | null
    id_token?: string | null
    access_token_expires_at?: Date | string | null
    refresh_token_expires_at?: Date | string | null
    scope?: string | null
    created_at?: Date | string
    updated_at?: Date | string | null
    id_user?: string | null
    id_account?: string | null
    author?: authorUncheckedCreateNestedManyWithoutAuth_accountInput
    customer?: customerUncheckedCreateNestedManyWithoutAuth_accountInput
    internal?: internalUncheckedCreateNestedManyWithoutAuth_accountInput
    publisher?: publisherUncheckedCreateNestedManyWithoutAuth_accountInput
  }

  export type auth_accountCreateOrConnectWithoutAffiliateInput = {
    where: auth_accountWhereUniqueInput
    create: XOR<auth_accountCreateWithoutAffiliateInput, auth_accountUncheckedCreateWithoutAffiliateInput>
  }

  export type auth_userCreateWithoutAffiliateInput = {
    id?: string
    name: string
    email: string
    email_verified?: boolean
    image?: string | null
    created_at?: Date | string
    updated_at?: Date | string | null
    username?: string | null
    display_username?: string | null
    two_factor_enabled?: boolean | null
    auth_account?: auth_accountCreateNestedManyWithoutAuth_userInput
    auth_session?: auth_sessionCreateNestedManyWithoutAuth_userInput
    auth_two_factor?: auth_two_factorCreateNestedManyWithoutAuth_userInput
    author?: authorCreateNestedOneWithoutAuth_userInput
    customer?: customerCreateNestedOneWithoutAuth_userInput
    internal?: internalCreateNestedOneWithoutAuth_userInput
    publisher?: publisherCreateNestedOneWithoutAuth_userInput
    reviews?: reviewsCreateNestedManyWithoutAuth_userInput
    reviews_likes?: reviews_likesCreateNestedManyWithoutAuth_userInput
  }

  export type auth_userUncheckedCreateWithoutAffiliateInput = {
    id?: string
    name: string
    email: string
    email_verified?: boolean
    image?: string | null
    created_at?: Date | string
    updated_at?: Date | string | null
    username?: string | null
    display_username?: string | null
    two_factor_enabled?: boolean | null
    id_customer?: string | null
    id_author?: string | null
    id_publisher?: string | null
    id_internal?: string | null
    auth_account?: auth_accountUncheckedCreateNestedManyWithoutAuth_userInput
    auth_session?: auth_sessionUncheckedCreateNestedManyWithoutAuth_userInput
    auth_two_factor?: auth_two_factorUncheckedCreateNestedManyWithoutAuth_userInput
    reviews?: reviewsUncheckedCreateNestedManyWithoutAuth_userInput
    reviews_likes?: reviews_likesUncheckedCreateNestedManyWithoutAuth_userInput
  }

  export type auth_userCreateOrConnectWithoutAffiliateInput = {
    where: auth_userWhereUniqueInput
    create: XOR<auth_userCreateWithoutAffiliateInput, auth_userUncheckedCreateWithoutAffiliateInput>
  }

  export type auth_userCreateManyAffiliateInputEnvelope = {
    data: auth_userCreateManyAffiliateInput | auth_userCreateManyAffiliateInput[]
    skipDuplicates?: boolean
  }

  export type auth_accountUpsertWithoutAffiliateInput = {
    update: XOR<auth_accountUpdateWithoutAffiliateInput, auth_accountUncheckedUpdateWithoutAffiliateInput>
    create: XOR<auth_accountCreateWithoutAffiliateInput, auth_accountUncheckedCreateWithoutAffiliateInput>
    where?: auth_accountWhereInput
  }

  export type auth_accountUpdateToOneWithWhereWithoutAffiliateInput = {
    where?: auth_accountWhereInput
    data: XOR<auth_accountUpdateWithoutAffiliateInput, auth_accountUncheckedUpdateWithoutAffiliateInput>
  }

  export type auth_accountUpdateWithoutAffiliateInput = {
    id?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    id_provider?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token_expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refresh_token_expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    id_account?: NullableStringFieldUpdateOperationsInput | string | null
    auth_user?: auth_userUpdateOneWithoutAuth_accountNestedInput
    author?: authorUpdateManyWithoutAuth_accountNestedInput
    customer?: customerUpdateManyWithoutAuth_accountNestedInput
    internal?: internalUpdateManyWithoutAuth_accountNestedInput
    publisher?: publisherUpdateManyWithoutAuth_accountNestedInput
  }

  export type auth_accountUncheckedUpdateWithoutAffiliateInput = {
    id?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    id_provider?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token_expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refresh_token_expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    id_user?: NullableStringFieldUpdateOperationsInput | string | null
    id_account?: NullableStringFieldUpdateOperationsInput | string | null
    author?: authorUncheckedUpdateManyWithoutAuth_accountNestedInput
    customer?: customerUncheckedUpdateManyWithoutAuth_accountNestedInput
    internal?: internalUncheckedUpdateManyWithoutAuth_accountNestedInput
    publisher?: publisherUncheckedUpdateManyWithoutAuth_accountNestedInput
  }

  export type auth_userUpsertWithWhereUniqueWithoutAffiliateInput = {
    where: auth_userWhereUniqueInput
    update: XOR<auth_userUpdateWithoutAffiliateInput, auth_userUncheckedUpdateWithoutAffiliateInput>
    create: XOR<auth_userCreateWithoutAffiliateInput, auth_userUncheckedCreateWithoutAffiliateInput>
  }

  export type auth_userUpdateWithWhereUniqueWithoutAffiliateInput = {
    where: auth_userWhereUniqueInput
    data: XOR<auth_userUpdateWithoutAffiliateInput, auth_userUncheckedUpdateWithoutAffiliateInput>
  }

  export type auth_userUpdateManyWithWhereWithoutAffiliateInput = {
    where: auth_userScalarWhereInput
    data: XOR<auth_userUpdateManyMutationInput, auth_userUncheckedUpdateManyWithoutAffiliateInput>
  }

  export type auth_userScalarWhereInput = {
    AND?: auth_userScalarWhereInput | auth_userScalarWhereInput[]
    OR?: auth_userScalarWhereInput[]
    NOT?: auth_userScalarWhereInput | auth_userScalarWhereInput[]
    id?: UuidFilter<"auth_user"> | string
    name?: StringFilter<"auth_user"> | string
    email?: StringFilter<"auth_user"> | string
    email_verified?: BoolFilter<"auth_user"> | boolean
    image?: StringNullableFilter<"auth_user"> | string | null
    created_at?: DateTimeFilter<"auth_user"> | Date | string
    updated_at?: DateTimeNullableFilter<"auth_user"> | Date | string | null
    username?: StringNullableFilter<"auth_user"> | string | null
    display_username?: StringNullableFilter<"auth_user"> | string | null
    two_factor_enabled?: BoolNullableFilter<"auth_user"> | boolean | null
    id_customer?: UuidNullableFilter<"auth_user"> | string | null
    id_author?: UuidNullableFilter<"auth_user"> | string | null
    id_affiliate?: UuidNullableFilter<"auth_user"> | string | null
    id_publisher?: UuidNullableFilter<"auth_user"> | string | null
    id_internal?: UuidNullableFilter<"auth_user"> | string | null
  }

  export type affiliateCreateWithoutAuth_accountInput = {
    id?: string
    name: string
    auth_user?: auth_userCreateNestedManyWithoutAffiliateInput
  }

  export type affiliateUncheckedCreateWithoutAuth_accountInput = {
    id?: string
    name: string
    auth_user?: auth_userUncheckedCreateNestedManyWithoutAffiliateInput
  }

  export type affiliateCreateOrConnectWithoutAuth_accountInput = {
    where: affiliateWhereUniqueInput
    create: XOR<affiliateCreateWithoutAuth_accountInput, affiliateUncheckedCreateWithoutAuth_accountInput>
  }

  export type affiliateCreateManyAuth_accountInputEnvelope = {
    data: affiliateCreateManyAuth_accountInput | affiliateCreateManyAuth_accountInput[]
    skipDuplicates?: boolean
  }

  export type auth_userCreateWithoutAuth_accountInput = {
    id?: string
    name: string
    email: string
    email_verified?: boolean
    image?: string | null
    created_at?: Date | string
    updated_at?: Date | string | null
    username?: string | null
    display_username?: string | null
    two_factor_enabled?: boolean | null
    auth_session?: auth_sessionCreateNestedManyWithoutAuth_userInput
    auth_two_factor?: auth_two_factorCreateNestedManyWithoutAuth_userInput
    affiliate?: affiliateCreateNestedOneWithoutAuth_userInput
    author?: authorCreateNestedOneWithoutAuth_userInput
    customer?: customerCreateNestedOneWithoutAuth_userInput
    internal?: internalCreateNestedOneWithoutAuth_userInput
    publisher?: publisherCreateNestedOneWithoutAuth_userInput
    reviews?: reviewsCreateNestedManyWithoutAuth_userInput
    reviews_likes?: reviews_likesCreateNestedManyWithoutAuth_userInput
  }

  export type auth_userUncheckedCreateWithoutAuth_accountInput = {
    id?: string
    name: string
    email: string
    email_verified?: boolean
    image?: string | null
    created_at?: Date | string
    updated_at?: Date | string | null
    username?: string | null
    display_username?: string | null
    two_factor_enabled?: boolean | null
    id_customer?: string | null
    id_author?: string | null
    id_affiliate?: string | null
    id_publisher?: string | null
    id_internal?: string | null
    auth_session?: auth_sessionUncheckedCreateNestedManyWithoutAuth_userInput
    auth_two_factor?: auth_two_factorUncheckedCreateNestedManyWithoutAuth_userInput
    reviews?: reviewsUncheckedCreateNestedManyWithoutAuth_userInput
    reviews_likes?: reviews_likesUncheckedCreateNestedManyWithoutAuth_userInput
  }

  export type auth_userCreateOrConnectWithoutAuth_accountInput = {
    where: auth_userWhereUniqueInput
    create: XOR<auth_userCreateWithoutAuth_accountInput, auth_userUncheckedCreateWithoutAuth_accountInput>
  }

  export type authorCreateWithoutAuth_accountInput = {
    id?: string
    name: string
    biography?: string | null
    social_media?: string | null
    avatar?: string | null
    auth_user?: auth_userCreateNestedManyWithoutAuthorInput
    book?: bookCreateNestedManyWithoutAuthorInput
    product?: productCreateNestedManyWithoutAuthorInput
    publisher_author?: publisher_authorCreateNestedManyWithoutAuthorInput
  }

  export type authorUncheckedCreateWithoutAuth_accountInput = {
    id?: string
    name: string
    biography?: string | null
    social_media?: string | null
    avatar?: string | null
    auth_user?: auth_userUncheckedCreateNestedManyWithoutAuthorInput
    book?: bookUncheckedCreateNestedManyWithoutAuthorInput
    product?: productUncheckedCreateNestedManyWithoutAuthorInput
    publisher_author?: publisher_authorUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type authorCreateOrConnectWithoutAuth_accountInput = {
    where: authorWhereUniqueInput
    create: XOR<authorCreateWithoutAuth_accountInput, authorUncheckedCreateWithoutAuth_accountInput>
  }

  export type authorCreateManyAuth_accountInputEnvelope = {
    data: authorCreateManyAuth_accountInput | authorCreateManyAuth_accountInput[]
    skipDuplicates?: boolean
  }

  export type customerCreateWithoutAuth_accountInput = {
    id?: string
    whatsapp: string
    deleted_at?: Date | string | null
    otp?: number | null
    name: string
    email: string
    auth_user?: auth_userCreateNestedManyWithoutCustomerInput
    customer_reader?: customer_readerCreateNestedManyWithoutCustomerInput
    customer_track?: customer_trackCreateNestedManyWithoutCustomerInput
    t_sales?: t_salesCreateNestedManyWithoutCustomerInput
    t_sales_download?: t_sales_downloadCreateNestedManyWithoutCustomerInput
  }

  export type customerUncheckedCreateWithoutAuth_accountInput = {
    id?: string
    whatsapp: string
    deleted_at?: Date | string | null
    otp?: number | null
    name: string
    email: string
    auth_user?: auth_userUncheckedCreateNestedManyWithoutCustomerInput
    customer_reader?: customer_readerUncheckedCreateNestedManyWithoutCustomerInput
    customer_track?: customer_trackUncheckedCreateNestedManyWithoutCustomerInput
    t_sales?: t_salesUncheckedCreateNestedManyWithoutCustomerInput
    t_sales_download?: t_sales_downloadUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type customerCreateOrConnectWithoutAuth_accountInput = {
    where: customerWhereUniqueInput
    create: XOR<customerCreateWithoutAuth_accountInput, customerUncheckedCreateWithoutAuth_accountInput>
  }

  export type customerCreateManyAuth_accountInputEnvelope = {
    data: customerCreateManyAuth_accountInput | customerCreateManyAuth_accountInput[]
    skipDuplicates?: boolean
  }

  export type internalCreateWithoutAuth_accountInput = {
    id?: string
    name: string
    is_sales_and_marketing?: boolean
    is_support?: boolean
    is_management?: boolean
    is_it?: boolean
    auth_user?: auth_userCreateNestedManyWithoutInternalInput
    book_approval?: book_approvalCreateNestedManyWithoutInternalInput
  }

  export type internalUncheckedCreateWithoutAuth_accountInput = {
    id?: string
    name: string
    is_sales_and_marketing?: boolean
    is_support?: boolean
    is_management?: boolean
    is_it?: boolean
    auth_user?: auth_userUncheckedCreateNestedManyWithoutInternalInput
    book_approval?: book_approvalUncheckedCreateNestedManyWithoutInternalInput
  }

  export type internalCreateOrConnectWithoutAuth_accountInput = {
    where: internalWhereUniqueInput
    create: XOR<internalCreateWithoutAuth_accountInput, internalUncheckedCreateWithoutAuth_accountInput>
  }

  export type internalCreateManyAuth_accountInputEnvelope = {
    data: internalCreateManyAuth_accountInput | internalCreateManyAuth_accountInput[]
    skipDuplicates?: boolean
  }

  export type publisherCreateWithoutAuth_accountInput = {
    id?: string
    name: string
    description?: string | null
    website?: string | null
    address?: string | null
    logo?: string | null
    auth_user?: auth_userCreateNestedManyWithoutPublisherInput
    promo_code?: promo_codeCreateNestedManyWithoutPublisherInput
    publisher_author?: publisher_authorCreateNestedManyWithoutPublisherInput
    t_ai_credit?: t_ai_creditCreateNestedManyWithoutPublisherInput
    transaction?: transactionCreateNestedManyWithoutPublisherInput
    withdrawal?: withdrawalCreateNestedManyWithoutPublisherInput
  }

  export type publisherUncheckedCreateWithoutAuth_accountInput = {
    id?: string
    name: string
    description?: string | null
    website?: string | null
    address?: string | null
    logo?: string | null
    auth_user?: auth_userUncheckedCreateNestedManyWithoutPublisherInput
    promo_code?: promo_codeUncheckedCreateNestedManyWithoutPublisherInput
    publisher_author?: publisher_authorUncheckedCreateNestedManyWithoutPublisherInput
    t_ai_credit?: t_ai_creditUncheckedCreateNestedManyWithoutPublisherInput
    transaction?: transactionUncheckedCreateNestedManyWithoutPublisherInput
    withdrawal?: withdrawalUncheckedCreateNestedManyWithoutPublisherInput
  }

  export type publisherCreateOrConnectWithoutAuth_accountInput = {
    where: publisherWhereUniqueInput
    create: XOR<publisherCreateWithoutAuth_accountInput, publisherUncheckedCreateWithoutAuth_accountInput>
  }

  export type publisherCreateManyAuth_accountInputEnvelope = {
    data: publisherCreateManyAuth_accountInput | publisherCreateManyAuth_accountInput[]
    skipDuplicates?: boolean
  }

  export type affiliateUpsertWithWhereUniqueWithoutAuth_accountInput = {
    where: affiliateWhereUniqueInput
    update: XOR<affiliateUpdateWithoutAuth_accountInput, affiliateUncheckedUpdateWithoutAuth_accountInput>
    create: XOR<affiliateCreateWithoutAuth_accountInput, affiliateUncheckedCreateWithoutAuth_accountInput>
  }

  export type affiliateUpdateWithWhereUniqueWithoutAuth_accountInput = {
    where: affiliateWhereUniqueInput
    data: XOR<affiliateUpdateWithoutAuth_accountInput, affiliateUncheckedUpdateWithoutAuth_accountInput>
  }

  export type affiliateUpdateManyWithWhereWithoutAuth_accountInput = {
    where: affiliateScalarWhereInput
    data: XOR<affiliateUpdateManyMutationInput, affiliateUncheckedUpdateManyWithoutAuth_accountInput>
  }

  export type affiliateScalarWhereInput = {
    AND?: affiliateScalarWhereInput | affiliateScalarWhereInput[]
    OR?: affiliateScalarWhereInput[]
    NOT?: affiliateScalarWhereInput | affiliateScalarWhereInput[]
    id?: UuidFilter<"affiliate"> | string
    name?: StringFilter<"affiliate"> | string
    id_account?: UuidNullableFilter<"affiliate"> | string | null
  }

  export type auth_userUpsertWithoutAuth_accountInput = {
    update: XOR<auth_userUpdateWithoutAuth_accountInput, auth_userUncheckedUpdateWithoutAuth_accountInput>
    create: XOR<auth_userCreateWithoutAuth_accountInput, auth_userUncheckedCreateWithoutAuth_accountInput>
    where?: auth_userWhereInput
  }

  export type auth_userUpdateToOneWithWhereWithoutAuth_accountInput = {
    where?: auth_userWhereInput
    data: XOR<auth_userUpdateWithoutAuth_accountInput, auth_userUncheckedUpdateWithoutAuth_accountInput>
  }

  export type auth_userUpdateWithoutAuth_accountInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    email_verified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    display_username?: NullableStringFieldUpdateOperationsInput | string | null
    two_factor_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    auth_session?: auth_sessionUpdateManyWithoutAuth_userNestedInput
    auth_two_factor?: auth_two_factorUpdateManyWithoutAuth_userNestedInput
    affiliate?: affiliateUpdateOneWithoutAuth_userNestedInput
    author?: authorUpdateOneWithoutAuth_userNestedInput
    customer?: customerUpdateOneWithoutAuth_userNestedInput
    internal?: internalUpdateOneWithoutAuth_userNestedInput
    publisher?: publisherUpdateOneWithoutAuth_userNestedInput
    reviews?: reviewsUpdateManyWithoutAuth_userNestedInput
    reviews_likes?: reviews_likesUpdateManyWithoutAuth_userNestedInput
  }

  export type auth_userUncheckedUpdateWithoutAuth_accountInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    email_verified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    display_username?: NullableStringFieldUpdateOperationsInput | string | null
    two_factor_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    id_customer?: NullableStringFieldUpdateOperationsInput | string | null
    id_author?: NullableStringFieldUpdateOperationsInput | string | null
    id_affiliate?: NullableStringFieldUpdateOperationsInput | string | null
    id_publisher?: NullableStringFieldUpdateOperationsInput | string | null
    id_internal?: NullableStringFieldUpdateOperationsInput | string | null
    auth_session?: auth_sessionUncheckedUpdateManyWithoutAuth_userNestedInput
    auth_two_factor?: auth_two_factorUncheckedUpdateManyWithoutAuth_userNestedInput
    reviews?: reviewsUncheckedUpdateManyWithoutAuth_userNestedInput
    reviews_likes?: reviews_likesUncheckedUpdateManyWithoutAuth_userNestedInput
  }

  export type authorUpsertWithWhereUniqueWithoutAuth_accountInput = {
    where: authorWhereUniqueInput
    update: XOR<authorUpdateWithoutAuth_accountInput, authorUncheckedUpdateWithoutAuth_accountInput>
    create: XOR<authorCreateWithoutAuth_accountInput, authorUncheckedCreateWithoutAuth_accountInput>
  }

  export type authorUpdateWithWhereUniqueWithoutAuth_accountInput = {
    where: authorWhereUniqueInput
    data: XOR<authorUpdateWithoutAuth_accountInput, authorUncheckedUpdateWithoutAuth_accountInput>
  }

  export type authorUpdateManyWithWhereWithoutAuth_accountInput = {
    where: authorScalarWhereInput
    data: XOR<authorUpdateManyMutationInput, authorUncheckedUpdateManyWithoutAuth_accountInput>
  }

  export type authorScalarWhereInput = {
    AND?: authorScalarWhereInput | authorScalarWhereInput[]
    OR?: authorScalarWhereInput[]
    NOT?: authorScalarWhereInput | authorScalarWhereInput[]
    id?: UuidFilter<"author"> | string
    name?: StringFilter<"author"> | string
    id_account?: UuidNullableFilter<"author"> | string | null
    biography?: StringNullableFilter<"author"> | string | null
    social_media?: StringNullableFilter<"author"> | string | null
    avatar?: StringNullableFilter<"author"> | string | null
  }

  export type customerUpsertWithWhereUniqueWithoutAuth_accountInput = {
    where: customerWhereUniqueInput
    update: XOR<customerUpdateWithoutAuth_accountInput, customerUncheckedUpdateWithoutAuth_accountInput>
    create: XOR<customerCreateWithoutAuth_accountInput, customerUncheckedCreateWithoutAuth_accountInput>
  }

  export type customerUpdateWithWhereUniqueWithoutAuth_accountInput = {
    where: customerWhereUniqueInput
    data: XOR<customerUpdateWithoutAuth_accountInput, customerUncheckedUpdateWithoutAuth_accountInput>
  }

  export type customerUpdateManyWithWhereWithoutAuth_accountInput = {
    where: customerScalarWhereInput
    data: XOR<customerUpdateManyMutationInput, customerUncheckedUpdateManyWithoutAuth_accountInput>
  }

  export type customerScalarWhereInput = {
    AND?: customerScalarWhereInput | customerScalarWhereInput[]
    OR?: customerScalarWhereInput[]
    NOT?: customerScalarWhereInput | customerScalarWhereInput[]
    id?: UuidFilter<"customer"> | string
    whatsapp?: StringFilter<"customer"> | string
    deleted_at?: DateTimeNullableFilter<"customer"> | Date | string | null
    otp?: IntNullableFilter<"customer"> | number | null
    id_account?: UuidNullableFilter<"customer"> | string | null
    name?: StringFilter<"customer"> | string
    email?: StringFilter<"customer"> | string
  }

  export type internalUpsertWithWhereUniqueWithoutAuth_accountInput = {
    where: internalWhereUniqueInput
    update: XOR<internalUpdateWithoutAuth_accountInput, internalUncheckedUpdateWithoutAuth_accountInput>
    create: XOR<internalCreateWithoutAuth_accountInput, internalUncheckedCreateWithoutAuth_accountInput>
  }

  export type internalUpdateWithWhereUniqueWithoutAuth_accountInput = {
    where: internalWhereUniqueInput
    data: XOR<internalUpdateWithoutAuth_accountInput, internalUncheckedUpdateWithoutAuth_accountInput>
  }

  export type internalUpdateManyWithWhereWithoutAuth_accountInput = {
    where: internalScalarWhereInput
    data: XOR<internalUpdateManyMutationInput, internalUncheckedUpdateManyWithoutAuth_accountInput>
  }

  export type internalScalarWhereInput = {
    AND?: internalScalarWhereInput | internalScalarWhereInput[]
    OR?: internalScalarWhereInput[]
    NOT?: internalScalarWhereInput | internalScalarWhereInput[]
    id?: UuidFilter<"internal"> | string
    id_account?: UuidNullableFilter<"internal"> | string | null
    name?: StringFilter<"internal"> | string
    is_sales_and_marketing?: BoolFilter<"internal"> | boolean
    is_support?: BoolFilter<"internal"> | boolean
    is_management?: BoolFilter<"internal"> | boolean
    is_it?: BoolFilter<"internal"> | boolean
  }

  export type publisherUpsertWithWhereUniqueWithoutAuth_accountInput = {
    where: publisherWhereUniqueInput
    update: XOR<publisherUpdateWithoutAuth_accountInput, publisherUncheckedUpdateWithoutAuth_accountInput>
    create: XOR<publisherCreateWithoutAuth_accountInput, publisherUncheckedCreateWithoutAuth_accountInput>
  }

  export type publisherUpdateWithWhereUniqueWithoutAuth_accountInput = {
    where: publisherWhereUniqueInput
    data: XOR<publisherUpdateWithoutAuth_accountInput, publisherUncheckedUpdateWithoutAuth_accountInput>
  }

  export type publisherUpdateManyWithWhereWithoutAuth_accountInput = {
    where: publisherScalarWhereInput
    data: XOR<publisherUpdateManyMutationInput, publisherUncheckedUpdateManyWithoutAuth_accountInput>
  }

  export type publisherScalarWhereInput = {
    AND?: publisherScalarWhereInput | publisherScalarWhereInput[]
    OR?: publisherScalarWhereInput[]
    NOT?: publisherScalarWhereInput | publisherScalarWhereInput[]
    id?: UuidFilter<"publisher"> | string
    id_account?: UuidNullableFilter<"publisher"> | string | null
    name?: StringFilter<"publisher"> | string
    description?: StringNullableFilter<"publisher"> | string | null
    website?: StringNullableFilter<"publisher"> | string | null
    address?: StringNullableFilter<"publisher"> | string | null
    logo?: StringNullableFilter<"publisher"> | string | null
  }

  export type auth_userCreateWithoutAuth_sessionInput = {
    id?: string
    name: string
    email: string
    email_verified?: boolean
    image?: string | null
    created_at?: Date | string
    updated_at?: Date | string | null
    username?: string | null
    display_username?: string | null
    two_factor_enabled?: boolean | null
    auth_account?: auth_accountCreateNestedManyWithoutAuth_userInput
    auth_two_factor?: auth_two_factorCreateNestedManyWithoutAuth_userInput
    affiliate?: affiliateCreateNestedOneWithoutAuth_userInput
    author?: authorCreateNestedOneWithoutAuth_userInput
    customer?: customerCreateNestedOneWithoutAuth_userInput
    internal?: internalCreateNestedOneWithoutAuth_userInput
    publisher?: publisherCreateNestedOneWithoutAuth_userInput
    reviews?: reviewsCreateNestedManyWithoutAuth_userInput
    reviews_likes?: reviews_likesCreateNestedManyWithoutAuth_userInput
  }

  export type auth_userUncheckedCreateWithoutAuth_sessionInput = {
    id?: string
    name: string
    email: string
    email_verified?: boolean
    image?: string | null
    created_at?: Date | string
    updated_at?: Date | string | null
    username?: string | null
    display_username?: string | null
    two_factor_enabled?: boolean | null
    id_customer?: string | null
    id_author?: string | null
    id_affiliate?: string | null
    id_publisher?: string | null
    id_internal?: string | null
    auth_account?: auth_accountUncheckedCreateNestedManyWithoutAuth_userInput
    auth_two_factor?: auth_two_factorUncheckedCreateNestedManyWithoutAuth_userInput
    reviews?: reviewsUncheckedCreateNestedManyWithoutAuth_userInput
    reviews_likes?: reviews_likesUncheckedCreateNestedManyWithoutAuth_userInput
  }

  export type auth_userCreateOrConnectWithoutAuth_sessionInput = {
    where: auth_userWhereUniqueInput
    create: XOR<auth_userCreateWithoutAuth_sessionInput, auth_userUncheckedCreateWithoutAuth_sessionInput>
  }

  export type auth_userUpsertWithoutAuth_sessionInput = {
    update: XOR<auth_userUpdateWithoutAuth_sessionInput, auth_userUncheckedUpdateWithoutAuth_sessionInput>
    create: XOR<auth_userCreateWithoutAuth_sessionInput, auth_userUncheckedCreateWithoutAuth_sessionInput>
    where?: auth_userWhereInput
  }

  export type auth_userUpdateToOneWithWhereWithoutAuth_sessionInput = {
    where?: auth_userWhereInput
    data: XOR<auth_userUpdateWithoutAuth_sessionInput, auth_userUncheckedUpdateWithoutAuth_sessionInput>
  }

  export type auth_userUpdateWithoutAuth_sessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    email_verified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    display_username?: NullableStringFieldUpdateOperationsInput | string | null
    two_factor_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    auth_account?: auth_accountUpdateManyWithoutAuth_userNestedInput
    auth_two_factor?: auth_two_factorUpdateManyWithoutAuth_userNestedInput
    affiliate?: affiliateUpdateOneWithoutAuth_userNestedInput
    author?: authorUpdateOneWithoutAuth_userNestedInput
    customer?: customerUpdateOneWithoutAuth_userNestedInput
    internal?: internalUpdateOneWithoutAuth_userNestedInput
    publisher?: publisherUpdateOneWithoutAuth_userNestedInput
    reviews?: reviewsUpdateManyWithoutAuth_userNestedInput
    reviews_likes?: reviews_likesUpdateManyWithoutAuth_userNestedInput
  }

  export type auth_userUncheckedUpdateWithoutAuth_sessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    email_verified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    display_username?: NullableStringFieldUpdateOperationsInput | string | null
    two_factor_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    id_customer?: NullableStringFieldUpdateOperationsInput | string | null
    id_author?: NullableStringFieldUpdateOperationsInput | string | null
    id_affiliate?: NullableStringFieldUpdateOperationsInput | string | null
    id_publisher?: NullableStringFieldUpdateOperationsInput | string | null
    id_internal?: NullableStringFieldUpdateOperationsInput | string | null
    auth_account?: auth_accountUncheckedUpdateManyWithoutAuth_userNestedInput
    auth_two_factor?: auth_two_factorUncheckedUpdateManyWithoutAuth_userNestedInput
    reviews?: reviewsUncheckedUpdateManyWithoutAuth_userNestedInput
    reviews_likes?: reviews_likesUncheckedUpdateManyWithoutAuth_userNestedInput
  }

  export type auth_userCreateWithoutAuth_two_factorInput = {
    id?: string
    name: string
    email: string
    email_verified?: boolean
    image?: string | null
    created_at?: Date | string
    updated_at?: Date | string | null
    username?: string | null
    display_username?: string | null
    two_factor_enabled?: boolean | null
    auth_account?: auth_accountCreateNestedManyWithoutAuth_userInput
    auth_session?: auth_sessionCreateNestedManyWithoutAuth_userInput
    affiliate?: affiliateCreateNestedOneWithoutAuth_userInput
    author?: authorCreateNestedOneWithoutAuth_userInput
    customer?: customerCreateNestedOneWithoutAuth_userInput
    internal?: internalCreateNestedOneWithoutAuth_userInput
    publisher?: publisherCreateNestedOneWithoutAuth_userInput
    reviews?: reviewsCreateNestedManyWithoutAuth_userInput
    reviews_likes?: reviews_likesCreateNestedManyWithoutAuth_userInput
  }

  export type auth_userUncheckedCreateWithoutAuth_two_factorInput = {
    id?: string
    name: string
    email: string
    email_verified?: boolean
    image?: string | null
    created_at?: Date | string
    updated_at?: Date | string | null
    username?: string | null
    display_username?: string | null
    two_factor_enabled?: boolean | null
    id_customer?: string | null
    id_author?: string | null
    id_affiliate?: string | null
    id_publisher?: string | null
    id_internal?: string | null
    auth_account?: auth_accountUncheckedCreateNestedManyWithoutAuth_userInput
    auth_session?: auth_sessionUncheckedCreateNestedManyWithoutAuth_userInput
    reviews?: reviewsUncheckedCreateNestedManyWithoutAuth_userInput
    reviews_likes?: reviews_likesUncheckedCreateNestedManyWithoutAuth_userInput
  }

  export type auth_userCreateOrConnectWithoutAuth_two_factorInput = {
    where: auth_userWhereUniqueInput
    create: XOR<auth_userCreateWithoutAuth_two_factorInput, auth_userUncheckedCreateWithoutAuth_two_factorInput>
  }

  export type auth_userUpsertWithoutAuth_two_factorInput = {
    update: XOR<auth_userUpdateWithoutAuth_two_factorInput, auth_userUncheckedUpdateWithoutAuth_two_factorInput>
    create: XOR<auth_userCreateWithoutAuth_two_factorInput, auth_userUncheckedCreateWithoutAuth_two_factorInput>
    where?: auth_userWhereInput
  }

  export type auth_userUpdateToOneWithWhereWithoutAuth_two_factorInput = {
    where?: auth_userWhereInput
    data: XOR<auth_userUpdateWithoutAuth_two_factorInput, auth_userUncheckedUpdateWithoutAuth_two_factorInput>
  }

  export type auth_userUpdateWithoutAuth_two_factorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    email_verified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    display_username?: NullableStringFieldUpdateOperationsInput | string | null
    two_factor_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    auth_account?: auth_accountUpdateManyWithoutAuth_userNestedInput
    auth_session?: auth_sessionUpdateManyWithoutAuth_userNestedInput
    affiliate?: affiliateUpdateOneWithoutAuth_userNestedInput
    author?: authorUpdateOneWithoutAuth_userNestedInput
    customer?: customerUpdateOneWithoutAuth_userNestedInput
    internal?: internalUpdateOneWithoutAuth_userNestedInput
    publisher?: publisherUpdateOneWithoutAuth_userNestedInput
    reviews?: reviewsUpdateManyWithoutAuth_userNestedInput
    reviews_likes?: reviews_likesUpdateManyWithoutAuth_userNestedInput
  }

  export type auth_userUncheckedUpdateWithoutAuth_two_factorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    email_verified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    display_username?: NullableStringFieldUpdateOperationsInput | string | null
    two_factor_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    id_customer?: NullableStringFieldUpdateOperationsInput | string | null
    id_author?: NullableStringFieldUpdateOperationsInput | string | null
    id_affiliate?: NullableStringFieldUpdateOperationsInput | string | null
    id_publisher?: NullableStringFieldUpdateOperationsInput | string | null
    id_internal?: NullableStringFieldUpdateOperationsInput | string | null
    auth_account?: auth_accountUncheckedUpdateManyWithoutAuth_userNestedInput
    auth_session?: auth_sessionUncheckedUpdateManyWithoutAuth_userNestedInput
    reviews?: reviewsUncheckedUpdateManyWithoutAuth_userNestedInput
    reviews_likes?: reviews_likesUncheckedUpdateManyWithoutAuth_userNestedInput
  }

  export type auth_accountCreateWithoutAuth_userInput = {
    id?: string
    password?: string | null
    id_provider?: string | null
    access_token?: string | null
    refresh_token?: string | null
    id_token?: string | null
    access_token_expires_at?: Date | string | null
    refresh_token_expires_at?: Date | string | null
    scope?: string | null
    created_at?: Date | string
    updated_at?: Date | string | null
    id_account?: string | null
    affiliate?: affiliateCreateNestedManyWithoutAuth_accountInput
    author?: authorCreateNestedManyWithoutAuth_accountInput
    customer?: customerCreateNestedManyWithoutAuth_accountInput
    internal?: internalCreateNestedManyWithoutAuth_accountInput
    publisher?: publisherCreateNestedManyWithoutAuth_accountInput
  }

  export type auth_accountUncheckedCreateWithoutAuth_userInput = {
    id?: string
    password?: string | null
    id_provider?: string | null
    access_token?: string | null
    refresh_token?: string | null
    id_token?: string | null
    access_token_expires_at?: Date | string | null
    refresh_token_expires_at?: Date | string | null
    scope?: string | null
    created_at?: Date | string
    updated_at?: Date | string | null
    id_account?: string | null
    affiliate?: affiliateUncheckedCreateNestedManyWithoutAuth_accountInput
    author?: authorUncheckedCreateNestedManyWithoutAuth_accountInput
    customer?: customerUncheckedCreateNestedManyWithoutAuth_accountInput
    internal?: internalUncheckedCreateNestedManyWithoutAuth_accountInput
    publisher?: publisherUncheckedCreateNestedManyWithoutAuth_accountInput
  }

  export type auth_accountCreateOrConnectWithoutAuth_userInput = {
    where: auth_accountWhereUniqueInput
    create: XOR<auth_accountCreateWithoutAuth_userInput, auth_accountUncheckedCreateWithoutAuth_userInput>
  }

  export type auth_accountCreateManyAuth_userInputEnvelope = {
    data: auth_accountCreateManyAuth_userInput | auth_accountCreateManyAuth_userInput[]
    skipDuplicates?: boolean
  }

  export type auth_sessionCreateWithoutAuth_userInput = {
    id?: string
    expires_at: Date | string
    token: string
    created_at?: Date | string
    updated_at?: Date | string | null
    ip_address?: string | null
    user_agent?: string | null
  }

  export type auth_sessionUncheckedCreateWithoutAuth_userInput = {
    id?: string
    expires_at: Date | string
    token: string
    created_at?: Date | string
    updated_at?: Date | string | null
    ip_address?: string | null
    user_agent?: string | null
  }

  export type auth_sessionCreateOrConnectWithoutAuth_userInput = {
    where: auth_sessionWhereUniqueInput
    create: XOR<auth_sessionCreateWithoutAuth_userInput, auth_sessionUncheckedCreateWithoutAuth_userInput>
  }

  export type auth_sessionCreateManyAuth_userInputEnvelope = {
    data: auth_sessionCreateManyAuth_userInput | auth_sessionCreateManyAuth_userInput[]
    skipDuplicates?: boolean
  }

  export type auth_two_factorCreateWithoutAuth_userInput = {
    id?: string
    secret?: string | null
    backup_codes?: string | null
  }

  export type auth_two_factorUncheckedCreateWithoutAuth_userInput = {
    id?: string
    secret?: string | null
    backup_codes?: string | null
  }

  export type auth_two_factorCreateOrConnectWithoutAuth_userInput = {
    where: auth_two_factorWhereUniqueInput
    create: XOR<auth_two_factorCreateWithoutAuth_userInput, auth_two_factorUncheckedCreateWithoutAuth_userInput>
  }

  export type auth_two_factorCreateManyAuth_userInputEnvelope = {
    data: auth_two_factorCreateManyAuth_userInput | auth_two_factorCreateManyAuth_userInput[]
    skipDuplicates?: boolean
  }

  export type affiliateCreateWithoutAuth_userInput = {
    id?: string
    name: string
    auth_account?: auth_accountCreateNestedOneWithoutAffiliateInput
  }

  export type affiliateUncheckedCreateWithoutAuth_userInput = {
    id?: string
    name: string
    id_account?: string | null
  }

  export type affiliateCreateOrConnectWithoutAuth_userInput = {
    where: affiliateWhereUniqueInput
    create: XOR<affiliateCreateWithoutAuth_userInput, affiliateUncheckedCreateWithoutAuth_userInput>
  }

  export type authorCreateWithoutAuth_userInput = {
    id?: string
    name: string
    biography?: string | null
    social_media?: string | null
    avatar?: string | null
    auth_account?: auth_accountCreateNestedOneWithoutAuthorInput
    book?: bookCreateNestedManyWithoutAuthorInput
    product?: productCreateNestedManyWithoutAuthorInput
    publisher_author?: publisher_authorCreateNestedManyWithoutAuthorInput
  }

  export type authorUncheckedCreateWithoutAuth_userInput = {
    id?: string
    name: string
    id_account?: string | null
    biography?: string | null
    social_media?: string | null
    avatar?: string | null
    book?: bookUncheckedCreateNestedManyWithoutAuthorInput
    product?: productUncheckedCreateNestedManyWithoutAuthorInput
    publisher_author?: publisher_authorUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type authorCreateOrConnectWithoutAuth_userInput = {
    where: authorWhereUniqueInput
    create: XOR<authorCreateWithoutAuth_userInput, authorUncheckedCreateWithoutAuth_userInput>
  }

  export type customerCreateWithoutAuth_userInput = {
    id?: string
    whatsapp: string
    deleted_at?: Date | string | null
    otp?: number | null
    name: string
    email: string
    auth_account?: auth_accountCreateNestedOneWithoutCustomerInput
    customer_reader?: customer_readerCreateNestedManyWithoutCustomerInput
    customer_track?: customer_trackCreateNestedManyWithoutCustomerInput
    t_sales?: t_salesCreateNestedManyWithoutCustomerInput
    t_sales_download?: t_sales_downloadCreateNestedManyWithoutCustomerInput
  }

  export type customerUncheckedCreateWithoutAuth_userInput = {
    id?: string
    whatsapp: string
    deleted_at?: Date | string | null
    otp?: number | null
    id_account?: string | null
    name: string
    email: string
    customer_reader?: customer_readerUncheckedCreateNestedManyWithoutCustomerInput
    customer_track?: customer_trackUncheckedCreateNestedManyWithoutCustomerInput
    t_sales?: t_salesUncheckedCreateNestedManyWithoutCustomerInput
    t_sales_download?: t_sales_downloadUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type customerCreateOrConnectWithoutAuth_userInput = {
    where: customerWhereUniqueInput
    create: XOR<customerCreateWithoutAuth_userInput, customerUncheckedCreateWithoutAuth_userInput>
  }

  export type internalCreateWithoutAuth_userInput = {
    id?: string
    name: string
    is_sales_and_marketing?: boolean
    is_support?: boolean
    is_management?: boolean
    is_it?: boolean
    book_approval?: book_approvalCreateNestedManyWithoutInternalInput
    auth_account?: auth_accountCreateNestedOneWithoutInternalInput
  }

  export type internalUncheckedCreateWithoutAuth_userInput = {
    id?: string
    id_account?: string | null
    name: string
    is_sales_and_marketing?: boolean
    is_support?: boolean
    is_management?: boolean
    is_it?: boolean
    book_approval?: book_approvalUncheckedCreateNestedManyWithoutInternalInput
  }

  export type internalCreateOrConnectWithoutAuth_userInput = {
    where: internalWhereUniqueInput
    create: XOR<internalCreateWithoutAuth_userInput, internalUncheckedCreateWithoutAuth_userInput>
  }

  export type publisherCreateWithoutAuth_userInput = {
    id?: string
    name: string
    description?: string | null
    website?: string | null
    address?: string | null
    logo?: string | null
    promo_code?: promo_codeCreateNestedManyWithoutPublisherInput
    auth_account?: auth_accountCreateNestedOneWithoutPublisherInput
    publisher_author?: publisher_authorCreateNestedManyWithoutPublisherInput
    t_ai_credit?: t_ai_creditCreateNestedManyWithoutPublisherInput
    transaction?: transactionCreateNestedManyWithoutPublisherInput
    withdrawal?: withdrawalCreateNestedManyWithoutPublisherInput
  }

  export type publisherUncheckedCreateWithoutAuth_userInput = {
    id?: string
    id_account?: string | null
    name: string
    description?: string | null
    website?: string | null
    address?: string | null
    logo?: string | null
    promo_code?: promo_codeUncheckedCreateNestedManyWithoutPublisherInput
    publisher_author?: publisher_authorUncheckedCreateNestedManyWithoutPublisherInput
    t_ai_credit?: t_ai_creditUncheckedCreateNestedManyWithoutPublisherInput
    transaction?: transactionUncheckedCreateNestedManyWithoutPublisherInput
    withdrawal?: withdrawalUncheckedCreateNestedManyWithoutPublisherInput
  }

  export type publisherCreateOrConnectWithoutAuth_userInput = {
    where: publisherWhereUniqueInput
    create: XOR<publisherCreateWithoutAuth_userInput, publisherUncheckedCreateWithoutAuth_userInput>
  }

  export type reviewsCreateWithoutAuth_userInput = {
    id?: string
    comments: string
    rating?: Decimal | DecimalJsLike | number | string | null
    created_at: Date | string
    deleted_at?: Date | string | null
    parent?: string | null
    book: bookCreateNestedOneWithoutReviewsInput
    reviews_likes?: reviews_likesCreateNestedManyWithoutReviewsInput
  }

  export type reviewsUncheckedCreateWithoutAuth_userInput = {
    id?: string
    id_book: string
    comments: string
    rating?: Decimal | DecimalJsLike | number | string | null
    created_at: Date | string
    deleted_at?: Date | string | null
    parent?: string | null
    reviews_likes?: reviews_likesUncheckedCreateNestedManyWithoutReviewsInput
  }

  export type reviewsCreateOrConnectWithoutAuth_userInput = {
    where: reviewsWhereUniqueInput
    create: XOR<reviewsCreateWithoutAuth_userInput, reviewsUncheckedCreateWithoutAuth_userInput>
  }

  export type reviewsCreateManyAuth_userInputEnvelope = {
    data: reviewsCreateManyAuth_userInput | reviewsCreateManyAuth_userInput[]
    skipDuplicates?: boolean
  }

  export type reviews_likesCreateWithoutAuth_userInput = {
    id?: string
    reviews: reviewsCreateNestedOneWithoutReviews_likesInput
  }

  export type reviews_likesUncheckedCreateWithoutAuth_userInput = {
    id?: string
    id_reviews: string
  }

  export type reviews_likesCreateOrConnectWithoutAuth_userInput = {
    where: reviews_likesWhereUniqueInput
    create: XOR<reviews_likesCreateWithoutAuth_userInput, reviews_likesUncheckedCreateWithoutAuth_userInput>
  }

  export type reviews_likesCreateManyAuth_userInputEnvelope = {
    data: reviews_likesCreateManyAuth_userInput | reviews_likesCreateManyAuth_userInput[]
    skipDuplicates?: boolean
  }

  export type auth_accountUpsertWithWhereUniqueWithoutAuth_userInput = {
    where: auth_accountWhereUniqueInput
    update: XOR<auth_accountUpdateWithoutAuth_userInput, auth_accountUncheckedUpdateWithoutAuth_userInput>
    create: XOR<auth_accountCreateWithoutAuth_userInput, auth_accountUncheckedCreateWithoutAuth_userInput>
  }

  export type auth_accountUpdateWithWhereUniqueWithoutAuth_userInput = {
    where: auth_accountWhereUniqueInput
    data: XOR<auth_accountUpdateWithoutAuth_userInput, auth_accountUncheckedUpdateWithoutAuth_userInput>
  }

  export type auth_accountUpdateManyWithWhereWithoutAuth_userInput = {
    where: auth_accountScalarWhereInput
    data: XOR<auth_accountUpdateManyMutationInput, auth_accountUncheckedUpdateManyWithoutAuth_userInput>
  }

  export type auth_accountScalarWhereInput = {
    AND?: auth_accountScalarWhereInput | auth_accountScalarWhereInput[]
    OR?: auth_accountScalarWhereInput[]
    NOT?: auth_accountScalarWhereInput | auth_accountScalarWhereInput[]
    id?: UuidFilter<"auth_account"> | string
    password?: StringNullableFilter<"auth_account"> | string | null
    id_provider?: StringNullableFilter<"auth_account"> | string | null
    access_token?: StringNullableFilter<"auth_account"> | string | null
    refresh_token?: StringNullableFilter<"auth_account"> | string | null
    id_token?: StringNullableFilter<"auth_account"> | string | null
    access_token_expires_at?: DateTimeNullableFilter<"auth_account"> | Date | string | null
    refresh_token_expires_at?: DateTimeNullableFilter<"auth_account"> | Date | string | null
    scope?: StringNullableFilter<"auth_account"> | string | null
    created_at?: DateTimeFilter<"auth_account"> | Date | string
    updated_at?: DateTimeNullableFilter<"auth_account"> | Date | string | null
    id_user?: UuidNullableFilter<"auth_account"> | string | null
    id_account?: StringNullableFilter<"auth_account"> | string | null
  }

  export type auth_sessionUpsertWithWhereUniqueWithoutAuth_userInput = {
    where: auth_sessionWhereUniqueInput
    update: XOR<auth_sessionUpdateWithoutAuth_userInput, auth_sessionUncheckedUpdateWithoutAuth_userInput>
    create: XOR<auth_sessionCreateWithoutAuth_userInput, auth_sessionUncheckedCreateWithoutAuth_userInput>
  }

  export type auth_sessionUpdateWithWhereUniqueWithoutAuth_userInput = {
    where: auth_sessionWhereUniqueInput
    data: XOR<auth_sessionUpdateWithoutAuth_userInput, auth_sessionUncheckedUpdateWithoutAuth_userInput>
  }

  export type auth_sessionUpdateManyWithWhereWithoutAuth_userInput = {
    where: auth_sessionScalarWhereInput
    data: XOR<auth_sessionUpdateManyMutationInput, auth_sessionUncheckedUpdateManyWithoutAuth_userInput>
  }

  export type auth_sessionScalarWhereInput = {
    AND?: auth_sessionScalarWhereInput | auth_sessionScalarWhereInput[]
    OR?: auth_sessionScalarWhereInput[]
    NOT?: auth_sessionScalarWhereInput | auth_sessionScalarWhereInput[]
    id?: UuidFilter<"auth_session"> | string
    expires_at?: DateTimeFilter<"auth_session"> | Date | string
    token?: StringFilter<"auth_session"> | string
    created_at?: DateTimeFilter<"auth_session"> | Date | string
    updated_at?: DateTimeNullableFilter<"auth_session"> | Date | string | null
    ip_address?: StringNullableFilter<"auth_session"> | string | null
    user_agent?: StringNullableFilter<"auth_session"> | string | null
    id_user?: UuidFilter<"auth_session"> | string
  }

  export type auth_two_factorUpsertWithWhereUniqueWithoutAuth_userInput = {
    where: auth_two_factorWhereUniqueInput
    update: XOR<auth_two_factorUpdateWithoutAuth_userInput, auth_two_factorUncheckedUpdateWithoutAuth_userInput>
    create: XOR<auth_two_factorCreateWithoutAuth_userInput, auth_two_factorUncheckedCreateWithoutAuth_userInput>
  }

  export type auth_two_factorUpdateWithWhereUniqueWithoutAuth_userInput = {
    where: auth_two_factorWhereUniqueInput
    data: XOR<auth_two_factorUpdateWithoutAuth_userInput, auth_two_factorUncheckedUpdateWithoutAuth_userInput>
  }

  export type auth_two_factorUpdateManyWithWhereWithoutAuth_userInput = {
    where: auth_two_factorScalarWhereInput
    data: XOR<auth_two_factorUpdateManyMutationInput, auth_two_factorUncheckedUpdateManyWithoutAuth_userInput>
  }

  export type auth_two_factorScalarWhereInput = {
    AND?: auth_two_factorScalarWhereInput | auth_two_factorScalarWhereInput[]
    OR?: auth_two_factorScalarWhereInput[]
    NOT?: auth_two_factorScalarWhereInput | auth_two_factorScalarWhereInput[]
    id?: UuidFilter<"auth_two_factor"> | string
    secret?: StringNullableFilter<"auth_two_factor"> | string | null
    backup_codes?: StringNullableFilter<"auth_two_factor"> | string | null
    id_user?: UuidFilter<"auth_two_factor"> | string
  }

  export type affiliateUpsertWithoutAuth_userInput = {
    update: XOR<affiliateUpdateWithoutAuth_userInput, affiliateUncheckedUpdateWithoutAuth_userInput>
    create: XOR<affiliateCreateWithoutAuth_userInput, affiliateUncheckedCreateWithoutAuth_userInput>
    where?: affiliateWhereInput
  }

  export type affiliateUpdateToOneWithWhereWithoutAuth_userInput = {
    where?: affiliateWhereInput
    data: XOR<affiliateUpdateWithoutAuth_userInput, affiliateUncheckedUpdateWithoutAuth_userInput>
  }

  export type affiliateUpdateWithoutAuth_userInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    auth_account?: auth_accountUpdateOneWithoutAffiliateNestedInput
  }

  export type affiliateUncheckedUpdateWithoutAuth_userInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    id_account?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type authorUpsertWithoutAuth_userInput = {
    update: XOR<authorUpdateWithoutAuth_userInput, authorUncheckedUpdateWithoutAuth_userInput>
    create: XOR<authorCreateWithoutAuth_userInput, authorUncheckedCreateWithoutAuth_userInput>
    where?: authorWhereInput
  }

  export type authorUpdateToOneWithWhereWithoutAuth_userInput = {
    where?: authorWhereInput
    data: XOR<authorUpdateWithoutAuth_userInput, authorUncheckedUpdateWithoutAuth_userInput>
  }

  export type authorUpdateWithoutAuth_userInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    biography?: NullableStringFieldUpdateOperationsInput | string | null
    social_media?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    auth_account?: auth_accountUpdateOneWithoutAuthorNestedInput
    book?: bookUpdateManyWithoutAuthorNestedInput
    product?: productUpdateManyWithoutAuthorNestedInput
    publisher_author?: publisher_authorUpdateManyWithoutAuthorNestedInput
  }

  export type authorUncheckedUpdateWithoutAuth_userInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    id_account?: NullableStringFieldUpdateOperationsInput | string | null
    biography?: NullableStringFieldUpdateOperationsInput | string | null
    social_media?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    book?: bookUncheckedUpdateManyWithoutAuthorNestedInput
    product?: productUncheckedUpdateManyWithoutAuthorNestedInput
    publisher_author?: publisher_authorUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type customerUpsertWithoutAuth_userInput = {
    update: XOR<customerUpdateWithoutAuth_userInput, customerUncheckedUpdateWithoutAuth_userInput>
    create: XOR<customerCreateWithoutAuth_userInput, customerUncheckedCreateWithoutAuth_userInput>
    where?: customerWhereInput
  }

  export type customerUpdateToOneWithWhereWithoutAuth_userInput = {
    where?: customerWhereInput
    data: XOR<customerUpdateWithoutAuth_userInput, customerUncheckedUpdateWithoutAuth_userInput>
  }

  export type customerUpdateWithoutAuth_userInput = {
    id?: StringFieldUpdateOperationsInput | string
    whatsapp?: StringFieldUpdateOperationsInput | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otp?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    auth_account?: auth_accountUpdateOneWithoutCustomerNestedInput
    customer_reader?: customer_readerUpdateManyWithoutCustomerNestedInput
    customer_track?: customer_trackUpdateManyWithoutCustomerNestedInput
    t_sales?: t_salesUpdateManyWithoutCustomerNestedInput
    t_sales_download?: t_sales_downloadUpdateManyWithoutCustomerNestedInput
  }

  export type customerUncheckedUpdateWithoutAuth_userInput = {
    id?: StringFieldUpdateOperationsInput | string
    whatsapp?: StringFieldUpdateOperationsInput | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otp?: NullableIntFieldUpdateOperationsInput | number | null
    id_account?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    customer_reader?: customer_readerUncheckedUpdateManyWithoutCustomerNestedInput
    customer_track?: customer_trackUncheckedUpdateManyWithoutCustomerNestedInput
    t_sales?: t_salesUncheckedUpdateManyWithoutCustomerNestedInput
    t_sales_download?: t_sales_downloadUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type internalUpsertWithoutAuth_userInput = {
    update: XOR<internalUpdateWithoutAuth_userInput, internalUncheckedUpdateWithoutAuth_userInput>
    create: XOR<internalCreateWithoutAuth_userInput, internalUncheckedCreateWithoutAuth_userInput>
    where?: internalWhereInput
  }

  export type internalUpdateToOneWithWhereWithoutAuth_userInput = {
    where?: internalWhereInput
    data: XOR<internalUpdateWithoutAuth_userInput, internalUncheckedUpdateWithoutAuth_userInput>
  }

  export type internalUpdateWithoutAuth_userInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    is_sales_and_marketing?: BoolFieldUpdateOperationsInput | boolean
    is_support?: BoolFieldUpdateOperationsInput | boolean
    is_management?: BoolFieldUpdateOperationsInput | boolean
    is_it?: BoolFieldUpdateOperationsInput | boolean
    book_approval?: book_approvalUpdateManyWithoutInternalNestedInput
    auth_account?: auth_accountUpdateOneWithoutInternalNestedInput
  }

  export type internalUncheckedUpdateWithoutAuth_userInput = {
    id?: StringFieldUpdateOperationsInput | string
    id_account?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    is_sales_and_marketing?: BoolFieldUpdateOperationsInput | boolean
    is_support?: BoolFieldUpdateOperationsInput | boolean
    is_management?: BoolFieldUpdateOperationsInput | boolean
    is_it?: BoolFieldUpdateOperationsInput | boolean
    book_approval?: book_approvalUncheckedUpdateManyWithoutInternalNestedInput
  }

  export type publisherUpsertWithoutAuth_userInput = {
    update: XOR<publisherUpdateWithoutAuth_userInput, publisherUncheckedUpdateWithoutAuth_userInput>
    create: XOR<publisherCreateWithoutAuth_userInput, publisherUncheckedCreateWithoutAuth_userInput>
    where?: publisherWhereInput
  }

  export type publisherUpdateToOneWithWhereWithoutAuth_userInput = {
    where?: publisherWhereInput
    data: XOR<publisherUpdateWithoutAuth_userInput, publisherUncheckedUpdateWithoutAuth_userInput>
  }

  export type publisherUpdateWithoutAuth_userInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    promo_code?: promo_codeUpdateManyWithoutPublisherNestedInput
    auth_account?: auth_accountUpdateOneWithoutPublisherNestedInput
    publisher_author?: publisher_authorUpdateManyWithoutPublisherNestedInput
    t_ai_credit?: t_ai_creditUpdateManyWithoutPublisherNestedInput
    transaction?: transactionUpdateManyWithoutPublisherNestedInput
    withdrawal?: withdrawalUpdateManyWithoutPublisherNestedInput
  }

  export type publisherUncheckedUpdateWithoutAuth_userInput = {
    id?: StringFieldUpdateOperationsInput | string
    id_account?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    promo_code?: promo_codeUncheckedUpdateManyWithoutPublisherNestedInput
    publisher_author?: publisher_authorUncheckedUpdateManyWithoutPublisherNestedInput
    t_ai_credit?: t_ai_creditUncheckedUpdateManyWithoutPublisherNestedInput
    transaction?: transactionUncheckedUpdateManyWithoutPublisherNestedInput
    withdrawal?: withdrawalUncheckedUpdateManyWithoutPublisherNestedInput
  }

  export type reviewsUpsertWithWhereUniqueWithoutAuth_userInput = {
    where: reviewsWhereUniqueInput
    update: XOR<reviewsUpdateWithoutAuth_userInput, reviewsUncheckedUpdateWithoutAuth_userInput>
    create: XOR<reviewsCreateWithoutAuth_userInput, reviewsUncheckedCreateWithoutAuth_userInput>
  }

  export type reviewsUpdateWithWhereUniqueWithoutAuth_userInput = {
    where: reviewsWhereUniqueInput
    data: XOR<reviewsUpdateWithoutAuth_userInput, reviewsUncheckedUpdateWithoutAuth_userInput>
  }

  export type reviewsUpdateManyWithWhereWithoutAuth_userInput = {
    where: reviewsScalarWhereInput
    data: XOR<reviewsUpdateManyMutationInput, reviewsUncheckedUpdateManyWithoutAuth_userInput>
  }

  export type reviewsScalarWhereInput = {
    AND?: reviewsScalarWhereInput | reviewsScalarWhereInput[]
    OR?: reviewsScalarWhereInput[]
    NOT?: reviewsScalarWhereInput | reviewsScalarWhereInput[]
    id?: UuidFilter<"reviews"> | string
    id_book?: UuidFilter<"reviews"> | string
    comments?: StringFilter<"reviews"> | string
    rating?: DecimalNullableFilter<"reviews"> | Decimal | DecimalJsLike | number | string | null
    created_at?: DateTimeFilter<"reviews"> | Date | string
    deleted_at?: DateTimeNullableFilter<"reviews"> | Date | string | null
    parent?: UuidNullableFilter<"reviews"> | string | null
    id_user?: UuidFilter<"reviews"> | string
  }

  export type reviews_likesUpsertWithWhereUniqueWithoutAuth_userInput = {
    where: reviews_likesWhereUniqueInput
    update: XOR<reviews_likesUpdateWithoutAuth_userInput, reviews_likesUncheckedUpdateWithoutAuth_userInput>
    create: XOR<reviews_likesCreateWithoutAuth_userInput, reviews_likesUncheckedCreateWithoutAuth_userInput>
  }

  export type reviews_likesUpdateWithWhereUniqueWithoutAuth_userInput = {
    where: reviews_likesWhereUniqueInput
    data: XOR<reviews_likesUpdateWithoutAuth_userInput, reviews_likesUncheckedUpdateWithoutAuth_userInput>
  }

  export type reviews_likesUpdateManyWithWhereWithoutAuth_userInput = {
    where: reviews_likesScalarWhereInput
    data: XOR<reviews_likesUpdateManyMutationInput, reviews_likesUncheckedUpdateManyWithoutAuth_userInput>
  }

  export type reviews_likesScalarWhereInput = {
    AND?: reviews_likesScalarWhereInput | reviews_likesScalarWhereInput[]
    OR?: reviews_likesScalarWhereInput[]
    NOT?: reviews_likesScalarWhereInput | reviews_likesScalarWhereInput[]
    id?: UuidFilter<"reviews_likes"> | string
    id_reviews?: UuidFilter<"reviews_likes"> | string
    id_user?: UuidFilter<"reviews_likes"> | string
  }

  export type auth_userCreateWithoutAuthorInput = {
    id?: string
    name: string
    email: string
    email_verified?: boolean
    image?: string | null
    created_at?: Date | string
    updated_at?: Date | string | null
    username?: string | null
    display_username?: string | null
    two_factor_enabled?: boolean | null
    auth_account?: auth_accountCreateNestedManyWithoutAuth_userInput
    auth_session?: auth_sessionCreateNestedManyWithoutAuth_userInput
    auth_two_factor?: auth_two_factorCreateNestedManyWithoutAuth_userInput
    affiliate?: affiliateCreateNestedOneWithoutAuth_userInput
    customer?: customerCreateNestedOneWithoutAuth_userInput
    internal?: internalCreateNestedOneWithoutAuth_userInput
    publisher?: publisherCreateNestedOneWithoutAuth_userInput
    reviews?: reviewsCreateNestedManyWithoutAuth_userInput
    reviews_likes?: reviews_likesCreateNestedManyWithoutAuth_userInput
  }

  export type auth_userUncheckedCreateWithoutAuthorInput = {
    id?: string
    name: string
    email: string
    email_verified?: boolean
    image?: string | null
    created_at?: Date | string
    updated_at?: Date | string | null
    username?: string | null
    display_username?: string | null
    two_factor_enabled?: boolean | null
    id_customer?: string | null
    id_affiliate?: string | null
    id_publisher?: string | null
    id_internal?: string | null
    auth_account?: auth_accountUncheckedCreateNestedManyWithoutAuth_userInput
    auth_session?: auth_sessionUncheckedCreateNestedManyWithoutAuth_userInput
    auth_two_factor?: auth_two_factorUncheckedCreateNestedManyWithoutAuth_userInput
    reviews?: reviewsUncheckedCreateNestedManyWithoutAuth_userInput
    reviews_likes?: reviews_likesUncheckedCreateNestedManyWithoutAuth_userInput
  }

  export type auth_userCreateOrConnectWithoutAuthorInput = {
    where: auth_userWhereUniqueInput
    create: XOR<auth_userCreateWithoutAuthorInput, auth_userUncheckedCreateWithoutAuthorInput>
  }

  export type auth_userCreateManyAuthorInputEnvelope = {
    data: auth_userCreateManyAuthorInput | auth_userCreateManyAuthorInput[]
    skipDuplicates?: boolean
  }

  export type auth_accountCreateWithoutAuthorInput = {
    id?: string
    password?: string | null
    id_provider?: string | null
    access_token?: string | null
    refresh_token?: string | null
    id_token?: string | null
    access_token_expires_at?: Date | string | null
    refresh_token_expires_at?: Date | string | null
    scope?: string | null
    created_at?: Date | string
    updated_at?: Date | string | null
    id_account?: string | null
    affiliate?: affiliateCreateNestedManyWithoutAuth_accountInput
    auth_user?: auth_userCreateNestedOneWithoutAuth_accountInput
    customer?: customerCreateNestedManyWithoutAuth_accountInput
    internal?: internalCreateNestedManyWithoutAuth_accountInput
    publisher?: publisherCreateNestedManyWithoutAuth_accountInput
  }

  export type auth_accountUncheckedCreateWithoutAuthorInput = {
    id?: string
    password?: string | null
    id_provider?: string | null
    access_token?: string | null
    refresh_token?: string | null
    id_token?: string | null
    access_token_expires_at?: Date | string | null
    refresh_token_expires_at?: Date | string | null
    scope?: string | null
    created_at?: Date | string
    updated_at?: Date | string | null
    id_user?: string | null
    id_account?: string | null
    affiliate?: affiliateUncheckedCreateNestedManyWithoutAuth_accountInput
    customer?: customerUncheckedCreateNestedManyWithoutAuth_accountInput
    internal?: internalUncheckedCreateNestedManyWithoutAuth_accountInput
    publisher?: publisherUncheckedCreateNestedManyWithoutAuth_accountInput
  }

  export type auth_accountCreateOrConnectWithoutAuthorInput = {
    where: auth_accountWhereUniqueInput
    create: XOR<auth_accountCreateWithoutAuthorInput, auth_accountUncheckedCreateWithoutAuthorInput>
  }

  export type bookCreateWithoutAuthorInput = {
    id?: string
    name: string
    slug: string
    alias?: string
    submitted_price: Decimal | DecimalJsLike | number | string
    desc?: string
    info?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    currency?: string
    deleted_at?: Date | string | null
    img_file?: string
    cover?: string
    product_file?: string
    sku?: string
    published_date?: Date | string
    is_physical?: boolean
    preorder_min_qty?: number | null
    content_type?: string | null
    is_chapter?: boolean
    created_at?: Date | string
    product?: productCreateNestedOneWithoutBookInput
    book_approval?: book_approvalCreateNestedManyWithoutBookInput
    book_changes_log?: book_changes_logCreateNestedManyWithoutBookInput
    book_genre?: book_genreCreateNestedManyWithoutBookInput
    book_tags?: book_tagsCreateNestedManyWithoutBookInput
    chapter?: chapterCreateNestedManyWithoutBookInput
    ranking?: rankingCreateNestedManyWithoutBookInput
    reviews?: reviewsCreateNestedManyWithoutBookInput
  }

  export type bookUncheckedCreateWithoutAuthorInput = {
    id?: string
    name: string
    slug: string
    alias?: string
    submitted_price: Decimal | DecimalJsLike | number | string
    desc?: string
    info?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    currency?: string
    deleted_at?: Date | string | null
    img_file?: string
    cover?: string
    product_file?: string
    sku?: string
    published_date?: Date | string
    is_physical?: boolean
    preorder_min_qty?: number | null
    content_type?: string | null
    is_chapter?: boolean
    id_product?: string | null
    created_at?: Date | string
    book_approval?: book_approvalUncheckedCreateNestedManyWithoutBookInput
    book_changes_log?: book_changes_logUncheckedCreateNestedManyWithoutBookInput
    book_genre?: book_genreUncheckedCreateNestedManyWithoutBookInput
    book_tags?: book_tagsUncheckedCreateNestedManyWithoutBookInput
    chapter?: chapterUncheckedCreateNestedManyWithoutBookInput
    ranking?: rankingUncheckedCreateNestedManyWithoutBookInput
    reviews?: reviewsUncheckedCreateNestedManyWithoutBookInput
  }

  export type bookCreateOrConnectWithoutAuthorInput = {
    where: bookWhereUniqueInput
    create: XOR<bookCreateWithoutAuthorInput, bookUncheckedCreateWithoutAuthorInput>
  }

  export type bookCreateManyAuthorInputEnvelope = {
    data: bookCreateManyAuthorInput | bookCreateManyAuthorInput[]
    skipDuplicates?: boolean
  }

  export type productCreateWithoutAuthorInput = {
    id?: string
    name: string
    slug: string
    alias?: string
    strike_price?: Decimal | DecimalJsLike | number | string | null
    real_price: Decimal | DecimalJsLike | number | string
    desc?: string
    info?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    currency?: string
    deleted_at?: Date | string | null
    img_file?: string
    cover?: string
    product_file?: string
    sku?: string
    published_date?: Date | string
    is_physical?: boolean
    preorder_min_qty?: number | null
    content_type?: string | null
    is_chapter?: boolean
    book?: bookCreateNestedManyWithoutProductInput
    bundle_product?: bundle_productCreateNestedManyWithoutProductInput
    chapter?: chapterCreateNestedManyWithoutProductInput
    customer_reader?: customer_readerCreateNestedManyWithoutProductInput
    preorder?: preorderCreateNestedManyWithoutProductInput
    product_category?: product_categoryCreateNestedManyWithoutProductInput
    t_sales_download?: t_sales_downloadCreateNestedManyWithoutProductInput
    t_sales_line?: t_sales_lineCreateNestedManyWithoutProductInput
  }

  export type productUncheckedCreateWithoutAuthorInput = {
    id?: string
    name: string
    slug: string
    alias?: string
    strike_price?: Decimal | DecimalJsLike | number | string | null
    real_price: Decimal | DecimalJsLike | number | string
    desc?: string
    info?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    currency?: string
    deleted_at?: Date | string | null
    img_file?: string
    cover?: string
    product_file?: string
    sku?: string
    published_date?: Date | string
    is_physical?: boolean
    preorder_min_qty?: number | null
    content_type?: string | null
    is_chapter?: boolean
    book?: bookUncheckedCreateNestedManyWithoutProductInput
    bundle_product?: bundle_productUncheckedCreateNestedManyWithoutProductInput
    chapter?: chapterUncheckedCreateNestedManyWithoutProductInput
    customer_reader?: customer_readerUncheckedCreateNestedManyWithoutProductInput
    preorder?: preorderUncheckedCreateNestedManyWithoutProductInput
    product_category?: product_categoryUncheckedCreateNestedManyWithoutProductInput
    t_sales_download?: t_sales_downloadUncheckedCreateNestedManyWithoutProductInput
    t_sales_line?: t_sales_lineUncheckedCreateNestedManyWithoutProductInput
  }

  export type productCreateOrConnectWithoutAuthorInput = {
    where: productWhereUniqueInput
    create: XOR<productCreateWithoutAuthorInput, productUncheckedCreateWithoutAuthorInput>
  }

  export type productCreateManyAuthorInputEnvelope = {
    data: productCreateManyAuthorInput | productCreateManyAuthorInput[]
    skipDuplicates?: boolean
  }

  export type publisher_authorCreateWithoutAuthorInput = {
    id?: string
    publisher: publisherCreateNestedOneWithoutPublisher_authorInput
  }

  export type publisher_authorUncheckedCreateWithoutAuthorInput = {
    id?: string
    publisher_id: string
  }

  export type publisher_authorCreateOrConnectWithoutAuthorInput = {
    where: publisher_authorWhereUniqueInput
    create: XOR<publisher_authorCreateWithoutAuthorInput, publisher_authorUncheckedCreateWithoutAuthorInput>
  }

  export type publisher_authorCreateManyAuthorInputEnvelope = {
    data: publisher_authorCreateManyAuthorInput | publisher_authorCreateManyAuthorInput[]
    skipDuplicates?: boolean
  }

  export type auth_userUpsertWithWhereUniqueWithoutAuthorInput = {
    where: auth_userWhereUniqueInput
    update: XOR<auth_userUpdateWithoutAuthorInput, auth_userUncheckedUpdateWithoutAuthorInput>
    create: XOR<auth_userCreateWithoutAuthorInput, auth_userUncheckedCreateWithoutAuthorInput>
  }

  export type auth_userUpdateWithWhereUniqueWithoutAuthorInput = {
    where: auth_userWhereUniqueInput
    data: XOR<auth_userUpdateWithoutAuthorInput, auth_userUncheckedUpdateWithoutAuthorInput>
  }

  export type auth_userUpdateManyWithWhereWithoutAuthorInput = {
    where: auth_userScalarWhereInput
    data: XOR<auth_userUpdateManyMutationInput, auth_userUncheckedUpdateManyWithoutAuthorInput>
  }

  export type auth_accountUpsertWithoutAuthorInput = {
    update: XOR<auth_accountUpdateWithoutAuthorInput, auth_accountUncheckedUpdateWithoutAuthorInput>
    create: XOR<auth_accountCreateWithoutAuthorInput, auth_accountUncheckedCreateWithoutAuthorInput>
    where?: auth_accountWhereInput
  }

  export type auth_accountUpdateToOneWithWhereWithoutAuthorInput = {
    where?: auth_accountWhereInput
    data: XOR<auth_accountUpdateWithoutAuthorInput, auth_accountUncheckedUpdateWithoutAuthorInput>
  }

  export type auth_accountUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    id_provider?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token_expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refresh_token_expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    id_account?: NullableStringFieldUpdateOperationsInput | string | null
    affiliate?: affiliateUpdateManyWithoutAuth_accountNestedInput
    auth_user?: auth_userUpdateOneWithoutAuth_accountNestedInput
    customer?: customerUpdateManyWithoutAuth_accountNestedInput
    internal?: internalUpdateManyWithoutAuth_accountNestedInput
    publisher?: publisherUpdateManyWithoutAuth_accountNestedInput
  }

  export type auth_accountUncheckedUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    id_provider?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token_expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refresh_token_expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    id_user?: NullableStringFieldUpdateOperationsInput | string | null
    id_account?: NullableStringFieldUpdateOperationsInput | string | null
    affiliate?: affiliateUncheckedUpdateManyWithoutAuth_accountNestedInput
    customer?: customerUncheckedUpdateManyWithoutAuth_accountNestedInput
    internal?: internalUncheckedUpdateManyWithoutAuth_accountNestedInput
    publisher?: publisherUncheckedUpdateManyWithoutAuth_accountNestedInput
  }

  export type bookUpsertWithWhereUniqueWithoutAuthorInput = {
    where: bookWhereUniqueInput
    update: XOR<bookUpdateWithoutAuthorInput, bookUncheckedUpdateWithoutAuthorInput>
    create: XOR<bookCreateWithoutAuthorInput, bookUncheckedCreateWithoutAuthorInput>
  }

  export type bookUpdateWithWhereUniqueWithoutAuthorInput = {
    where: bookWhereUniqueInput
    data: XOR<bookUpdateWithoutAuthorInput, bookUncheckedUpdateWithoutAuthorInput>
  }

  export type bookUpdateManyWithWhereWithoutAuthorInput = {
    where: bookScalarWhereInput
    data: XOR<bookUpdateManyMutationInput, bookUncheckedUpdateManyWithoutAuthorInput>
  }

  export type bookScalarWhereInput = {
    AND?: bookScalarWhereInput | bookScalarWhereInput[]
    OR?: bookScalarWhereInput[]
    NOT?: bookScalarWhereInput | bookScalarWhereInput[]
    id?: UuidFilter<"book"> | string
    name?: StringFilter<"book"> | string
    slug?: StringFilter<"book"> | string
    alias?: StringFilter<"book"> | string
    submitted_price?: DecimalFilter<"book"> | Decimal | DecimalJsLike | number | string
    desc?: StringFilter<"book"> | string
    info?: JsonNullableFilter<"book">
    status?: StringFilter<"book"> | string
    currency?: StringFilter<"book"> | string
    deleted_at?: DateTimeNullableFilter<"book"> | Date | string | null
    img_file?: StringFilter<"book"> | string
    cover?: StringFilter<"book"> | string
    product_file?: StringFilter<"book"> | string
    sku?: StringFilter<"book"> | string
    id_author?: UuidNullableFilter<"book"> | string | null
    published_date?: DateTimeFilter<"book"> | Date | string
    is_physical?: BoolFilter<"book"> | boolean
    preorder_min_qty?: IntNullableFilter<"book"> | number | null
    content_type?: StringNullableFilter<"book"> | string | null
    is_chapter?: BoolFilter<"book"> | boolean
    id_product?: UuidNullableFilter<"book"> | string | null
    created_at?: DateTimeFilter<"book"> | Date | string
  }

  export type productUpsertWithWhereUniqueWithoutAuthorInput = {
    where: productWhereUniqueInput
    update: XOR<productUpdateWithoutAuthorInput, productUncheckedUpdateWithoutAuthorInput>
    create: XOR<productCreateWithoutAuthorInput, productUncheckedCreateWithoutAuthorInput>
  }

  export type productUpdateWithWhereUniqueWithoutAuthorInput = {
    where: productWhereUniqueInput
    data: XOR<productUpdateWithoutAuthorInput, productUncheckedUpdateWithoutAuthorInput>
  }

  export type productUpdateManyWithWhereWithoutAuthorInput = {
    where: productScalarWhereInput
    data: XOR<productUpdateManyMutationInput, productUncheckedUpdateManyWithoutAuthorInput>
  }

  export type productScalarWhereInput = {
    AND?: productScalarWhereInput | productScalarWhereInput[]
    OR?: productScalarWhereInput[]
    NOT?: productScalarWhereInput | productScalarWhereInput[]
    id?: UuidFilter<"product"> | string
    name?: StringFilter<"product"> | string
    slug?: StringFilter<"product"> | string
    alias?: StringFilter<"product"> | string
    strike_price?: DecimalNullableFilter<"product"> | Decimal | DecimalJsLike | number | string | null
    real_price?: DecimalFilter<"product"> | Decimal | DecimalJsLike | number | string
    desc?: StringFilter<"product"> | string
    info?: JsonNullableFilter<"product">
    status?: StringFilter<"product"> | string
    currency?: StringFilter<"product"> | string
    deleted_at?: DateTimeNullableFilter<"product"> | Date | string | null
    img_file?: StringFilter<"product"> | string
    cover?: StringFilter<"product"> | string
    product_file?: StringFilter<"product"> | string
    sku?: StringFilter<"product"> | string
    id_author?: UuidNullableFilter<"product"> | string | null
    published_date?: DateTimeFilter<"product"> | Date | string
    is_physical?: BoolFilter<"product"> | boolean
    preorder_min_qty?: IntNullableFilter<"product"> | number | null
    content_type?: StringNullableFilter<"product"> | string | null
    is_chapter?: BoolFilter<"product"> | boolean
  }

  export type publisher_authorUpsertWithWhereUniqueWithoutAuthorInput = {
    where: publisher_authorWhereUniqueInput
    update: XOR<publisher_authorUpdateWithoutAuthorInput, publisher_authorUncheckedUpdateWithoutAuthorInput>
    create: XOR<publisher_authorCreateWithoutAuthorInput, publisher_authorUncheckedCreateWithoutAuthorInput>
  }

  export type publisher_authorUpdateWithWhereUniqueWithoutAuthorInput = {
    where: publisher_authorWhereUniqueInput
    data: XOR<publisher_authorUpdateWithoutAuthorInput, publisher_authorUncheckedUpdateWithoutAuthorInput>
  }

  export type publisher_authorUpdateManyWithWhereWithoutAuthorInput = {
    where: publisher_authorScalarWhereInput
    data: XOR<publisher_authorUpdateManyMutationInput, publisher_authorUncheckedUpdateManyWithoutAuthorInput>
  }

  export type publisher_authorScalarWhereInput = {
    AND?: publisher_authorScalarWhereInput | publisher_authorScalarWhereInput[]
    OR?: publisher_authorScalarWhereInput[]
    NOT?: publisher_authorScalarWhereInput | publisher_authorScalarWhereInput[]
    id?: UuidFilter<"publisher_author"> | string
    publisher_id?: UuidFilter<"publisher_author"> | string
    author_id?: UuidFilter<"publisher_author"> | string
  }

  export type authorCreateWithoutBookInput = {
    id?: string
    name: string
    biography?: string | null
    social_media?: string | null
    avatar?: string | null
    auth_user?: auth_userCreateNestedManyWithoutAuthorInput
    auth_account?: auth_accountCreateNestedOneWithoutAuthorInput
    product?: productCreateNestedManyWithoutAuthorInput
    publisher_author?: publisher_authorCreateNestedManyWithoutAuthorInput
  }

  export type authorUncheckedCreateWithoutBookInput = {
    id?: string
    name: string
    id_account?: string | null
    biography?: string | null
    social_media?: string | null
    avatar?: string | null
    auth_user?: auth_userUncheckedCreateNestedManyWithoutAuthorInput
    product?: productUncheckedCreateNestedManyWithoutAuthorInput
    publisher_author?: publisher_authorUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type authorCreateOrConnectWithoutBookInput = {
    where: authorWhereUniqueInput
    create: XOR<authorCreateWithoutBookInput, authorUncheckedCreateWithoutBookInput>
  }

  export type productCreateWithoutBookInput = {
    id?: string
    name: string
    slug: string
    alias?: string
    strike_price?: Decimal | DecimalJsLike | number | string | null
    real_price: Decimal | DecimalJsLike | number | string
    desc?: string
    info?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    currency?: string
    deleted_at?: Date | string | null
    img_file?: string
    cover?: string
    product_file?: string
    sku?: string
    published_date?: Date | string
    is_physical?: boolean
    preorder_min_qty?: number | null
    content_type?: string | null
    is_chapter?: boolean
    bundle_product?: bundle_productCreateNestedManyWithoutProductInput
    chapter?: chapterCreateNestedManyWithoutProductInput
    customer_reader?: customer_readerCreateNestedManyWithoutProductInput
    preorder?: preorderCreateNestedManyWithoutProductInput
    author?: authorCreateNestedOneWithoutProductInput
    product_category?: product_categoryCreateNestedManyWithoutProductInput
    t_sales_download?: t_sales_downloadCreateNestedManyWithoutProductInput
    t_sales_line?: t_sales_lineCreateNestedManyWithoutProductInput
  }

  export type productUncheckedCreateWithoutBookInput = {
    id?: string
    name: string
    slug: string
    alias?: string
    strike_price?: Decimal | DecimalJsLike | number | string | null
    real_price: Decimal | DecimalJsLike | number | string
    desc?: string
    info?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    currency?: string
    deleted_at?: Date | string | null
    img_file?: string
    cover?: string
    product_file?: string
    sku?: string
    id_author?: string | null
    published_date?: Date | string
    is_physical?: boolean
    preorder_min_qty?: number | null
    content_type?: string | null
    is_chapter?: boolean
    bundle_product?: bundle_productUncheckedCreateNestedManyWithoutProductInput
    chapter?: chapterUncheckedCreateNestedManyWithoutProductInput
    customer_reader?: customer_readerUncheckedCreateNestedManyWithoutProductInput
    preorder?: preorderUncheckedCreateNestedManyWithoutProductInput
    product_category?: product_categoryUncheckedCreateNestedManyWithoutProductInput
    t_sales_download?: t_sales_downloadUncheckedCreateNestedManyWithoutProductInput
    t_sales_line?: t_sales_lineUncheckedCreateNestedManyWithoutProductInput
  }

  export type productCreateOrConnectWithoutBookInput = {
    where: productWhereUniqueInput
    create: XOR<productCreateWithoutBookInput, productUncheckedCreateWithoutBookInput>
  }

  export type book_approvalCreateWithoutBookInput = {
    id?: string
    comment?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    created_at?: Date | string
    internal?: internalCreateNestedOneWithoutBook_approvalInput
  }

  export type book_approvalUncheckedCreateWithoutBookInput = {
    id?: string
    id_internal?: string | null
    comment?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    created_at?: Date | string
  }

  export type book_approvalCreateOrConnectWithoutBookInput = {
    where: book_approvalWhereUniqueInput
    create: XOR<book_approvalCreateWithoutBookInput, book_approvalUncheckedCreateWithoutBookInput>
  }

  export type book_approvalCreateManyBookInputEnvelope = {
    data: book_approvalCreateManyBookInput | book_approvalCreateManyBookInput[]
    skipDuplicates?: boolean
  }

  export type book_changes_logCreateWithoutBookInput = {
    created_at?: Date | string
    changes?: NullableJsonNullValueInput | InputJsonValue
  }

  export type book_changes_logUncheckedCreateWithoutBookInput = {
    created_at?: Date | string
    changes?: NullableJsonNullValueInput | InputJsonValue
  }

  export type book_changes_logCreateOrConnectWithoutBookInput = {
    where: book_changes_logWhereUniqueInput
    create: XOR<book_changes_logCreateWithoutBookInput, book_changes_logUncheckedCreateWithoutBookInput>
  }

  export type book_changes_logCreateManyBookInputEnvelope = {
    data: book_changes_logCreateManyBookInput | book_changes_logCreateManyBookInput[]
    skipDuplicates?: boolean
  }

  export type book_genreCreateWithoutBookInput = {
    id?: string
    genre: genreCreateNestedOneWithoutBook_genreInput
  }

  export type book_genreUncheckedCreateWithoutBookInput = {
    id?: string
    id_genre: string
  }

  export type book_genreCreateOrConnectWithoutBookInput = {
    where: book_genreWhereUniqueInput
    create: XOR<book_genreCreateWithoutBookInput, book_genreUncheckedCreateWithoutBookInput>
  }

  export type book_genreCreateManyBookInputEnvelope = {
    data: book_genreCreateManyBookInput | book_genreCreateManyBookInput[]
    skipDuplicates?: boolean
  }

  export type book_tagsCreateWithoutBookInput = {
    id?: string
    tags: tagsCreateNestedOneWithoutBook_tagsInput
  }

  export type book_tagsUncheckedCreateWithoutBookInput = {
    id?: string
    id_tags: string
  }

  export type book_tagsCreateOrConnectWithoutBookInput = {
    where: book_tagsWhereUniqueInput
    create: XOR<book_tagsCreateWithoutBookInput, book_tagsUncheckedCreateWithoutBookInput>
  }

  export type book_tagsCreateManyBookInputEnvelope = {
    data: book_tagsCreateManyBookInput | book_tagsCreateManyBookInput[]
    skipDuplicates?: boolean
  }

  export type chapterCreateWithoutBookInput = {
    id?: string
    number: number
    name: string
    content?: JsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string | null
    product?: productCreateNestedOneWithoutChapterInput
  }

  export type chapterUncheckedCreateWithoutBookInput = {
    id?: string
    id_product?: string | null
    number: number
    name: string
    content?: JsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string | null
  }

  export type chapterCreateOrConnectWithoutBookInput = {
    where: chapterWhereUniqueInput
    create: XOR<chapterCreateWithoutBookInput, chapterUncheckedCreateWithoutBookInput>
  }

  export type chapterCreateManyBookInputEnvelope = {
    data: chapterCreateManyBookInput | chapterCreateManyBookInput[]
    skipDuplicates?: boolean
  }

  export type rankingCreateWithoutBookInput = {
    id?: string
  }

  export type rankingUncheckedCreateWithoutBookInput = {
    id?: string
  }

  export type rankingCreateOrConnectWithoutBookInput = {
    where: rankingWhereUniqueInput
    create: XOR<rankingCreateWithoutBookInput, rankingUncheckedCreateWithoutBookInput>
  }

  export type rankingCreateManyBookInputEnvelope = {
    data: rankingCreateManyBookInput | rankingCreateManyBookInput[]
    skipDuplicates?: boolean
  }

  export type reviewsCreateWithoutBookInput = {
    id?: string
    comments: string
    rating?: Decimal | DecimalJsLike | number | string | null
    created_at: Date | string
    deleted_at?: Date | string | null
    parent?: string | null
    auth_user: auth_userCreateNestedOneWithoutReviewsInput
    reviews_likes?: reviews_likesCreateNestedManyWithoutReviewsInput
  }

  export type reviewsUncheckedCreateWithoutBookInput = {
    id?: string
    comments: string
    rating?: Decimal | DecimalJsLike | number | string | null
    created_at: Date | string
    deleted_at?: Date | string | null
    parent?: string | null
    id_user: string
    reviews_likes?: reviews_likesUncheckedCreateNestedManyWithoutReviewsInput
  }

  export type reviewsCreateOrConnectWithoutBookInput = {
    where: reviewsWhereUniqueInput
    create: XOR<reviewsCreateWithoutBookInput, reviewsUncheckedCreateWithoutBookInput>
  }

  export type reviewsCreateManyBookInputEnvelope = {
    data: reviewsCreateManyBookInput | reviewsCreateManyBookInput[]
    skipDuplicates?: boolean
  }

  export type authorUpsertWithoutBookInput = {
    update: XOR<authorUpdateWithoutBookInput, authorUncheckedUpdateWithoutBookInput>
    create: XOR<authorCreateWithoutBookInput, authorUncheckedCreateWithoutBookInput>
    where?: authorWhereInput
  }

  export type authorUpdateToOneWithWhereWithoutBookInput = {
    where?: authorWhereInput
    data: XOR<authorUpdateWithoutBookInput, authorUncheckedUpdateWithoutBookInput>
  }

  export type authorUpdateWithoutBookInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    biography?: NullableStringFieldUpdateOperationsInput | string | null
    social_media?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    auth_user?: auth_userUpdateManyWithoutAuthorNestedInput
    auth_account?: auth_accountUpdateOneWithoutAuthorNestedInput
    product?: productUpdateManyWithoutAuthorNestedInput
    publisher_author?: publisher_authorUpdateManyWithoutAuthorNestedInput
  }

  export type authorUncheckedUpdateWithoutBookInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    id_account?: NullableStringFieldUpdateOperationsInput | string | null
    biography?: NullableStringFieldUpdateOperationsInput | string | null
    social_media?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    auth_user?: auth_userUncheckedUpdateManyWithoutAuthorNestedInput
    product?: productUncheckedUpdateManyWithoutAuthorNestedInput
    publisher_author?: publisher_authorUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type productUpsertWithoutBookInput = {
    update: XOR<productUpdateWithoutBookInput, productUncheckedUpdateWithoutBookInput>
    create: XOR<productCreateWithoutBookInput, productUncheckedCreateWithoutBookInput>
    where?: productWhereInput
  }

  export type productUpdateToOneWithWhereWithoutBookInput = {
    where?: productWhereInput
    data: XOR<productUpdateWithoutBookInput, productUncheckedUpdateWithoutBookInput>
  }

  export type productUpdateWithoutBookInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    alias?: StringFieldUpdateOperationsInput | string
    strike_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    real_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    desc?: StringFieldUpdateOperationsInput | string
    info?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    img_file?: StringFieldUpdateOperationsInput | string
    cover?: StringFieldUpdateOperationsInput | string
    product_file?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    published_date?: DateTimeFieldUpdateOperationsInput | Date | string
    is_physical?: BoolFieldUpdateOperationsInput | boolean
    preorder_min_qty?: NullableIntFieldUpdateOperationsInput | number | null
    content_type?: NullableStringFieldUpdateOperationsInput | string | null
    is_chapter?: BoolFieldUpdateOperationsInput | boolean
    bundle_product?: bundle_productUpdateManyWithoutProductNestedInput
    chapter?: chapterUpdateManyWithoutProductNestedInput
    customer_reader?: customer_readerUpdateManyWithoutProductNestedInput
    preorder?: preorderUpdateManyWithoutProductNestedInput
    author?: authorUpdateOneWithoutProductNestedInput
    product_category?: product_categoryUpdateManyWithoutProductNestedInput
    t_sales_download?: t_sales_downloadUpdateManyWithoutProductNestedInput
    t_sales_line?: t_sales_lineUpdateManyWithoutProductNestedInput
  }

  export type productUncheckedUpdateWithoutBookInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    alias?: StringFieldUpdateOperationsInput | string
    strike_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    real_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    desc?: StringFieldUpdateOperationsInput | string
    info?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    img_file?: StringFieldUpdateOperationsInput | string
    cover?: StringFieldUpdateOperationsInput | string
    product_file?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    id_author?: NullableStringFieldUpdateOperationsInput | string | null
    published_date?: DateTimeFieldUpdateOperationsInput | Date | string
    is_physical?: BoolFieldUpdateOperationsInput | boolean
    preorder_min_qty?: NullableIntFieldUpdateOperationsInput | number | null
    content_type?: NullableStringFieldUpdateOperationsInput | string | null
    is_chapter?: BoolFieldUpdateOperationsInput | boolean
    bundle_product?: bundle_productUncheckedUpdateManyWithoutProductNestedInput
    chapter?: chapterUncheckedUpdateManyWithoutProductNestedInput
    customer_reader?: customer_readerUncheckedUpdateManyWithoutProductNestedInput
    preorder?: preorderUncheckedUpdateManyWithoutProductNestedInput
    product_category?: product_categoryUncheckedUpdateManyWithoutProductNestedInput
    t_sales_download?: t_sales_downloadUncheckedUpdateManyWithoutProductNestedInput
    t_sales_line?: t_sales_lineUncheckedUpdateManyWithoutProductNestedInput
  }

  export type book_approvalUpsertWithWhereUniqueWithoutBookInput = {
    where: book_approvalWhereUniqueInput
    update: XOR<book_approvalUpdateWithoutBookInput, book_approvalUncheckedUpdateWithoutBookInput>
    create: XOR<book_approvalCreateWithoutBookInput, book_approvalUncheckedCreateWithoutBookInput>
  }

  export type book_approvalUpdateWithWhereUniqueWithoutBookInput = {
    where: book_approvalWhereUniqueInput
    data: XOR<book_approvalUpdateWithoutBookInput, book_approvalUncheckedUpdateWithoutBookInput>
  }

  export type book_approvalUpdateManyWithWhereWithoutBookInput = {
    where: book_approvalScalarWhereInput
    data: XOR<book_approvalUpdateManyMutationInput, book_approvalUncheckedUpdateManyWithoutBookInput>
  }

  export type book_approvalScalarWhereInput = {
    AND?: book_approvalScalarWhereInput | book_approvalScalarWhereInput[]
    OR?: book_approvalScalarWhereInput[]
    NOT?: book_approvalScalarWhereInput | book_approvalScalarWhereInput[]
    id?: UuidFilter<"book_approval"> | string
    id_book?: UuidFilter<"book_approval"> | string
    id_internal?: UuidNullableFilter<"book_approval"> | string | null
    comment?: JsonNullableFilter<"book_approval">
    status?: StringFilter<"book_approval"> | string
    created_at?: DateTimeFilter<"book_approval"> | Date | string
  }

  export type book_changes_logUpsertWithWhereUniqueWithoutBookInput = {
    where: book_changes_logWhereUniqueInput
    update: XOR<book_changes_logUpdateWithoutBookInput, book_changes_logUncheckedUpdateWithoutBookInput>
    create: XOR<book_changes_logCreateWithoutBookInput, book_changes_logUncheckedCreateWithoutBookInput>
  }

  export type book_changes_logUpdateWithWhereUniqueWithoutBookInput = {
    where: book_changes_logWhereUniqueInput
    data: XOR<book_changes_logUpdateWithoutBookInput, book_changes_logUncheckedUpdateWithoutBookInput>
  }

  export type book_changes_logUpdateManyWithWhereWithoutBookInput = {
    where: book_changes_logScalarWhereInput
    data: XOR<book_changes_logUpdateManyMutationInput, book_changes_logUncheckedUpdateManyWithoutBookInput>
  }

  export type book_changes_logScalarWhereInput = {
    AND?: book_changes_logScalarWhereInput | book_changes_logScalarWhereInput[]
    OR?: book_changes_logScalarWhereInput[]
    NOT?: book_changes_logScalarWhereInput | book_changes_logScalarWhereInput[]
    id_book?: UuidFilter<"book_changes_log"> | string
    created_at?: DateTimeFilter<"book_changes_log"> | Date | string
    changes?: JsonNullableFilter<"book_changes_log">
  }

  export type book_genreUpsertWithWhereUniqueWithoutBookInput = {
    where: book_genreWhereUniqueInput
    update: XOR<book_genreUpdateWithoutBookInput, book_genreUncheckedUpdateWithoutBookInput>
    create: XOR<book_genreCreateWithoutBookInput, book_genreUncheckedCreateWithoutBookInput>
  }

  export type book_genreUpdateWithWhereUniqueWithoutBookInput = {
    where: book_genreWhereUniqueInput
    data: XOR<book_genreUpdateWithoutBookInput, book_genreUncheckedUpdateWithoutBookInput>
  }

  export type book_genreUpdateManyWithWhereWithoutBookInput = {
    where: book_genreScalarWhereInput
    data: XOR<book_genreUpdateManyMutationInput, book_genreUncheckedUpdateManyWithoutBookInput>
  }

  export type book_genreScalarWhereInput = {
    AND?: book_genreScalarWhereInput | book_genreScalarWhereInput[]
    OR?: book_genreScalarWhereInput[]
    NOT?: book_genreScalarWhereInput | book_genreScalarWhereInput[]
    id?: UuidFilter<"book_genre"> | string
    id_genre?: UuidFilter<"book_genre"> | string
    id_book?: UuidFilter<"book_genre"> | string
  }

  export type book_tagsUpsertWithWhereUniqueWithoutBookInput = {
    where: book_tagsWhereUniqueInput
    update: XOR<book_tagsUpdateWithoutBookInput, book_tagsUncheckedUpdateWithoutBookInput>
    create: XOR<book_tagsCreateWithoutBookInput, book_tagsUncheckedCreateWithoutBookInput>
  }

  export type book_tagsUpdateWithWhereUniqueWithoutBookInput = {
    where: book_tagsWhereUniqueInput
    data: XOR<book_tagsUpdateWithoutBookInput, book_tagsUncheckedUpdateWithoutBookInput>
  }

  export type book_tagsUpdateManyWithWhereWithoutBookInput = {
    where: book_tagsScalarWhereInput
    data: XOR<book_tagsUpdateManyMutationInput, book_tagsUncheckedUpdateManyWithoutBookInput>
  }

  export type book_tagsScalarWhereInput = {
    AND?: book_tagsScalarWhereInput | book_tagsScalarWhereInput[]
    OR?: book_tagsScalarWhereInput[]
    NOT?: book_tagsScalarWhereInput | book_tagsScalarWhereInput[]
    id?: UuidFilter<"book_tags"> | string
    id_tags?: UuidFilter<"book_tags"> | string
    id_book?: UuidFilter<"book_tags"> | string
  }

  export type chapterUpsertWithWhereUniqueWithoutBookInput = {
    where: chapterWhereUniqueInput
    update: XOR<chapterUpdateWithoutBookInput, chapterUncheckedUpdateWithoutBookInput>
    create: XOR<chapterCreateWithoutBookInput, chapterUncheckedCreateWithoutBookInput>
  }

  export type chapterUpdateWithWhereUniqueWithoutBookInput = {
    where: chapterWhereUniqueInput
    data: XOR<chapterUpdateWithoutBookInput, chapterUncheckedUpdateWithoutBookInput>
  }

  export type chapterUpdateManyWithWhereWithoutBookInput = {
    where: chapterScalarWhereInput
    data: XOR<chapterUpdateManyMutationInput, chapterUncheckedUpdateManyWithoutBookInput>
  }

  export type chapterScalarWhereInput = {
    AND?: chapterScalarWhereInput | chapterScalarWhereInput[]
    OR?: chapterScalarWhereInput[]
    NOT?: chapterScalarWhereInput | chapterScalarWhereInput[]
    id?: UuidFilter<"chapter"> | string
    id_product?: UuidNullableFilter<"chapter"> | string | null
    id_book?: UuidNullableFilter<"chapter"> | string | null
    number?: IntFilter<"chapter"> | number
    name?: StringFilter<"chapter"> | string
    content?: JsonFilter<"chapter">
    created_at?: DateTimeFilter<"chapter"> | Date | string
    updated_at?: DateTimeNullableFilter<"chapter"> | Date | string | null
  }

  export type rankingUpsertWithWhereUniqueWithoutBookInput = {
    where: rankingWhereUniqueInput
    update: XOR<rankingUpdateWithoutBookInput, rankingUncheckedUpdateWithoutBookInput>
    create: XOR<rankingCreateWithoutBookInput, rankingUncheckedCreateWithoutBookInput>
  }

  export type rankingUpdateWithWhereUniqueWithoutBookInput = {
    where: rankingWhereUniqueInput
    data: XOR<rankingUpdateWithoutBookInput, rankingUncheckedUpdateWithoutBookInput>
  }

  export type rankingUpdateManyWithWhereWithoutBookInput = {
    where: rankingScalarWhereInput
    data: XOR<rankingUpdateManyMutationInput, rankingUncheckedUpdateManyWithoutBookInput>
  }

  export type rankingScalarWhereInput = {
    AND?: rankingScalarWhereInput | rankingScalarWhereInput[]
    OR?: rankingScalarWhereInput[]
    NOT?: rankingScalarWhereInput | rankingScalarWhereInput[]
    id?: UuidFilter<"ranking"> | string
    id_book?: UuidFilter<"ranking"> | string
  }

  export type reviewsUpsertWithWhereUniqueWithoutBookInput = {
    where: reviewsWhereUniqueInput
    update: XOR<reviewsUpdateWithoutBookInput, reviewsUncheckedUpdateWithoutBookInput>
    create: XOR<reviewsCreateWithoutBookInput, reviewsUncheckedCreateWithoutBookInput>
  }

  export type reviewsUpdateWithWhereUniqueWithoutBookInput = {
    where: reviewsWhereUniqueInput
    data: XOR<reviewsUpdateWithoutBookInput, reviewsUncheckedUpdateWithoutBookInput>
  }

  export type reviewsUpdateManyWithWhereWithoutBookInput = {
    where: reviewsScalarWhereInput
    data: XOR<reviewsUpdateManyMutationInput, reviewsUncheckedUpdateManyWithoutBookInput>
  }

  export type bookCreateWithoutBook_approvalInput = {
    id?: string
    name: string
    slug: string
    alias?: string
    submitted_price: Decimal | DecimalJsLike | number | string
    desc?: string
    info?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    currency?: string
    deleted_at?: Date | string | null
    img_file?: string
    cover?: string
    product_file?: string
    sku?: string
    published_date?: Date | string
    is_physical?: boolean
    preorder_min_qty?: number | null
    content_type?: string | null
    is_chapter?: boolean
    created_at?: Date | string
    author?: authorCreateNestedOneWithoutBookInput
    product?: productCreateNestedOneWithoutBookInput
    book_changes_log?: book_changes_logCreateNestedManyWithoutBookInput
    book_genre?: book_genreCreateNestedManyWithoutBookInput
    book_tags?: book_tagsCreateNestedManyWithoutBookInput
    chapter?: chapterCreateNestedManyWithoutBookInput
    ranking?: rankingCreateNestedManyWithoutBookInput
    reviews?: reviewsCreateNestedManyWithoutBookInput
  }

  export type bookUncheckedCreateWithoutBook_approvalInput = {
    id?: string
    name: string
    slug: string
    alias?: string
    submitted_price: Decimal | DecimalJsLike | number | string
    desc?: string
    info?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    currency?: string
    deleted_at?: Date | string | null
    img_file?: string
    cover?: string
    product_file?: string
    sku?: string
    id_author?: string | null
    published_date?: Date | string
    is_physical?: boolean
    preorder_min_qty?: number | null
    content_type?: string | null
    is_chapter?: boolean
    id_product?: string | null
    created_at?: Date | string
    book_changes_log?: book_changes_logUncheckedCreateNestedManyWithoutBookInput
    book_genre?: book_genreUncheckedCreateNestedManyWithoutBookInput
    book_tags?: book_tagsUncheckedCreateNestedManyWithoutBookInput
    chapter?: chapterUncheckedCreateNestedManyWithoutBookInput
    ranking?: rankingUncheckedCreateNestedManyWithoutBookInput
    reviews?: reviewsUncheckedCreateNestedManyWithoutBookInput
  }

  export type bookCreateOrConnectWithoutBook_approvalInput = {
    where: bookWhereUniqueInput
    create: XOR<bookCreateWithoutBook_approvalInput, bookUncheckedCreateWithoutBook_approvalInput>
  }

  export type internalCreateWithoutBook_approvalInput = {
    id?: string
    name: string
    is_sales_and_marketing?: boolean
    is_support?: boolean
    is_management?: boolean
    is_it?: boolean
    auth_user?: auth_userCreateNestedManyWithoutInternalInput
    auth_account?: auth_accountCreateNestedOneWithoutInternalInput
  }

  export type internalUncheckedCreateWithoutBook_approvalInput = {
    id?: string
    id_account?: string | null
    name: string
    is_sales_and_marketing?: boolean
    is_support?: boolean
    is_management?: boolean
    is_it?: boolean
    auth_user?: auth_userUncheckedCreateNestedManyWithoutInternalInput
  }

  export type internalCreateOrConnectWithoutBook_approvalInput = {
    where: internalWhereUniqueInput
    create: XOR<internalCreateWithoutBook_approvalInput, internalUncheckedCreateWithoutBook_approvalInput>
  }

  export type bookUpsertWithoutBook_approvalInput = {
    update: XOR<bookUpdateWithoutBook_approvalInput, bookUncheckedUpdateWithoutBook_approvalInput>
    create: XOR<bookCreateWithoutBook_approvalInput, bookUncheckedCreateWithoutBook_approvalInput>
    where?: bookWhereInput
  }

  export type bookUpdateToOneWithWhereWithoutBook_approvalInput = {
    where?: bookWhereInput
    data: XOR<bookUpdateWithoutBook_approvalInput, bookUncheckedUpdateWithoutBook_approvalInput>
  }

  export type bookUpdateWithoutBook_approvalInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    alias?: StringFieldUpdateOperationsInput | string
    submitted_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    desc?: StringFieldUpdateOperationsInput | string
    info?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    img_file?: StringFieldUpdateOperationsInput | string
    cover?: StringFieldUpdateOperationsInput | string
    product_file?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    published_date?: DateTimeFieldUpdateOperationsInput | Date | string
    is_physical?: BoolFieldUpdateOperationsInput | boolean
    preorder_min_qty?: NullableIntFieldUpdateOperationsInput | number | null
    content_type?: NullableStringFieldUpdateOperationsInput | string | null
    is_chapter?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: authorUpdateOneWithoutBookNestedInput
    product?: productUpdateOneWithoutBookNestedInput
    book_changes_log?: book_changes_logUpdateManyWithoutBookNestedInput
    book_genre?: book_genreUpdateManyWithoutBookNestedInput
    book_tags?: book_tagsUpdateManyWithoutBookNestedInput
    chapter?: chapterUpdateManyWithoutBookNestedInput
    ranking?: rankingUpdateManyWithoutBookNestedInput
    reviews?: reviewsUpdateManyWithoutBookNestedInput
  }

  export type bookUncheckedUpdateWithoutBook_approvalInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    alias?: StringFieldUpdateOperationsInput | string
    submitted_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    desc?: StringFieldUpdateOperationsInput | string
    info?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    img_file?: StringFieldUpdateOperationsInput | string
    cover?: StringFieldUpdateOperationsInput | string
    product_file?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    id_author?: NullableStringFieldUpdateOperationsInput | string | null
    published_date?: DateTimeFieldUpdateOperationsInput | Date | string
    is_physical?: BoolFieldUpdateOperationsInput | boolean
    preorder_min_qty?: NullableIntFieldUpdateOperationsInput | number | null
    content_type?: NullableStringFieldUpdateOperationsInput | string | null
    is_chapter?: BoolFieldUpdateOperationsInput | boolean
    id_product?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    book_changes_log?: book_changes_logUncheckedUpdateManyWithoutBookNestedInput
    book_genre?: book_genreUncheckedUpdateManyWithoutBookNestedInput
    book_tags?: book_tagsUncheckedUpdateManyWithoutBookNestedInput
    chapter?: chapterUncheckedUpdateManyWithoutBookNestedInput
    ranking?: rankingUncheckedUpdateManyWithoutBookNestedInput
    reviews?: reviewsUncheckedUpdateManyWithoutBookNestedInput
  }

  export type internalUpsertWithoutBook_approvalInput = {
    update: XOR<internalUpdateWithoutBook_approvalInput, internalUncheckedUpdateWithoutBook_approvalInput>
    create: XOR<internalCreateWithoutBook_approvalInput, internalUncheckedCreateWithoutBook_approvalInput>
    where?: internalWhereInput
  }

  export type internalUpdateToOneWithWhereWithoutBook_approvalInput = {
    where?: internalWhereInput
    data: XOR<internalUpdateWithoutBook_approvalInput, internalUncheckedUpdateWithoutBook_approvalInput>
  }

  export type internalUpdateWithoutBook_approvalInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    is_sales_and_marketing?: BoolFieldUpdateOperationsInput | boolean
    is_support?: BoolFieldUpdateOperationsInput | boolean
    is_management?: BoolFieldUpdateOperationsInput | boolean
    is_it?: BoolFieldUpdateOperationsInput | boolean
    auth_user?: auth_userUpdateManyWithoutInternalNestedInput
    auth_account?: auth_accountUpdateOneWithoutInternalNestedInput
  }

  export type internalUncheckedUpdateWithoutBook_approvalInput = {
    id?: StringFieldUpdateOperationsInput | string
    id_account?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    is_sales_and_marketing?: BoolFieldUpdateOperationsInput | boolean
    is_support?: BoolFieldUpdateOperationsInput | boolean
    is_management?: BoolFieldUpdateOperationsInput | boolean
    is_it?: BoolFieldUpdateOperationsInput | boolean
    auth_user?: auth_userUncheckedUpdateManyWithoutInternalNestedInput
  }

  export type bookCreateWithoutBook_changes_logInput = {
    id?: string
    name: string
    slug: string
    alias?: string
    submitted_price: Decimal | DecimalJsLike | number | string
    desc?: string
    info?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    currency?: string
    deleted_at?: Date | string | null
    img_file?: string
    cover?: string
    product_file?: string
    sku?: string
    published_date?: Date | string
    is_physical?: boolean
    preorder_min_qty?: number | null
    content_type?: string | null
    is_chapter?: boolean
    created_at?: Date | string
    author?: authorCreateNestedOneWithoutBookInput
    product?: productCreateNestedOneWithoutBookInput
    book_approval?: book_approvalCreateNestedManyWithoutBookInput
    book_genre?: book_genreCreateNestedManyWithoutBookInput
    book_tags?: book_tagsCreateNestedManyWithoutBookInput
    chapter?: chapterCreateNestedManyWithoutBookInput
    ranking?: rankingCreateNestedManyWithoutBookInput
    reviews?: reviewsCreateNestedManyWithoutBookInput
  }

  export type bookUncheckedCreateWithoutBook_changes_logInput = {
    id?: string
    name: string
    slug: string
    alias?: string
    submitted_price: Decimal | DecimalJsLike | number | string
    desc?: string
    info?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    currency?: string
    deleted_at?: Date | string | null
    img_file?: string
    cover?: string
    product_file?: string
    sku?: string
    id_author?: string | null
    published_date?: Date | string
    is_physical?: boolean
    preorder_min_qty?: number | null
    content_type?: string | null
    is_chapter?: boolean
    id_product?: string | null
    created_at?: Date | string
    book_approval?: book_approvalUncheckedCreateNestedManyWithoutBookInput
    book_genre?: book_genreUncheckedCreateNestedManyWithoutBookInput
    book_tags?: book_tagsUncheckedCreateNestedManyWithoutBookInput
    chapter?: chapterUncheckedCreateNestedManyWithoutBookInput
    ranking?: rankingUncheckedCreateNestedManyWithoutBookInput
    reviews?: reviewsUncheckedCreateNestedManyWithoutBookInput
  }

  export type bookCreateOrConnectWithoutBook_changes_logInput = {
    where: bookWhereUniqueInput
    create: XOR<bookCreateWithoutBook_changes_logInput, bookUncheckedCreateWithoutBook_changes_logInput>
  }

  export type bookUpsertWithoutBook_changes_logInput = {
    update: XOR<bookUpdateWithoutBook_changes_logInput, bookUncheckedUpdateWithoutBook_changes_logInput>
    create: XOR<bookCreateWithoutBook_changes_logInput, bookUncheckedCreateWithoutBook_changes_logInput>
    where?: bookWhereInput
  }

  export type bookUpdateToOneWithWhereWithoutBook_changes_logInput = {
    where?: bookWhereInput
    data: XOR<bookUpdateWithoutBook_changes_logInput, bookUncheckedUpdateWithoutBook_changes_logInput>
  }

  export type bookUpdateWithoutBook_changes_logInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    alias?: StringFieldUpdateOperationsInput | string
    submitted_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    desc?: StringFieldUpdateOperationsInput | string
    info?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    img_file?: StringFieldUpdateOperationsInput | string
    cover?: StringFieldUpdateOperationsInput | string
    product_file?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    published_date?: DateTimeFieldUpdateOperationsInput | Date | string
    is_physical?: BoolFieldUpdateOperationsInput | boolean
    preorder_min_qty?: NullableIntFieldUpdateOperationsInput | number | null
    content_type?: NullableStringFieldUpdateOperationsInput | string | null
    is_chapter?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: authorUpdateOneWithoutBookNestedInput
    product?: productUpdateOneWithoutBookNestedInput
    book_approval?: book_approvalUpdateManyWithoutBookNestedInput
    book_genre?: book_genreUpdateManyWithoutBookNestedInput
    book_tags?: book_tagsUpdateManyWithoutBookNestedInput
    chapter?: chapterUpdateManyWithoutBookNestedInput
    ranking?: rankingUpdateManyWithoutBookNestedInput
    reviews?: reviewsUpdateManyWithoutBookNestedInput
  }

  export type bookUncheckedUpdateWithoutBook_changes_logInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    alias?: StringFieldUpdateOperationsInput | string
    submitted_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    desc?: StringFieldUpdateOperationsInput | string
    info?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    img_file?: StringFieldUpdateOperationsInput | string
    cover?: StringFieldUpdateOperationsInput | string
    product_file?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    id_author?: NullableStringFieldUpdateOperationsInput | string | null
    published_date?: DateTimeFieldUpdateOperationsInput | Date | string
    is_physical?: BoolFieldUpdateOperationsInput | boolean
    preorder_min_qty?: NullableIntFieldUpdateOperationsInput | number | null
    content_type?: NullableStringFieldUpdateOperationsInput | string | null
    is_chapter?: BoolFieldUpdateOperationsInput | boolean
    id_product?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    book_approval?: book_approvalUncheckedUpdateManyWithoutBookNestedInput
    book_genre?: book_genreUncheckedUpdateManyWithoutBookNestedInput
    book_tags?: book_tagsUncheckedUpdateManyWithoutBookNestedInput
    chapter?: chapterUncheckedUpdateManyWithoutBookNestedInput
    ranking?: rankingUncheckedUpdateManyWithoutBookNestedInput
    reviews?: reviewsUncheckedUpdateManyWithoutBookNestedInput
  }

  export type bookCreateWithoutBook_genreInput = {
    id?: string
    name: string
    slug: string
    alias?: string
    submitted_price: Decimal | DecimalJsLike | number | string
    desc?: string
    info?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    currency?: string
    deleted_at?: Date | string | null
    img_file?: string
    cover?: string
    product_file?: string
    sku?: string
    published_date?: Date | string
    is_physical?: boolean
    preorder_min_qty?: number | null
    content_type?: string | null
    is_chapter?: boolean
    created_at?: Date | string
    author?: authorCreateNestedOneWithoutBookInput
    product?: productCreateNestedOneWithoutBookInput
    book_approval?: book_approvalCreateNestedManyWithoutBookInput
    book_changes_log?: book_changes_logCreateNestedManyWithoutBookInput
    book_tags?: book_tagsCreateNestedManyWithoutBookInput
    chapter?: chapterCreateNestedManyWithoutBookInput
    ranking?: rankingCreateNestedManyWithoutBookInput
    reviews?: reviewsCreateNestedManyWithoutBookInput
  }

  export type bookUncheckedCreateWithoutBook_genreInput = {
    id?: string
    name: string
    slug: string
    alias?: string
    submitted_price: Decimal | DecimalJsLike | number | string
    desc?: string
    info?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    currency?: string
    deleted_at?: Date | string | null
    img_file?: string
    cover?: string
    product_file?: string
    sku?: string
    id_author?: string | null
    published_date?: Date | string
    is_physical?: boolean
    preorder_min_qty?: number | null
    content_type?: string | null
    is_chapter?: boolean
    id_product?: string | null
    created_at?: Date | string
    book_approval?: book_approvalUncheckedCreateNestedManyWithoutBookInput
    book_changes_log?: book_changes_logUncheckedCreateNestedManyWithoutBookInput
    book_tags?: book_tagsUncheckedCreateNestedManyWithoutBookInput
    chapter?: chapterUncheckedCreateNestedManyWithoutBookInput
    ranking?: rankingUncheckedCreateNestedManyWithoutBookInput
    reviews?: reviewsUncheckedCreateNestedManyWithoutBookInput
  }

  export type bookCreateOrConnectWithoutBook_genreInput = {
    where: bookWhereUniqueInput
    create: XOR<bookCreateWithoutBook_genreInput, bookUncheckedCreateWithoutBook_genreInput>
  }

  export type genreCreateWithoutBook_genreInput = {
    id?: string
    name: string
    slug?: string | null
    img?: string | null
    deleted_at?: Date | string | null
    genre?: genreCreateNestedOneWithoutOther_genreInput
    other_genre?: genreCreateNestedManyWithoutGenreInput
  }

  export type genreUncheckedCreateWithoutBook_genreInput = {
    id?: string
    name: string
    id_parent?: string | null
    slug?: string | null
    img?: string | null
    deleted_at?: Date | string | null
    other_genre?: genreUncheckedCreateNestedManyWithoutGenreInput
  }

  export type genreCreateOrConnectWithoutBook_genreInput = {
    where: genreWhereUniqueInput
    create: XOR<genreCreateWithoutBook_genreInput, genreUncheckedCreateWithoutBook_genreInput>
  }

  export type bookUpsertWithoutBook_genreInput = {
    update: XOR<bookUpdateWithoutBook_genreInput, bookUncheckedUpdateWithoutBook_genreInput>
    create: XOR<bookCreateWithoutBook_genreInput, bookUncheckedCreateWithoutBook_genreInput>
    where?: bookWhereInput
  }

  export type bookUpdateToOneWithWhereWithoutBook_genreInput = {
    where?: bookWhereInput
    data: XOR<bookUpdateWithoutBook_genreInput, bookUncheckedUpdateWithoutBook_genreInput>
  }

  export type bookUpdateWithoutBook_genreInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    alias?: StringFieldUpdateOperationsInput | string
    submitted_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    desc?: StringFieldUpdateOperationsInput | string
    info?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    img_file?: StringFieldUpdateOperationsInput | string
    cover?: StringFieldUpdateOperationsInput | string
    product_file?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    published_date?: DateTimeFieldUpdateOperationsInput | Date | string
    is_physical?: BoolFieldUpdateOperationsInput | boolean
    preorder_min_qty?: NullableIntFieldUpdateOperationsInput | number | null
    content_type?: NullableStringFieldUpdateOperationsInput | string | null
    is_chapter?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: authorUpdateOneWithoutBookNestedInput
    product?: productUpdateOneWithoutBookNestedInput
    book_approval?: book_approvalUpdateManyWithoutBookNestedInput
    book_changes_log?: book_changes_logUpdateManyWithoutBookNestedInput
    book_tags?: book_tagsUpdateManyWithoutBookNestedInput
    chapter?: chapterUpdateManyWithoutBookNestedInput
    ranking?: rankingUpdateManyWithoutBookNestedInput
    reviews?: reviewsUpdateManyWithoutBookNestedInput
  }

  export type bookUncheckedUpdateWithoutBook_genreInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    alias?: StringFieldUpdateOperationsInput | string
    submitted_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    desc?: StringFieldUpdateOperationsInput | string
    info?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    img_file?: StringFieldUpdateOperationsInput | string
    cover?: StringFieldUpdateOperationsInput | string
    product_file?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    id_author?: NullableStringFieldUpdateOperationsInput | string | null
    published_date?: DateTimeFieldUpdateOperationsInput | Date | string
    is_physical?: BoolFieldUpdateOperationsInput | boolean
    preorder_min_qty?: NullableIntFieldUpdateOperationsInput | number | null
    content_type?: NullableStringFieldUpdateOperationsInput | string | null
    is_chapter?: BoolFieldUpdateOperationsInput | boolean
    id_product?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    book_approval?: book_approvalUncheckedUpdateManyWithoutBookNestedInput
    book_changes_log?: book_changes_logUncheckedUpdateManyWithoutBookNestedInput
    book_tags?: book_tagsUncheckedUpdateManyWithoutBookNestedInput
    chapter?: chapterUncheckedUpdateManyWithoutBookNestedInput
    ranking?: rankingUncheckedUpdateManyWithoutBookNestedInput
    reviews?: reviewsUncheckedUpdateManyWithoutBookNestedInput
  }

  export type genreUpsertWithoutBook_genreInput = {
    update: XOR<genreUpdateWithoutBook_genreInput, genreUncheckedUpdateWithoutBook_genreInput>
    create: XOR<genreCreateWithoutBook_genreInput, genreUncheckedCreateWithoutBook_genreInput>
    where?: genreWhereInput
  }

  export type genreUpdateToOneWithWhereWithoutBook_genreInput = {
    where?: genreWhereInput
    data: XOR<genreUpdateWithoutBook_genreInput, genreUncheckedUpdateWithoutBook_genreInput>
  }

  export type genreUpdateWithoutBook_genreInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    img?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    genre?: genreUpdateOneWithoutOther_genreNestedInput
    other_genre?: genreUpdateManyWithoutGenreNestedInput
  }

  export type genreUncheckedUpdateWithoutBook_genreInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    id_parent?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    img?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    other_genre?: genreUncheckedUpdateManyWithoutGenreNestedInput
  }

  export type bookCreateWithoutBook_tagsInput = {
    id?: string
    name: string
    slug: string
    alias?: string
    submitted_price: Decimal | DecimalJsLike | number | string
    desc?: string
    info?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    currency?: string
    deleted_at?: Date | string | null
    img_file?: string
    cover?: string
    product_file?: string
    sku?: string
    published_date?: Date | string
    is_physical?: boolean
    preorder_min_qty?: number | null
    content_type?: string | null
    is_chapter?: boolean
    created_at?: Date | string
    author?: authorCreateNestedOneWithoutBookInput
    product?: productCreateNestedOneWithoutBookInput
    book_approval?: book_approvalCreateNestedManyWithoutBookInput
    book_changes_log?: book_changes_logCreateNestedManyWithoutBookInput
    book_genre?: book_genreCreateNestedManyWithoutBookInput
    chapter?: chapterCreateNestedManyWithoutBookInput
    ranking?: rankingCreateNestedManyWithoutBookInput
    reviews?: reviewsCreateNestedManyWithoutBookInput
  }

  export type bookUncheckedCreateWithoutBook_tagsInput = {
    id?: string
    name: string
    slug: string
    alias?: string
    submitted_price: Decimal | DecimalJsLike | number | string
    desc?: string
    info?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    currency?: string
    deleted_at?: Date | string | null
    img_file?: string
    cover?: string
    product_file?: string
    sku?: string
    id_author?: string | null
    published_date?: Date | string
    is_physical?: boolean
    preorder_min_qty?: number | null
    content_type?: string | null
    is_chapter?: boolean
    id_product?: string | null
    created_at?: Date | string
    book_approval?: book_approvalUncheckedCreateNestedManyWithoutBookInput
    book_changes_log?: book_changes_logUncheckedCreateNestedManyWithoutBookInput
    book_genre?: book_genreUncheckedCreateNestedManyWithoutBookInput
    chapter?: chapterUncheckedCreateNestedManyWithoutBookInput
    ranking?: rankingUncheckedCreateNestedManyWithoutBookInput
    reviews?: reviewsUncheckedCreateNestedManyWithoutBookInput
  }

  export type bookCreateOrConnectWithoutBook_tagsInput = {
    where: bookWhereUniqueInput
    create: XOR<bookCreateWithoutBook_tagsInput, bookUncheckedCreateWithoutBook_tagsInput>
  }

  export type tagsCreateWithoutBook_tagsInput = {
    id?: string
    name: string
    deleted_at?: Date | string | null
    slug?: string | null
    img?: string | null
    tags?: tagsCreateNestedOneWithoutOther_tagsInput
    other_tags?: tagsCreateNestedManyWithoutTagsInput
  }

  export type tagsUncheckedCreateWithoutBook_tagsInput = {
    id?: string
    name: string
    id_parent?: string | null
    deleted_at?: Date | string | null
    slug?: string | null
    img?: string | null
    other_tags?: tagsUncheckedCreateNestedManyWithoutTagsInput
  }

  export type tagsCreateOrConnectWithoutBook_tagsInput = {
    where: tagsWhereUniqueInput
    create: XOR<tagsCreateWithoutBook_tagsInput, tagsUncheckedCreateWithoutBook_tagsInput>
  }

  export type bookUpsertWithoutBook_tagsInput = {
    update: XOR<bookUpdateWithoutBook_tagsInput, bookUncheckedUpdateWithoutBook_tagsInput>
    create: XOR<bookCreateWithoutBook_tagsInput, bookUncheckedCreateWithoutBook_tagsInput>
    where?: bookWhereInput
  }

  export type bookUpdateToOneWithWhereWithoutBook_tagsInput = {
    where?: bookWhereInput
    data: XOR<bookUpdateWithoutBook_tagsInput, bookUncheckedUpdateWithoutBook_tagsInput>
  }

  export type bookUpdateWithoutBook_tagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    alias?: StringFieldUpdateOperationsInput | string
    submitted_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    desc?: StringFieldUpdateOperationsInput | string
    info?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    img_file?: StringFieldUpdateOperationsInput | string
    cover?: StringFieldUpdateOperationsInput | string
    product_file?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    published_date?: DateTimeFieldUpdateOperationsInput | Date | string
    is_physical?: BoolFieldUpdateOperationsInput | boolean
    preorder_min_qty?: NullableIntFieldUpdateOperationsInput | number | null
    content_type?: NullableStringFieldUpdateOperationsInput | string | null
    is_chapter?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: authorUpdateOneWithoutBookNestedInput
    product?: productUpdateOneWithoutBookNestedInput
    book_approval?: book_approvalUpdateManyWithoutBookNestedInput
    book_changes_log?: book_changes_logUpdateManyWithoutBookNestedInput
    book_genre?: book_genreUpdateManyWithoutBookNestedInput
    chapter?: chapterUpdateManyWithoutBookNestedInput
    ranking?: rankingUpdateManyWithoutBookNestedInput
    reviews?: reviewsUpdateManyWithoutBookNestedInput
  }

  export type bookUncheckedUpdateWithoutBook_tagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    alias?: StringFieldUpdateOperationsInput | string
    submitted_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    desc?: StringFieldUpdateOperationsInput | string
    info?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    img_file?: StringFieldUpdateOperationsInput | string
    cover?: StringFieldUpdateOperationsInput | string
    product_file?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    id_author?: NullableStringFieldUpdateOperationsInput | string | null
    published_date?: DateTimeFieldUpdateOperationsInput | Date | string
    is_physical?: BoolFieldUpdateOperationsInput | boolean
    preorder_min_qty?: NullableIntFieldUpdateOperationsInput | number | null
    content_type?: NullableStringFieldUpdateOperationsInput | string | null
    is_chapter?: BoolFieldUpdateOperationsInput | boolean
    id_product?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    book_approval?: book_approvalUncheckedUpdateManyWithoutBookNestedInput
    book_changes_log?: book_changes_logUncheckedUpdateManyWithoutBookNestedInput
    book_genre?: book_genreUncheckedUpdateManyWithoutBookNestedInput
    chapter?: chapterUncheckedUpdateManyWithoutBookNestedInput
    ranking?: rankingUncheckedUpdateManyWithoutBookNestedInput
    reviews?: reviewsUncheckedUpdateManyWithoutBookNestedInput
  }

  export type tagsUpsertWithoutBook_tagsInput = {
    update: XOR<tagsUpdateWithoutBook_tagsInput, tagsUncheckedUpdateWithoutBook_tagsInput>
    create: XOR<tagsCreateWithoutBook_tagsInput, tagsUncheckedCreateWithoutBook_tagsInput>
    where?: tagsWhereInput
  }

  export type tagsUpdateToOneWithWhereWithoutBook_tagsInput = {
    where?: tagsWhereInput
    data: XOR<tagsUpdateWithoutBook_tagsInput, tagsUncheckedUpdateWithoutBook_tagsInput>
  }

  export type tagsUpdateWithoutBook_tagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    img?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: tagsUpdateOneWithoutOther_tagsNestedInput
    other_tags?: tagsUpdateManyWithoutTagsNestedInput
  }

  export type tagsUncheckedUpdateWithoutBook_tagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    id_parent?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    img?: NullableStringFieldUpdateOperationsInput | string | null
    other_tags?: tagsUncheckedUpdateManyWithoutTagsNestedInput
  }

  export type bundle_categoryCreateWithoutBundleInput = {
    id?: string
    category: categoryCreateNestedOneWithoutBundle_categoryInput
  }

  export type bundle_categoryUncheckedCreateWithoutBundleInput = {
    id?: string
    id_category: string
  }

  export type bundle_categoryCreateOrConnectWithoutBundleInput = {
    where: bundle_categoryWhereUniqueInput
    create: XOR<bundle_categoryCreateWithoutBundleInput, bundle_categoryUncheckedCreateWithoutBundleInput>
  }

  export type bundle_categoryCreateManyBundleInputEnvelope = {
    data: bundle_categoryCreateManyBundleInput | bundle_categoryCreateManyBundleInput[]
    skipDuplicates?: boolean
  }

  export type bundle_productCreateWithoutBundleInput = {
    id?: string
    qty?: number | null
    product: productCreateNestedOneWithoutBundle_productInput
  }

  export type bundle_productUncheckedCreateWithoutBundleInput = {
    id_product: string
    id?: string
    qty?: number | null
  }

  export type bundle_productCreateOrConnectWithoutBundleInput = {
    where: bundle_productWhereUniqueInput
    create: XOR<bundle_productCreateWithoutBundleInput, bundle_productUncheckedCreateWithoutBundleInput>
  }

  export type bundle_productCreateManyBundleInputEnvelope = {
    data: bundle_productCreateManyBundleInput | bundle_productCreateManyBundleInput[]
    skipDuplicates?: boolean
  }

  export type t_sales_lineCreateWithoutBundleInput = {
    id?: string
    unit_price: Decimal | DecimalJsLike | number | string
    qty: number
    total_price: Decimal | DecimalJsLike | number | string
    product?: productCreateNestedOneWithoutT_sales_lineInput
    t_sales: t_salesCreateNestedOneWithoutT_sales_lineInput
  }

  export type t_sales_lineUncheckedCreateWithoutBundleInput = {
    id?: string
    id_sales: string
    unit_price: Decimal | DecimalJsLike | number | string
    qty: number
    total_price: Decimal | DecimalJsLike | number | string
    id_product?: string | null
  }

  export type t_sales_lineCreateOrConnectWithoutBundleInput = {
    where: t_sales_lineWhereUniqueInput
    create: XOR<t_sales_lineCreateWithoutBundleInput, t_sales_lineUncheckedCreateWithoutBundleInput>
  }

  export type t_sales_lineCreateManyBundleInputEnvelope = {
    data: t_sales_lineCreateManyBundleInput | t_sales_lineCreateManyBundleInput[]
    skipDuplicates?: boolean
  }

  export type bundle_categoryUpsertWithWhereUniqueWithoutBundleInput = {
    where: bundle_categoryWhereUniqueInput
    update: XOR<bundle_categoryUpdateWithoutBundleInput, bundle_categoryUncheckedUpdateWithoutBundleInput>
    create: XOR<bundle_categoryCreateWithoutBundleInput, bundle_categoryUncheckedCreateWithoutBundleInput>
  }

  export type bundle_categoryUpdateWithWhereUniqueWithoutBundleInput = {
    where: bundle_categoryWhereUniqueInput
    data: XOR<bundle_categoryUpdateWithoutBundleInput, bundle_categoryUncheckedUpdateWithoutBundleInput>
  }

  export type bundle_categoryUpdateManyWithWhereWithoutBundleInput = {
    where: bundle_categoryScalarWhereInput
    data: XOR<bundle_categoryUpdateManyMutationInput, bundle_categoryUncheckedUpdateManyWithoutBundleInput>
  }

  export type bundle_categoryScalarWhereInput = {
    AND?: bundle_categoryScalarWhereInput | bundle_categoryScalarWhereInput[]
    OR?: bundle_categoryScalarWhereInput[]
    NOT?: bundle_categoryScalarWhereInput | bundle_categoryScalarWhereInput[]
    id?: UuidFilter<"bundle_category"> | string
    id_category?: UuidFilter<"bundle_category"> | string
    id_bundle?: UuidFilter<"bundle_category"> | string
  }

  export type bundle_productUpsertWithWhereUniqueWithoutBundleInput = {
    where: bundle_productWhereUniqueInput
    update: XOR<bundle_productUpdateWithoutBundleInput, bundle_productUncheckedUpdateWithoutBundleInput>
    create: XOR<bundle_productCreateWithoutBundleInput, bundle_productUncheckedCreateWithoutBundleInput>
  }

  export type bundle_productUpdateWithWhereUniqueWithoutBundleInput = {
    where: bundle_productWhereUniqueInput
    data: XOR<bundle_productUpdateWithoutBundleInput, bundle_productUncheckedUpdateWithoutBundleInput>
  }

  export type bundle_productUpdateManyWithWhereWithoutBundleInput = {
    where: bundle_productScalarWhereInput
    data: XOR<bundle_productUpdateManyMutationInput, bundle_productUncheckedUpdateManyWithoutBundleInput>
  }

  export type bundle_productScalarWhereInput = {
    AND?: bundle_productScalarWhereInput | bundle_productScalarWhereInput[]
    OR?: bundle_productScalarWhereInput[]
    NOT?: bundle_productScalarWhereInput | bundle_productScalarWhereInput[]
    id_bundle?: UuidFilter<"bundle_product"> | string
    id_product?: UuidFilter<"bundle_product"> | string
    id?: UuidFilter<"bundle_product"> | string
    qty?: IntNullableFilter<"bundle_product"> | number | null
  }

  export type t_sales_lineUpsertWithWhereUniqueWithoutBundleInput = {
    where: t_sales_lineWhereUniqueInput
    update: XOR<t_sales_lineUpdateWithoutBundleInput, t_sales_lineUncheckedUpdateWithoutBundleInput>
    create: XOR<t_sales_lineCreateWithoutBundleInput, t_sales_lineUncheckedCreateWithoutBundleInput>
  }

  export type t_sales_lineUpdateWithWhereUniqueWithoutBundleInput = {
    where: t_sales_lineWhereUniqueInput
    data: XOR<t_sales_lineUpdateWithoutBundleInput, t_sales_lineUncheckedUpdateWithoutBundleInput>
  }

  export type t_sales_lineUpdateManyWithWhereWithoutBundleInput = {
    where: t_sales_lineScalarWhereInput
    data: XOR<t_sales_lineUpdateManyMutationInput, t_sales_lineUncheckedUpdateManyWithoutBundleInput>
  }

  export type t_sales_lineScalarWhereInput = {
    AND?: t_sales_lineScalarWhereInput | t_sales_lineScalarWhereInput[]
    OR?: t_sales_lineScalarWhereInput[]
    NOT?: t_sales_lineScalarWhereInput | t_sales_lineScalarWhereInput[]
    id?: UuidFilter<"t_sales_line"> | string
    id_sales?: UuidFilter<"t_sales_line"> | string
    unit_price?: DecimalFilter<"t_sales_line"> | Decimal | DecimalJsLike | number | string
    qty?: IntFilter<"t_sales_line"> | number
    total_price?: DecimalFilter<"t_sales_line"> | Decimal | DecimalJsLike | number | string
    id_product?: UuidNullableFilter<"t_sales_line"> | string | null
    id_bundle?: UuidNullableFilter<"t_sales_line"> | string | null
  }

  export type bundleCreateWithoutBundle_categoryInput = {
    id?: string
    name: string
    slug: string
    strike_price?: Decimal | DecimalJsLike | number | string | null
    real_price: Decimal | DecimalJsLike | number | string
    currency?: string
    desc?: string
    info?: JsonNullValueInput | InputJsonValue
    deleted_at?: Date | string | null
    status?: string
    img_file?: string
    cover?: string
    sku?: string
    bundle_product?: bundle_productCreateNestedManyWithoutBundleInput
    t_sales_line?: t_sales_lineCreateNestedManyWithoutBundleInput
  }

  export type bundleUncheckedCreateWithoutBundle_categoryInput = {
    id?: string
    name: string
    slug: string
    strike_price?: Decimal | DecimalJsLike | number | string | null
    real_price: Decimal | DecimalJsLike | number | string
    currency?: string
    desc?: string
    info?: JsonNullValueInput | InputJsonValue
    deleted_at?: Date | string | null
    status?: string
    img_file?: string
    cover?: string
    sku?: string
    bundle_product?: bundle_productUncheckedCreateNestedManyWithoutBundleInput
    t_sales_line?: t_sales_lineUncheckedCreateNestedManyWithoutBundleInput
  }

  export type bundleCreateOrConnectWithoutBundle_categoryInput = {
    where: bundleWhereUniqueInput
    create: XOR<bundleCreateWithoutBundle_categoryInput, bundleUncheckedCreateWithoutBundle_categoryInput>
  }

  export type categoryCreateWithoutBundle_categoryInput = {
    id?: string
    name: string
    deleted_at?: Date | string | null
    slug?: string | null
    img?: string | null
    category?: categoryCreateNestedOneWithoutOther_categoryInput
    other_category?: categoryCreateNestedManyWithoutCategoryInput
    product_category?: product_categoryCreateNestedManyWithoutCategoryInput
  }

  export type categoryUncheckedCreateWithoutBundle_categoryInput = {
    id?: string
    name: string
    id_parent?: string | null
    deleted_at?: Date | string | null
    slug?: string | null
    img?: string | null
    other_category?: categoryUncheckedCreateNestedManyWithoutCategoryInput
    product_category?: product_categoryUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type categoryCreateOrConnectWithoutBundle_categoryInput = {
    where: categoryWhereUniqueInput
    create: XOR<categoryCreateWithoutBundle_categoryInput, categoryUncheckedCreateWithoutBundle_categoryInput>
  }

  export type bundleUpsertWithoutBundle_categoryInput = {
    update: XOR<bundleUpdateWithoutBundle_categoryInput, bundleUncheckedUpdateWithoutBundle_categoryInput>
    create: XOR<bundleCreateWithoutBundle_categoryInput, bundleUncheckedCreateWithoutBundle_categoryInput>
    where?: bundleWhereInput
  }

  export type bundleUpdateToOneWithWhereWithoutBundle_categoryInput = {
    where?: bundleWhereInput
    data: XOR<bundleUpdateWithoutBundle_categoryInput, bundleUncheckedUpdateWithoutBundle_categoryInput>
  }

  export type bundleUpdateWithoutBundle_categoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    strike_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    real_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    desc?: StringFieldUpdateOperationsInput | string
    info?: JsonNullValueInput | InputJsonValue
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    img_file?: StringFieldUpdateOperationsInput | string
    cover?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    bundle_product?: bundle_productUpdateManyWithoutBundleNestedInput
    t_sales_line?: t_sales_lineUpdateManyWithoutBundleNestedInput
  }

  export type bundleUncheckedUpdateWithoutBundle_categoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    strike_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    real_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    desc?: StringFieldUpdateOperationsInput | string
    info?: JsonNullValueInput | InputJsonValue
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    img_file?: StringFieldUpdateOperationsInput | string
    cover?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    bundle_product?: bundle_productUncheckedUpdateManyWithoutBundleNestedInput
    t_sales_line?: t_sales_lineUncheckedUpdateManyWithoutBundleNestedInput
  }

  export type categoryUpsertWithoutBundle_categoryInput = {
    update: XOR<categoryUpdateWithoutBundle_categoryInput, categoryUncheckedUpdateWithoutBundle_categoryInput>
    create: XOR<categoryCreateWithoutBundle_categoryInput, categoryUncheckedCreateWithoutBundle_categoryInput>
    where?: categoryWhereInput
  }

  export type categoryUpdateToOneWithWhereWithoutBundle_categoryInput = {
    where?: categoryWhereInput
    data: XOR<categoryUpdateWithoutBundle_categoryInput, categoryUncheckedUpdateWithoutBundle_categoryInput>
  }

  export type categoryUpdateWithoutBundle_categoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    img?: NullableStringFieldUpdateOperationsInput | string | null
    category?: categoryUpdateOneWithoutOther_categoryNestedInput
    other_category?: categoryUpdateManyWithoutCategoryNestedInput
    product_category?: product_categoryUpdateManyWithoutCategoryNestedInput
  }

  export type categoryUncheckedUpdateWithoutBundle_categoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    id_parent?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    img?: NullableStringFieldUpdateOperationsInput | string | null
    other_category?: categoryUncheckedUpdateManyWithoutCategoryNestedInput
    product_category?: product_categoryUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type bundleCreateWithoutBundle_productInput = {
    id?: string
    name: string
    slug: string
    strike_price?: Decimal | DecimalJsLike | number | string | null
    real_price: Decimal | DecimalJsLike | number | string
    currency?: string
    desc?: string
    info?: JsonNullValueInput | InputJsonValue
    deleted_at?: Date | string | null
    status?: string
    img_file?: string
    cover?: string
    sku?: string
    bundle_category?: bundle_categoryCreateNestedManyWithoutBundleInput
    t_sales_line?: t_sales_lineCreateNestedManyWithoutBundleInput
  }

  export type bundleUncheckedCreateWithoutBundle_productInput = {
    id?: string
    name: string
    slug: string
    strike_price?: Decimal | DecimalJsLike | number | string | null
    real_price: Decimal | DecimalJsLike | number | string
    currency?: string
    desc?: string
    info?: JsonNullValueInput | InputJsonValue
    deleted_at?: Date | string | null
    status?: string
    img_file?: string
    cover?: string
    sku?: string
    bundle_category?: bundle_categoryUncheckedCreateNestedManyWithoutBundleInput
    t_sales_line?: t_sales_lineUncheckedCreateNestedManyWithoutBundleInput
  }

  export type bundleCreateOrConnectWithoutBundle_productInput = {
    where: bundleWhereUniqueInput
    create: XOR<bundleCreateWithoutBundle_productInput, bundleUncheckedCreateWithoutBundle_productInput>
  }

  export type productCreateWithoutBundle_productInput = {
    id?: string
    name: string
    slug: string
    alias?: string
    strike_price?: Decimal | DecimalJsLike | number | string | null
    real_price: Decimal | DecimalJsLike | number | string
    desc?: string
    info?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    currency?: string
    deleted_at?: Date | string | null
    img_file?: string
    cover?: string
    product_file?: string
    sku?: string
    published_date?: Date | string
    is_physical?: boolean
    preorder_min_qty?: number | null
    content_type?: string | null
    is_chapter?: boolean
    book?: bookCreateNestedManyWithoutProductInput
    chapter?: chapterCreateNestedManyWithoutProductInput
    customer_reader?: customer_readerCreateNestedManyWithoutProductInput
    preorder?: preorderCreateNestedManyWithoutProductInput
    author?: authorCreateNestedOneWithoutProductInput
    product_category?: product_categoryCreateNestedManyWithoutProductInput
    t_sales_download?: t_sales_downloadCreateNestedManyWithoutProductInput
    t_sales_line?: t_sales_lineCreateNestedManyWithoutProductInput
  }

  export type productUncheckedCreateWithoutBundle_productInput = {
    id?: string
    name: string
    slug: string
    alias?: string
    strike_price?: Decimal | DecimalJsLike | number | string | null
    real_price: Decimal | DecimalJsLike | number | string
    desc?: string
    info?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    currency?: string
    deleted_at?: Date | string | null
    img_file?: string
    cover?: string
    product_file?: string
    sku?: string
    id_author?: string | null
    published_date?: Date | string
    is_physical?: boolean
    preorder_min_qty?: number | null
    content_type?: string | null
    is_chapter?: boolean
    book?: bookUncheckedCreateNestedManyWithoutProductInput
    chapter?: chapterUncheckedCreateNestedManyWithoutProductInput
    customer_reader?: customer_readerUncheckedCreateNestedManyWithoutProductInput
    preorder?: preorderUncheckedCreateNestedManyWithoutProductInput
    product_category?: product_categoryUncheckedCreateNestedManyWithoutProductInput
    t_sales_download?: t_sales_downloadUncheckedCreateNestedManyWithoutProductInput
    t_sales_line?: t_sales_lineUncheckedCreateNestedManyWithoutProductInput
  }

  export type productCreateOrConnectWithoutBundle_productInput = {
    where: productWhereUniqueInput
    create: XOR<productCreateWithoutBundle_productInput, productUncheckedCreateWithoutBundle_productInput>
  }

  export type bundleUpsertWithoutBundle_productInput = {
    update: XOR<bundleUpdateWithoutBundle_productInput, bundleUncheckedUpdateWithoutBundle_productInput>
    create: XOR<bundleCreateWithoutBundle_productInput, bundleUncheckedCreateWithoutBundle_productInput>
    where?: bundleWhereInput
  }

  export type bundleUpdateToOneWithWhereWithoutBundle_productInput = {
    where?: bundleWhereInput
    data: XOR<bundleUpdateWithoutBundle_productInput, bundleUncheckedUpdateWithoutBundle_productInput>
  }

  export type bundleUpdateWithoutBundle_productInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    strike_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    real_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    desc?: StringFieldUpdateOperationsInput | string
    info?: JsonNullValueInput | InputJsonValue
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    img_file?: StringFieldUpdateOperationsInput | string
    cover?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    bundle_category?: bundle_categoryUpdateManyWithoutBundleNestedInput
    t_sales_line?: t_sales_lineUpdateManyWithoutBundleNestedInput
  }

  export type bundleUncheckedUpdateWithoutBundle_productInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    strike_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    real_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    desc?: StringFieldUpdateOperationsInput | string
    info?: JsonNullValueInput | InputJsonValue
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    img_file?: StringFieldUpdateOperationsInput | string
    cover?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    bundle_category?: bundle_categoryUncheckedUpdateManyWithoutBundleNestedInput
    t_sales_line?: t_sales_lineUncheckedUpdateManyWithoutBundleNestedInput
  }

  export type productUpsertWithoutBundle_productInput = {
    update: XOR<productUpdateWithoutBundle_productInput, productUncheckedUpdateWithoutBundle_productInput>
    create: XOR<productCreateWithoutBundle_productInput, productUncheckedCreateWithoutBundle_productInput>
    where?: productWhereInput
  }

  export type productUpdateToOneWithWhereWithoutBundle_productInput = {
    where?: productWhereInput
    data: XOR<productUpdateWithoutBundle_productInput, productUncheckedUpdateWithoutBundle_productInput>
  }

  export type productUpdateWithoutBundle_productInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    alias?: StringFieldUpdateOperationsInput | string
    strike_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    real_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    desc?: StringFieldUpdateOperationsInput | string
    info?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    img_file?: StringFieldUpdateOperationsInput | string
    cover?: StringFieldUpdateOperationsInput | string
    product_file?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    published_date?: DateTimeFieldUpdateOperationsInput | Date | string
    is_physical?: BoolFieldUpdateOperationsInput | boolean
    preorder_min_qty?: NullableIntFieldUpdateOperationsInput | number | null
    content_type?: NullableStringFieldUpdateOperationsInput | string | null
    is_chapter?: BoolFieldUpdateOperationsInput | boolean
    book?: bookUpdateManyWithoutProductNestedInput
    chapter?: chapterUpdateManyWithoutProductNestedInput
    customer_reader?: customer_readerUpdateManyWithoutProductNestedInput
    preorder?: preorderUpdateManyWithoutProductNestedInput
    author?: authorUpdateOneWithoutProductNestedInput
    product_category?: product_categoryUpdateManyWithoutProductNestedInput
    t_sales_download?: t_sales_downloadUpdateManyWithoutProductNestedInput
    t_sales_line?: t_sales_lineUpdateManyWithoutProductNestedInput
  }

  export type productUncheckedUpdateWithoutBundle_productInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    alias?: StringFieldUpdateOperationsInput | string
    strike_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    real_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    desc?: StringFieldUpdateOperationsInput | string
    info?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    img_file?: StringFieldUpdateOperationsInput | string
    cover?: StringFieldUpdateOperationsInput | string
    product_file?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    id_author?: NullableStringFieldUpdateOperationsInput | string | null
    published_date?: DateTimeFieldUpdateOperationsInput | Date | string
    is_physical?: BoolFieldUpdateOperationsInput | boolean
    preorder_min_qty?: NullableIntFieldUpdateOperationsInput | number | null
    content_type?: NullableStringFieldUpdateOperationsInput | string | null
    is_chapter?: BoolFieldUpdateOperationsInput | boolean
    book?: bookUncheckedUpdateManyWithoutProductNestedInput
    chapter?: chapterUncheckedUpdateManyWithoutProductNestedInput
    customer_reader?: customer_readerUncheckedUpdateManyWithoutProductNestedInput
    preorder?: preorderUncheckedUpdateManyWithoutProductNestedInput
    product_category?: product_categoryUncheckedUpdateManyWithoutProductNestedInput
    t_sales_download?: t_sales_downloadUncheckedUpdateManyWithoutProductNestedInput
    t_sales_line?: t_sales_lineUncheckedUpdateManyWithoutProductNestedInput
  }

  export type bundle_categoryCreateWithoutCategoryInput = {
    id?: string
    bundle: bundleCreateNestedOneWithoutBundle_categoryInput
  }

  export type bundle_categoryUncheckedCreateWithoutCategoryInput = {
    id?: string
    id_bundle: string
  }

  export type bundle_categoryCreateOrConnectWithoutCategoryInput = {
    where: bundle_categoryWhereUniqueInput
    create: XOR<bundle_categoryCreateWithoutCategoryInput, bundle_categoryUncheckedCreateWithoutCategoryInput>
  }

  export type bundle_categoryCreateManyCategoryInputEnvelope = {
    data: bundle_categoryCreateManyCategoryInput | bundle_categoryCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type categoryCreateWithoutOther_categoryInput = {
    id?: string
    name: string
    deleted_at?: Date | string | null
    slug?: string | null
    img?: string | null
    bundle_category?: bundle_categoryCreateNestedManyWithoutCategoryInput
    category?: categoryCreateNestedOneWithoutOther_categoryInput
    product_category?: product_categoryCreateNestedManyWithoutCategoryInput
  }

  export type categoryUncheckedCreateWithoutOther_categoryInput = {
    id?: string
    name: string
    id_parent?: string | null
    deleted_at?: Date | string | null
    slug?: string | null
    img?: string | null
    bundle_category?: bundle_categoryUncheckedCreateNestedManyWithoutCategoryInput
    product_category?: product_categoryUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type categoryCreateOrConnectWithoutOther_categoryInput = {
    where: categoryWhereUniqueInput
    create: XOR<categoryCreateWithoutOther_categoryInput, categoryUncheckedCreateWithoutOther_categoryInput>
  }

  export type categoryCreateWithoutCategoryInput = {
    id?: string
    name: string
    deleted_at?: Date | string | null
    slug?: string | null
    img?: string | null
    bundle_category?: bundle_categoryCreateNestedManyWithoutCategoryInput
    other_category?: categoryCreateNestedManyWithoutCategoryInput
    product_category?: product_categoryCreateNestedManyWithoutCategoryInput
  }

  export type categoryUncheckedCreateWithoutCategoryInput = {
    id?: string
    name: string
    deleted_at?: Date | string | null
    slug?: string | null
    img?: string | null
    bundle_category?: bundle_categoryUncheckedCreateNestedManyWithoutCategoryInput
    other_category?: categoryUncheckedCreateNestedManyWithoutCategoryInput
    product_category?: product_categoryUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type categoryCreateOrConnectWithoutCategoryInput = {
    where: categoryWhereUniqueInput
    create: XOR<categoryCreateWithoutCategoryInput, categoryUncheckedCreateWithoutCategoryInput>
  }

  export type categoryCreateManyCategoryInputEnvelope = {
    data: categoryCreateManyCategoryInput | categoryCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type product_categoryCreateWithoutCategoryInput = {
    id?: string
    product: productCreateNestedOneWithoutProduct_categoryInput
  }

  export type product_categoryUncheckedCreateWithoutCategoryInput = {
    id_product: string
    id?: string
  }

  export type product_categoryCreateOrConnectWithoutCategoryInput = {
    where: product_categoryWhereUniqueInput
    create: XOR<product_categoryCreateWithoutCategoryInput, product_categoryUncheckedCreateWithoutCategoryInput>
  }

  export type product_categoryCreateManyCategoryInputEnvelope = {
    data: product_categoryCreateManyCategoryInput | product_categoryCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type bundle_categoryUpsertWithWhereUniqueWithoutCategoryInput = {
    where: bundle_categoryWhereUniqueInput
    update: XOR<bundle_categoryUpdateWithoutCategoryInput, bundle_categoryUncheckedUpdateWithoutCategoryInput>
    create: XOR<bundle_categoryCreateWithoutCategoryInput, bundle_categoryUncheckedCreateWithoutCategoryInput>
  }

  export type bundle_categoryUpdateWithWhereUniqueWithoutCategoryInput = {
    where: bundle_categoryWhereUniqueInput
    data: XOR<bundle_categoryUpdateWithoutCategoryInput, bundle_categoryUncheckedUpdateWithoutCategoryInput>
  }

  export type bundle_categoryUpdateManyWithWhereWithoutCategoryInput = {
    where: bundle_categoryScalarWhereInput
    data: XOR<bundle_categoryUpdateManyMutationInput, bundle_categoryUncheckedUpdateManyWithoutCategoryInput>
  }

  export type categoryUpsertWithoutOther_categoryInput = {
    update: XOR<categoryUpdateWithoutOther_categoryInput, categoryUncheckedUpdateWithoutOther_categoryInput>
    create: XOR<categoryCreateWithoutOther_categoryInput, categoryUncheckedCreateWithoutOther_categoryInput>
    where?: categoryWhereInput
  }

  export type categoryUpdateToOneWithWhereWithoutOther_categoryInput = {
    where?: categoryWhereInput
    data: XOR<categoryUpdateWithoutOther_categoryInput, categoryUncheckedUpdateWithoutOther_categoryInput>
  }

  export type categoryUpdateWithoutOther_categoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    img?: NullableStringFieldUpdateOperationsInput | string | null
    bundle_category?: bundle_categoryUpdateManyWithoutCategoryNestedInput
    category?: categoryUpdateOneWithoutOther_categoryNestedInput
    product_category?: product_categoryUpdateManyWithoutCategoryNestedInput
  }

  export type categoryUncheckedUpdateWithoutOther_categoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    id_parent?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    img?: NullableStringFieldUpdateOperationsInput | string | null
    bundle_category?: bundle_categoryUncheckedUpdateManyWithoutCategoryNestedInput
    product_category?: product_categoryUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type categoryUpsertWithWhereUniqueWithoutCategoryInput = {
    where: categoryWhereUniqueInput
    update: XOR<categoryUpdateWithoutCategoryInput, categoryUncheckedUpdateWithoutCategoryInput>
    create: XOR<categoryCreateWithoutCategoryInput, categoryUncheckedCreateWithoutCategoryInput>
  }

  export type categoryUpdateWithWhereUniqueWithoutCategoryInput = {
    where: categoryWhereUniqueInput
    data: XOR<categoryUpdateWithoutCategoryInput, categoryUncheckedUpdateWithoutCategoryInput>
  }

  export type categoryUpdateManyWithWhereWithoutCategoryInput = {
    where: categoryScalarWhereInput
    data: XOR<categoryUpdateManyMutationInput, categoryUncheckedUpdateManyWithoutCategoryInput>
  }

  export type categoryScalarWhereInput = {
    AND?: categoryScalarWhereInput | categoryScalarWhereInput[]
    OR?: categoryScalarWhereInput[]
    NOT?: categoryScalarWhereInput | categoryScalarWhereInput[]
    id?: UuidFilter<"category"> | string
    name?: StringFilter<"category"> | string
    id_parent?: UuidNullableFilter<"category"> | string | null
    deleted_at?: DateTimeNullableFilter<"category"> | Date | string | null
    slug?: StringNullableFilter<"category"> | string | null
    img?: StringNullableFilter<"category"> | string | null
  }

  export type product_categoryUpsertWithWhereUniqueWithoutCategoryInput = {
    where: product_categoryWhereUniqueInput
    update: XOR<product_categoryUpdateWithoutCategoryInput, product_categoryUncheckedUpdateWithoutCategoryInput>
    create: XOR<product_categoryCreateWithoutCategoryInput, product_categoryUncheckedCreateWithoutCategoryInput>
  }

  export type product_categoryUpdateWithWhereUniqueWithoutCategoryInput = {
    where: product_categoryWhereUniqueInput
    data: XOR<product_categoryUpdateWithoutCategoryInput, product_categoryUncheckedUpdateWithoutCategoryInput>
  }

  export type product_categoryUpdateManyWithWhereWithoutCategoryInput = {
    where: product_categoryScalarWhereInput
    data: XOR<product_categoryUpdateManyMutationInput, product_categoryUncheckedUpdateManyWithoutCategoryInput>
  }

  export type product_categoryScalarWhereInput = {
    AND?: product_categoryScalarWhereInput | product_categoryScalarWhereInput[]
    OR?: product_categoryScalarWhereInput[]
    NOT?: product_categoryScalarWhereInput | product_categoryScalarWhereInput[]
    id_product?: UuidFilter<"product_category"> | string
    id_category?: UuidFilter<"product_category"> | string
    id?: UuidFilter<"product_category"> | string
  }

  export type bookCreateWithoutChapterInput = {
    id?: string
    name: string
    slug: string
    alias?: string
    submitted_price: Decimal | DecimalJsLike | number | string
    desc?: string
    info?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    currency?: string
    deleted_at?: Date | string | null
    img_file?: string
    cover?: string
    product_file?: string
    sku?: string
    published_date?: Date | string
    is_physical?: boolean
    preorder_min_qty?: number | null
    content_type?: string | null
    is_chapter?: boolean
    created_at?: Date | string
    author?: authorCreateNestedOneWithoutBookInput
    product?: productCreateNestedOneWithoutBookInput
    book_approval?: book_approvalCreateNestedManyWithoutBookInput
    book_changes_log?: book_changes_logCreateNestedManyWithoutBookInput
    book_genre?: book_genreCreateNestedManyWithoutBookInput
    book_tags?: book_tagsCreateNestedManyWithoutBookInput
    ranking?: rankingCreateNestedManyWithoutBookInput
    reviews?: reviewsCreateNestedManyWithoutBookInput
  }

  export type bookUncheckedCreateWithoutChapterInput = {
    id?: string
    name: string
    slug: string
    alias?: string
    submitted_price: Decimal | DecimalJsLike | number | string
    desc?: string
    info?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    currency?: string
    deleted_at?: Date | string | null
    img_file?: string
    cover?: string
    product_file?: string
    sku?: string
    id_author?: string | null
    published_date?: Date | string
    is_physical?: boolean
    preorder_min_qty?: number | null
    content_type?: string | null
    is_chapter?: boolean
    id_product?: string | null
    created_at?: Date | string
    book_approval?: book_approvalUncheckedCreateNestedManyWithoutBookInput
    book_changes_log?: book_changes_logUncheckedCreateNestedManyWithoutBookInput
    book_genre?: book_genreUncheckedCreateNestedManyWithoutBookInput
    book_tags?: book_tagsUncheckedCreateNestedManyWithoutBookInput
    ranking?: rankingUncheckedCreateNestedManyWithoutBookInput
    reviews?: reviewsUncheckedCreateNestedManyWithoutBookInput
  }

  export type bookCreateOrConnectWithoutChapterInput = {
    where: bookWhereUniqueInput
    create: XOR<bookCreateWithoutChapterInput, bookUncheckedCreateWithoutChapterInput>
  }

  export type productCreateWithoutChapterInput = {
    id?: string
    name: string
    slug: string
    alias?: string
    strike_price?: Decimal | DecimalJsLike | number | string | null
    real_price: Decimal | DecimalJsLike | number | string
    desc?: string
    info?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    currency?: string
    deleted_at?: Date | string | null
    img_file?: string
    cover?: string
    product_file?: string
    sku?: string
    published_date?: Date | string
    is_physical?: boolean
    preorder_min_qty?: number | null
    content_type?: string | null
    is_chapter?: boolean
    book?: bookCreateNestedManyWithoutProductInput
    bundle_product?: bundle_productCreateNestedManyWithoutProductInput
    customer_reader?: customer_readerCreateNestedManyWithoutProductInput
    preorder?: preorderCreateNestedManyWithoutProductInput
    author?: authorCreateNestedOneWithoutProductInput
    product_category?: product_categoryCreateNestedManyWithoutProductInput
    t_sales_download?: t_sales_downloadCreateNestedManyWithoutProductInput
    t_sales_line?: t_sales_lineCreateNestedManyWithoutProductInput
  }

  export type productUncheckedCreateWithoutChapterInput = {
    id?: string
    name: string
    slug: string
    alias?: string
    strike_price?: Decimal | DecimalJsLike | number | string | null
    real_price: Decimal | DecimalJsLike | number | string
    desc?: string
    info?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    currency?: string
    deleted_at?: Date | string | null
    img_file?: string
    cover?: string
    product_file?: string
    sku?: string
    id_author?: string | null
    published_date?: Date | string
    is_physical?: boolean
    preorder_min_qty?: number | null
    content_type?: string | null
    is_chapter?: boolean
    book?: bookUncheckedCreateNestedManyWithoutProductInput
    bundle_product?: bundle_productUncheckedCreateNestedManyWithoutProductInput
    customer_reader?: customer_readerUncheckedCreateNestedManyWithoutProductInput
    preorder?: preorderUncheckedCreateNestedManyWithoutProductInput
    product_category?: product_categoryUncheckedCreateNestedManyWithoutProductInput
    t_sales_download?: t_sales_downloadUncheckedCreateNestedManyWithoutProductInput
    t_sales_line?: t_sales_lineUncheckedCreateNestedManyWithoutProductInput
  }

  export type productCreateOrConnectWithoutChapterInput = {
    where: productWhereUniqueInput
    create: XOR<productCreateWithoutChapterInput, productUncheckedCreateWithoutChapterInput>
  }

  export type bookUpsertWithoutChapterInput = {
    update: XOR<bookUpdateWithoutChapterInput, bookUncheckedUpdateWithoutChapterInput>
    create: XOR<bookCreateWithoutChapterInput, bookUncheckedCreateWithoutChapterInput>
    where?: bookWhereInput
  }

  export type bookUpdateToOneWithWhereWithoutChapterInput = {
    where?: bookWhereInput
    data: XOR<bookUpdateWithoutChapterInput, bookUncheckedUpdateWithoutChapterInput>
  }

  export type bookUpdateWithoutChapterInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    alias?: StringFieldUpdateOperationsInput | string
    submitted_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    desc?: StringFieldUpdateOperationsInput | string
    info?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    img_file?: StringFieldUpdateOperationsInput | string
    cover?: StringFieldUpdateOperationsInput | string
    product_file?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    published_date?: DateTimeFieldUpdateOperationsInput | Date | string
    is_physical?: BoolFieldUpdateOperationsInput | boolean
    preorder_min_qty?: NullableIntFieldUpdateOperationsInput | number | null
    content_type?: NullableStringFieldUpdateOperationsInput | string | null
    is_chapter?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: authorUpdateOneWithoutBookNestedInput
    product?: productUpdateOneWithoutBookNestedInput
    book_approval?: book_approvalUpdateManyWithoutBookNestedInput
    book_changes_log?: book_changes_logUpdateManyWithoutBookNestedInput
    book_genre?: book_genreUpdateManyWithoutBookNestedInput
    book_tags?: book_tagsUpdateManyWithoutBookNestedInput
    ranking?: rankingUpdateManyWithoutBookNestedInput
    reviews?: reviewsUpdateManyWithoutBookNestedInput
  }

  export type bookUncheckedUpdateWithoutChapterInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    alias?: StringFieldUpdateOperationsInput | string
    submitted_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    desc?: StringFieldUpdateOperationsInput | string
    info?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    img_file?: StringFieldUpdateOperationsInput | string
    cover?: StringFieldUpdateOperationsInput | string
    product_file?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    id_author?: NullableStringFieldUpdateOperationsInput | string | null
    published_date?: DateTimeFieldUpdateOperationsInput | Date | string
    is_physical?: BoolFieldUpdateOperationsInput | boolean
    preorder_min_qty?: NullableIntFieldUpdateOperationsInput | number | null
    content_type?: NullableStringFieldUpdateOperationsInput | string | null
    is_chapter?: BoolFieldUpdateOperationsInput | boolean
    id_product?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    book_approval?: book_approvalUncheckedUpdateManyWithoutBookNestedInput
    book_changes_log?: book_changes_logUncheckedUpdateManyWithoutBookNestedInput
    book_genre?: book_genreUncheckedUpdateManyWithoutBookNestedInput
    book_tags?: book_tagsUncheckedUpdateManyWithoutBookNestedInput
    ranking?: rankingUncheckedUpdateManyWithoutBookNestedInput
    reviews?: reviewsUncheckedUpdateManyWithoutBookNestedInput
  }

  export type productUpsertWithoutChapterInput = {
    update: XOR<productUpdateWithoutChapterInput, productUncheckedUpdateWithoutChapterInput>
    create: XOR<productCreateWithoutChapterInput, productUncheckedCreateWithoutChapterInput>
    where?: productWhereInput
  }

  export type productUpdateToOneWithWhereWithoutChapterInput = {
    where?: productWhereInput
    data: XOR<productUpdateWithoutChapterInput, productUncheckedUpdateWithoutChapterInput>
  }

  export type productUpdateWithoutChapterInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    alias?: StringFieldUpdateOperationsInput | string
    strike_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    real_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    desc?: StringFieldUpdateOperationsInput | string
    info?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    img_file?: StringFieldUpdateOperationsInput | string
    cover?: StringFieldUpdateOperationsInput | string
    product_file?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    published_date?: DateTimeFieldUpdateOperationsInput | Date | string
    is_physical?: BoolFieldUpdateOperationsInput | boolean
    preorder_min_qty?: NullableIntFieldUpdateOperationsInput | number | null
    content_type?: NullableStringFieldUpdateOperationsInput | string | null
    is_chapter?: BoolFieldUpdateOperationsInput | boolean
    book?: bookUpdateManyWithoutProductNestedInput
    bundle_product?: bundle_productUpdateManyWithoutProductNestedInput
    customer_reader?: customer_readerUpdateManyWithoutProductNestedInput
    preorder?: preorderUpdateManyWithoutProductNestedInput
    author?: authorUpdateOneWithoutProductNestedInput
    product_category?: product_categoryUpdateManyWithoutProductNestedInput
    t_sales_download?: t_sales_downloadUpdateManyWithoutProductNestedInput
    t_sales_line?: t_sales_lineUpdateManyWithoutProductNestedInput
  }

  export type productUncheckedUpdateWithoutChapterInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    alias?: StringFieldUpdateOperationsInput | string
    strike_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    real_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    desc?: StringFieldUpdateOperationsInput | string
    info?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    img_file?: StringFieldUpdateOperationsInput | string
    cover?: StringFieldUpdateOperationsInput | string
    product_file?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    id_author?: NullableStringFieldUpdateOperationsInput | string | null
    published_date?: DateTimeFieldUpdateOperationsInput | Date | string
    is_physical?: BoolFieldUpdateOperationsInput | boolean
    preorder_min_qty?: NullableIntFieldUpdateOperationsInput | number | null
    content_type?: NullableStringFieldUpdateOperationsInput | string | null
    is_chapter?: BoolFieldUpdateOperationsInput | boolean
    book?: bookUncheckedUpdateManyWithoutProductNestedInput
    bundle_product?: bundle_productUncheckedUpdateManyWithoutProductNestedInput
    customer_reader?: customer_readerUncheckedUpdateManyWithoutProductNestedInput
    preorder?: preorderUncheckedUpdateManyWithoutProductNestedInput
    product_category?: product_categoryUncheckedUpdateManyWithoutProductNestedInput
    t_sales_download?: t_sales_downloadUncheckedUpdateManyWithoutProductNestedInput
    t_sales_line?: t_sales_lineUncheckedUpdateManyWithoutProductNestedInput
  }

  export type auth_userCreateWithoutCustomerInput = {
    id?: string
    name: string
    email: string
    email_verified?: boolean
    image?: string | null
    created_at?: Date | string
    updated_at?: Date | string | null
    username?: string | null
    display_username?: string | null
    two_factor_enabled?: boolean | null
    auth_account?: auth_accountCreateNestedManyWithoutAuth_userInput
    auth_session?: auth_sessionCreateNestedManyWithoutAuth_userInput
    auth_two_factor?: auth_two_factorCreateNestedManyWithoutAuth_userInput
    affiliate?: affiliateCreateNestedOneWithoutAuth_userInput
    author?: authorCreateNestedOneWithoutAuth_userInput
    internal?: internalCreateNestedOneWithoutAuth_userInput
    publisher?: publisherCreateNestedOneWithoutAuth_userInput
    reviews?: reviewsCreateNestedManyWithoutAuth_userInput
    reviews_likes?: reviews_likesCreateNestedManyWithoutAuth_userInput
  }

  export type auth_userUncheckedCreateWithoutCustomerInput = {
    id?: string
    name: string
    email: string
    email_verified?: boolean
    image?: string | null
    created_at?: Date | string
    updated_at?: Date | string | null
    username?: string | null
    display_username?: string | null
    two_factor_enabled?: boolean | null
    id_author?: string | null
    id_affiliate?: string | null
    id_publisher?: string | null
    id_internal?: string | null
    auth_account?: auth_accountUncheckedCreateNestedManyWithoutAuth_userInput
    auth_session?: auth_sessionUncheckedCreateNestedManyWithoutAuth_userInput
    auth_two_factor?: auth_two_factorUncheckedCreateNestedManyWithoutAuth_userInput
    reviews?: reviewsUncheckedCreateNestedManyWithoutAuth_userInput
    reviews_likes?: reviews_likesUncheckedCreateNestedManyWithoutAuth_userInput
  }

  export type auth_userCreateOrConnectWithoutCustomerInput = {
    where: auth_userWhereUniqueInput
    create: XOR<auth_userCreateWithoutCustomerInput, auth_userUncheckedCreateWithoutCustomerInput>
  }

  export type auth_userCreateManyCustomerInputEnvelope = {
    data: auth_userCreateManyCustomerInput | auth_userCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type auth_accountCreateWithoutCustomerInput = {
    id?: string
    password?: string | null
    id_provider?: string | null
    access_token?: string | null
    refresh_token?: string | null
    id_token?: string | null
    access_token_expires_at?: Date | string | null
    refresh_token_expires_at?: Date | string | null
    scope?: string | null
    created_at?: Date | string
    updated_at?: Date | string | null
    id_account?: string | null
    affiliate?: affiliateCreateNestedManyWithoutAuth_accountInput
    auth_user?: auth_userCreateNestedOneWithoutAuth_accountInput
    author?: authorCreateNestedManyWithoutAuth_accountInput
    internal?: internalCreateNestedManyWithoutAuth_accountInput
    publisher?: publisherCreateNestedManyWithoutAuth_accountInput
  }

  export type auth_accountUncheckedCreateWithoutCustomerInput = {
    id?: string
    password?: string | null
    id_provider?: string | null
    access_token?: string | null
    refresh_token?: string | null
    id_token?: string | null
    access_token_expires_at?: Date | string | null
    refresh_token_expires_at?: Date | string | null
    scope?: string | null
    created_at?: Date | string
    updated_at?: Date | string | null
    id_user?: string | null
    id_account?: string | null
    affiliate?: affiliateUncheckedCreateNestedManyWithoutAuth_accountInput
    author?: authorUncheckedCreateNestedManyWithoutAuth_accountInput
    internal?: internalUncheckedCreateNestedManyWithoutAuth_accountInput
    publisher?: publisherUncheckedCreateNestedManyWithoutAuth_accountInput
  }

  export type auth_accountCreateOrConnectWithoutCustomerInput = {
    where: auth_accountWhereUniqueInput
    create: XOR<auth_accountCreateWithoutCustomerInput, auth_accountUncheckedCreateWithoutCustomerInput>
  }

  export type customer_readerCreateWithoutCustomerInput = {
    id?: string
    last_page: number
    percent: number
    product: productCreateNestedOneWithoutCustomer_readerInput
  }

  export type customer_readerUncheckedCreateWithoutCustomerInput = {
    id?: string
    id_product: string
    last_page: number
    percent: number
  }

  export type customer_readerCreateOrConnectWithoutCustomerInput = {
    where: customer_readerWhereUniqueInput
    create: XOR<customer_readerCreateWithoutCustomerInput, customer_readerUncheckedCreateWithoutCustomerInput>
  }

  export type customer_readerCreateManyCustomerInputEnvelope = {
    data: customer_readerCreateManyCustomerInput | customer_readerCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type customer_trackCreateWithoutCustomerInput = {
    id?: string
    ts?: Date | string
    path: string
    referrer: string
    info: JsonNullValueInput | InputJsonValue
    ip: string
  }

  export type customer_trackUncheckedCreateWithoutCustomerInput = {
    id?: string
    ts?: Date | string
    path: string
    referrer: string
    info: JsonNullValueInput | InputJsonValue
    ip: string
  }

  export type customer_trackCreateOrConnectWithoutCustomerInput = {
    where: customer_trackWhereUniqueInput
    create: XOR<customer_trackCreateWithoutCustomerInput, customer_trackUncheckedCreateWithoutCustomerInput>
  }

  export type customer_trackCreateManyCustomerInputEnvelope = {
    data: customer_trackCreateManyCustomerInput | customer_trackCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type t_salesCreateWithoutCustomerInput = {
    id?: string
    status?: string
    total: Decimal | DecimalJsLike | number | string
    currency?: string
    info: JsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    midtrans_order_id?: string
    midtrans_success?: NullableJsonNullValueInput | InputJsonValue
    midtrans_pending?: NullableJsonNullValueInput | InputJsonValue
    midtrans_error?: NullableJsonNullValueInput | InputJsonValue
    t_sales_line?: t_sales_lineCreateNestedManyWithoutT_salesInput
  }

  export type t_salesUncheckedCreateWithoutCustomerInput = {
    id?: string
    status?: string
    total: Decimal | DecimalJsLike | number | string
    currency?: string
    info: JsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    midtrans_order_id?: string
    midtrans_success?: NullableJsonNullValueInput | InputJsonValue
    midtrans_pending?: NullableJsonNullValueInput | InputJsonValue
    midtrans_error?: NullableJsonNullValueInput | InputJsonValue
    t_sales_line?: t_sales_lineUncheckedCreateNestedManyWithoutT_salesInput
  }

  export type t_salesCreateOrConnectWithoutCustomerInput = {
    where: t_salesWhereUniqueInput
    create: XOR<t_salesCreateWithoutCustomerInput, t_salesUncheckedCreateWithoutCustomerInput>
  }

  export type t_salesCreateManyCustomerInputEnvelope = {
    data: t_salesCreateManyCustomerInput | t_salesCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type t_sales_downloadCreateWithoutCustomerInput = {
    id?: string
    downloaded_at?: Date | string | null
    ip_address?: string | null
    download_key?: string
    product: productCreateNestedOneWithoutT_sales_downloadInput
  }

  export type t_sales_downloadUncheckedCreateWithoutCustomerInput = {
    id?: string
    id_product: string
    downloaded_at?: Date | string | null
    ip_address?: string | null
    download_key?: string
  }

  export type t_sales_downloadCreateOrConnectWithoutCustomerInput = {
    where: t_sales_downloadWhereUniqueInput
    create: XOR<t_sales_downloadCreateWithoutCustomerInput, t_sales_downloadUncheckedCreateWithoutCustomerInput>
  }

  export type t_sales_downloadCreateManyCustomerInputEnvelope = {
    data: t_sales_downloadCreateManyCustomerInput | t_sales_downloadCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type auth_userUpsertWithWhereUniqueWithoutCustomerInput = {
    where: auth_userWhereUniqueInput
    update: XOR<auth_userUpdateWithoutCustomerInput, auth_userUncheckedUpdateWithoutCustomerInput>
    create: XOR<auth_userCreateWithoutCustomerInput, auth_userUncheckedCreateWithoutCustomerInput>
  }

  export type auth_userUpdateWithWhereUniqueWithoutCustomerInput = {
    where: auth_userWhereUniqueInput
    data: XOR<auth_userUpdateWithoutCustomerInput, auth_userUncheckedUpdateWithoutCustomerInput>
  }

  export type auth_userUpdateManyWithWhereWithoutCustomerInput = {
    where: auth_userScalarWhereInput
    data: XOR<auth_userUpdateManyMutationInput, auth_userUncheckedUpdateManyWithoutCustomerInput>
  }

  export type auth_accountUpsertWithoutCustomerInput = {
    update: XOR<auth_accountUpdateWithoutCustomerInput, auth_accountUncheckedUpdateWithoutCustomerInput>
    create: XOR<auth_accountCreateWithoutCustomerInput, auth_accountUncheckedCreateWithoutCustomerInput>
    where?: auth_accountWhereInput
  }

  export type auth_accountUpdateToOneWithWhereWithoutCustomerInput = {
    where?: auth_accountWhereInput
    data: XOR<auth_accountUpdateWithoutCustomerInput, auth_accountUncheckedUpdateWithoutCustomerInput>
  }

  export type auth_accountUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    id_provider?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token_expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refresh_token_expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    id_account?: NullableStringFieldUpdateOperationsInput | string | null
    affiliate?: affiliateUpdateManyWithoutAuth_accountNestedInput
    auth_user?: auth_userUpdateOneWithoutAuth_accountNestedInput
    author?: authorUpdateManyWithoutAuth_accountNestedInput
    internal?: internalUpdateManyWithoutAuth_accountNestedInput
    publisher?: publisherUpdateManyWithoutAuth_accountNestedInput
  }

  export type auth_accountUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    id_provider?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token_expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refresh_token_expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    id_user?: NullableStringFieldUpdateOperationsInput | string | null
    id_account?: NullableStringFieldUpdateOperationsInput | string | null
    affiliate?: affiliateUncheckedUpdateManyWithoutAuth_accountNestedInput
    author?: authorUncheckedUpdateManyWithoutAuth_accountNestedInput
    internal?: internalUncheckedUpdateManyWithoutAuth_accountNestedInput
    publisher?: publisherUncheckedUpdateManyWithoutAuth_accountNestedInput
  }

  export type customer_readerUpsertWithWhereUniqueWithoutCustomerInput = {
    where: customer_readerWhereUniqueInput
    update: XOR<customer_readerUpdateWithoutCustomerInput, customer_readerUncheckedUpdateWithoutCustomerInput>
    create: XOR<customer_readerCreateWithoutCustomerInput, customer_readerUncheckedCreateWithoutCustomerInput>
  }

  export type customer_readerUpdateWithWhereUniqueWithoutCustomerInput = {
    where: customer_readerWhereUniqueInput
    data: XOR<customer_readerUpdateWithoutCustomerInput, customer_readerUncheckedUpdateWithoutCustomerInput>
  }

  export type customer_readerUpdateManyWithWhereWithoutCustomerInput = {
    where: customer_readerScalarWhereInput
    data: XOR<customer_readerUpdateManyMutationInput, customer_readerUncheckedUpdateManyWithoutCustomerInput>
  }

  export type customer_readerScalarWhereInput = {
    AND?: customer_readerScalarWhereInput | customer_readerScalarWhereInput[]
    OR?: customer_readerScalarWhereInput[]
    NOT?: customer_readerScalarWhereInput | customer_readerScalarWhereInput[]
    id?: UuidFilter<"customer_reader"> | string
    id_customer?: UuidFilter<"customer_reader"> | string
    id_product?: UuidFilter<"customer_reader"> | string
    last_page?: IntFilter<"customer_reader"> | number
    percent?: IntFilter<"customer_reader"> | number
  }

  export type customer_trackUpsertWithWhereUniqueWithoutCustomerInput = {
    where: customer_trackWhereUniqueInput
    update: XOR<customer_trackUpdateWithoutCustomerInput, customer_trackUncheckedUpdateWithoutCustomerInput>
    create: XOR<customer_trackCreateWithoutCustomerInput, customer_trackUncheckedCreateWithoutCustomerInput>
  }

  export type customer_trackUpdateWithWhereUniqueWithoutCustomerInput = {
    where: customer_trackWhereUniqueInput
    data: XOR<customer_trackUpdateWithoutCustomerInput, customer_trackUncheckedUpdateWithoutCustomerInput>
  }

  export type customer_trackUpdateManyWithWhereWithoutCustomerInput = {
    where: customer_trackScalarWhereInput
    data: XOR<customer_trackUpdateManyMutationInput, customer_trackUncheckedUpdateManyWithoutCustomerInput>
  }

  export type customer_trackScalarWhereInput = {
    AND?: customer_trackScalarWhereInput | customer_trackScalarWhereInput[]
    OR?: customer_trackScalarWhereInput[]
    NOT?: customer_trackScalarWhereInput | customer_trackScalarWhereInput[]
    id?: UuidFilter<"customer_track"> | string
    ts?: DateTimeFilter<"customer_track"> | Date | string
    id_customer?: UuidFilter<"customer_track"> | string
    path?: StringFilter<"customer_track"> | string
    referrer?: StringFilter<"customer_track"> | string
    info?: JsonFilter<"customer_track">
    ip?: StringFilter<"customer_track"> | string
  }

  export type t_salesUpsertWithWhereUniqueWithoutCustomerInput = {
    where: t_salesWhereUniqueInput
    update: XOR<t_salesUpdateWithoutCustomerInput, t_salesUncheckedUpdateWithoutCustomerInput>
    create: XOR<t_salesCreateWithoutCustomerInput, t_salesUncheckedCreateWithoutCustomerInput>
  }

  export type t_salesUpdateWithWhereUniqueWithoutCustomerInput = {
    where: t_salesWhereUniqueInput
    data: XOR<t_salesUpdateWithoutCustomerInput, t_salesUncheckedUpdateWithoutCustomerInput>
  }

  export type t_salesUpdateManyWithWhereWithoutCustomerInput = {
    where: t_salesScalarWhereInput
    data: XOR<t_salesUpdateManyMutationInput, t_salesUncheckedUpdateManyWithoutCustomerInput>
  }

  export type t_salesScalarWhereInput = {
    AND?: t_salesScalarWhereInput | t_salesScalarWhereInput[]
    OR?: t_salesScalarWhereInput[]
    NOT?: t_salesScalarWhereInput | t_salesScalarWhereInput[]
    id?: UuidFilter<"t_sales"> | string
    id_customer?: UuidFilter<"t_sales"> | string
    status?: StringFilter<"t_sales"> | string
    total?: DecimalFilter<"t_sales"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"t_sales"> | string
    info?: JsonFilter<"t_sales">
    created_at?: DateTimeFilter<"t_sales"> | Date | string
    updated_at?: DateTimeNullableFilter<"t_sales"> | Date | string | null
    deleted_at?: DateTimeNullableFilter<"t_sales"> | Date | string | null
    midtrans_order_id?: StringFilter<"t_sales"> | string
    midtrans_success?: JsonNullableFilter<"t_sales">
    midtrans_pending?: JsonNullableFilter<"t_sales">
    midtrans_error?: JsonNullableFilter<"t_sales">
  }

  export type t_sales_downloadUpsertWithWhereUniqueWithoutCustomerInput = {
    where: t_sales_downloadWhereUniqueInput
    update: XOR<t_sales_downloadUpdateWithoutCustomerInput, t_sales_downloadUncheckedUpdateWithoutCustomerInput>
    create: XOR<t_sales_downloadCreateWithoutCustomerInput, t_sales_downloadUncheckedCreateWithoutCustomerInput>
  }

  export type t_sales_downloadUpdateWithWhereUniqueWithoutCustomerInput = {
    where: t_sales_downloadWhereUniqueInput
    data: XOR<t_sales_downloadUpdateWithoutCustomerInput, t_sales_downloadUncheckedUpdateWithoutCustomerInput>
  }

  export type t_sales_downloadUpdateManyWithWhereWithoutCustomerInput = {
    where: t_sales_downloadScalarWhereInput
    data: XOR<t_sales_downloadUpdateManyMutationInput, t_sales_downloadUncheckedUpdateManyWithoutCustomerInput>
  }

  export type t_sales_downloadScalarWhereInput = {
    AND?: t_sales_downloadScalarWhereInput | t_sales_downloadScalarWhereInput[]
    OR?: t_sales_downloadScalarWhereInput[]
    NOT?: t_sales_downloadScalarWhereInput | t_sales_downloadScalarWhereInput[]
    id?: UuidFilter<"t_sales_download"> | string
    id_product?: UuidFilter<"t_sales_download"> | string
    id_customer?: UuidFilter<"t_sales_download"> | string
    downloaded_at?: DateTimeNullableFilter<"t_sales_download"> | Date | string | null
    ip_address?: StringNullableFilter<"t_sales_download"> | string | null
    download_key?: StringFilter<"t_sales_download"> | string
  }

  export type customerCreateWithoutCustomer_readerInput = {
    id?: string
    whatsapp: string
    deleted_at?: Date | string | null
    otp?: number | null
    name: string
    email: string
    auth_user?: auth_userCreateNestedManyWithoutCustomerInput
    auth_account?: auth_accountCreateNestedOneWithoutCustomerInput
    customer_track?: customer_trackCreateNestedManyWithoutCustomerInput
    t_sales?: t_salesCreateNestedManyWithoutCustomerInput
    t_sales_download?: t_sales_downloadCreateNestedManyWithoutCustomerInput
  }

  export type customerUncheckedCreateWithoutCustomer_readerInput = {
    id?: string
    whatsapp: string
    deleted_at?: Date | string | null
    otp?: number | null
    id_account?: string | null
    name: string
    email: string
    auth_user?: auth_userUncheckedCreateNestedManyWithoutCustomerInput
    customer_track?: customer_trackUncheckedCreateNestedManyWithoutCustomerInput
    t_sales?: t_salesUncheckedCreateNestedManyWithoutCustomerInput
    t_sales_download?: t_sales_downloadUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type customerCreateOrConnectWithoutCustomer_readerInput = {
    where: customerWhereUniqueInput
    create: XOR<customerCreateWithoutCustomer_readerInput, customerUncheckedCreateWithoutCustomer_readerInput>
  }

  export type productCreateWithoutCustomer_readerInput = {
    id?: string
    name: string
    slug: string
    alias?: string
    strike_price?: Decimal | DecimalJsLike | number | string | null
    real_price: Decimal | DecimalJsLike | number | string
    desc?: string
    info?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    currency?: string
    deleted_at?: Date | string | null
    img_file?: string
    cover?: string
    product_file?: string
    sku?: string
    published_date?: Date | string
    is_physical?: boolean
    preorder_min_qty?: number | null
    content_type?: string | null
    is_chapter?: boolean
    book?: bookCreateNestedManyWithoutProductInput
    bundle_product?: bundle_productCreateNestedManyWithoutProductInput
    chapter?: chapterCreateNestedManyWithoutProductInput
    preorder?: preorderCreateNestedManyWithoutProductInput
    author?: authorCreateNestedOneWithoutProductInput
    product_category?: product_categoryCreateNestedManyWithoutProductInput
    t_sales_download?: t_sales_downloadCreateNestedManyWithoutProductInput
    t_sales_line?: t_sales_lineCreateNestedManyWithoutProductInput
  }

  export type productUncheckedCreateWithoutCustomer_readerInput = {
    id?: string
    name: string
    slug: string
    alias?: string
    strike_price?: Decimal | DecimalJsLike | number | string | null
    real_price: Decimal | DecimalJsLike | number | string
    desc?: string
    info?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    currency?: string
    deleted_at?: Date | string | null
    img_file?: string
    cover?: string
    product_file?: string
    sku?: string
    id_author?: string | null
    published_date?: Date | string
    is_physical?: boolean
    preorder_min_qty?: number | null
    content_type?: string | null
    is_chapter?: boolean
    book?: bookUncheckedCreateNestedManyWithoutProductInput
    bundle_product?: bundle_productUncheckedCreateNestedManyWithoutProductInput
    chapter?: chapterUncheckedCreateNestedManyWithoutProductInput
    preorder?: preorderUncheckedCreateNestedManyWithoutProductInput
    product_category?: product_categoryUncheckedCreateNestedManyWithoutProductInput
    t_sales_download?: t_sales_downloadUncheckedCreateNestedManyWithoutProductInput
    t_sales_line?: t_sales_lineUncheckedCreateNestedManyWithoutProductInput
  }

  export type productCreateOrConnectWithoutCustomer_readerInput = {
    where: productWhereUniqueInput
    create: XOR<productCreateWithoutCustomer_readerInput, productUncheckedCreateWithoutCustomer_readerInput>
  }

  export type customerUpsertWithoutCustomer_readerInput = {
    update: XOR<customerUpdateWithoutCustomer_readerInput, customerUncheckedUpdateWithoutCustomer_readerInput>
    create: XOR<customerCreateWithoutCustomer_readerInput, customerUncheckedCreateWithoutCustomer_readerInput>
    where?: customerWhereInput
  }

  export type customerUpdateToOneWithWhereWithoutCustomer_readerInput = {
    where?: customerWhereInput
    data: XOR<customerUpdateWithoutCustomer_readerInput, customerUncheckedUpdateWithoutCustomer_readerInput>
  }

  export type customerUpdateWithoutCustomer_readerInput = {
    id?: StringFieldUpdateOperationsInput | string
    whatsapp?: StringFieldUpdateOperationsInput | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otp?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    auth_user?: auth_userUpdateManyWithoutCustomerNestedInput
    auth_account?: auth_accountUpdateOneWithoutCustomerNestedInput
    customer_track?: customer_trackUpdateManyWithoutCustomerNestedInput
    t_sales?: t_salesUpdateManyWithoutCustomerNestedInput
    t_sales_download?: t_sales_downloadUpdateManyWithoutCustomerNestedInput
  }

  export type customerUncheckedUpdateWithoutCustomer_readerInput = {
    id?: StringFieldUpdateOperationsInput | string
    whatsapp?: StringFieldUpdateOperationsInput | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otp?: NullableIntFieldUpdateOperationsInput | number | null
    id_account?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    auth_user?: auth_userUncheckedUpdateManyWithoutCustomerNestedInput
    customer_track?: customer_trackUncheckedUpdateManyWithoutCustomerNestedInput
    t_sales?: t_salesUncheckedUpdateManyWithoutCustomerNestedInput
    t_sales_download?: t_sales_downloadUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type productUpsertWithoutCustomer_readerInput = {
    update: XOR<productUpdateWithoutCustomer_readerInput, productUncheckedUpdateWithoutCustomer_readerInput>
    create: XOR<productCreateWithoutCustomer_readerInput, productUncheckedCreateWithoutCustomer_readerInput>
    where?: productWhereInput
  }

  export type productUpdateToOneWithWhereWithoutCustomer_readerInput = {
    where?: productWhereInput
    data: XOR<productUpdateWithoutCustomer_readerInput, productUncheckedUpdateWithoutCustomer_readerInput>
  }

  export type productUpdateWithoutCustomer_readerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    alias?: StringFieldUpdateOperationsInput | string
    strike_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    real_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    desc?: StringFieldUpdateOperationsInput | string
    info?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    img_file?: StringFieldUpdateOperationsInput | string
    cover?: StringFieldUpdateOperationsInput | string
    product_file?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    published_date?: DateTimeFieldUpdateOperationsInput | Date | string
    is_physical?: BoolFieldUpdateOperationsInput | boolean
    preorder_min_qty?: NullableIntFieldUpdateOperationsInput | number | null
    content_type?: NullableStringFieldUpdateOperationsInput | string | null
    is_chapter?: BoolFieldUpdateOperationsInput | boolean
    book?: bookUpdateManyWithoutProductNestedInput
    bundle_product?: bundle_productUpdateManyWithoutProductNestedInput
    chapter?: chapterUpdateManyWithoutProductNestedInput
    preorder?: preorderUpdateManyWithoutProductNestedInput
    author?: authorUpdateOneWithoutProductNestedInput
    product_category?: product_categoryUpdateManyWithoutProductNestedInput
    t_sales_download?: t_sales_downloadUpdateManyWithoutProductNestedInput
    t_sales_line?: t_sales_lineUpdateManyWithoutProductNestedInput
  }

  export type productUncheckedUpdateWithoutCustomer_readerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    alias?: StringFieldUpdateOperationsInput | string
    strike_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    real_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    desc?: StringFieldUpdateOperationsInput | string
    info?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    img_file?: StringFieldUpdateOperationsInput | string
    cover?: StringFieldUpdateOperationsInput | string
    product_file?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    id_author?: NullableStringFieldUpdateOperationsInput | string | null
    published_date?: DateTimeFieldUpdateOperationsInput | Date | string
    is_physical?: BoolFieldUpdateOperationsInput | boolean
    preorder_min_qty?: NullableIntFieldUpdateOperationsInput | number | null
    content_type?: NullableStringFieldUpdateOperationsInput | string | null
    is_chapter?: BoolFieldUpdateOperationsInput | boolean
    book?: bookUncheckedUpdateManyWithoutProductNestedInput
    bundle_product?: bundle_productUncheckedUpdateManyWithoutProductNestedInput
    chapter?: chapterUncheckedUpdateManyWithoutProductNestedInput
    preorder?: preorderUncheckedUpdateManyWithoutProductNestedInput
    product_category?: product_categoryUncheckedUpdateManyWithoutProductNestedInput
    t_sales_download?: t_sales_downloadUncheckedUpdateManyWithoutProductNestedInput
    t_sales_line?: t_sales_lineUncheckedUpdateManyWithoutProductNestedInput
  }

  export type customerCreateWithoutCustomer_trackInput = {
    id?: string
    whatsapp: string
    deleted_at?: Date | string | null
    otp?: number | null
    name: string
    email: string
    auth_user?: auth_userCreateNestedManyWithoutCustomerInput
    auth_account?: auth_accountCreateNestedOneWithoutCustomerInput
    customer_reader?: customer_readerCreateNestedManyWithoutCustomerInput
    t_sales?: t_salesCreateNestedManyWithoutCustomerInput
    t_sales_download?: t_sales_downloadCreateNestedManyWithoutCustomerInput
  }

  export type customerUncheckedCreateWithoutCustomer_trackInput = {
    id?: string
    whatsapp: string
    deleted_at?: Date | string | null
    otp?: number | null
    id_account?: string | null
    name: string
    email: string
    auth_user?: auth_userUncheckedCreateNestedManyWithoutCustomerInput
    customer_reader?: customer_readerUncheckedCreateNestedManyWithoutCustomerInput
    t_sales?: t_salesUncheckedCreateNestedManyWithoutCustomerInput
    t_sales_download?: t_sales_downloadUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type customerCreateOrConnectWithoutCustomer_trackInput = {
    where: customerWhereUniqueInput
    create: XOR<customerCreateWithoutCustomer_trackInput, customerUncheckedCreateWithoutCustomer_trackInput>
  }

  export type customerUpsertWithoutCustomer_trackInput = {
    update: XOR<customerUpdateWithoutCustomer_trackInput, customerUncheckedUpdateWithoutCustomer_trackInput>
    create: XOR<customerCreateWithoutCustomer_trackInput, customerUncheckedCreateWithoutCustomer_trackInput>
    where?: customerWhereInput
  }

  export type customerUpdateToOneWithWhereWithoutCustomer_trackInput = {
    where?: customerWhereInput
    data: XOR<customerUpdateWithoutCustomer_trackInput, customerUncheckedUpdateWithoutCustomer_trackInput>
  }

  export type customerUpdateWithoutCustomer_trackInput = {
    id?: StringFieldUpdateOperationsInput | string
    whatsapp?: StringFieldUpdateOperationsInput | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otp?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    auth_user?: auth_userUpdateManyWithoutCustomerNestedInput
    auth_account?: auth_accountUpdateOneWithoutCustomerNestedInput
    customer_reader?: customer_readerUpdateManyWithoutCustomerNestedInput
    t_sales?: t_salesUpdateManyWithoutCustomerNestedInput
    t_sales_download?: t_sales_downloadUpdateManyWithoutCustomerNestedInput
  }

  export type customerUncheckedUpdateWithoutCustomer_trackInput = {
    id?: StringFieldUpdateOperationsInput | string
    whatsapp?: StringFieldUpdateOperationsInput | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otp?: NullableIntFieldUpdateOperationsInput | number | null
    id_account?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    auth_user?: auth_userUncheckedUpdateManyWithoutCustomerNestedInput
    customer_reader?: customer_readerUncheckedUpdateManyWithoutCustomerNestedInput
    t_sales?: t_salesUncheckedUpdateManyWithoutCustomerNestedInput
    t_sales_download?: t_sales_downloadUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type book_genreCreateWithoutGenreInput = {
    id?: string
    book: bookCreateNestedOneWithoutBook_genreInput
  }

  export type book_genreUncheckedCreateWithoutGenreInput = {
    id?: string
    id_book: string
  }

  export type book_genreCreateOrConnectWithoutGenreInput = {
    where: book_genreWhereUniqueInput
    create: XOR<book_genreCreateWithoutGenreInput, book_genreUncheckedCreateWithoutGenreInput>
  }

  export type book_genreCreateManyGenreInputEnvelope = {
    data: book_genreCreateManyGenreInput | book_genreCreateManyGenreInput[]
    skipDuplicates?: boolean
  }

  export type genreCreateWithoutOther_genreInput = {
    id?: string
    name: string
    slug?: string | null
    img?: string | null
    deleted_at?: Date | string | null
    book_genre?: book_genreCreateNestedManyWithoutGenreInput
    genre?: genreCreateNestedOneWithoutOther_genreInput
  }

  export type genreUncheckedCreateWithoutOther_genreInput = {
    id?: string
    name: string
    id_parent?: string | null
    slug?: string | null
    img?: string | null
    deleted_at?: Date | string | null
    book_genre?: book_genreUncheckedCreateNestedManyWithoutGenreInput
  }

  export type genreCreateOrConnectWithoutOther_genreInput = {
    where: genreWhereUniqueInput
    create: XOR<genreCreateWithoutOther_genreInput, genreUncheckedCreateWithoutOther_genreInput>
  }

  export type genreCreateWithoutGenreInput = {
    id?: string
    name: string
    slug?: string | null
    img?: string | null
    deleted_at?: Date | string | null
    book_genre?: book_genreCreateNestedManyWithoutGenreInput
    other_genre?: genreCreateNestedManyWithoutGenreInput
  }

  export type genreUncheckedCreateWithoutGenreInput = {
    id?: string
    name: string
    slug?: string | null
    img?: string | null
    deleted_at?: Date | string | null
    book_genre?: book_genreUncheckedCreateNestedManyWithoutGenreInput
    other_genre?: genreUncheckedCreateNestedManyWithoutGenreInput
  }

  export type genreCreateOrConnectWithoutGenreInput = {
    where: genreWhereUniqueInput
    create: XOR<genreCreateWithoutGenreInput, genreUncheckedCreateWithoutGenreInput>
  }

  export type genreCreateManyGenreInputEnvelope = {
    data: genreCreateManyGenreInput | genreCreateManyGenreInput[]
    skipDuplicates?: boolean
  }

  export type book_genreUpsertWithWhereUniqueWithoutGenreInput = {
    where: book_genreWhereUniqueInput
    update: XOR<book_genreUpdateWithoutGenreInput, book_genreUncheckedUpdateWithoutGenreInput>
    create: XOR<book_genreCreateWithoutGenreInput, book_genreUncheckedCreateWithoutGenreInput>
  }

  export type book_genreUpdateWithWhereUniqueWithoutGenreInput = {
    where: book_genreWhereUniqueInput
    data: XOR<book_genreUpdateWithoutGenreInput, book_genreUncheckedUpdateWithoutGenreInput>
  }

  export type book_genreUpdateManyWithWhereWithoutGenreInput = {
    where: book_genreScalarWhereInput
    data: XOR<book_genreUpdateManyMutationInput, book_genreUncheckedUpdateManyWithoutGenreInput>
  }

  export type genreUpsertWithoutOther_genreInput = {
    update: XOR<genreUpdateWithoutOther_genreInput, genreUncheckedUpdateWithoutOther_genreInput>
    create: XOR<genreCreateWithoutOther_genreInput, genreUncheckedCreateWithoutOther_genreInput>
    where?: genreWhereInput
  }

  export type genreUpdateToOneWithWhereWithoutOther_genreInput = {
    where?: genreWhereInput
    data: XOR<genreUpdateWithoutOther_genreInput, genreUncheckedUpdateWithoutOther_genreInput>
  }

  export type genreUpdateWithoutOther_genreInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    img?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    book_genre?: book_genreUpdateManyWithoutGenreNestedInput
    genre?: genreUpdateOneWithoutOther_genreNestedInput
  }

  export type genreUncheckedUpdateWithoutOther_genreInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    id_parent?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    img?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    book_genre?: book_genreUncheckedUpdateManyWithoutGenreNestedInput
  }

  export type genreUpsertWithWhereUniqueWithoutGenreInput = {
    where: genreWhereUniqueInput
    update: XOR<genreUpdateWithoutGenreInput, genreUncheckedUpdateWithoutGenreInput>
    create: XOR<genreCreateWithoutGenreInput, genreUncheckedCreateWithoutGenreInput>
  }

  export type genreUpdateWithWhereUniqueWithoutGenreInput = {
    where: genreWhereUniqueInput
    data: XOR<genreUpdateWithoutGenreInput, genreUncheckedUpdateWithoutGenreInput>
  }

  export type genreUpdateManyWithWhereWithoutGenreInput = {
    where: genreScalarWhereInput
    data: XOR<genreUpdateManyMutationInput, genreUncheckedUpdateManyWithoutGenreInput>
  }

  export type genreScalarWhereInput = {
    AND?: genreScalarWhereInput | genreScalarWhereInput[]
    OR?: genreScalarWhereInput[]
    NOT?: genreScalarWhereInput | genreScalarWhereInput[]
    id?: UuidFilter<"genre"> | string
    name?: StringFilter<"genre"> | string
    id_parent?: UuidNullableFilter<"genre"> | string | null
    slug?: StringNullableFilter<"genre"> | string | null
    img?: StringNullableFilter<"genre"> | string | null
    deleted_at?: DateTimeNullableFilter<"genre"> | Date | string | null
  }

  export type auth_userCreateWithoutInternalInput = {
    id?: string
    name: string
    email: string
    email_verified?: boolean
    image?: string | null
    created_at?: Date | string
    updated_at?: Date | string | null
    username?: string | null
    display_username?: string | null
    two_factor_enabled?: boolean | null
    auth_account?: auth_accountCreateNestedManyWithoutAuth_userInput
    auth_session?: auth_sessionCreateNestedManyWithoutAuth_userInput
    auth_two_factor?: auth_two_factorCreateNestedManyWithoutAuth_userInput
    affiliate?: affiliateCreateNestedOneWithoutAuth_userInput
    author?: authorCreateNestedOneWithoutAuth_userInput
    customer?: customerCreateNestedOneWithoutAuth_userInput
    publisher?: publisherCreateNestedOneWithoutAuth_userInput
    reviews?: reviewsCreateNestedManyWithoutAuth_userInput
    reviews_likes?: reviews_likesCreateNestedManyWithoutAuth_userInput
  }

  export type auth_userUncheckedCreateWithoutInternalInput = {
    id?: string
    name: string
    email: string
    email_verified?: boolean
    image?: string | null
    created_at?: Date | string
    updated_at?: Date | string | null
    username?: string | null
    display_username?: string | null
    two_factor_enabled?: boolean | null
    id_customer?: string | null
    id_author?: string | null
    id_affiliate?: string | null
    id_publisher?: string | null
    auth_account?: auth_accountUncheckedCreateNestedManyWithoutAuth_userInput
    auth_session?: auth_sessionUncheckedCreateNestedManyWithoutAuth_userInput
    auth_two_factor?: auth_two_factorUncheckedCreateNestedManyWithoutAuth_userInput
    reviews?: reviewsUncheckedCreateNestedManyWithoutAuth_userInput
    reviews_likes?: reviews_likesUncheckedCreateNestedManyWithoutAuth_userInput
  }

  export type auth_userCreateOrConnectWithoutInternalInput = {
    where: auth_userWhereUniqueInput
    create: XOR<auth_userCreateWithoutInternalInput, auth_userUncheckedCreateWithoutInternalInput>
  }

  export type auth_userCreateManyInternalInputEnvelope = {
    data: auth_userCreateManyInternalInput | auth_userCreateManyInternalInput[]
    skipDuplicates?: boolean
  }

  export type book_approvalCreateWithoutInternalInput = {
    id?: string
    comment?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    created_at?: Date | string
    book: bookCreateNestedOneWithoutBook_approvalInput
  }

  export type book_approvalUncheckedCreateWithoutInternalInput = {
    id?: string
    id_book: string
    comment?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    created_at?: Date | string
  }

  export type book_approvalCreateOrConnectWithoutInternalInput = {
    where: book_approvalWhereUniqueInput
    create: XOR<book_approvalCreateWithoutInternalInput, book_approvalUncheckedCreateWithoutInternalInput>
  }

  export type book_approvalCreateManyInternalInputEnvelope = {
    data: book_approvalCreateManyInternalInput | book_approvalCreateManyInternalInput[]
    skipDuplicates?: boolean
  }

  export type auth_accountCreateWithoutInternalInput = {
    id?: string
    password?: string | null
    id_provider?: string | null
    access_token?: string | null
    refresh_token?: string | null
    id_token?: string | null
    access_token_expires_at?: Date | string | null
    refresh_token_expires_at?: Date | string | null
    scope?: string | null
    created_at?: Date | string
    updated_at?: Date | string | null
    id_account?: string | null
    affiliate?: affiliateCreateNestedManyWithoutAuth_accountInput
    auth_user?: auth_userCreateNestedOneWithoutAuth_accountInput
    author?: authorCreateNestedManyWithoutAuth_accountInput
    customer?: customerCreateNestedManyWithoutAuth_accountInput
    publisher?: publisherCreateNestedManyWithoutAuth_accountInput
  }

  export type auth_accountUncheckedCreateWithoutInternalInput = {
    id?: string
    password?: string | null
    id_provider?: string | null
    access_token?: string | null
    refresh_token?: string | null
    id_token?: string | null
    access_token_expires_at?: Date | string | null
    refresh_token_expires_at?: Date | string | null
    scope?: string | null
    created_at?: Date | string
    updated_at?: Date | string | null
    id_user?: string | null
    id_account?: string | null
    affiliate?: affiliateUncheckedCreateNestedManyWithoutAuth_accountInput
    author?: authorUncheckedCreateNestedManyWithoutAuth_accountInput
    customer?: customerUncheckedCreateNestedManyWithoutAuth_accountInput
    publisher?: publisherUncheckedCreateNestedManyWithoutAuth_accountInput
  }

  export type auth_accountCreateOrConnectWithoutInternalInput = {
    where: auth_accountWhereUniqueInput
    create: XOR<auth_accountCreateWithoutInternalInput, auth_accountUncheckedCreateWithoutInternalInput>
  }

  export type auth_userUpsertWithWhereUniqueWithoutInternalInput = {
    where: auth_userWhereUniqueInput
    update: XOR<auth_userUpdateWithoutInternalInput, auth_userUncheckedUpdateWithoutInternalInput>
    create: XOR<auth_userCreateWithoutInternalInput, auth_userUncheckedCreateWithoutInternalInput>
  }

  export type auth_userUpdateWithWhereUniqueWithoutInternalInput = {
    where: auth_userWhereUniqueInput
    data: XOR<auth_userUpdateWithoutInternalInput, auth_userUncheckedUpdateWithoutInternalInput>
  }

  export type auth_userUpdateManyWithWhereWithoutInternalInput = {
    where: auth_userScalarWhereInput
    data: XOR<auth_userUpdateManyMutationInput, auth_userUncheckedUpdateManyWithoutInternalInput>
  }

  export type book_approvalUpsertWithWhereUniqueWithoutInternalInput = {
    where: book_approvalWhereUniqueInput
    update: XOR<book_approvalUpdateWithoutInternalInput, book_approvalUncheckedUpdateWithoutInternalInput>
    create: XOR<book_approvalCreateWithoutInternalInput, book_approvalUncheckedCreateWithoutInternalInput>
  }

  export type book_approvalUpdateWithWhereUniqueWithoutInternalInput = {
    where: book_approvalWhereUniqueInput
    data: XOR<book_approvalUpdateWithoutInternalInput, book_approvalUncheckedUpdateWithoutInternalInput>
  }

  export type book_approvalUpdateManyWithWhereWithoutInternalInput = {
    where: book_approvalScalarWhereInput
    data: XOR<book_approvalUpdateManyMutationInput, book_approvalUncheckedUpdateManyWithoutInternalInput>
  }

  export type auth_accountUpsertWithoutInternalInput = {
    update: XOR<auth_accountUpdateWithoutInternalInput, auth_accountUncheckedUpdateWithoutInternalInput>
    create: XOR<auth_accountCreateWithoutInternalInput, auth_accountUncheckedCreateWithoutInternalInput>
    where?: auth_accountWhereInput
  }

  export type auth_accountUpdateToOneWithWhereWithoutInternalInput = {
    where?: auth_accountWhereInput
    data: XOR<auth_accountUpdateWithoutInternalInput, auth_accountUncheckedUpdateWithoutInternalInput>
  }

  export type auth_accountUpdateWithoutInternalInput = {
    id?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    id_provider?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token_expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refresh_token_expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    id_account?: NullableStringFieldUpdateOperationsInput | string | null
    affiliate?: affiliateUpdateManyWithoutAuth_accountNestedInput
    auth_user?: auth_userUpdateOneWithoutAuth_accountNestedInput
    author?: authorUpdateManyWithoutAuth_accountNestedInput
    customer?: customerUpdateManyWithoutAuth_accountNestedInput
    publisher?: publisherUpdateManyWithoutAuth_accountNestedInput
  }

  export type auth_accountUncheckedUpdateWithoutInternalInput = {
    id?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    id_provider?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token_expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refresh_token_expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    id_user?: NullableStringFieldUpdateOperationsInput | string | null
    id_account?: NullableStringFieldUpdateOperationsInput | string | null
    affiliate?: affiliateUncheckedUpdateManyWithoutAuth_accountNestedInput
    author?: authorUncheckedUpdateManyWithoutAuth_accountNestedInput
    customer?: customerUncheckedUpdateManyWithoutAuth_accountNestedInput
    publisher?: publisherUncheckedUpdateManyWithoutAuth_accountNestedInput
  }

  export type landing_itemsCreateWithoutLandingInput = {
    id?: string
    desc?: string
    img_file: string
    tag?: string
    link_to: string
    idx?: number
    color?: string
  }

  export type landing_itemsUncheckedCreateWithoutLandingInput = {
    id?: string
    desc?: string
    img_file: string
    tag?: string
    link_to: string
    idx?: number
    color?: string
  }

  export type landing_itemsCreateOrConnectWithoutLandingInput = {
    where: landing_itemsWhereUniqueInput
    create: XOR<landing_itemsCreateWithoutLandingInput, landing_itemsUncheckedCreateWithoutLandingInput>
  }

  export type landing_itemsCreateManyLandingInputEnvelope = {
    data: landing_itemsCreateManyLandingInput | landing_itemsCreateManyLandingInput[]
    skipDuplicates?: boolean
  }

  export type landing_itemsUpsertWithWhereUniqueWithoutLandingInput = {
    where: landing_itemsWhereUniqueInput
    update: XOR<landing_itemsUpdateWithoutLandingInput, landing_itemsUncheckedUpdateWithoutLandingInput>
    create: XOR<landing_itemsCreateWithoutLandingInput, landing_itemsUncheckedCreateWithoutLandingInput>
  }

  export type landing_itemsUpdateWithWhereUniqueWithoutLandingInput = {
    where: landing_itemsWhereUniqueInput
    data: XOR<landing_itemsUpdateWithoutLandingInput, landing_itemsUncheckedUpdateWithoutLandingInput>
  }

  export type landing_itemsUpdateManyWithWhereWithoutLandingInput = {
    where: landing_itemsScalarWhereInput
    data: XOR<landing_itemsUpdateManyMutationInput, landing_itemsUncheckedUpdateManyWithoutLandingInput>
  }

  export type landing_itemsScalarWhereInput = {
    AND?: landing_itemsScalarWhereInput | landing_itemsScalarWhereInput[]
    OR?: landing_itemsScalarWhereInput[]
    NOT?: landing_itemsScalarWhereInput | landing_itemsScalarWhereInput[]
    id?: UuidFilter<"landing_items"> | string
    desc?: StringFilter<"landing_items"> | string
    img_file?: StringFilter<"landing_items"> | string
    tag?: StringFilter<"landing_items"> | string
    link_to?: StringFilter<"landing_items"> | string
    landing_id?: UuidFilter<"landing_items"> | string
    idx?: IntFilter<"landing_items"> | number
    color?: StringFilter<"landing_items"> | string
  }

  export type landingCreateWithoutLanding_itemsInput = {
    id?: string
    slug: string
    views: number
    deleted_at?: Date | string | null
    status?: string
    title?: string
  }

  export type landingUncheckedCreateWithoutLanding_itemsInput = {
    id?: string
    slug: string
    views: number
    deleted_at?: Date | string | null
    status?: string
    title?: string
  }

  export type landingCreateOrConnectWithoutLanding_itemsInput = {
    where: landingWhereUniqueInput
    create: XOR<landingCreateWithoutLanding_itemsInput, landingUncheckedCreateWithoutLanding_itemsInput>
  }

  export type landingUpsertWithoutLanding_itemsInput = {
    update: XOR<landingUpdateWithoutLanding_itemsInput, landingUncheckedUpdateWithoutLanding_itemsInput>
    create: XOR<landingCreateWithoutLanding_itemsInput, landingUncheckedCreateWithoutLanding_itemsInput>
    where?: landingWhereInput
  }

  export type landingUpdateToOneWithWhereWithoutLanding_itemsInput = {
    where?: landingWhereInput
    data: XOR<landingUpdateWithoutLanding_itemsInput, landingUncheckedUpdateWithoutLanding_itemsInput>
  }

  export type landingUpdateWithoutLanding_itemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    views?: IntFieldUpdateOperationsInput | number
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
  }

  export type landingUncheckedUpdateWithoutLanding_itemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    views?: IntFieldUpdateOperationsInput | number
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
  }

  export type productCreateWithoutPreorderInput = {
    id?: string
    name: string
    slug: string
    alias?: string
    strike_price?: Decimal | DecimalJsLike | number | string | null
    real_price: Decimal | DecimalJsLike | number | string
    desc?: string
    info?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    currency?: string
    deleted_at?: Date | string | null
    img_file?: string
    cover?: string
    product_file?: string
    sku?: string
    published_date?: Date | string
    is_physical?: boolean
    preorder_min_qty?: number | null
    content_type?: string | null
    is_chapter?: boolean
    book?: bookCreateNestedManyWithoutProductInput
    bundle_product?: bundle_productCreateNestedManyWithoutProductInput
    chapter?: chapterCreateNestedManyWithoutProductInput
    customer_reader?: customer_readerCreateNestedManyWithoutProductInput
    author?: authorCreateNestedOneWithoutProductInput
    product_category?: product_categoryCreateNestedManyWithoutProductInput
    t_sales_download?: t_sales_downloadCreateNestedManyWithoutProductInput
    t_sales_line?: t_sales_lineCreateNestedManyWithoutProductInput
  }

  export type productUncheckedCreateWithoutPreorderInput = {
    id?: string
    name: string
    slug: string
    alias?: string
    strike_price?: Decimal | DecimalJsLike | number | string | null
    real_price: Decimal | DecimalJsLike | number | string
    desc?: string
    info?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    currency?: string
    deleted_at?: Date | string | null
    img_file?: string
    cover?: string
    product_file?: string
    sku?: string
    id_author?: string | null
    published_date?: Date | string
    is_physical?: boolean
    preorder_min_qty?: number | null
    content_type?: string | null
    is_chapter?: boolean
    book?: bookUncheckedCreateNestedManyWithoutProductInput
    bundle_product?: bundle_productUncheckedCreateNestedManyWithoutProductInput
    chapter?: chapterUncheckedCreateNestedManyWithoutProductInput
    customer_reader?: customer_readerUncheckedCreateNestedManyWithoutProductInput
    product_category?: product_categoryUncheckedCreateNestedManyWithoutProductInput
    t_sales_download?: t_sales_downloadUncheckedCreateNestedManyWithoutProductInput
    t_sales_line?: t_sales_lineUncheckedCreateNestedManyWithoutProductInput
  }

  export type productCreateOrConnectWithoutPreorderInput = {
    where: productWhereUniqueInput
    create: XOR<productCreateWithoutPreorderInput, productUncheckedCreateWithoutPreorderInput>
  }

  export type productUpsertWithoutPreorderInput = {
    update: XOR<productUpdateWithoutPreorderInput, productUncheckedUpdateWithoutPreorderInput>
    create: XOR<productCreateWithoutPreorderInput, productUncheckedCreateWithoutPreorderInput>
    where?: productWhereInput
  }

  export type productUpdateToOneWithWhereWithoutPreorderInput = {
    where?: productWhereInput
    data: XOR<productUpdateWithoutPreorderInput, productUncheckedUpdateWithoutPreorderInput>
  }

  export type productUpdateWithoutPreorderInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    alias?: StringFieldUpdateOperationsInput | string
    strike_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    real_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    desc?: StringFieldUpdateOperationsInput | string
    info?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    img_file?: StringFieldUpdateOperationsInput | string
    cover?: StringFieldUpdateOperationsInput | string
    product_file?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    published_date?: DateTimeFieldUpdateOperationsInput | Date | string
    is_physical?: BoolFieldUpdateOperationsInput | boolean
    preorder_min_qty?: NullableIntFieldUpdateOperationsInput | number | null
    content_type?: NullableStringFieldUpdateOperationsInput | string | null
    is_chapter?: BoolFieldUpdateOperationsInput | boolean
    book?: bookUpdateManyWithoutProductNestedInput
    bundle_product?: bundle_productUpdateManyWithoutProductNestedInput
    chapter?: chapterUpdateManyWithoutProductNestedInput
    customer_reader?: customer_readerUpdateManyWithoutProductNestedInput
    author?: authorUpdateOneWithoutProductNestedInput
    product_category?: product_categoryUpdateManyWithoutProductNestedInput
    t_sales_download?: t_sales_downloadUpdateManyWithoutProductNestedInput
    t_sales_line?: t_sales_lineUpdateManyWithoutProductNestedInput
  }

  export type productUncheckedUpdateWithoutPreorderInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    alias?: StringFieldUpdateOperationsInput | string
    strike_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    real_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    desc?: StringFieldUpdateOperationsInput | string
    info?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    img_file?: StringFieldUpdateOperationsInput | string
    cover?: StringFieldUpdateOperationsInput | string
    product_file?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    id_author?: NullableStringFieldUpdateOperationsInput | string | null
    published_date?: DateTimeFieldUpdateOperationsInput | Date | string
    is_physical?: BoolFieldUpdateOperationsInput | boolean
    preorder_min_qty?: NullableIntFieldUpdateOperationsInput | number | null
    content_type?: NullableStringFieldUpdateOperationsInput | string | null
    is_chapter?: BoolFieldUpdateOperationsInput | boolean
    book?: bookUncheckedUpdateManyWithoutProductNestedInput
    bundle_product?: bundle_productUncheckedUpdateManyWithoutProductNestedInput
    chapter?: chapterUncheckedUpdateManyWithoutProductNestedInput
    customer_reader?: customer_readerUncheckedUpdateManyWithoutProductNestedInput
    product_category?: product_categoryUncheckedUpdateManyWithoutProductNestedInput
    t_sales_download?: t_sales_downloadUncheckedUpdateManyWithoutProductNestedInput
    t_sales_line?: t_sales_lineUncheckedUpdateManyWithoutProductNestedInput
  }

  export type bookCreateWithoutProductInput = {
    id?: string
    name: string
    slug: string
    alias?: string
    submitted_price: Decimal | DecimalJsLike | number | string
    desc?: string
    info?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    currency?: string
    deleted_at?: Date | string | null
    img_file?: string
    cover?: string
    product_file?: string
    sku?: string
    published_date?: Date | string
    is_physical?: boolean
    preorder_min_qty?: number | null
    content_type?: string | null
    is_chapter?: boolean
    created_at?: Date | string
    author?: authorCreateNestedOneWithoutBookInput
    book_approval?: book_approvalCreateNestedManyWithoutBookInput
    book_changes_log?: book_changes_logCreateNestedManyWithoutBookInput
    book_genre?: book_genreCreateNestedManyWithoutBookInput
    book_tags?: book_tagsCreateNestedManyWithoutBookInput
    chapter?: chapterCreateNestedManyWithoutBookInput
    ranking?: rankingCreateNestedManyWithoutBookInput
    reviews?: reviewsCreateNestedManyWithoutBookInput
  }

  export type bookUncheckedCreateWithoutProductInput = {
    id?: string
    name: string
    slug: string
    alias?: string
    submitted_price: Decimal | DecimalJsLike | number | string
    desc?: string
    info?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    currency?: string
    deleted_at?: Date | string | null
    img_file?: string
    cover?: string
    product_file?: string
    sku?: string
    id_author?: string | null
    published_date?: Date | string
    is_physical?: boolean
    preorder_min_qty?: number | null
    content_type?: string | null
    is_chapter?: boolean
    created_at?: Date | string
    book_approval?: book_approvalUncheckedCreateNestedManyWithoutBookInput
    book_changes_log?: book_changes_logUncheckedCreateNestedManyWithoutBookInput
    book_genre?: book_genreUncheckedCreateNestedManyWithoutBookInput
    book_tags?: book_tagsUncheckedCreateNestedManyWithoutBookInput
    chapter?: chapterUncheckedCreateNestedManyWithoutBookInput
    ranking?: rankingUncheckedCreateNestedManyWithoutBookInput
    reviews?: reviewsUncheckedCreateNestedManyWithoutBookInput
  }

  export type bookCreateOrConnectWithoutProductInput = {
    where: bookWhereUniqueInput
    create: XOR<bookCreateWithoutProductInput, bookUncheckedCreateWithoutProductInput>
  }

  export type bookCreateManyProductInputEnvelope = {
    data: bookCreateManyProductInput | bookCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type bundle_productCreateWithoutProductInput = {
    id?: string
    qty?: number | null
    bundle: bundleCreateNestedOneWithoutBundle_productInput
  }

  export type bundle_productUncheckedCreateWithoutProductInput = {
    id_bundle: string
    id?: string
    qty?: number | null
  }

  export type bundle_productCreateOrConnectWithoutProductInput = {
    where: bundle_productWhereUniqueInput
    create: XOR<bundle_productCreateWithoutProductInput, bundle_productUncheckedCreateWithoutProductInput>
  }

  export type bundle_productCreateManyProductInputEnvelope = {
    data: bundle_productCreateManyProductInput | bundle_productCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type chapterCreateWithoutProductInput = {
    id?: string
    number: number
    name: string
    content?: JsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string | null
    book?: bookCreateNestedOneWithoutChapterInput
  }

  export type chapterUncheckedCreateWithoutProductInput = {
    id?: string
    id_book?: string | null
    number: number
    name: string
    content?: JsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string | null
  }

  export type chapterCreateOrConnectWithoutProductInput = {
    where: chapterWhereUniqueInput
    create: XOR<chapterCreateWithoutProductInput, chapterUncheckedCreateWithoutProductInput>
  }

  export type chapterCreateManyProductInputEnvelope = {
    data: chapterCreateManyProductInput | chapterCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type customer_readerCreateWithoutProductInput = {
    id?: string
    last_page: number
    percent: number
    customer: customerCreateNestedOneWithoutCustomer_readerInput
  }

  export type customer_readerUncheckedCreateWithoutProductInput = {
    id?: string
    id_customer: string
    last_page: number
    percent: number
  }

  export type customer_readerCreateOrConnectWithoutProductInput = {
    where: customer_readerWhereUniqueInput
    create: XOR<customer_readerCreateWithoutProductInput, customer_readerUncheckedCreateWithoutProductInput>
  }

  export type customer_readerCreateManyProductInputEnvelope = {
    data: customer_readerCreateManyProductInput | customer_readerCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type preorderCreateWithoutProductInput = {
    id?: string
    min_qty: number
    current_qty?: number
    status?: string
    deadline: Date | string
  }

  export type preorderUncheckedCreateWithoutProductInput = {
    id?: string
    min_qty: number
    current_qty?: number
    status?: string
    deadline: Date | string
  }

  export type preorderCreateOrConnectWithoutProductInput = {
    where: preorderWhereUniqueInput
    create: XOR<preorderCreateWithoutProductInput, preorderUncheckedCreateWithoutProductInput>
  }

  export type preorderCreateManyProductInputEnvelope = {
    data: preorderCreateManyProductInput | preorderCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type authorCreateWithoutProductInput = {
    id?: string
    name: string
    biography?: string | null
    social_media?: string | null
    avatar?: string | null
    auth_user?: auth_userCreateNestedManyWithoutAuthorInput
    auth_account?: auth_accountCreateNestedOneWithoutAuthorInput
    book?: bookCreateNestedManyWithoutAuthorInput
    publisher_author?: publisher_authorCreateNestedManyWithoutAuthorInput
  }

  export type authorUncheckedCreateWithoutProductInput = {
    id?: string
    name: string
    id_account?: string | null
    biography?: string | null
    social_media?: string | null
    avatar?: string | null
    auth_user?: auth_userUncheckedCreateNestedManyWithoutAuthorInput
    book?: bookUncheckedCreateNestedManyWithoutAuthorInput
    publisher_author?: publisher_authorUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type authorCreateOrConnectWithoutProductInput = {
    where: authorWhereUniqueInput
    create: XOR<authorCreateWithoutProductInput, authorUncheckedCreateWithoutProductInput>
  }

  export type product_categoryCreateWithoutProductInput = {
    id?: string
    category: categoryCreateNestedOneWithoutProduct_categoryInput
  }

  export type product_categoryUncheckedCreateWithoutProductInput = {
    id_category: string
    id?: string
  }

  export type product_categoryCreateOrConnectWithoutProductInput = {
    where: product_categoryWhereUniqueInput
    create: XOR<product_categoryCreateWithoutProductInput, product_categoryUncheckedCreateWithoutProductInput>
  }

  export type product_categoryCreateManyProductInputEnvelope = {
    data: product_categoryCreateManyProductInput | product_categoryCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type t_sales_downloadCreateWithoutProductInput = {
    id?: string
    downloaded_at?: Date | string | null
    ip_address?: string | null
    download_key?: string
    customer: customerCreateNestedOneWithoutT_sales_downloadInput
  }

  export type t_sales_downloadUncheckedCreateWithoutProductInput = {
    id?: string
    id_customer: string
    downloaded_at?: Date | string | null
    ip_address?: string | null
    download_key?: string
  }

  export type t_sales_downloadCreateOrConnectWithoutProductInput = {
    where: t_sales_downloadWhereUniqueInput
    create: XOR<t_sales_downloadCreateWithoutProductInput, t_sales_downloadUncheckedCreateWithoutProductInput>
  }

  export type t_sales_downloadCreateManyProductInputEnvelope = {
    data: t_sales_downloadCreateManyProductInput | t_sales_downloadCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type t_sales_lineCreateWithoutProductInput = {
    id?: string
    unit_price: Decimal | DecimalJsLike | number | string
    qty: number
    total_price: Decimal | DecimalJsLike | number | string
    bundle?: bundleCreateNestedOneWithoutT_sales_lineInput
    t_sales: t_salesCreateNestedOneWithoutT_sales_lineInput
  }

  export type t_sales_lineUncheckedCreateWithoutProductInput = {
    id?: string
    id_sales: string
    unit_price: Decimal | DecimalJsLike | number | string
    qty: number
    total_price: Decimal | DecimalJsLike | number | string
    id_bundle?: string | null
  }

  export type t_sales_lineCreateOrConnectWithoutProductInput = {
    where: t_sales_lineWhereUniqueInput
    create: XOR<t_sales_lineCreateWithoutProductInput, t_sales_lineUncheckedCreateWithoutProductInput>
  }

  export type t_sales_lineCreateManyProductInputEnvelope = {
    data: t_sales_lineCreateManyProductInput | t_sales_lineCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type bookUpsertWithWhereUniqueWithoutProductInput = {
    where: bookWhereUniqueInput
    update: XOR<bookUpdateWithoutProductInput, bookUncheckedUpdateWithoutProductInput>
    create: XOR<bookCreateWithoutProductInput, bookUncheckedCreateWithoutProductInput>
  }

  export type bookUpdateWithWhereUniqueWithoutProductInput = {
    where: bookWhereUniqueInput
    data: XOR<bookUpdateWithoutProductInput, bookUncheckedUpdateWithoutProductInput>
  }

  export type bookUpdateManyWithWhereWithoutProductInput = {
    where: bookScalarWhereInput
    data: XOR<bookUpdateManyMutationInput, bookUncheckedUpdateManyWithoutProductInput>
  }

  export type bundle_productUpsertWithWhereUniqueWithoutProductInput = {
    where: bundle_productWhereUniqueInput
    update: XOR<bundle_productUpdateWithoutProductInput, bundle_productUncheckedUpdateWithoutProductInput>
    create: XOR<bundle_productCreateWithoutProductInput, bundle_productUncheckedCreateWithoutProductInput>
  }

  export type bundle_productUpdateWithWhereUniqueWithoutProductInput = {
    where: bundle_productWhereUniqueInput
    data: XOR<bundle_productUpdateWithoutProductInput, bundle_productUncheckedUpdateWithoutProductInput>
  }

  export type bundle_productUpdateManyWithWhereWithoutProductInput = {
    where: bundle_productScalarWhereInput
    data: XOR<bundle_productUpdateManyMutationInput, bundle_productUncheckedUpdateManyWithoutProductInput>
  }

  export type chapterUpsertWithWhereUniqueWithoutProductInput = {
    where: chapterWhereUniqueInput
    update: XOR<chapterUpdateWithoutProductInput, chapterUncheckedUpdateWithoutProductInput>
    create: XOR<chapterCreateWithoutProductInput, chapterUncheckedCreateWithoutProductInput>
  }

  export type chapterUpdateWithWhereUniqueWithoutProductInput = {
    where: chapterWhereUniqueInput
    data: XOR<chapterUpdateWithoutProductInput, chapterUncheckedUpdateWithoutProductInput>
  }

  export type chapterUpdateManyWithWhereWithoutProductInput = {
    where: chapterScalarWhereInput
    data: XOR<chapterUpdateManyMutationInput, chapterUncheckedUpdateManyWithoutProductInput>
  }

  export type customer_readerUpsertWithWhereUniqueWithoutProductInput = {
    where: customer_readerWhereUniqueInput
    update: XOR<customer_readerUpdateWithoutProductInput, customer_readerUncheckedUpdateWithoutProductInput>
    create: XOR<customer_readerCreateWithoutProductInput, customer_readerUncheckedCreateWithoutProductInput>
  }

  export type customer_readerUpdateWithWhereUniqueWithoutProductInput = {
    where: customer_readerWhereUniqueInput
    data: XOR<customer_readerUpdateWithoutProductInput, customer_readerUncheckedUpdateWithoutProductInput>
  }

  export type customer_readerUpdateManyWithWhereWithoutProductInput = {
    where: customer_readerScalarWhereInput
    data: XOR<customer_readerUpdateManyMutationInput, customer_readerUncheckedUpdateManyWithoutProductInput>
  }

  export type preorderUpsertWithWhereUniqueWithoutProductInput = {
    where: preorderWhereUniqueInput
    update: XOR<preorderUpdateWithoutProductInput, preorderUncheckedUpdateWithoutProductInput>
    create: XOR<preorderCreateWithoutProductInput, preorderUncheckedCreateWithoutProductInput>
  }

  export type preorderUpdateWithWhereUniqueWithoutProductInput = {
    where: preorderWhereUniqueInput
    data: XOR<preorderUpdateWithoutProductInput, preorderUncheckedUpdateWithoutProductInput>
  }

  export type preorderUpdateManyWithWhereWithoutProductInput = {
    where: preorderScalarWhereInput
    data: XOR<preorderUpdateManyMutationInput, preorderUncheckedUpdateManyWithoutProductInput>
  }

  export type preorderScalarWhereInput = {
    AND?: preorderScalarWhereInput | preorderScalarWhereInput[]
    OR?: preorderScalarWhereInput[]
    NOT?: preorderScalarWhereInput | preorderScalarWhereInput[]
    id?: UuidFilter<"preorder"> | string
    id_product?: UuidFilter<"preorder"> | string
    min_qty?: IntFilter<"preorder"> | number
    current_qty?: IntFilter<"preorder"> | number
    status?: StringFilter<"preorder"> | string
    deadline?: DateTimeFilter<"preorder"> | Date | string
  }

  export type authorUpsertWithoutProductInput = {
    update: XOR<authorUpdateWithoutProductInput, authorUncheckedUpdateWithoutProductInput>
    create: XOR<authorCreateWithoutProductInput, authorUncheckedCreateWithoutProductInput>
    where?: authorWhereInput
  }

  export type authorUpdateToOneWithWhereWithoutProductInput = {
    where?: authorWhereInput
    data: XOR<authorUpdateWithoutProductInput, authorUncheckedUpdateWithoutProductInput>
  }

  export type authorUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    biography?: NullableStringFieldUpdateOperationsInput | string | null
    social_media?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    auth_user?: auth_userUpdateManyWithoutAuthorNestedInput
    auth_account?: auth_accountUpdateOneWithoutAuthorNestedInput
    book?: bookUpdateManyWithoutAuthorNestedInput
    publisher_author?: publisher_authorUpdateManyWithoutAuthorNestedInput
  }

  export type authorUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    id_account?: NullableStringFieldUpdateOperationsInput | string | null
    biography?: NullableStringFieldUpdateOperationsInput | string | null
    social_media?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    auth_user?: auth_userUncheckedUpdateManyWithoutAuthorNestedInput
    book?: bookUncheckedUpdateManyWithoutAuthorNestedInput
    publisher_author?: publisher_authorUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type product_categoryUpsertWithWhereUniqueWithoutProductInput = {
    where: product_categoryWhereUniqueInput
    update: XOR<product_categoryUpdateWithoutProductInput, product_categoryUncheckedUpdateWithoutProductInput>
    create: XOR<product_categoryCreateWithoutProductInput, product_categoryUncheckedCreateWithoutProductInput>
  }

  export type product_categoryUpdateWithWhereUniqueWithoutProductInput = {
    where: product_categoryWhereUniqueInput
    data: XOR<product_categoryUpdateWithoutProductInput, product_categoryUncheckedUpdateWithoutProductInput>
  }

  export type product_categoryUpdateManyWithWhereWithoutProductInput = {
    where: product_categoryScalarWhereInput
    data: XOR<product_categoryUpdateManyMutationInput, product_categoryUncheckedUpdateManyWithoutProductInput>
  }

  export type t_sales_downloadUpsertWithWhereUniqueWithoutProductInput = {
    where: t_sales_downloadWhereUniqueInput
    update: XOR<t_sales_downloadUpdateWithoutProductInput, t_sales_downloadUncheckedUpdateWithoutProductInput>
    create: XOR<t_sales_downloadCreateWithoutProductInput, t_sales_downloadUncheckedCreateWithoutProductInput>
  }

  export type t_sales_downloadUpdateWithWhereUniqueWithoutProductInput = {
    where: t_sales_downloadWhereUniqueInput
    data: XOR<t_sales_downloadUpdateWithoutProductInput, t_sales_downloadUncheckedUpdateWithoutProductInput>
  }

  export type t_sales_downloadUpdateManyWithWhereWithoutProductInput = {
    where: t_sales_downloadScalarWhereInput
    data: XOR<t_sales_downloadUpdateManyMutationInput, t_sales_downloadUncheckedUpdateManyWithoutProductInput>
  }

  export type t_sales_lineUpsertWithWhereUniqueWithoutProductInput = {
    where: t_sales_lineWhereUniqueInput
    update: XOR<t_sales_lineUpdateWithoutProductInput, t_sales_lineUncheckedUpdateWithoutProductInput>
    create: XOR<t_sales_lineCreateWithoutProductInput, t_sales_lineUncheckedCreateWithoutProductInput>
  }

  export type t_sales_lineUpdateWithWhereUniqueWithoutProductInput = {
    where: t_sales_lineWhereUniqueInput
    data: XOR<t_sales_lineUpdateWithoutProductInput, t_sales_lineUncheckedUpdateWithoutProductInput>
  }

  export type t_sales_lineUpdateManyWithWhereWithoutProductInput = {
    where: t_sales_lineScalarWhereInput
    data: XOR<t_sales_lineUpdateManyMutationInput, t_sales_lineUncheckedUpdateManyWithoutProductInput>
  }

  export type categoryCreateWithoutProduct_categoryInput = {
    id?: string
    name: string
    deleted_at?: Date | string | null
    slug?: string | null
    img?: string | null
    bundle_category?: bundle_categoryCreateNestedManyWithoutCategoryInput
    category?: categoryCreateNestedOneWithoutOther_categoryInput
    other_category?: categoryCreateNestedManyWithoutCategoryInput
  }

  export type categoryUncheckedCreateWithoutProduct_categoryInput = {
    id?: string
    name: string
    id_parent?: string | null
    deleted_at?: Date | string | null
    slug?: string | null
    img?: string | null
    bundle_category?: bundle_categoryUncheckedCreateNestedManyWithoutCategoryInput
    other_category?: categoryUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type categoryCreateOrConnectWithoutProduct_categoryInput = {
    where: categoryWhereUniqueInput
    create: XOR<categoryCreateWithoutProduct_categoryInput, categoryUncheckedCreateWithoutProduct_categoryInput>
  }

  export type productCreateWithoutProduct_categoryInput = {
    id?: string
    name: string
    slug: string
    alias?: string
    strike_price?: Decimal | DecimalJsLike | number | string | null
    real_price: Decimal | DecimalJsLike | number | string
    desc?: string
    info?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    currency?: string
    deleted_at?: Date | string | null
    img_file?: string
    cover?: string
    product_file?: string
    sku?: string
    published_date?: Date | string
    is_physical?: boolean
    preorder_min_qty?: number | null
    content_type?: string | null
    is_chapter?: boolean
    book?: bookCreateNestedManyWithoutProductInput
    bundle_product?: bundle_productCreateNestedManyWithoutProductInput
    chapter?: chapterCreateNestedManyWithoutProductInput
    customer_reader?: customer_readerCreateNestedManyWithoutProductInput
    preorder?: preorderCreateNestedManyWithoutProductInput
    author?: authorCreateNestedOneWithoutProductInput
    t_sales_download?: t_sales_downloadCreateNestedManyWithoutProductInput
    t_sales_line?: t_sales_lineCreateNestedManyWithoutProductInput
  }

  export type productUncheckedCreateWithoutProduct_categoryInput = {
    id?: string
    name: string
    slug: string
    alias?: string
    strike_price?: Decimal | DecimalJsLike | number | string | null
    real_price: Decimal | DecimalJsLike | number | string
    desc?: string
    info?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    currency?: string
    deleted_at?: Date | string | null
    img_file?: string
    cover?: string
    product_file?: string
    sku?: string
    id_author?: string | null
    published_date?: Date | string
    is_physical?: boolean
    preorder_min_qty?: number | null
    content_type?: string | null
    is_chapter?: boolean
    book?: bookUncheckedCreateNestedManyWithoutProductInput
    bundle_product?: bundle_productUncheckedCreateNestedManyWithoutProductInput
    chapter?: chapterUncheckedCreateNestedManyWithoutProductInput
    customer_reader?: customer_readerUncheckedCreateNestedManyWithoutProductInput
    preorder?: preorderUncheckedCreateNestedManyWithoutProductInput
    t_sales_download?: t_sales_downloadUncheckedCreateNestedManyWithoutProductInput
    t_sales_line?: t_sales_lineUncheckedCreateNestedManyWithoutProductInput
  }

  export type productCreateOrConnectWithoutProduct_categoryInput = {
    where: productWhereUniqueInput
    create: XOR<productCreateWithoutProduct_categoryInput, productUncheckedCreateWithoutProduct_categoryInput>
  }

  export type categoryUpsertWithoutProduct_categoryInput = {
    update: XOR<categoryUpdateWithoutProduct_categoryInput, categoryUncheckedUpdateWithoutProduct_categoryInput>
    create: XOR<categoryCreateWithoutProduct_categoryInput, categoryUncheckedCreateWithoutProduct_categoryInput>
    where?: categoryWhereInput
  }

  export type categoryUpdateToOneWithWhereWithoutProduct_categoryInput = {
    where?: categoryWhereInput
    data: XOR<categoryUpdateWithoutProduct_categoryInput, categoryUncheckedUpdateWithoutProduct_categoryInput>
  }

  export type categoryUpdateWithoutProduct_categoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    img?: NullableStringFieldUpdateOperationsInput | string | null
    bundle_category?: bundle_categoryUpdateManyWithoutCategoryNestedInput
    category?: categoryUpdateOneWithoutOther_categoryNestedInput
    other_category?: categoryUpdateManyWithoutCategoryNestedInput
  }

  export type categoryUncheckedUpdateWithoutProduct_categoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    id_parent?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    img?: NullableStringFieldUpdateOperationsInput | string | null
    bundle_category?: bundle_categoryUncheckedUpdateManyWithoutCategoryNestedInput
    other_category?: categoryUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type productUpsertWithoutProduct_categoryInput = {
    update: XOR<productUpdateWithoutProduct_categoryInput, productUncheckedUpdateWithoutProduct_categoryInput>
    create: XOR<productCreateWithoutProduct_categoryInput, productUncheckedCreateWithoutProduct_categoryInput>
    where?: productWhereInput
  }

  export type productUpdateToOneWithWhereWithoutProduct_categoryInput = {
    where?: productWhereInput
    data: XOR<productUpdateWithoutProduct_categoryInput, productUncheckedUpdateWithoutProduct_categoryInput>
  }

  export type productUpdateWithoutProduct_categoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    alias?: StringFieldUpdateOperationsInput | string
    strike_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    real_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    desc?: StringFieldUpdateOperationsInput | string
    info?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    img_file?: StringFieldUpdateOperationsInput | string
    cover?: StringFieldUpdateOperationsInput | string
    product_file?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    published_date?: DateTimeFieldUpdateOperationsInput | Date | string
    is_physical?: BoolFieldUpdateOperationsInput | boolean
    preorder_min_qty?: NullableIntFieldUpdateOperationsInput | number | null
    content_type?: NullableStringFieldUpdateOperationsInput | string | null
    is_chapter?: BoolFieldUpdateOperationsInput | boolean
    book?: bookUpdateManyWithoutProductNestedInput
    bundle_product?: bundle_productUpdateManyWithoutProductNestedInput
    chapter?: chapterUpdateManyWithoutProductNestedInput
    customer_reader?: customer_readerUpdateManyWithoutProductNestedInput
    preorder?: preorderUpdateManyWithoutProductNestedInput
    author?: authorUpdateOneWithoutProductNestedInput
    t_sales_download?: t_sales_downloadUpdateManyWithoutProductNestedInput
    t_sales_line?: t_sales_lineUpdateManyWithoutProductNestedInput
  }

  export type productUncheckedUpdateWithoutProduct_categoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    alias?: StringFieldUpdateOperationsInput | string
    strike_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    real_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    desc?: StringFieldUpdateOperationsInput | string
    info?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    img_file?: StringFieldUpdateOperationsInput | string
    cover?: StringFieldUpdateOperationsInput | string
    product_file?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    id_author?: NullableStringFieldUpdateOperationsInput | string | null
    published_date?: DateTimeFieldUpdateOperationsInput | Date | string
    is_physical?: BoolFieldUpdateOperationsInput | boolean
    preorder_min_qty?: NullableIntFieldUpdateOperationsInput | number | null
    content_type?: NullableStringFieldUpdateOperationsInput | string | null
    is_chapter?: BoolFieldUpdateOperationsInput | boolean
    book?: bookUncheckedUpdateManyWithoutProductNestedInput
    bundle_product?: bundle_productUncheckedUpdateManyWithoutProductNestedInput
    chapter?: chapterUncheckedUpdateManyWithoutProductNestedInput
    customer_reader?: customer_readerUncheckedUpdateManyWithoutProductNestedInput
    preorder?: preorderUncheckedUpdateManyWithoutProductNestedInput
    t_sales_download?: t_sales_downloadUncheckedUpdateManyWithoutProductNestedInput
    t_sales_line?: t_sales_lineUncheckedUpdateManyWithoutProductNestedInput
  }

  export type publisherCreateWithoutPromo_codeInput = {
    id?: string
    name: string
    description?: string | null
    website?: string | null
    address?: string | null
    logo?: string | null
    auth_user?: auth_userCreateNestedManyWithoutPublisherInput
    auth_account?: auth_accountCreateNestedOneWithoutPublisherInput
    publisher_author?: publisher_authorCreateNestedManyWithoutPublisherInput
    t_ai_credit?: t_ai_creditCreateNestedManyWithoutPublisherInput
    transaction?: transactionCreateNestedManyWithoutPublisherInput
    withdrawal?: withdrawalCreateNestedManyWithoutPublisherInput
  }

  export type publisherUncheckedCreateWithoutPromo_codeInput = {
    id?: string
    id_account?: string | null
    name: string
    description?: string | null
    website?: string | null
    address?: string | null
    logo?: string | null
    auth_user?: auth_userUncheckedCreateNestedManyWithoutPublisherInput
    publisher_author?: publisher_authorUncheckedCreateNestedManyWithoutPublisherInput
    t_ai_credit?: t_ai_creditUncheckedCreateNestedManyWithoutPublisherInput
    transaction?: transactionUncheckedCreateNestedManyWithoutPublisherInput
    withdrawal?: withdrawalUncheckedCreateNestedManyWithoutPublisherInput
  }

  export type publisherCreateOrConnectWithoutPromo_codeInput = {
    where: publisherWhereUniqueInput
    create: XOR<publisherCreateWithoutPromo_codeInput, publisherUncheckedCreateWithoutPromo_codeInput>
  }

  export type publisherUpsertWithoutPromo_codeInput = {
    update: XOR<publisherUpdateWithoutPromo_codeInput, publisherUncheckedUpdateWithoutPromo_codeInput>
    create: XOR<publisherCreateWithoutPromo_codeInput, publisherUncheckedCreateWithoutPromo_codeInput>
    where?: publisherWhereInput
  }

  export type publisherUpdateToOneWithWhereWithoutPromo_codeInput = {
    where?: publisherWhereInput
    data: XOR<publisherUpdateWithoutPromo_codeInput, publisherUncheckedUpdateWithoutPromo_codeInput>
  }

  export type publisherUpdateWithoutPromo_codeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    auth_user?: auth_userUpdateManyWithoutPublisherNestedInput
    auth_account?: auth_accountUpdateOneWithoutPublisherNestedInput
    publisher_author?: publisher_authorUpdateManyWithoutPublisherNestedInput
    t_ai_credit?: t_ai_creditUpdateManyWithoutPublisherNestedInput
    transaction?: transactionUpdateManyWithoutPublisherNestedInput
    withdrawal?: withdrawalUpdateManyWithoutPublisherNestedInput
  }

  export type publisherUncheckedUpdateWithoutPromo_codeInput = {
    id?: StringFieldUpdateOperationsInput | string
    id_account?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    auth_user?: auth_userUncheckedUpdateManyWithoutPublisherNestedInput
    publisher_author?: publisher_authorUncheckedUpdateManyWithoutPublisherNestedInput
    t_ai_credit?: t_ai_creditUncheckedUpdateManyWithoutPublisherNestedInput
    transaction?: transactionUncheckedUpdateManyWithoutPublisherNestedInput
    withdrawal?: withdrawalUncheckedUpdateManyWithoutPublisherNestedInput
  }

  export type auth_userCreateWithoutPublisherInput = {
    id?: string
    name: string
    email: string
    email_verified?: boolean
    image?: string | null
    created_at?: Date | string
    updated_at?: Date | string | null
    username?: string | null
    display_username?: string | null
    two_factor_enabled?: boolean | null
    auth_account?: auth_accountCreateNestedManyWithoutAuth_userInput
    auth_session?: auth_sessionCreateNestedManyWithoutAuth_userInput
    auth_two_factor?: auth_two_factorCreateNestedManyWithoutAuth_userInput
    affiliate?: affiliateCreateNestedOneWithoutAuth_userInput
    author?: authorCreateNestedOneWithoutAuth_userInput
    customer?: customerCreateNestedOneWithoutAuth_userInput
    internal?: internalCreateNestedOneWithoutAuth_userInput
    reviews?: reviewsCreateNestedManyWithoutAuth_userInput
    reviews_likes?: reviews_likesCreateNestedManyWithoutAuth_userInput
  }

  export type auth_userUncheckedCreateWithoutPublisherInput = {
    id?: string
    name: string
    email: string
    email_verified?: boolean
    image?: string | null
    created_at?: Date | string
    updated_at?: Date | string | null
    username?: string | null
    display_username?: string | null
    two_factor_enabled?: boolean | null
    id_customer?: string | null
    id_author?: string | null
    id_affiliate?: string | null
    id_internal?: string | null
    auth_account?: auth_accountUncheckedCreateNestedManyWithoutAuth_userInput
    auth_session?: auth_sessionUncheckedCreateNestedManyWithoutAuth_userInput
    auth_two_factor?: auth_two_factorUncheckedCreateNestedManyWithoutAuth_userInput
    reviews?: reviewsUncheckedCreateNestedManyWithoutAuth_userInput
    reviews_likes?: reviews_likesUncheckedCreateNestedManyWithoutAuth_userInput
  }

  export type auth_userCreateOrConnectWithoutPublisherInput = {
    where: auth_userWhereUniqueInput
    create: XOR<auth_userCreateWithoutPublisherInput, auth_userUncheckedCreateWithoutPublisherInput>
  }

  export type auth_userCreateManyPublisherInputEnvelope = {
    data: auth_userCreateManyPublisherInput | auth_userCreateManyPublisherInput[]
    skipDuplicates?: boolean
  }

  export type promo_codeCreateWithoutPublisherInput = {
    id?: string
    code: string
    discount_type: string
    discount_value: Decimal | DecimalJsLike | number | string
    valid_from: Date | string
    valid_to: Date | string
    usage_limit: number
    used_count?: number
    status?: string
  }

  export type promo_codeUncheckedCreateWithoutPublisherInput = {
    id?: string
    code: string
    discount_type: string
    discount_value: Decimal | DecimalJsLike | number | string
    valid_from: Date | string
    valid_to: Date | string
    usage_limit: number
    used_count?: number
    status?: string
  }

  export type promo_codeCreateOrConnectWithoutPublisherInput = {
    where: promo_codeWhereUniqueInput
    create: XOR<promo_codeCreateWithoutPublisherInput, promo_codeUncheckedCreateWithoutPublisherInput>
  }

  export type promo_codeCreateManyPublisherInputEnvelope = {
    data: promo_codeCreateManyPublisherInput | promo_codeCreateManyPublisherInput[]
    skipDuplicates?: boolean
  }

  export type auth_accountCreateWithoutPublisherInput = {
    id?: string
    password?: string | null
    id_provider?: string | null
    access_token?: string | null
    refresh_token?: string | null
    id_token?: string | null
    access_token_expires_at?: Date | string | null
    refresh_token_expires_at?: Date | string | null
    scope?: string | null
    created_at?: Date | string
    updated_at?: Date | string | null
    id_account?: string | null
    affiliate?: affiliateCreateNestedManyWithoutAuth_accountInput
    auth_user?: auth_userCreateNestedOneWithoutAuth_accountInput
    author?: authorCreateNestedManyWithoutAuth_accountInput
    customer?: customerCreateNestedManyWithoutAuth_accountInput
    internal?: internalCreateNestedManyWithoutAuth_accountInput
  }

  export type auth_accountUncheckedCreateWithoutPublisherInput = {
    id?: string
    password?: string | null
    id_provider?: string | null
    access_token?: string | null
    refresh_token?: string | null
    id_token?: string | null
    access_token_expires_at?: Date | string | null
    refresh_token_expires_at?: Date | string | null
    scope?: string | null
    created_at?: Date | string
    updated_at?: Date | string | null
    id_user?: string | null
    id_account?: string | null
    affiliate?: affiliateUncheckedCreateNestedManyWithoutAuth_accountInput
    author?: authorUncheckedCreateNestedManyWithoutAuth_accountInput
    customer?: customerUncheckedCreateNestedManyWithoutAuth_accountInput
    internal?: internalUncheckedCreateNestedManyWithoutAuth_accountInput
  }

  export type auth_accountCreateOrConnectWithoutPublisherInput = {
    where: auth_accountWhereUniqueInput
    create: XOR<auth_accountCreateWithoutPublisherInput, auth_accountUncheckedCreateWithoutPublisherInput>
  }

  export type publisher_authorCreateWithoutPublisherInput = {
    id?: string
    author: authorCreateNestedOneWithoutPublisher_authorInput
  }

  export type publisher_authorUncheckedCreateWithoutPublisherInput = {
    id?: string
    author_id: string
  }

  export type publisher_authorCreateOrConnectWithoutPublisherInput = {
    where: publisher_authorWhereUniqueInput
    create: XOR<publisher_authorCreateWithoutPublisherInput, publisher_authorUncheckedCreateWithoutPublisherInput>
  }

  export type publisher_authorCreateManyPublisherInputEnvelope = {
    data: publisher_authorCreateManyPublisherInput | publisher_authorCreateManyPublisherInput[]
    skipDuplicates?: boolean
  }

  export type t_ai_creditCreateWithoutPublisherInput = {
    id?: string
    balance?: number
    last_topup_at?: Date | string | null
    t_ai_credit_topup?: t_ai_credit_topupCreateNestedManyWithoutT_ai_creditInput
  }

  export type t_ai_creditUncheckedCreateWithoutPublisherInput = {
    id?: string
    balance?: number
    last_topup_at?: Date | string | null
    t_ai_credit_topup?: t_ai_credit_topupUncheckedCreateNestedManyWithoutT_ai_creditInput
  }

  export type t_ai_creditCreateOrConnectWithoutPublisherInput = {
    where: t_ai_creditWhereUniqueInput
    create: XOR<t_ai_creditCreateWithoutPublisherInput, t_ai_creditUncheckedCreateWithoutPublisherInput>
  }

  export type t_ai_creditCreateManyPublisherInputEnvelope = {
    data: t_ai_creditCreateManyPublisherInput | t_ai_creditCreateManyPublisherInput[]
    skipDuplicates?: boolean
  }

  export type transactionCreateWithoutPublisherInput = {
    id?: string
    type: string
    amount: Decimal | DecimalJsLike | number | string
    created_at?: Date | string
    info?: JsonNullValueInput | InputJsonValue
  }

  export type transactionUncheckedCreateWithoutPublisherInput = {
    id?: string
    type: string
    amount: Decimal | DecimalJsLike | number | string
    created_at?: Date | string
    info?: JsonNullValueInput | InputJsonValue
  }

  export type transactionCreateOrConnectWithoutPublisherInput = {
    where: transactionWhereUniqueInput
    create: XOR<transactionCreateWithoutPublisherInput, transactionUncheckedCreateWithoutPublisherInput>
  }

  export type transactionCreateManyPublisherInputEnvelope = {
    data: transactionCreateManyPublisherInput | transactionCreateManyPublisherInput[]
    skipDuplicates?: boolean
  }

  export type withdrawalCreateWithoutPublisherInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    status?: string
    requested_at?: Date | string
    processed_at?: Date | string | null
  }

  export type withdrawalUncheckedCreateWithoutPublisherInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    status?: string
    requested_at?: Date | string
    processed_at?: Date | string | null
  }

  export type withdrawalCreateOrConnectWithoutPublisherInput = {
    where: withdrawalWhereUniqueInput
    create: XOR<withdrawalCreateWithoutPublisherInput, withdrawalUncheckedCreateWithoutPublisherInput>
  }

  export type withdrawalCreateManyPublisherInputEnvelope = {
    data: withdrawalCreateManyPublisherInput | withdrawalCreateManyPublisherInput[]
    skipDuplicates?: boolean
  }

  export type auth_userUpsertWithWhereUniqueWithoutPublisherInput = {
    where: auth_userWhereUniqueInput
    update: XOR<auth_userUpdateWithoutPublisherInput, auth_userUncheckedUpdateWithoutPublisherInput>
    create: XOR<auth_userCreateWithoutPublisherInput, auth_userUncheckedCreateWithoutPublisherInput>
  }

  export type auth_userUpdateWithWhereUniqueWithoutPublisherInput = {
    where: auth_userWhereUniqueInput
    data: XOR<auth_userUpdateWithoutPublisherInput, auth_userUncheckedUpdateWithoutPublisherInput>
  }

  export type auth_userUpdateManyWithWhereWithoutPublisherInput = {
    where: auth_userScalarWhereInput
    data: XOR<auth_userUpdateManyMutationInput, auth_userUncheckedUpdateManyWithoutPublisherInput>
  }

  export type promo_codeUpsertWithWhereUniqueWithoutPublisherInput = {
    where: promo_codeWhereUniqueInput
    update: XOR<promo_codeUpdateWithoutPublisherInput, promo_codeUncheckedUpdateWithoutPublisherInput>
    create: XOR<promo_codeCreateWithoutPublisherInput, promo_codeUncheckedCreateWithoutPublisherInput>
  }

  export type promo_codeUpdateWithWhereUniqueWithoutPublisherInput = {
    where: promo_codeWhereUniqueInput
    data: XOR<promo_codeUpdateWithoutPublisherInput, promo_codeUncheckedUpdateWithoutPublisherInput>
  }

  export type promo_codeUpdateManyWithWhereWithoutPublisherInput = {
    where: promo_codeScalarWhereInput
    data: XOR<promo_codeUpdateManyMutationInput, promo_codeUncheckedUpdateManyWithoutPublisherInput>
  }

  export type promo_codeScalarWhereInput = {
    AND?: promo_codeScalarWhereInput | promo_codeScalarWhereInput[]
    OR?: promo_codeScalarWhereInput[]
    NOT?: promo_codeScalarWhereInput | promo_codeScalarWhereInput[]
    id?: UuidFilter<"promo_code"> | string
    code?: StringFilter<"promo_code"> | string
    discount_type?: StringFilter<"promo_code"> | string
    discount_value?: DecimalFilter<"promo_code"> | Decimal | DecimalJsLike | number | string
    valid_from?: DateTimeFilter<"promo_code"> | Date | string
    valid_to?: DateTimeFilter<"promo_code"> | Date | string
    usage_limit?: IntFilter<"promo_code"> | number
    used_count?: IntFilter<"promo_code"> | number
    status?: StringFilter<"promo_code"> | string
    id_publisher?: UuidFilter<"promo_code"> | string
  }

  export type auth_accountUpsertWithoutPublisherInput = {
    update: XOR<auth_accountUpdateWithoutPublisherInput, auth_accountUncheckedUpdateWithoutPublisherInput>
    create: XOR<auth_accountCreateWithoutPublisherInput, auth_accountUncheckedCreateWithoutPublisherInput>
    where?: auth_accountWhereInput
  }

  export type auth_accountUpdateToOneWithWhereWithoutPublisherInput = {
    where?: auth_accountWhereInput
    data: XOR<auth_accountUpdateWithoutPublisherInput, auth_accountUncheckedUpdateWithoutPublisherInput>
  }

  export type auth_accountUpdateWithoutPublisherInput = {
    id?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    id_provider?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token_expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refresh_token_expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    id_account?: NullableStringFieldUpdateOperationsInput | string | null
    affiliate?: affiliateUpdateManyWithoutAuth_accountNestedInput
    auth_user?: auth_userUpdateOneWithoutAuth_accountNestedInput
    author?: authorUpdateManyWithoutAuth_accountNestedInput
    customer?: customerUpdateManyWithoutAuth_accountNestedInput
    internal?: internalUpdateManyWithoutAuth_accountNestedInput
  }

  export type auth_accountUncheckedUpdateWithoutPublisherInput = {
    id?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    id_provider?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token_expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refresh_token_expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    id_user?: NullableStringFieldUpdateOperationsInput | string | null
    id_account?: NullableStringFieldUpdateOperationsInput | string | null
    affiliate?: affiliateUncheckedUpdateManyWithoutAuth_accountNestedInput
    author?: authorUncheckedUpdateManyWithoutAuth_accountNestedInput
    customer?: customerUncheckedUpdateManyWithoutAuth_accountNestedInput
    internal?: internalUncheckedUpdateManyWithoutAuth_accountNestedInput
  }

  export type publisher_authorUpsertWithWhereUniqueWithoutPublisherInput = {
    where: publisher_authorWhereUniqueInput
    update: XOR<publisher_authorUpdateWithoutPublisherInput, publisher_authorUncheckedUpdateWithoutPublisherInput>
    create: XOR<publisher_authorCreateWithoutPublisherInput, publisher_authorUncheckedCreateWithoutPublisherInput>
  }

  export type publisher_authorUpdateWithWhereUniqueWithoutPublisherInput = {
    where: publisher_authorWhereUniqueInput
    data: XOR<publisher_authorUpdateWithoutPublisherInput, publisher_authorUncheckedUpdateWithoutPublisherInput>
  }

  export type publisher_authorUpdateManyWithWhereWithoutPublisherInput = {
    where: publisher_authorScalarWhereInput
    data: XOR<publisher_authorUpdateManyMutationInput, publisher_authorUncheckedUpdateManyWithoutPublisherInput>
  }

  export type t_ai_creditUpsertWithWhereUniqueWithoutPublisherInput = {
    where: t_ai_creditWhereUniqueInput
    update: XOR<t_ai_creditUpdateWithoutPublisherInput, t_ai_creditUncheckedUpdateWithoutPublisherInput>
    create: XOR<t_ai_creditCreateWithoutPublisherInput, t_ai_creditUncheckedCreateWithoutPublisherInput>
  }

  export type t_ai_creditUpdateWithWhereUniqueWithoutPublisherInput = {
    where: t_ai_creditWhereUniqueInput
    data: XOR<t_ai_creditUpdateWithoutPublisherInput, t_ai_creditUncheckedUpdateWithoutPublisherInput>
  }

  export type t_ai_creditUpdateManyWithWhereWithoutPublisherInput = {
    where: t_ai_creditScalarWhereInput
    data: XOR<t_ai_creditUpdateManyMutationInput, t_ai_creditUncheckedUpdateManyWithoutPublisherInput>
  }

  export type t_ai_creditScalarWhereInput = {
    AND?: t_ai_creditScalarWhereInput | t_ai_creditScalarWhereInput[]
    OR?: t_ai_creditScalarWhereInput[]
    NOT?: t_ai_creditScalarWhereInput | t_ai_creditScalarWhereInput[]
    id?: UuidFilter<"t_ai_credit"> | string
    id_publisher?: UuidFilter<"t_ai_credit"> | string
    balance?: IntFilter<"t_ai_credit"> | number
    last_topup_at?: DateTimeNullableFilter<"t_ai_credit"> | Date | string | null
  }

  export type transactionUpsertWithWhereUniqueWithoutPublisherInput = {
    where: transactionWhereUniqueInput
    update: XOR<transactionUpdateWithoutPublisherInput, transactionUncheckedUpdateWithoutPublisherInput>
    create: XOR<transactionCreateWithoutPublisherInput, transactionUncheckedCreateWithoutPublisherInput>
  }

  export type transactionUpdateWithWhereUniqueWithoutPublisherInput = {
    where: transactionWhereUniqueInput
    data: XOR<transactionUpdateWithoutPublisherInput, transactionUncheckedUpdateWithoutPublisherInput>
  }

  export type transactionUpdateManyWithWhereWithoutPublisherInput = {
    where: transactionScalarWhereInput
    data: XOR<transactionUpdateManyMutationInput, transactionUncheckedUpdateManyWithoutPublisherInput>
  }

  export type transactionScalarWhereInput = {
    AND?: transactionScalarWhereInput | transactionScalarWhereInput[]
    OR?: transactionScalarWhereInput[]
    NOT?: transactionScalarWhereInput | transactionScalarWhereInput[]
    id?: UuidFilter<"transaction"> | string
    id_publisher?: UuidFilter<"transaction"> | string
    type?: StringFilter<"transaction"> | string
    amount?: DecimalFilter<"transaction"> | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeFilter<"transaction"> | Date | string
    info?: JsonFilter<"transaction">
  }

  export type withdrawalUpsertWithWhereUniqueWithoutPublisherInput = {
    where: withdrawalWhereUniqueInput
    update: XOR<withdrawalUpdateWithoutPublisherInput, withdrawalUncheckedUpdateWithoutPublisherInput>
    create: XOR<withdrawalCreateWithoutPublisherInput, withdrawalUncheckedCreateWithoutPublisherInput>
  }

  export type withdrawalUpdateWithWhereUniqueWithoutPublisherInput = {
    where: withdrawalWhereUniqueInput
    data: XOR<withdrawalUpdateWithoutPublisherInput, withdrawalUncheckedUpdateWithoutPublisherInput>
  }

  export type withdrawalUpdateManyWithWhereWithoutPublisherInput = {
    where: withdrawalScalarWhereInput
    data: XOR<withdrawalUpdateManyMutationInput, withdrawalUncheckedUpdateManyWithoutPublisherInput>
  }

  export type withdrawalScalarWhereInput = {
    AND?: withdrawalScalarWhereInput | withdrawalScalarWhereInput[]
    OR?: withdrawalScalarWhereInput[]
    NOT?: withdrawalScalarWhereInput | withdrawalScalarWhereInput[]
    id?: UuidFilter<"withdrawal"> | string
    id_publisher?: UuidFilter<"withdrawal"> | string
    amount?: DecimalFilter<"withdrawal"> | Decimal | DecimalJsLike | number | string
    status?: StringFilter<"withdrawal"> | string
    requested_at?: DateTimeFilter<"withdrawal"> | Date | string
    processed_at?: DateTimeNullableFilter<"withdrawal"> | Date | string | null
  }

  export type authorCreateWithoutPublisher_authorInput = {
    id?: string
    name: string
    biography?: string | null
    social_media?: string | null
    avatar?: string | null
    auth_user?: auth_userCreateNestedManyWithoutAuthorInput
    auth_account?: auth_accountCreateNestedOneWithoutAuthorInput
    book?: bookCreateNestedManyWithoutAuthorInput
    product?: productCreateNestedManyWithoutAuthorInput
  }

  export type authorUncheckedCreateWithoutPublisher_authorInput = {
    id?: string
    name: string
    id_account?: string | null
    biography?: string | null
    social_media?: string | null
    avatar?: string | null
    auth_user?: auth_userUncheckedCreateNestedManyWithoutAuthorInput
    book?: bookUncheckedCreateNestedManyWithoutAuthorInput
    product?: productUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type authorCreateOrConnectWithoutPublisher_authorInput = {
    where: authorWhereUniqueInput
    create: XOR<authorCreateWithoutPublisher_authorInput, authorUncheckedCreateWithoutPublisher_authorInput>
  }

  export type publisherCreateWithoutPublisher_authorInput = {
    id?: string
    name: string
    description?: string | null
    website?: string | null
    address?: string | null
    logo?: string | null
    auth_user?: auth_userCreateNestedManyWithoutPublisherInput
    promo_code?: promo_codeCreateNestedManyWithoutPublisherInput
    auth_account?: auth_accountCreateNestedOneWithoutPublisherInput
    t_ai_credit?: t_ai_creditCreateNestedManyWithoutPublisherInput
    transaction?: transactionCreateNestedManyWithoutPublisherInput
    withdrawal?: withdrawalCreateNestedManyWithoutPublisherInput
  }

  export type publisherUncheckedCreateWithoutPublisher_authorInput = {
    id?: string
    id_account?: string | null
    name: string
    description?: string | null
    website?: string | null
    address?: string | null
    logo?: string | null
    auth_user?: auth_userUncheckedCreateNestedManyWithoutPublisherInput
    promo_code?: promo_codeUncheckedCreateNestedManyWithoutPublisherInput
    t_ai_credit?: t_ai_creditUncheckedCreateNestedManyWithoutPublisherInput
    transaction?: transactionUncheckedCreateNestedManyWithoutPublisherInput
    withdrawal?: withdrawalUncheckedCreateNestedManyWithoutPublisherInput
  }

  export type publisherCreateOrConnectWithoutPublisher_authorInput = {
    where: publisherWhereUniqueInput
    create: XOR<publisherCreateWithoutPublisher_authorInput, publisherUncheckedCreateWithoutPublisher_authorInput>
  }

  export type authorUpsertWithoutPublisher_authorInput = {
    update: XOR<authorUpdateWithoutPublisher_authorInput, authorUncheckedUpdateWithoutPublisher_authorInput>
    create: XOR<authorCreateWithoutPublisher_authorInput, authorUncheckedCreateWithoutPublisher_authorInput>
    where?: authorWhereInput
  }

  export type authorUpdateToOneWithWhereWithoutPublisher_authorInput = {
    where?: authorWhereInput
    data: XOR<authorUpdateWithoutPublisher_authorInput, authorUncheckedUpdateWithoutPublisher_authorInput>
  }

  export type authorUpdateWithoutPublisher_authorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    biography?: NullableStringFieldUpdateOperationsInput | string | null
    social_media?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    auth_user?: auth_userUpdateManyWithoutAuthorNestedInput
    auth_account?: auth_accountUpdateOneWithoutAuthorNestedInput
    book?: bookUpdateManyWithoutAuthorNestedInput
    product?: productUpdateManyWithoutAuthorNestedInput
  }

  export type authorUncheckedUpdateWithoutPublisher_authorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    id_account?: NullableStringFieldUpdateOperationsInput | string | null
    biography?: NullableStringFieldUpdateOperationsInput | string | null
    social_media?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    auth_user?: auth_userUncheckedUpdateManyWithoutAuthorNestedInput
    book?: bookUncheckedUpdateManyWithoutAuthorNestedInput
    product?: productUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type publisherUpsertWithoutPublisher_authorInput = {
    update: XOR<publisherUpdateWithoutPublisher_authorInput, publisherUncheckedUpdateWithoutPublisher_authorInput>
    create: XOR<publisherCreateWithoutPublisher_authorInput, publisherUncheckedCreateWithoutPublisher_authorInput>
    where?: publisherWhereInput
  }

  export type publisherUpdateToOneWithWhereWithoutPublisher_authorInput = {
    where?: publisherWhereInput
    data: XOR<publisherUpdateWithoutPublisher_authorInput, publisherUncheckedUpdateWithoutPublisher_authorInput>
  }

  export type publisherUpdateWithoutPublisher_authorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    auth_user?: auth_userUpdateManyWithoutPublisherNestedInput
    promo_code?: promo_codeUpdateManyWithoutPublisherNestedInput
    auth_account?: auth_accountUpdateOneWithoutPublisherNestedInput
    t_ai_credit?: t_ai_creditUpdateManyWithoutPublisherNestedInput
    transaction?: transactionUpdateManyWithoutPublisherNestedInput
    withdrawal?: withdrawalUpdateManyWithoutPublisherNestedInput
  }

  export type publisherUncheckedUpdateWithoutPublisher_authorInput = {
    id?: StringFieldUpdateOperationsInput | string
    id_account?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    auth_user?: auth_userUncheckedUpdateManyWithoutPublisherNestedInput
    promo_code?: promo_codeUncheckedUpdateManyWithoutPublisherNestedInput
    t_ai_credit?: t_ai_creditUncheckedUpdateManyWithoutPublisherNestedInput
    transaction?: transactionUncheckedUpdateManyWithoutPublisherNestedInput
    withdrawal?: withdrawalUncheckedUpdateManyWithoutPublisherNestedInput
  }

  export type bookCreateWithoutRankingInput = {
    id?: string
    name: string
    slug: string
    alias?: string
    submitted_price: Decimal | DecimalJsLike | number | string
    desc?: string
    info?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    currency?: string
    deleted_at?: Date | string | null
    img_file?: string
    cover?: string
    product_file?: string
    sku?: string
    published_date?: Date | string
    is_physical?: boolean
    preorder_min_qty?: number | null
    content_type?: string | null
    is_chapter?: boolean
    created_at?: Date | string
    author?: authorCreateNestedOneWithoutBookInput
    product?: productCreateNestedOneWithoutBookInput
    book_approval?: book_approvalCreateNestedManyWithoutBookInput
    book_changes_log?: book_changes_logCreateNestedManyWithoutBookInput
    book_genre?: book_genreCreateNestedManyWithoutBookInput
    book_tags?: book_tagsCreateNestedManyWithoutBookInput
    chapter?: chapterCreateNestedManyWithoutBookInput
    reviews?: reviewsCreateNestedManyWithoutBookInput
  }

  export type bookUncheckedCreateWithoutRankingInput = {
    id?: string
    name: string
    slug: string
    alias?: string
    submitted_price: Decimal | DecimalJsLike | number | string
    desc?: string
    info?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    currency?: string
    deleted_at?: Date | string | null
    img_file?: string
    cover?: string
    product_file?: string
    sku?: string
    id_author?: string | null
    published_date?: Date | string
    is_physical?: boolean
    preorder_min_qty?: number | null
    content_type?: string | null
    is_chapter?: boolean
    id_product?: string | null
    created_at?: Date | string
    book_approval?: book_approvalUncheckedCreateNestedManyWithoutBookInput
    book_changes_log?: book_changes_logUncheckedCreateNestedManyWithoutBookInput
    book_genre?: book_genreUncheckedCreateNestedManyWithoutBookInput
    book_tags?: book_tagsUncheckedCreateNestedManyWithoutBookInput
    chapter?: chapterUncheckedCreateNestedManyWithoutBookInput
    reviews?: reviewsUncheckedCreateNestedManyWithoutBookInput
  }

  export type bookCreateOrConnectWithoutRankingInput = {
    where: bookWhereUniqueInput
    create: XOR<bookCreateWithoutRankingInput, bookUncheckedCreateWithoutRankingInput>
  }

  export type bookUpsertWithoutRankingInput = {
    update: XOR<bookUpdateWithoutRankingInput, bookUncheckedUpdateWithoutRankingInput>
    create: XOR<bookCreateWithoutRankingInput, bookUncheckedCreateWithoutRankingInput>
    where?: bookWhereInput
  }

  export type bookUpdateToOneWithWhereWithoutRankingInput = {
    where?: bookWhereInput
    data: XOR<bookUpdateWithoutRankingInput, bookUncheckedUpdateWithoutRankingInput>
  }

  export type bookUpdateWithoutRankingInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    alias?: StringFieldUpdateOperationsInput | string
    submitted_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    desc?: StringFieldUpdateOperationsInput | string
    info?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    img_file?: StringFieldUpdateOperationsInput | string
    cover?: StringFieldUpdateOperationsInput | string
    product_file?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    published_date?: DateTimeFieldUpdateOperationsInput | Date | string
    is_physical?: BoolFieldUpdateOperationsInput | boolean
    preorder_min_qty?: NullableIntFieldUpdateOperationsInput | number | null
    content_type?: NullableStringFieldUpdateOperationsInput | string | null
    is_chapter?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: authorUpdateOneWithoutBookNestedInput
    product?: productUpdateOneWithoutBookNestedInput
    book_approval?: book_approvalUpdateManyWithoutBookNestedInput
    book_changes_log?: book_changes_logUpdateManyWithoutBookNestedInput
    book_genre?: book_genreUpdateManyWithoutBookNestedInput
    book_tags?: book_tagsUpdateManyWithoutBookNestedInput
    chapter?: chapterUpdateManyWithoutBookNestedInput
    reviews?: reviewsUpdateManyWithoutBookNestedInput
  }

  export type bookUncheckedUpdateWithoutRankingInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    alias?: StringFieldUpdateOperationsInput | string
    submitted_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    desc?: StringFieldUpdateOperationsInput | string
    info?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    img_file?: StringFieldUpdateOperationsInput | string
    cover?: StringFieldUpdateOperationsInput | string
    product_file?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    id_author?: NullableStringFieldUpdateOperationsInput | string | null
    published_date?: DateTimeFieldUpdateOperationsInput | Date | string
    is_physical?: BoolFieldUpdateOperationsInput | boolean
    preorder_min_qty?: NullableIntFieldUpdateOperationsInput | number | null
    content_type?: NullableStringFieldUpdateOperationsInput | string | null
    is_chapter?: BoolFieldUpdateOperationsInput | boolean
    id_product?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    book_approval?: book_approvalUncheckedUpdateManyWithoutBookNestedInput
    book_changes_log?: book_changes_logUncheckedUpdateManyWithoutBookNestedInput
    book_genre?: book_genreUncheckedUpdateManyWithoutBookNestedInput
    book_tags?: book_tagsUncheckedUpdateManyWithoutBookNestedInput
    chapter?: chapterUncheckedUpdateManyWithoutBookNestedInput
    reviews?: reviewsUncheckedUpdateManyWithoutBookNestedInput
  }

  export type bookCreateWithoutReviewsInput = {
    id?: string
    name: string
    slug: string
    alias?: string
    submitted_price: Decimal | DecimalJsLike | number | string
    desc?: string
    info?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    currency?: string
    deleted_at?: Date | string | null
    img_file?: string
    cover?: string
    product_file?: string
    sku?: string
    published_date?: Date | string
    is_physical?: boolean
    preorder_min_qty?: number | null
    content_type?: string | null
    is_chapter?: boolean
    created_at?: Date | string
    author?: authorCreateNestedOneWithoutBookInput
    product?: productCreateNestedOneWithoutBookInput
    book_approval?: book_approvalCreateNestedManyWithoutBookInput
    book_changes_log?: book_changes_logCreateNestedManyWithoutBookInput
    book_genre?: book_genreCreateNestedManyWithoutBookInput
    book_tags?: book_tagsCreateNestedManyWithoutBookInput
    chapter?: chapterCreateNestedManyWithoutBookInput
    ranking?: rankingCreateNestedManyWithoutBookInput
  }

  export type bookUncheckedCreateWithoutReviewsInput = {
    id?: string
    name: string
    slug: string
    alias?: string
    submitted_price: Decimal | DecimalJsLike | number | string
    desc?: string
    info?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    currency?: string
    deleted_at?: Date | string | null
    img_file?: string
    cover?: string
    product_file?: string
    sku?: string
    id_author?: string | null
    published_date?: Date | string
    is_physical?: boolean
    preorder_min_qty?: number | null
    content_type?: string | null
    is_chapter?: boolean
    id_product?: string | null
    created_at?: Date | string
    book_approval?: book_approvalUncheckedCreateNestedManyWithoutBookInput
    book_changes_log?: book_changes_logUncheckedCreateNestedManyWithoutBookInput
    book_genre?: book_genreUncheckedCreateNestedManyWithoutBookInput
    book_tags?: book_tagsUncheckedCreateNestedManyWithoutBookInput
    chapter?: chapterUncheckedCreateNestedManyWithoutBookInput
    ranking?: rankingUncheckedCreateNestedManyWithoutBookInput
  }

  export type bookCreateOrConnectWithoutReviewsInput = {
    where: bookWhereUniqueInput
    create: XOR<bookCreateWithoutReviewsInput, bookUncheckedCreateWithoutReviewsInput>
  }

  export type auth_userCreateWithoutReviewsInput = {
    id?: string
    name: string
    email: string
    email_verified?: boolean
    image?: string | null
    created_at?: Date | string
    updated_at?: Date | string | null
    username?: string | null
    display_username?: string | null
    two_factor_enabled?: boolean | null
    auth_account?: auth_accountCreateNestedManyWithoutAuth_userInput
    auth_session?: auth_sessionCreateNestedManyWithoutAuth_userInput
    auth_two_factor?: auth_two_factorCreateNestedManyWithoutAuth_userInput
    affiliate?: affiliateCreateNestedOneWithoutAuth_userInput
    author?: authorCreateNestedOneWithoutAuth_userInput
    customer?: customerCreateNestedOneWithoutAuth_userInput
    internal?: internalCreateNestedOneWithoutAuth_userInput
    publisher?: publisherCreateNestedOneWithoutAuth_userInput
    reviews_likes?: reviews_likesCreateNestedManyWithoutAuth_userInput
  }

  export type auth_userUncheckedCreateWithoutReviewsInput = {
    id?: string
    name: string
    email: string
    email_verified?: boolean
    image?: string | null
    created_at?: Date | string
    updated_at?: Date | string | null
    username?: string | null
    display_username?: string | null
    two_factor_enabled?: boolean | null
    id_customer?: string | null
    id_author?: string | null
    id_affiliate?: string | null
    id_publisher?: string | null
    id_internal?: string | null
    auth_account?: auth_accountUncheckedCreateNestedManyWithoutAuth_userInput
    auth_session?: auth_sessionUncheckedCreateNestedManyWithoutAuth_userInput
    auth_two_factor?: auth_two_factorUncheckedCreateNestedManyWithoutAuth_userInput
    reviews_likes?: reviews_likesUncheckedCreateNestedManyWithoutAuth_userInput
  }

  export type auth_userCreateOrConnectWithoutReviewsInput = {
    where: auth_userWhereUniqueInput
    create: XOR<auth_userCreateWithoutReviewsInput, auth_userUncheckedCreateWithoutReviewsInput>
  }

  export type reviews_likesCreateWithoutReviewsInput = {
    id?: string
    auth_user: auth_userCreateNestedOneWithoutReviews_likesInput
  }

  export type reviews_likesUncheckedCreateWithoutReviewsInput = {
    id?: string
    id_user: string
  }

  export type reviews_likesCreateOrConnectWithoutReviewsInput = {
    where: reviews_likesWhereUniqueInput
    create: XOR<reviews_likesCreateWithoutReviewsInput, reviews_likesUncheckedCreateWithoutReviewsInput>
  }

  export type reviews_likesCreateManyReviewsInputEnvelope = {
    data: reviews_likesCreateManyReviewsInput | reviews_likesCreateManyReviewsInput[]
    skipDuplicates?: boolean
  }

  export type bookUpsertWithoutReviewsInput = {
    update: XOR<bookUpdateWithoutReviewsInput, bookUncheckedUpdateWithoutReviewsInput>
    create: XOR<bookCreateWithoutReviewsInput, bookUncheckedCreateWithoutReviewsInput>
    where?: bookWhereInput
  }

  export type bookUpdateToOneWithWhereWithoutReviewsInput = {
    where?: bookWhereInput
    data: XOR<bookUpdateWithoutReviewsInput, bookUncheckedUpdateWithoutReviewsInput>
  }

  export type bookUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    alias?: StringFieldUpdateOperationsInput | string
    submitted_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    desc?: StringFieldUpdateOperationsInput | string
    info?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    img_file?: StringFieldUpdateOperationsInput | string
    cover?: StringFieldUpdateOperationsInput | string
    product_file?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    published_date?: DateTimeFieldUpdateOperationsInput | Date | string
    is_physical?: BoolFieldUpdateOperationsInput | boolean
    preorder_min_qty?: NullableIntFieldUpdateOperationsInput | number | null
    content_type?: NullableStringFieldUpdateOperationsInput | string | null
    is_chapter?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: authorUpdateOneWithoutBookNestedInput
    product?: productUpdateOneWithoutBookNestedInput
    book_approval?: book_approvalUpdateManyWithoutBookNestedInput
    book_changes_log?: book_changes_logUpdateManyWithoutBookNestedInput
    book_genre?: book_genreUpdateManyWithoutBookNestedInput
    book_tags?: book_tagsUpdateManyWithoutBookNestedInput
    chapter?: chapterUpdateManyWithoutBookNestedInput
    ranking?: rankingUpdateManyWithoutBookNestedInput
  }

  export type bookUncheckedUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    alias?: StringFieldUpdateOperationsInput | string
    submitted_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    desc?: StringFieldUpdateOperationsInput | string
    info?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    img_file?: StringFieldUpdateOperationsInput | string
    cover?: StringFieldUpdateOperationsInput | string
    product_file?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    id_author?: NullableStringFieldUpdateOperationsInput | string | null
    published_date?: DateTimeFieldUpdateOperationsInput | Date | string
    is_physical?: BoolFieldUpdateOperationsInput | boolean
    preorder_min_qty?: NullableIntFieldUpdateOperationsInput | number | null
    content_type?: NullableStringFieldUpdateOperationsInput | string | null
    is_chapter?: BoolFieldUpdateOperationsInput | boolean
    id_product?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    book_approval?: book_approvalUncheckedUpdateManyWithoutBookNestedInput
    book_changes_log?: book_changes_logUncheckedUpdateManyWithoutBookNestedInput
    book_genre?: book_genreUncheckedUpdateManyWithoutBookNestedInput
    book_tags?: book_tagsUncheckedUpdateManyWithoutBookNestedInput
    chapter?: chapterUncheckedUpdateManyWithoutBookNestedInput
    ranking?: rankingUncheckedUpdateManyWithoutBookNestedInput
  }

  export type auth_userUpsertWithoutReviewsInput = {
    update: XOR<auth_userUpdateWithoutReviewsInput, auth_userUncheckedUpdateWithoutReviewsInput>
    create: XOR<auth_userCreateWithoutReviewsInput, auth_userUncheckedCreateWithoutReviewsInput>
    where?: auth_userWhereInput
  }

  export type auth_userUpdateToOneWithWhereWithoutReviewsInput = {
    where?: auth_userWhereInput
    data: XOR<auth_userUpdateWithoutReviewsInput, auth_userUncheckedUpdateWithoutReviewsInput>
  }

  export type auth_userUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    email_verified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    display_username?: NullableStringFieldUpdateOperationsInput | string | null
    two_factor_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    auth_account?: auth_accountUpdateManyWithoutAuth_userNestedInput
    auth_session?: auth_sessionUpdateManyWithoutAuth_userNestedInput
    auth_two_factor?: auth_two_factorUpdateManyWithoutAuth_userNestedInput
    affiliate?: affiliateUpdateOneWithoutAuth_userNestedInput
    author?: authorUpdateOneWithoutAuth_userNestedInput
    customer?: customerUpdateOneWithoutAuth_userNestedInput
    internal?: internalUpdateOneWithoutAuth_userNestedInput
    publisher?: publisherUpdateOneWithoutAuth_userNestedInput
    reviews_likes?: reviews_likesUpdateManyWithoutAuth_userNestedInput
  }

  export type auth_userUncheckedUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    email_verified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    display_username?: NullableStringFieldUpdateOperationsInput | string | null
    two_factor_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    id_customer?: NullableStringFieldUpdateOperationsInput | string | null
    id_author?: NullableStringFieldUpdateOperationsInput | string | null
    id_affiliate?: NullableStringFieldUpdateOperationsInput | string | null
    id_publisher?: NullableStringFieldUpdateOperationsInput | string | null
    id_internal?: NullableStringFieldUpdateOperationsInput | string | null
    auth_account?: auth_accountUncheckedUpdateManyWithoutAuth_userNestedInput
    auth_session?: auth_sessionUncheckedUpdateManyWithoutAuth_userNestedInput
    auth_two_factor?: auth_two_factorUncheckedUpdateManyWithoutAuth_userNestedInput
    reviews_likes?: reviews_likesUncheckedUpdateManyWithoutAuth_userNestedInput
  }

  export type reviews_likesUpsertWithWhereUniqueWithoutReviewsInput = {
    where: reviews_likesWhereUniqueInput
    update: XOR<reviews_likesUpdateWithoutReviewsInput, reviews_likesUncheckedUpdateWithoutReviewsInput>
    create: XOR<reviews_likesCreateWithoutReviewsInput, reviews_likesUncheckedCreateWithoutReviewsInput>
  }

  export type reviews_likesUpdateWithWhereUniqueWithoutReviewsInput = {
    where: reviews_likesWhereUniqueInput
    data: XOR<reviews_likesUpdateWithoutReviewsInput, reviews_likesUncheckedUpdateWithoutReviewsInput>
  }

  export type reviews_likesUpdateManyWithWhereWithoutReviewsInput = {
    where: reviews_likesScalarWhereInput
    data: XOR<reviews_likesUpdateManyMutationInput, reviews_likesUncheckedUpdateManyWithoutReviewsInput>
  }

  export type reviewsCreateWithoutReviews_likesInput = {
    id?: string
    comments: string
    rating?: Decimal | DecimalJsLike | number | string | null
    created_at: Date | string
    deleted_at?: Date | string | null
    parent?: string | null
    book: bookCreateNestedOneWithoutReviewsInput
    auth_user: auth_userCreateNestedOneWithoutReviewsInput
  }

  export type reviewsUncheckedCreateWithoutReviews_likesInput = {
    id?: string
    id_book: string
    comments: string
    rating?: Decimal | DecimalJsLike | number | string | null
    created_at: Date | string
    deleted_at?: Date | string | null
    parent?: string | null
    id_user: string
  }

  export type reviewsCreateOrConnectWithoutReviews_likesInput = {
    where: reviewsWhereUniqueInput
    create: XOR<reviewsCreateWithoutReviews_likesInput, reviewsUncheckedCreateWithoutReviews_likesInput>
  }

  export type auth_userCreateWithoutReviews_likesInput = {
    id?: string
    name: string
    email: string
    email_verified?: boolean
    image?: string | null
    created_at?: Date | string
    updated_at?: Date | string | null
    username?: string | null
    display_username?: string | null
    two_factor_enabled?: boolean | null
    auth_account?: auth_accountCreateNestedManyWithoutAuth_userInput
    auth_session?: auth_sessionCreateNestedManyWithoutAuth_userInput
    auth_two_factor?: auth_two_factorCreateNestedManyWithoutAuth_userInput
    affiliate?: affiliateCreateNestedOneWithoutAuth_userInput
    author?: authorCreateNestedOneWithoutAuth_userInput
    customer?: customerCreateNestedOneWithoutAuth_userInput
    internal?: internalCreateNestedOneWithoutAuth_userInput
    publisher?: publisherCreateNestedOneWithoutAuth_userInput
    reviews?: reviewsCreateNestedManyWithoutAuth_userInput
  }

  export type auth_userUncheckedCreateWithoutReviews_likesInput = {
    id?: string
    name: string
    email: string
    email_verified?: boolean
    image?: string | null
    created_at?: Date | string
    updated_at?: Date | string | null
    username?: string | null
    display_username?: string | null
    two_factor_enabled?: boolean | null
    id_customer?: string | null
    id_author?: string | null
    id_affiliate?: string | null
    id_publisher?: string | null
    id_internal?: string | null
    auth_account?: auth_accountUncheckedCreateNestedManyWithoutAuth_userInput
    auth_session?: auth_sessionUncheckedCreateNestedManyWithoutAuth_userInput
    auth_two_factor?: auth_two_factorUncheckedCreateNestedManyWithoutAuth_userInput
    reviews?: reviewsUncheckedCreateNestedManyWithoutAuth_userInput
  }

  export type auth_userCreateOrConnectWithoutReviews_likesInput = {
    where: auth_userWhereUniqueInput
    create: XOR<auth_userCreateWithoutReviews_likesInput, auth_userUncheckedCreateWithoutReviews_likesInput>
  }

  export type reviewsUpsertWithoutReviews_likesInput = {
    update: XOR<reviewsUpdateWithoutReviews_likesInput, reviewsUncheckedUpdateWithoutReviews_likesInput>
    create: XOR<reviewsCreateWithoutReviews_likesInput, reviewsUncheckedCreateWithoutReviews_likesInput>
    where?: reviewsWhereInput
  }

  export type reviewsUpdateToOneWithWhereWithoutReviews_likesInput = {
    where?: reviewsWhereInput
    data: XOR<reviewsUpdateWithoutReviews_likesInput, reviewsUncheckedUpdateWithoutReviews_likesInput>
  }

  export type reviewsUpdateWithoutReviews_likesInput = {
    id?: StringFieldUpdateOperationsInput | string
    comments?: StringFieldUpdateOperationsInput | string
    rating?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parent?: NullableStringFieldUpdateOperationsInput | string | null
    book?: bookUpdateOneRequiredWithoutReviewsNestedInput
    auth_user?: auth_userUpdateOneRequiredWithoutReviewsNestedInput
  }

  export type reviewsUncheckedUpdateWithoutReviews_likesInput = {
    id?: StringFieldUpdateOperationsInput | string
    id_book?: StringFieldUpdateOperationsInput | string
    comments?: StringFieldUpdateOperationsInput | string
    rating?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parent?: NullableStringFieldUpdateOperationsInput | string | null
    id_user?: StringFieldUpdateOperationsInput | string
  }

  export type auth_userUpsertWithoutReviews_likesInput = {
    update: XOR<auth_userUpdateWithoutReviews_likesInput, auth_userUncheckedUpdateWithoutReviews_likesInput>
    create: XOR<auth_userCreateWithoutReviews_likesInput, auth_userUncheckedCreateWithoutReviews_likesInput>
    where?: auth_userWhereInput
  }

  export type auth_userUpdateToOneWithWhereWithoutReviews_likesInput = {
    where?: auth_userWhereInput
    data: XOR<auth_userUpdateWithoutReviews_likesInput, auth_userUncheckedUpdateWithoutReviews_likesInput>
  }

  export type auth_userUpdateWithoutReviews_likesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    email_verified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    display_username?: NullableStringFieldUpdateOperationsInput | string | null
    two_factor_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    auth_account?: auth_accountUpdateManyWithoutAuth_userNestedInput
    auth_session?: auth_sessionUpdateManyWithoutAuth_userNestedInput
    auth_two_factor?: auth_two_factorUpdateManyWithoutAuth_userNestedInput
    affiliate?: affiliateUpdateOneWithoutAuth_userNestedInput
    author?: authorUpdateOneWithoutAuth_userNestedInput
    customer?: customerUpdateOneWithoutAuth_userNestedInput
    internal?: internalUpdateOneWithoutAuth_userNestedInput
    publisher?: publisherUpdateOneWithoutAuth_userNestedInput
    reviews?: reviewsUpdateManyWithoutAuth_userNestedInput
  }

  export type auth_userUncheckedUpdateWithoutReviews_likesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    email_verified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    display_username?: NullableStringFieldUpdateOperationsInput | string | null
    two_factor_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    id_customer?: NullableStringFieldUpdateOperationsInput | string | null
    id_author?: NullableStringFieldUpdateOperationsInput | string | null
    id_affiliate?: NullableStringFieldUpdateOperationsInput | string | null
    id_publisher?: NullableStringFieldUpdateOperationsInput | string | null
    id_internal?: NullableStringFieldUpdateOperationsInput | string | null
    auth_account?: auth_accountUncheckedUpdateManyWithoutAuth_userNestedInput
    auth_session?: auth_sessionUncheckedUpdateManyWithoutAuth_userNestedInput
    auth_two_factor?: auth_two_factorUncheckedUpdateManyWithoutAuth_userNestedInput
    reviews?: reviewsUncheckedUpdateManyWithoutAuth_userNestedInput
  }

  export type publisherCreateWithoutT_ai_creditInput = {
    id?: string
    name: string
    description?: string | null
    website?: string | null
    address?: string | null
    logo?: string | null
    auth_user?: auth_userCreateNestedManyWithoutPublisherInput
    promo_code?: promo_codeCreateNestedManyWithoutPublisherInput
    auth_account?: auth_accountCreateNestedOneWithoutPublisherInput
    publisher_author?: publisher_authorCreateNestedManyWithoutPublisherInput
    transaction?: transactionCreateNestedManyWithoutPublisherInput
    withdrawal?: withdrawalCreateNestedManyWithoutPublisherInput
  }

  export type publisherUncheckedCreateWithoutT_ai_creditInput = {
    id?: string
    id_account?: string | null
    name: string
    description?: string | null
    website?: string | null
    address?: string | null
    logo?: string | null
    auth_user?: auth_userUncheckedCreateNestedManyWithoutPublisherInput
    promo_code?: promo_codeUncheckedCreateNestedManyWithoutPublisherInput
    publisher_author?: publisher_authorUncheckedCreateNestedManyWithoutPublisherInput
    transaction?: transactionUncheckedCreateNestedManyWithoutPublisherInput
    withdrawal?: withdrawalUncheckedCreateNestedManyWithoutPublisherInput
  }

  export type publisherCreateOrConnectWithoutT_ai_creditInput = {
    where: publisherWhereUniqueInput
    create: XOR<publisherCreateWithoutT_ai_creditInput, publisherUncheckedCreateWithoutT_ai_creditInput>
  }

  export type t_ai_credit_topupCreateWithoutT_ai_creditInput = {
    id?: string
    amount: number
    created_at?: Date | string
    status?: string
  }

  export type t_ai_credit_topupUncheckedCreateWithoutT_ai_creditInput = {
    id?: string
    amount: number
    created_at?: Date | string
    status?: string
  }

  export type t_ai_credit_topupCreateOrConnectWithoutT_ai_creditInput = {
    where: t_ai_credit_topupWhereUniqueInput
    create: XOR<t_ai_credit_topupCreateWithoutT_ai_creditInput, t_ai_credit_topupUncheckedCreateWithoutT_ai_creditInput>
  }

  export type t_ai_credit_topupCreateManyT_ai_creditInputEnvelope = {
    data: t_ai_credit_topupCreateManyT_ai_creditInput | t_ai_credit_topupCreateManyT_ai_creditInput[]
    skipDuplicates?: boolean
  }

  export type publisherUpsertWithoutT_ai_creditInput = {
    update: XOR<publisherUpdateWithoutT_ai_creditInput, publisherUncheckedUpdateWithoutT_ai_creditInput>
    create: XOR<publisherCreateWithoutT_ai_creditInput, publisherUncheckedCreateWithoutT_ai_creditInput>
    where?: publisherWhereInput
  }

  export type publisherUpdateToOneWithWhereWithoutT_ai_creditInput = {
    where?: publisherWhereInput
    data: XOR<publisherUpdateWithoutT_ai_creditInput, publisherUncheckedUpdateWithoutT_ai_creditInput>
  }

  export type publisherUpdateWithoutT_ai_creditInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    auth_user?: auth_userUpdateManyWithoutPublisherNestedInput
    promo_code?: promo_codeUpdateManyWithoutPublisherNestedInput
    auth_account?: auth_accountUpdateOneWithoutPublisherNestedInput
    publisher_author?: publisher_authorUpdateManyWithoutPublisherNestedInput
    transaction?: transactionUpdateManyWithoutPublisherNestedInput
    withdrawal?: withdrawalUpdateManyWithoutPublisherNestedInput
  }

  export type publisherUncheckedUpdateWithoutT_ai_creditInput = {
    id?: StringFieldUpdateOperationsInput | string
    id_account?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    auth_user?: auth_userUncheckedUpdateManyWithoutPublisherNestedInput
    promo_code?: promo_codeUncheckedUpdateManyWithoutPublisherNestedInput
    publisher_author?: publisher_authorUncheckedUpdateManyWithoutPublisherNestedInput
    transaction?: transactionUncheckedUpdateManyWithoutPublisherNestedInput
    withdrawal?: withdrawalUncheckedUpdateManyWithoutPublisherNestedInput
  }

  export type t_ai_credit_topupUpsertWithWhereUniqueWithoutT_ai_creditInput = {
    where: t_ai_credit_topupWhereUniqueInput
    update: XOR<t_ai_credit_topupUpdateWithoutT_ai_creditInput, t_ai_credit_topupUncheckedUpdateWithoutT_ai_creditInput>
    create: XOR<t_ai_credit_topupCreateWithoutT_ai_creditInput, t_ai_credit_topupUncheckedCreateWithoutT_ai_creditInput>
  }

  export type t_ai_credit_topupUpdateWithWhereUniqueWithoutT_ai_creditInput = {
    where: t_ai_credit_topupWhereUniqueInput
    data: XOR<t_ai_credit_topupUpdateWithoutT_ai_creditInput, t_ai_credit_topupUncheckedUpdateWithoutT_ai_creditInput>
  }

  export type t_ai_credit_topupUpdateManyWithWhereWithoutT_ai_creditInput = {
    where: t_ai_credit_topupScalarWhereInput
    data: XOR<t_ai_credit_topupUpdateManyMutationInput, t_ai_credit_topupUncheckedUpdateManyWithoutT_ai_creditInput>
  }

  export type t_ai_credit_topupScalarWhereInput = {
    AND?: t_ai_credit_topupScalarWhereInput | t_ai_credit_topupScalarWhereInput[]
    OR?: t_ai_credit_topupScalarWhereInput[]
    NOT?: t_ai_credit_topupScalarWhereInput | t_ai_credit_topupScalarWhereInput[]
    id?: UuidFilter<"t_ai_credit_topup"> | string
    id_t_ai_credit?: UuidFilter<"t_ai_credit_topup"> | string
    amount?: IntFilter<"t_ai_credit_topup"> | number
    created_at?: DateTimeFilter<"t_ai_credit_topup"> | Date | string
    status?: StringFilter<"t_ai_credit_topup"> | string
  }

  export type t_ai_creditCreateWithoutT_ai_credit_topupInput = {
    id?: string
    balance?: number
    last_topup_at?: Date | string | null
    publisher: publisherCreateNestedOneWithoutT_ai_creditInput
  }

  export type t_ai_creditUncheckedCreateWithoutT_ai_credit_topupInput = {
    id?: string
    id_publisher: string
    balance?: number
    last_topup_at?: Date | string | null
  }

  export type t_ai_creditCreateOrConnectWithoutT_ai_credit_topupInput = {
    where: t_ai_creditWhereUniqueInput
    create: XOR<t_ai_creditCreateWithoutT_ai_credit_topupInput, t_ai_creditUncheckedCreateWithoutT_ai_credit_topupInput>
  }

  export type t_ai_creditUpsertWithoutT_ai_credit_topupInput = {
    update: XOR<t_ai_creditUpdateWithoutT_ai_credit_topupInput, t_ai_creditUncheckedUpdateWithoutT_ai_credit_topupInput>
    create: XOR<t_ai_creditCreateWithoutT_ai_credit_topupInput, t_ai_creditUncheckedCreateWithoutT_ai_credit_topupInput>
    where?: t_ai_creditWhereInput
  }

  export type t_ai_creditUpdateToOneWithWhereWithoutT_ai_credit_topupInput = {
    where?: t_ai_creditWhereInput
    data: XOR<t_ai_creditUpdateWithoutT_ai_credit_topupInput, t_ai_creditUncheckedUpdateWithoutT_ai_credit_topupInput>
  }

  export type t_ai_creditUpdateWithoutT_ai_credit_topupInput = {
    id?: StringFieldUpdateOperationsInput | string
    balance?: IntFieldUpdateOperationsInput | number
    last_topup_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    publisher?: publisherUpdateOneRequiredWithoutT_ai_creditNestedInput
  }

  export type t_ai_creditUncheckedUpdateWithoutT_ai_credit_topupInput = {
    id?: StringFieldUpdateOperationsInput | string
    id_publisher?: StringFieldUpdateOperationsInput | string
    balance?: IntFieldUpdateOperationsInput | number
    last_topup_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type customerCreateWithoutT_salesInput = {
    id?: string
    whatsapp: string
    deleted_at?: Date | string | null
    otp?: number | null
    name: string
    email: string
    auth_user?: auth_userCreateNestedManyWithoutCustomerInput
    auth_account?: auth_accountCreateNestedOneWithoutCustomerInput
    customer_reader?: customer_readerCreateNestedManyWithoutCustomerInput
    customer_track?: customer_trackCreateNestedManyWithoutCustomerInput
    t_sales_download?: t_sales_downloadCreateNestedManyWithoutCustomerInput
  }

  export type customerUncheckedCreateWithoutT_salesInput = {
    id?: string
    whatsapp: string
    deleted_at?: Date | string | null
    otp?: number | null
    id_account?: string | null
    name: string
    email: string
    auth_user?: auth_userUncheckedCreateNestedManyWithoutCustomerInput
    customer_reader?: customer_readerUncheckedCreateNestedManyWithoutCustomerInput
    customer_track?: customer_trackUncheckedCreateNestedManyWithoutCustomerInput
    t_sales_download?: t_sales_downloadUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type customerCreateOrConnectWithoutT_salesInput = {
    where: customerWhereUniqueInput
    create: XOR<customerCreateWithoutT_salesInput, customerUncheckedCreateWithoutT_salesInput>
  }

  export type t_sales_lineCreateWithoutT_salesInput = {
    id?: string
    unit_price: Decimal | DecimalJsLike | number | string
    qty: number
    total_price: Decimal | DecimalJsLike | number | string
    bundle?: bundleCreateNestedOneWithoutT_sales_lineInput
    product?: productCreateNestedOneWithoutT_sales_lineInput
  }

  export type t_sales_lineUncheckedCreateWithoutT_salesInput = {
    id?: string
    unit_price: Decimal | DecimalJsLike | number | string
    qty: number
    total_price: Decimal | DecimalJsLike | number | string
    id_product?: string | null
    id_bundle?: string | null
  }

  export type t_sales_lineCreateOrConnectWithoutT_salesInput = {
    where: t_sales_lineWhereUniqueInput
    create: XOR<t_sales_lineCreateWithoutT_salesInput, t_sales_lineUncheckedCreateWithoutT_salesInput>
  }

  export type t_sales_lineCreateManyT_salesInputEnvelope = {
    data: t_sales_lineCreateManyT_salesInput | t_sales_lineCreateManyT_salesInput[]
    skipDuplicates?: boolean
  }

  export type customerUpsertWithoutT_salesInput = {
    update: XOR<customerUpdateWithoutT_salesInput, customerUncheckedUpdateWithoutT_salesInput>
    create: XOR<customerCreateWithoutT_salesInput, customerUncheckedCreateWithoutT_salesInput>
    where?: customerWhereInput
  }

  export type customerUpdateToOneWithWhereWithoutT_salesInput = {
    where?: customerWhereInput
    data: XOR<customerUpdateWithoutT_salesInput, customerUncheckedUpdateWithoutT_salesInput>
  }

  export type customerUpdateWithoutT_salesInput = {
    id?: StringFieldUpdateOperationsInput | string
    whatsapp?: StringFieldUpdateOperationsInput | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otp?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    auth_user?: auth_userUpdateManyWithoutCustomerNestedInput
    auth_account?: auth_accountUpdateOneWithoutCustomerNestedInput
    customer_reader?: customer_readerUpdateManyWithoutCustomerNestedInput
    customer_track?: customer_trackUpdateManyWithoutCustomerNestedInput
    t_sales_download?: t_sales_downloadUpdateManyWithoutCustomerNestedInput
  }

  export type customerUncheckedUpdateWithoutT_salesInput = {
    id?: StringFieldUpdateOperationsInput | string
    whatsapp?: StringFieldUpdateOperationsInput | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otp?: NullableIntFieldUpdateOperationsInput | number | null
    id_account?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    auth_user?: auth_userUncheckedUpdateManyWithoutCustomerNestedInput
    customer_reader?: customer_readerUncheckedUpdateManyWithoutCustomerNestedInput
    customer_track?: customer_trackUncheckedUpdateManyWithoutCustomerNestedInput
    t_sales_download?: t_sales_downloadUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type t_sales_lineUpsertWithWhereUniqueWithoutT_salesInput = {
    where: t_sales_lineWhereUniqueInput
    update: XOR<t_sales_lineUpdateWithoutT_salesInput, t_sales_lineUncheckedUpdateWithoutT_salesInput>
    create: XOR<t_sales_lineCreateWithoutT_salesInput, t_sales_lineUncheckedCreateWithoutT_salesInput>
  }

  export type t_sales_lineUpdateWithWhereUniqueWithoutT_salesInput = {
    where: t_sales_lineWhereUniqueInput
    data: XOR<t_sales_lineUpdateWithoutT_salesInput, t_sales_lineUncheckedUpdateWithoutT_salesInput>
  }

  export type t_sales_lineUpdateManyWithWhereWithoutT_salesInput = {
    where: t_sales_lineScalarWhereInput
    data: XOR<t_sales_lineUpdateManyMutationInput, t_sales_lineUncheckedUpdateManyWithoutT_salesInput>
  }

  export type customerCreateWithoutT_sales_downloadInput = {
    id?: string
    whatsapp: string
    deleted_at?: Date | string | null
    otp?: number | null
    name: string
    email: string
    auth_user?: auth_userCreateNestedManyWithoutCustomerInput
    auth_account?: auth_accountCreateNestedOneWithoutCustomerInput
    customer_reader?: customer_readerCreateNestedManyWithoutCustomerInput
    customer_track?: customer_trackCreateNestedManyWithoutCustomerInput
    t_sales?: t_salesCreateNestedManyWithoutCustomerInput
  }

  export type customerUncheckedCreateWithoutT_sales_downloadInput = {
    id?: string
    whatsapp: string
    deleted_at?: Date | string | null
    otp?: number | null
    id_account?: string | null
    name: string
    email: string
    auth_user?: auth_userUncheckedCreateNestedManyWithoutCustomerInput
    customer_reader?: customer_readerUncheckedCreateNestedManyWithoutCustomerInput
    customer_track?: customer_trackUncheckedCreateNestedManyWithoutCustomerInput
    t_sales?: t_salesUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type customerCreateOrConnectWithoutT_sales_downloadInput = {
    where: customerWhereUniqueInput
    create: XOR<customerCreateWithoutT_sales_downloadInput, customerUncheckedCreateWithoutT_sales_downloadInput>
  }

  export type productCreateWithoutT_sales_downloadInput = {
    id?: string
    name: string
    slug: string
    alias?: string
    strike_price?: Decimal | DecimalJsLike | number | string | null
    real_price: Decimal | DecimalJsLike | number | string
    desc?: string
    info?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    currency?: string
    deleted_at?: Date | string | null
    img_file?: string
    cover?: string
    product_file?: string
    sku?: string
    published_date?: Date | string
    is_physical?: boolean
    preorder_min_qty?: number | null
    content_type?: string | null
    is_chapter?: boolean
    book?: bookCreateNestedManyWithoutProductInput
    bundle_product?: bundle_productCreateNestedManyWithoutProductInput
    chapter?: chapterCreateNestedManyWithoutProductInput
    customer_reader?: customer_readerCreateNestedManyWithoutProductInput
    preorder?: preorderCreateNestedManyWithoutProductInput
    author?: authorCreateNestedOneWithoutProductInput
    product_category?: product_categoryCreateNestedManyWithoutProductInput
    t_sales_line?: t_sales_lineCreateNestedManyWithoutProductInput
  }

  export type productUncheckedCreateWithoutT_sales_downloadInput = {
    id?: string
    name: string
    slug: string
    alias?: string
    strike_price?: Decimal | DecimalJsLike | number | string | null
    real_price: Decimal | DecimalJsLike | number | string
    desc?: string
    info?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    currency?: string
    deleted_at?: Date | string | null
    img_file?: string
    cover?: string
    product_file?: string
    sku?: string
    id_author?: string | null
    published_date?: Date | string
    is_physical?: boolean
    preorder_min_qty?: number | null
    content_type?: string | null
    is_chapter?: boolean
    book?: bookUncheckedCreateNestedManyWithoutProductInput
    bundle_product?: bundle_productUncheckedCreateNestedManyWithoutProductInput
    chapter?: chapterUncheckedCreateNestedManyWithoutProductInput
    customer_reader?: customer_readerUncheckedCreateNestedManyWithoutProductInput
    preorder?: preorderUncheckedCreateNestedManyWithoutProductInput
    product_category?: product_categoryUncheckedCreateNestedManyWithoutProductInput
    t_sales_line?: t_sales_lineUncheckedCreateNestedManyWithoutProductInput
  }

  export type productCreateOrConnectWithoutT_sales_downloadInput = {
    where: productWhereUniqueInput
    create: XOR<productCreateWithoutT_sales_downloadInput, productUncheckedCreateWithoutT_sales_downloadInput>
  }

  export type customerUpsertWithoutT_sales_downloadInput = {
    update: XOR<customerUpdateWithoutT_sales_downloadInput, customerUncheckedUpdateWithoutT_sales_downloadInput>
    create: XOR<customerCreateWithoutT_sales_downloadInput, customerUncheckedCreateWithoutT_sales_downloadInput>
    where?: customerWhereInput
  }

  export type customerUpdateToOneWithWhereWithoutT_sales_downloadInput = {
    where?: customerWhereInput
    data: XOR<customerUpdateWithoutT_sales_downloadInput, customerUncheckedUpdateWithoutT_sales_downloadInput>
  }

  export type customerUpdateWithoutT_sales_downloadInput = {
    id?: StringFieldUpdateOperationsInput | string
    whatsapp?: StringFieldUpdateOperationsInput | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otp?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    auth_user?: auth_userUpdateManyWithoutCustomerNestedInput
    auth_account?: auth_accountUpdateOneWithoutCustomerNestedInput
    customer_reader?: customer_readerUpdateManyWithoutCustomerNestedInput
    customer_track?: customer_trackUpdateManyWithoutCustomerNestedInput
    t_sales?: t_salesUpdateManyWithoutCustomerNestedInput
  }

  export type customerUncheckedUpdateWithoutT_sales_downloadInput = {
    id?: StringFieldUpdateOperationsInput | string
    whatsapp?: StringFieldUpdateOperationsInput | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otp?: NullableIntFieldUpdateOperationsInput | number | null
    id_account?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    auth_user?: auth_userUncheckedUpdateManyWithoutCustomerNestedInput
    customer_reader?: customer_readerUncheckedUpdateManyWithoutCustomerNestedInput
    customer_track?: customer_trackUncheckedUpdateManyWithoutCustomerNestedInput
    t_sales?: t_salesUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type productUpsertWithoutT_sales_downloadInput = {
    update: XOR<productUpdateWithoutT_sales_downloadInput, productUncheckedUpdateWithoutT_sales_downloadInput>
    create: XOR<productCreateWithoutT_sales_downloadInput, productUncheckedCreateWithoutT_sales_downloadInput>
    where?: productWhereInput
  }

  export type productUpdateToOneWithWhereWithoutT_sales_downloadInput = {
    where?: productWhereInput
    data: XOR<productUpdateWithoutT_sales_downloadInput, productUncheckedUpdateWithoutT_sales_downloadInput>
  }

  export type productUpdateWithoutT_sales_downloadInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    alias?: StringFieldUpdateOperationsInput | string
    strike_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    real_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    desc?: StringFieldUpdateOperationsInput | string
    info?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    img_file?: StringFieldUpdateOperationsInput | string
    cover?: StringFieldUpdateOperationsInput | string
    product_file?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    published_date?: DateTimeFieldUpdateOperationsInput | Date | string
    is_physical?: BoolFieldUpdateOperationsInput | boolean
    preorder_min_qty?: NullableIntFieldUpdateOperationsInput | number | null
    content_type?: NullableStringFieldUpdateOperationsInput | string | null
    is_chapter?: BoolFieldUpdateOperationsInput | boolean
    book?: bookUpdateManyWithoutProductNestedInput
    bundle_product?: bundle_productUpdateManyWithoutProductNestedInput
    chapter?: chapterUpdateManyWithoutProductNestedInput
    customer_reader?: customer_readerUpdateManyWithoutProductNestedInput
    preorder?: preorderUpdateManyWithoutProductNestedInput
    author?: authorUpdateOneWithoutProductNestedInput
    product_category?: product_categoryUpdateManyWithoutProductNestedInput
    t_sales_line?: t_sales_lineUpdateManyWithoutProductNestedInput
  }

  export type productUncheckedUpdateWithoutT_sales_downloadInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    alias?: StringFieldUpdateOperationsInput | string
    strike_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    real_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    desc?: StringFieldUpdateOperationsInput | string
    info?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    img_file?: StringFieldUpdateOperationsInput | string
    cover?: StringFieldUpdateOperationsInput | string
    product_file?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    id_author?: NullableStringFieldUpdateOperationsInput | string | null
    published_date?: DateTimeFieldUpdateOperationsInput | Date | string
    is_physical?: BoolFieldUpdateOperationsInput | boolean
    preorder_min_qty?: NullableIntFieldUpdateOperationsInput | number | null
    content_type?: NullableStringFieldUpdateOperationsInput | string | null
    is_chapter?: BoolFieldUpdateOperationsInput | boolean
    book?: bookUncheckedUpdateManyWithoutProductNestedInput
    bundle_product?: bundle_productUncheckedUpdateManyWithoutProductNestedInput
    chapter?: chapterUncheckedUpdateManyWithoutProductNestedInput
    customer_reader?: customer_readerUncheckedUpdateManyWithoutProductNestedInput
    preorder?: preorderUncheckedUpdateManyWithoutProductNestedInput
    product_category?: product_categoryUncheckedUpdateManyWithoutProductNestedInput
    t_sales_line?: t_sales_lineUncheckedUpdateManyWithoutProductNestedInput
  }

  export type bundleCreateWithoutT_sales_lineInput = {
    id?: string
    name: string
    slug: string
    strike_price?: Decimal | DecimalJsLike | number | string | null
    real_price: Decimal | DecimalJsLike | number | string
    currency?: string
    desc?: string
    info?: JsonNullValueInput | InputJsonValue
    deleted_at?: Date | string | null
    status?: string
    img_file?: string
    cover?: string
    sku?: string
    bundle_category?: bundle_categoryCreateNestedManyWithoutBundleInput
    bundle_product?: bundle_productCreateNestedManyWithoutBundleInput
  }

  export type bundleUncheckedCreateWithoutT_sales_lineInput = {
    id?: string
    name: string
    slug: string
    strike_price?: Decimal | DecimalJsLike | number | string | null
    real_price: Decimal | DecimalJsLike | number | string
    currency?: string
    desc?: string
    info?: JsonNullValueInput | InputJsonValue
    deleted_at?: Date | string | null
    status?: string
    img_file?: string
    cover?: string
    sku?: string
    bundle_category?: bundle_categoryUncheckedCreateNestedManyWithoutBundleInput
    bundle_product?: bundle_productUncheckedCreateNestedManyWithoutBundleInput
  }

  export type bundleCreateOrConnectWithoutT_sales_lineInput = {
    where: bundleWhereUniqueInput
    create: XOR<bundleCreateWithoutT_sales_lineInput, bundleUncheckedCreateWithoutT_sales_lineInput>
  }

  export type productCreateWithoutT_sales_lineInput = {
    id?: string
    name: string
    slug: string
    alias?: string
    strike_price?: Decimal | DecimalJsLike | number | string | null
    real_price: Decimal | DecimalJsLike | number | string
    desc?: string
    info?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    currency?: string
    deleted_at?: Date | string | null
    img_file?: string
    cover?: string
    product_file?: string
    sku?: string
    published_date?: Date | string
    is_physical?: boolean
    preorder_min_qty?: number | null
    content_type?: string | null
    is_chapter?: boolean
    book?: bookCreateNestedManyWithoutProductInput
    bundle_product?: bundle_productCreateNestedManyWithoutProductInput
    chapter?: chapterCreateNestedManyWithoutProductInput
    customer_reader?: customer_readerCreateNestedManyWithoutProductInput
    preorder?: preorderCreateNestedManyWithoutProductInput
    author?: authorCreateNestedOneWithoutProductInput
    product_category?: product_categoryCreateNestedManyWithoutProductInput
    t_sales_download?: t_sales_downloadCreateNestedManyWithoutProductInput
  }

  export type productUncheckedCreateWithoutT_sales_lineInput = {
    id?: string
    name: string
    slug: string
    alias?: string
    strike_price?: Decimal | DecimalJsLike | number | string | null
    real_price: Decimal | DecimalJsLike | number | string
    desc?: string
    info?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    currency?: string
    deleted_at?: Date | string | null
    img_file?: string
    cover?: string
    product_file?: string
    sku?: string
    id_author?: string | null
    published_date?: Date | string
    is_physical?: boolean
    preorder_min_qty?: number | null
    content_type?: string | null
    is_chapter?: boolean
    book?: bookUncheckedCreateNestedManyWithoutProductInput
    bundle_product?: bundle_productUncheckedCreateNestedManyWithoutProductInput
    chapter?: chapterUncheckedCreateNestedManyWithoutProductInput
    customer_reader?: customer_readerUncheckedCreateNestedManyWithoutProductInput
    preorder?: preorderUncheckedCreateNestedManyWithoutProductInput
    product_category?: product_categoryUncheckedCreateNestedManyWithoutProductInput
    t_sales_download?: t_sales_downloadUncheckedCreateNestedManyWithoutProductInput
  }

  export type productCreateOrConnectWithoutT_sales_lineInput = {
    where: productWhereUniqueInput
    create: XOR<productCreateWithoutT_sales_lineInput, productUncheckedCreateWithoutT_sales_lineInput>
  }

  export type t_salesCreateWithoutT_sales_lineInput = {
    id?: string
    status?: string
    total: Decimal | DecimalJsLike | number | string
    currency?: string
    info: JsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    midtrans_order_id?: string
    midtrans_success?: NullableJsonNullValueInput | InputJsonValue
    midtrans_pending?: NullableJsonNullValueInput | InputJsonValue
    midtrans_error?: NullableJsonNullValueInput | InputJsonValue
    customer: customerCreateNestedOneWithoutT_salesInput
  }

  export type t_salesUncheckedCreateWithoutT_sales_lineInput = {
    id?: string
    id_customer: string
    status?: string
    total: Decimal | DecimalJsLike | number | string
    currency?: string
    info: JsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    midtrans_order_id?: string
    midtrans_success?: NullableJsonNullValueInput | InputJsonValue
    midtrans_pending?: NullableJsonNullValueInput | InputJsonValue
    midtrans_error?: NullableJsonNullValueInput | InputJsonValue
  }

  export type t_salesCreateOrConnectWithoutT_sales_lineInput = {
    where: t_salesWhereUniqueInput
    create: XOR<t_salesCreateWithoutT_sales_lineInput, t_salesUncheckedCreateWithoutT_sales_lineInput>
  }

  export type bundleUpsertWithoutT_sales_lineInput = {
    update: XOR<bundleUpdateWithoutT_sales_lineInput, bundleUncheckedUpdateWithoutT_sales_lineInput>
    create: XOR<bundleCreateWithoutT_sales_lineInput, bundleUncheckedCreateWithoutT_sales_lineInput>
    where?: bundleWhereInput
  }

  export type bundleUpdateToOneWithWhereWithoutT_sales_lineInput = {
    where?: bundleWhereInput
    data: XOR<bundleUpdateWithoutT_sales_lineInput, bundleUncheckedUpdateWithoutT_sales_lineInput>
  }

  export type bundleUpdateWithoutT_sales_lineInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    strike_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    real_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    desc?: StringFieldUpdateOperationsInput | string
    info?: JsonNullValueInput | InputJsonValue
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    img_file?: StringFieldUpdateOperationsInput | string
    cover?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    bundle_category?: bundle_categoryUpdateManyWithoutBundleNestedInput
    bundle_product?: bundle_productUpdateManyWithoutBundleNestedInput
  }

  export type bundleUncheckedUpdateWithoutT_sales_lineInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    strike_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    real_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    desc?: StringFieldUpdateOperationsInput | string
    info?: JsonNullValueInput | InputJsonValue
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    img_file?: StringFieldUpdateOperationsInput | string
    cover?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    bundle_category?: bundle_categoryUncheckedUpdateManyWithoutBundleNestedInput
    bundle_product?: bundle_productUncheckedUpdateManyWithoutBundleNestedInput
  }

  export type productUpsertWithoutT_sales_lineInput = {
    update: XOR<productUpdateWithoutT_sales_lineInput, productUncheckedUpdateWithoutT_sales_lineInput>
    create: XOR<productCreateWithoutT_sales_lineInput, productUncheckedCreateWithoutT_sales_lineInput>
    where?: productWhereInput
  }

  export type productUpdateToOneWithWhereWithoutT_sales_lineInput = {
    where?: productWhereInput
    data: XOR<productUpdateWithoutT_sales_lineInput, productUncheckedUpdateWithoutT_sales_lineInput>
  }

  export type productUpdateWithoutT_sales_lineInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    alias?: StringFieldUpdateOperationsInput | string
    strike_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    real_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    desc?: StringFieldUpdateOperationsInput | string
    info?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    img_file?: StringFieldUpdateOperationsInput | string
    cover?: StringFieldUpdateOperationsInput | string
    product_file?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    published_date?: DateTimeFieldUpdateOperationsInput | Date | string
    is_physical?: BoolFieldUpdateOperationsInput | boolean
    preorder_min_qty?: NullableIntFieldUpdateOperationsInput | number | null
    content_type?: NullableStringFieldUpdateOperationsInput | string | null
    is_chapter?: BoolFieldUpdateOperationsInput | boolean
    book?: bookUpdateManyWithoutProductNestedInput
    bundle_product?: bundle_productUpdateManyWithoutProductNestedInput
    chapter?: chapterUpdateManyWithoutProductNestedInput
    customer_reader?: customer_readerUpdateManyWithoutProductNestedInput
    preorder?: preorderUpdateManyWithoutProductNestedInput
    author?: authorUpdateOneWithoutProductNestedInput
    product_category?: product_categoryUpdateManyWithoutProductNestedInput
    t_sales_download?: t_sales_downloadUpdateManyWithoutProductNestedInput
  }

  export type productUncheckedUpdateWithoutT_sales_lineInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    alias?: StringFieldUpdateOperationsInput | string
    strike_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    real_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    desc?: StringFieldUpdateOperationsInput | string
    info?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    img_file?: StringFieldUpdateOperationsInput | string
    cover?: StringFieldUpdateOperationsInput | string
    product_file?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    id_author?: NullableStringFieldUpdateOperationsInput | string | null
    published_date?: DateTimeFieldUpdateOperationsInput | Date | string
    is_physical?: BoolFieldUpdateOperationsInput | boolean
    preorder_min_qty?: NullableIntFieldUpdateOperationsInput | number | null
    content_type?: NullableStringFieldUpdateOperationsInput | string | null
    is_chapter?: BoolFieldUpdateOperationsInput | boolean
    book?: bookUncheckedUpdateManyWithoutProductNestedInput
    bundle_product?: bundle_productUncheckedUpdateManyWithoutProductNestedInput
    chapter?: chapterUncheckedUpdateManyWithoutProductNestedInput
    customer_reader?: customer_readerUncheckedUpdateManyWithoutProductNestedInput
    preorder?: preorderUncheckedUpdateManyWithoutProductNestedInput
    product_category?: product_categoryUncheckedUpdateManyWithoutProductNestedInput
    t_sales_download?: t_sales_downloadUncheckedUpdateManyWithoutProductNestedInput
  }

  export type t_salesUpsertWithoutT_sales_lineInput = {
    update: XOR<t_salesUpdateWithoutT_sales_lineInput, t_salesUncheckedUpdateWithoutT_sales_lineInput>
    create: XOR<t_salesCreateWithoutT_sales_lineInput, t_salesUncheckedCreateWithoutT_sales_lineInput>
    where?: t_salesWhereInput
  }

  export type t_salesUpdateToOneWithWhereWithoutT_sales_lineInput = {
    where?: t_salesWhereInput
    data: XOR<t_salesUpdateWithoutT_sales_lineInput, t_salesUncheckedUpdateWithoutT_sales_lineInput>
  }

  export type t_salesUpdateWithoutT_sales_lineInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    info?: JsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    midtrans_order_id?: StringFieldUpdateOperationsInput | string
    midtrans_success?: NullableJsonNullValueInput | InputJsonValue
    midtrans_pending?: NullableJsonNullValueInput | InputJsonValue
    midtrans_error?: NullableJsonNullValueInput | InputJsonValue
    customer?: customerUpdateOneRequiredWithoutT_salesNestedInput
  }

  export type t_salesUncheckedUpdateWithoutT_sales_lineInput = {
    id?: StringFieldUpdateOperationsInput | string
    id_customer?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    info?: JsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    midtrans_order_id?: StringFieldUpdateOperationsInput | string
    midtrans_success?: NullableJsonNullValueInput | InputJsonValue
    midtrans_pending?: NullableJsonNullValueInput | InputJsonValue
    midtrans_error?: NullableJsonNullValueInput | InputJsonValue
  }

  export type book_tagsCreateWithoutTagsInput = {
    id?: string
    book: bookCreateNestedOneWithoutBook_tagsInput
  }

  export type book_tagsUncheckedCreateWithoutTagsInput = {
    id?: string
    id_book: string
  }

  export type book_tagsCreateOrConnectWithoutTagsInput = {
    where: book_tagsWhereUniqueInput
    create: XOR<book_tagsCreateWithoutTagsInput, book_tagsUncheckedCreateWithoutTagsInput>
  }

  export type book_tagsCreateManyTagsInputEnvelope = {
    data: book_tagsCreateManyTagsInput | book_tagsCreateManyTagsInput[]
    skipDuplicates?: boolean
  }

  export type tagsCreateWithoutOther_tagsInput = {
    id?: string
    name: string
    deleted_at?: Date | string | null
    slug?: string | null
    img?: string | null
    book_tags?: book_tagsCreateNestedManyWithoutTagsInput
    tags?: tagsCreateNestedOneWithoutOther_tagsInput
  }

  export type tagsUncheckedCreateWithoutOther_tagsInput = {
    id?: string
    name: string
    id_parent?: string | null
    deleted_at?: Date | string | null
    slug?: string | null
    img?: string | null
    book_tags?: book_tagsUncheckedCreateNestedManyWithoutTagsInput
  }

  export type tagsCreateOrConnectWithoutOther_tagsInput = {
    where: tagsWhereUniqueInput
    create: XOR<tagsCreateWithoutOther_tagsInput, tagsUncheckedCreateWithoutOther_tagsInput>
  }

  export type tagsCreateWithoutTagsInput = {
    id?: string
    name: string
    deleted_at?: Date | string | null
    slug?: string | null
    img?: string | null
    book_tags?: book_tagsCreateNestedManyWithoutTagsInput
    other_tags?: tagsCreateNestedManyWithoutTagsInput
  }

  export type tagsUncheckedCreateWithoutTagsInput = {
    id?: string
    name: string
    deleted_at?: Date | string | null
    slug?: string | null
    img?: string | null
    book_tags?: book_tagsUncheckedCreateNestedManyWithoutTagsInput
    other_tags?: tagsUncheckedCreateNestedManyWithoutTagsInput
  }

  export type tagsCreateOrConnectWithoutTagsInput = {
    where: tagsWhereUniqueInput
    create: XOR<tagsCreateWithoutTagsInput, tagsUncheckedCreateWithoutTagsInput>
  }

  export type tagsCreateManyTagsInputEnvelope = {
    data: tagsCreateManyTagsInput | tagsCreateManyTagsInput[]
    skipDuplicates?: boolean
  }

  export type book_tagsUpsertWithWhereUniqueWithoutTagsInput = {
    where: book_tagsWhereUniqueInput
    update: XOR<book_tagsUpdateWithoutTagsInput, book_tagsUncheckedUpdateWithoutTagsInput>
    create: XOR<book_tagsCreateWithoutTagsInput, book_tagsUncheckedCreateWithoutTagsInput>
  }

  export type book_tagsUpdateWithWhereUniqueWithoutTagsInput = {
    where: book_tagsWhereUniqueInput
    data: XOR<book_tagsUpdateWithoutTagsInput, book_tagsUncheckedUpdateWithoutTagsInput>
  }

  export type book_tagsUpdateManyWithWhereWithoutTagsInput = {
    where: book_tagsScalarWhereInput
    data: XOR<book_tagsUpdateManyMutationInput, book_tagsUncheckedUpdateManyWithoutTagsInput>
  }

  export type tagsUpsertWithoutOther_tagsInput = {
    update: XOR<tagsUpdateWithoutOther_tagsInput, tagsUncheckedUpdateWithoutOther_tagsInput>
    create: XOR<tagsCreateWithoutOther_tagsInput, tagsUncheckedCreateWithoutOther_tagsInput>
    where?: tagsWhereInput
  }

  export type tagsUpdateToOneWithWhereWithoutOther_tagsInput = {
    where?: tagsWhereInput
    data: XOR<tagsUpdateWithoutOther_tagsInput, tagsUncheckedUpdateWithoutOther_tagsInput>
  }

  export type tagsUpdateWithoutOther_tagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    img?: NullableStringFieldUpdateOperationsInput | string | null
    book_tags?: book_tagsUpdateManyWithoutTagsNestedInput
    tags?: tagsUpdateOneWithoutOther_tagsNestedInput
  }

  export type tagsUncheckedUpdateWithoutOther_tagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    id_parent?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    img?: NullableStringFieldUpdateOperationsInput | string | null
    book_tags?: book_tagsUncheckedUpdateManyWithoutTagsNestedInput
  }

  export type tagsUpsertWithWhereUniqueWithoutTagsInput = {
    where: tagsWhereUniqueInput
    update: XOR<tagsUpdateWithoutTagsInput, tagsUncheckedUpdateWithoutTagsInput>
    create: XOR<tagsCreateWithoutTagsInput, tagsUncheckedCreateWithoutTagsInput>
  }

  export type tagsUpdateWithWhereUniqueWithoutTagsInput = {
    where: tagsWhereUniqueInput
    data: XOR<tagsUpdateWithoutTagsInput, tagsUncheckedUpdateWithoutTagsInput>
  }

  export type tagsUpdateManyWithWhereWithoutTagsInput = {
    where: tagsScalarWhereInput
    data: XOR<tagsUpdateManyMutationInput, tagsUncheckedUpdateManyWithoutTagsInput>
  }

  export type tagsScalarWhereInput = {
    AND?: tagsScalarWhereInput | tagsScalarWhereInput[]
    OR?: tagsScalarWhereInput[]
    NOT?: tagsScalarWhereInput | tagsScalarWhereInput[]
    id?: UuidFilter<"tags"> | string
    name?: StringFilter<"tags"> | string
    id_parent?: UuidNullableFilter<"tags"> | string | null
    deleted_at?: DateTimeNullableFilter<"tags"> | Date | string | null
    slug?: StringNullableFilter<"tags"> | string | null
    img?: StringNullableFilter<"tags"> | string | null
  }

  export type publisherCreateWithoutTransactionInput = {
    id?: string
    name: string
    description?: string | null
    website?: string | null
    address?: string | null
    logo?: string | null
    auth_user?: auth_userCreateNestedManyWithoutPublisherInput
    promo_code?: promo_codeCreateNestedManyWithoutPublisherInput
    auth_account?: auth_accountCreateNestedOneWithoutPublisherInput
    publisher_author?: publisher_authorCreateNestedManyWithoutPublisherInput
    t_ai_credit?: t_ai_creditCreateNestedManyWithoutPublisherInput
    withdrawal?: withdrawalCreateNestedManyWithoutPublisherInput
  }

  export type publisherUncheckedCreateWithoutTransactionInput = {
    id?: string
    id_account?: string | null
    name: string
    description?: string | null
    website?: string | null
    address?: string | null
    logo?: string | null
    auth_user?: auth_userUncheckedCreateNestedManyWithoutPublisherInput
    promo_code?: promo_codeUncheckedCreateNestedManyWithoutPublisherInput
    publisher_author?: publisher_authorUncheckedCreateNestedManyWithoutPublisherInput
    t_ai_credit?: t_ai_creditUncheckedCreateNestedManyWithoutPublisherInput
    withdrawal?: withdrawalUncheckedCreateNestedManyWithoutPublisherInput
  }

  export type publisherCreateOrConnectWithoutTransactionInput = {
    where: publisherWhereUniqueInput
    create: XOR<publisherCreateWithoutTransactionInput, publisherUncheckedCreateWithoutTransactionInput>
  }

  export type publisherUpsertWithoutTransactionInput = {
    update: XOR<publisherUpdateWithoutTransactionInput, publisherUncheckedUpdateWithoutTransactionInput>
    create: XOR<publisherCreateWithoutTransactionInput, publisherUncheckedCreateWithoutTransactionInput>
    where?: publisherWhereInput
  }

  export type publisherUpdateToOneWithWhereWithoutTransactionInput = {
    where?: publisherWhereInput
    data: XOR<publisherUpdateWithoutTransactionInput, publisherUncheckedUpdateWithoutTransactionInput>
  }

  export type publisherUpdateWithoutTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    auth_user?: auth_userUpdateManyWithoutPublisherNestedInput
    promo_code?: promo_codeUpdateManyWithoutPublisherNestedInput
    auth_account?: auth_accountUpdateOneWithoutPublisherNestedInput
    publisher_author?: publisher_authorUpdateManyWithoutPublisherNestedInput
    t_ai_credit?: t_ai_creditUpdateManyWithoutPublisherNestedInput
    withdrawal?: withdrawalUpdateManyWithoutPublisherNestedInput
  }

  export type publisherUncheckedUpdateWithoutTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    id_account?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    auth_user?: auth_userUncheckedUpdateManyWithoutPublisherNestedInput
    promo_code?: promo_codeUncheckedUpdateManyWithoutPublisherNestedInput
    publisher_author?: publisher_authorUncheckedUpdateManyWithoutPublisherNestedInput
    t_ai_credit?: t_ai_creditUncheckedUpdateManyWithoutPublisherNestedInput
    withdrawal?: withdrawalUncheckedUpdateManyWithoutPublisherNestedInput
  }

  export type publisherCreateWithoutWithdrawalInput = {
    id?: string
    name: string
    description?: string | null
    website?: string | null
    address?: string | null
    logo?: string | null
    auth_user?: auth_userCreateNestedManyWithoutPublisherInput
    promo_code?: promo_codeCreateNestedManyWithoutPublisherInput
    auth_account?: auth_accountCreateNestedOneWithoutPublisherInput
    publisher_author?: publisher_authorCreateNestedManyWithoutPublisherInput
    t_ai_credit?: t_ai_creditCreateNestedManyWithoutPublisherInput
    transaction?: transactionCreateNestedManyWithoutPublisherInput
  }

  export type publisherUncheckedCreateWithoutWithdrawalInput = {
    id?: string
    id_account?: string | null
    name: string
    description?: string | null
    website?: string | null
    address?: string | null
    logo?: string | null
    auth_user?: auth_userUncheckedCreateNestedManyWithoutPublisherInput
    promo_code?: promo_codeUncheckedCreateNestedManyWithoutPublisherInput
    publisher_author?: publisher_authorUncheckedCreateNestedManyWithoutPublisherInput
    t_ai_credit?: t_ai_creditUncheckedCreateNestedManyWithoutPublisherInput
    transaction?: transactionUncheckedCreateNestedManyWithoutPublisherInput
  }

  export type publisherCreateOrConnectWithoutWithdrawalInput = {
    where: publisherWhereUniqueInput
    create: XOR<publisherCreateWithoutWithdrawalInput, publisherUncheckedCreateWithoutWithdrawalInput>
  }

  export type publisherUpsertWithoutWithdrawalInput = {
    update: XOR<publisherUpdateWithoutWithdrawalInput, publisherUncheckedUpdateWithoutWithdrawalInput>
    create: XOR<publisherCreateWithoutWithdrawalInput, publisherUncheckedCreateWithoutWithdrawalInput>
    where?: publisherWhereInput
  }

  export type publisherUpdateToOneWithWhereWithoutWithdrawalInput = {
    where?: publisherWhereInput
    data: XOR<publisherUpdateWithoutWithdrawalInput, publisherUncheckedUpdateWithoutWithdrawalInput>
  }

  export type publisherUpdateWithoutWithdrawalInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    auth_user?: auth_userUpdateManyWithoutPublisherNestedInput
    promo_code?: promo_codeUpdateManyWithoutPublisherNestedInput
    auth_account?: auth_accountUpdateOneWithoutPublisherNestedInput
    publisher_author?: publisher_authorUpdateManyWithoutPublisherNestedInput
    t_ai_credit?: t_ai_creditUpdateManyWithoutPublisherNestedInput
    transaction?: transactionUpdateManyWithoutPublisherNestedInput
  }

  export type publisherUncheckedUpdateWithoutWithdrawalInput = {
    id?: StringFieldUpdateOperationsInput | string
    id_account?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    auth_user?: auth_userUncheckedUpdateManyWithoutPublisherNestedInput
    promo_code?: promo_codeUncheckedUpdateManyWithoutPublisherNestedInput
    publisher_author?: publisher_authorUncheckedUpdateManyWithoutPublisherNestedInput
    t_ai_credit?: t_ai_creditUncheckedUpdateManyWithoutPublisherNestedInput
    transaction?: transactionUncheckedUpdateManyWithoutPublisherNestedInput
  }

  export type auth_userCreateManyAffiliateInput = {
    id?: string
    name: string
    email: string
    email_verified?: boolean
    image?: string | null
    created_at?: Date | string
    updated_at?: Date | string | null
    username?: string | null
    display_username?: string | null
    two_factor_enabled?: boolean | null
    id_customer?: string | null
    id_author?: string | null
    id_publisher?: string | null
    id_internal?: string | null
  }

  export type auth_userUpdateWithoutAffiliateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    email_verified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    display_username?: NullableStringFieldUpdateOperationsInput | string | null
    two_factor_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    auth_account?: auth_accountUpdateManyWithoutAuth_userNestedInput
    auth_session?: auth_sessionUpdateManyWithoutAuth_userNestedInput
    auth_two_factor?: auth_two_factorUpdateManyWithoutAuth_userNestedInput
    author?: authorUpdateOneWithoutAuth_userNestedInput
    customer?: customerUpdateOneWithoutAuth_userNestedInput
    internal?: internalUpdateOneWithoutAuth_userNestedInput
    publisher?: publisherUpdateOneWithoutAuth_userNestedInput
    reviews?: reviewsUpdateManyWithoutAuth_userNestedInput
    reviews_likes?: reviews_likesUpdateManyWithoutAuth_userNestedInput
  }

  export type auth_userUncheckedUpdateWithoutAffiliateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    email_verified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    display_username?: NullableStringFieldUpdateOperationsInput | string | null
    two_factor_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    id_customer?: NullableStringFieldUpdateOperationsInput | string | null
    id_author?: NullableStringFieldUpdateOperationsInput | string | null
    id_publisher?: NullableStringFieldUpdateOperationsInput | string | null
    id_internal?: NullableStringFieldUpdateOperationsInput | string | null
    auth_account?: auth_accountUncheckedUpdateManyWithoutAuth_userNestedInput
    auth_session?: auth_sessionUncheckedUpdateManyWithoutAuth_userNestedInput
    auth_two_factor?: auth_two_factorUncheckedUpdateManyWithoutAuth_userNestedInput
    reviews?: reviewsUncheckedUpdateManyWithoutAuth_userNestedInput
    reviews_likes?: reviews_likesUncheckedUpdateManyWithoutAuth_userNestedInput
  }

  export type auth_userUncheckedUpdateManyWithoutAffiliateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    email_verified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    display_username?: NullableStringFieldUpdateOperationsInput | string | null
    two_factor_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    id_customer?: NullableStringFieldUpdateOperationsInput | string | null
    id_author?: NullableStringFieldUpdateOperationsInput | string | null
    id_publisher?: NullableStringFieldUpdateOperationsInput | string | null
    id_internal?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type affiliateCreateManyAuth_accountInput = {
    id?: string
    name: string
  }

  export type authorCreateManyAuth_accountInput = {
    id?: string
    name: string
    biography?: string | null
    social_media?: string | null
    avatar?: string | null
  }

  export type customerCreateManyAuth_accountInput = {
    id?: string
    whatsapp: string
    deleted_at?: Date | string | null
    otp?: number | null
    name: string
    email: string
  }

  export type internalCreateManyAuth_accountInput = {
    id?: string
    name: string
    is_sales_and_marketing?: boolean
    is_support?: boolean
    is_management?: boolean
    is_it?: boolean
  }

  export type publisherCreateManyAuth_accountInput = {
    id?: string
    name: string
    description?: string | null
    website?: string | null
    address?: string | null
    logo?: string | null
  }

  export type affiliateUpdateWithoutAuth_accountInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    auth_user?: auth_userUpdateManyWithoutAffiliateNestedInput
  }

  export type affiliateUncheckedUpdateWithoutAuth_accountInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    auth_user?: auth_userUncheckedUpdateManyWithoutAffiliateNestedInput
  }

  export type affiliateUncheckedUpdateManyWithoutAuth_accountInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type authorUpdateWithoutAuth_accountInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    biography?: NullableStringFieldUpdateOperationsInput | string | null
    social_media?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    auth_user?: auth_userUpdateManyWithoutAuthorNestedInput
    book?: bookUpdateManyWithoutAuthorNestedInput
    product?: productUpdateManyWithoutAuthorNestedInput
    publisher_author?: publisher_authorUpdateManyWithoutAuthorNestedInput
  }

  export type authorUncheckedUpdateWithoutAuth_accountInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    biography?: NullableStringFieldUpdateOperationsInput | string | null
    social_media?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    auth_user?: auth_userUncheckedUpdateManyWithoutAuthorNestedInput
    book?: bookUncheckedUpdateManyWithoutAuthorNestedInput
    product?: productUncheckedUpdateManyWithoutAuthorNestedInput
    publisher_author?: publisher_authorUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type authorUncheckedUpdateManyWithoutAuth_accountInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    biography?: NullableStringFieldUpdateOperationsInput | string | null
    social_media?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type customerUpdateWithoutAuth_accountInput = {
    id?: StringFieldUpdateOperationsInput | string
    whatsapp?: StringFieldUpdateOperationsInput | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otp?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    auth_user?: auth_userUpdateManyWithoutCustomerNestedInput
    customer_reader?: customer_readerUpdateManyWithoutCustomerNestedInput
    customer_track?: customer_trackUpdateManyWithoutCustomerNestedInput
    t_sales?: t_salesUpdateManyWithoutCustomerNestedInput
    t_sales_download?: t_sales_downloadUpdateManyWithoutCustomerNestedInput
  }

  export type customerUncheckedUpdateWithoutAuth_accountInput = {
    id?: StringFieldUpdateOperationsInput | string
    whatsapp?: StringFieldUpdateOperationsInput | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otp?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    auth_user?: auth_userUncheckedUpdateManyWithoutCustomerNestedInput
    customer_reader?: customer_readerUncheckedUpdateManyWithoutCustomerNestedInput
    customer_track?: customer_trackUncheckedUpdateManyWithoutCustomerNestedInput
    t_sales?: t_salesUncheckedUpdateManyWithoutCustomerNestedInput
    t_sales_download?: t_sales_downloadUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type customerUncheckedUpdateManyWithoutAuth_accountInput = {
    id?: StringFieldUpdateOperationsInput | string
    whatsapp?: StringFieldUpdateOperationsInput | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otp?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
  }

  export type internalUpdateWithoutAuth_accountInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    is_sales_and_marketing?: BoolFieldUpdateOperationsInput | boolean
    is_support?: BoolFieldUpdateOperationsInput | boolean
    is_management?: BoolFieldUpdateOperationsInput | boolean
    is_it?: BoolFieldUpdateOperationsInput | boolean
    auth_user?: auth_userUpdateManyWithoutInternalNestedInput
    book_approval?: book_approvalUpdateManyWithoutInternalNestedInput
  }

  export type internalUncheckedUpdateWithoutAuth_accountInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    is_sales_and_marketing?: BoolFieldUpdateOperationsInput | boolean
    is_support?: BoolFieldUpdateOperationsInput | boolean
    is_management?: BoolFieldUpdateOperationsInput | boolean
    is_it?: BoolFieldUpdateOperationsInput | boolean
    auth_user?: auth_userUncheckedUpdateManyWithoutInternalNestedInput
    book_approval?: book_approvalUncheckedUpdateManyWithoutInternalNestedInput
  }

  export type internalUncheckedUpdateManyWithoutAuth_accountInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    is_sales_and_marketing?: BoolFieldUpdateOperationsInput | boolean
    is_support?: BoolFieldUpdateOperationsInput | boolean
    is_management?: BoolFieldUpdateOperationsInput | boolean
    is_it?: BoolFieldUpdateOperationsInput | boolean
  }

  export type publisherUpdateWithoutAuth_accountInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    auth_user?: auth_userUpdateManyWithoutPublisherNestedInput
    promo_code?: promo_codeUpdateManyWithoutPublisherNestedInput
    publisher_author?: publisher_authorUpdateManyWithoutPublisherNestedInput
    t_ai_credit?: t_ai_creditUpdateManyWithoutPublisherNestedInput
    transaction?: transactionUpdateManyWithoutPublisherNestedInput
    withdrawal?: withdrawalUpdateManyWithoutPublisherNestedInput
  }

  export type publisherUncheckedUpdateWithoutAuth_accountInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    auth_user?: auth_userUncheckedUpdateManyWithoutPublisherNestedInput
    promo_code?: promo_codeUncheckedUpdateManyWithoutPublisherNestedInput
    publisher_author?: publisher_authorUncheckedUpdateManyWithoutPublisherNestedInput
    t_ai_credit?: t_ai_creditUncheckedUpdateManyWithoutPublisherNestedInput
    transaction?: transactionUncheckedUpdateManyWithoutPublisherNestedInput
    withdrawal?: withdrawalUncheckedUpdateManyWithoutPublisherNestedInput
  }

  export type publisherUncheckedUpdateManyWithoutAuth_accountInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type auth_accountCreateManyAuth_userInput = {
    id?: string
    password?: string | null
    id_provider?: string | null
    access_token?: string | null
    refresh_token?: string | null
    id_token?: string | null
    access_token_expires_at?: Date | string | null
    refresh_token_expires_at?: Date | string | null
    scope?: string | null
    created_at?: Date | string
    updated_at?: Date | string | null
    id_account?: string | null
  }

  export type auth_sessionCreateManyAuth_userInput = {
    id?: string
    expires_at: Date | string
    token: string
    created_at?: Date | string
    updated_at?: Date | string | null
    ip_address?: string | null
    user_agent?: string | null
  }

  export type auth_two_factorCreateManyAuth_userInput = {
    id?: string
    secret?: string | null
    backup_codes?: string | null
  }

  export type reviewsCreateManyAuth_userInput = {
    id?: string
    id_book: string
    comments: string
    rating?: Decimal | DecimalJsLike | number | string | null
    created_at: Date | string
    deleted_at?: Date | string | null
    parent?: string | null
  }

  export type reviews_likesCreateManyAuth_userInput = {
    id?: string
    id_reviews: string
  }

  export type auth_accountUpdateWithoutAuth_userInput = {
    id?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    id_provider?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token_expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refresh_token_expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    id_account?: NullableStringFieldUpdateOperationsInput | string | null
    affiliate?: affiliateUpdateManyWithoutAuth_accountNestedInput
    author?: authorUpdateManyWithoutAuth_accountNestedInput
    customer?: customerUpdateManyWithoutAuth_accountNestedInput
    internal?: internalUpdateManyWithoutAuth_accountNestedInput
    publisher?: publisherUpdateManyWithoutAuth_accountNestedInput
  }

  export type auth_accountUncheckedUpdateWithoutAuth_userInput = {
    id?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    id_provider?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token_expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refresh_token_expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    id_account?: NullableStringFieldUpdateOperationsInput | string | null
    affiliate?: affiliateUncheckedUpdateManyWithoutAuth_accountNestedInput
    author?: authorUncheckedUpdateManyWithoutAuth_accountNestedInput
    customer?: customerUncheckedUpdateManyWithoutAuth_accountNestedInput
    internal?: internalUncheckedUpdateManyWithoutAuth_accountNestedInput
    publisher?: publisherUncheckedUpdateManyWithoutAuth_accountNestedInput
  }

  export type auth_accountUncheckedUpdateManyWithoutAuth_userInput = {
    id?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    id_provider?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token_expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refresh_token_expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    id_account?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type auth_sessionUpdateWithoutAuth_userInput = {
    id?: StringFieldUpdateOperationsInput | string
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type auth_sessionUncheckedUpdateWithoutAuth_userInput = {
    id?: StringFieldUpdateOperationsInput | string
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type auth_sessionUncheckedUpdateManyWithoutAuth_userInput = {
    id?: StringFieldUpdateOperationsInput | string
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type auth_two_factorUpdateWithoutAuth_userInput = {
    id?: StringFieldUpdateOperationsInput | string
    secret?: NullableStringFieldUpdateOperationsInput | string | null
    backup_codes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type auth_two_factorUncheckedUpdateWithoutAuth_userInput = {
    id?: StringFieldUpdateOperationsInput | string
    secret?: NullableStringFieldUpdateOperationsInput | string | null
    backup_codes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type auth_two_factorUncheckedUpdateManyWithoutAuth_userInput = {
    id?: StringFieldUpdateOperationsInput | string
    secret?: NullableStringFieldUpdateOperationsInput | string | null
    backup_codes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type reviewsUpdateWithoutAuth_userInput = {
    id?: StringFieldUpdateOperationsInput | string
    comments?: StringFieldUpdateOperationsInput | string
    rating?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parent?: NullableStringFieldUpdateOperationsInput | string | null
    book?: bookUpdateOneRequiredWithoutReviewsNestedInput
    reviews_likes?: reviews_likesUpdateManyWithoutReviewsNestedInput
  }

  export type reviewsUncheckedUpdateWithoutAuth_userInput = {
    id?: StringFieldUpdateOperationsInput | string
    id_book?: StringFieldUpdateOperationsInput | string
    comments?: StringFieldUpdateOperationsInput | string
    rating?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parent?: NullableStringFieldUpdateOperationsInput | string | null
    reviews_likes?: reviews_likesUncheckedUpdateManyWithoutReviewsNestedInput
  }

  export type reviewsUncheckedUpdateManyWithoutAuth_userInput = {
    id?: StringFieldUpdateOperationsInput | string
    id_book?: StringFieldUpdateOperationsInput | string
    comments?: StringFieldUpdateOperationsInput | string
    rating?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type reviews_likesUpdateWithoutAuth_userInput = {
    id?: StringFieldUpdateOperationsInput | string
    reviews?: reviewsUpdateOneRequiredWithoutReviews_likesNestedInput
  }

  export type reviews_likesUncheckedUpdateWithoutAuth_userInput = {
    id?: StringFieldUpdateOperationsInput | string
    id_reviews?: StringFieldUpdateOperationsInput | string
  }

  export type reviews_likesUncheckedUpdateManyWithoutAuth_userInput = {
    id?: StringFieldUpdateOperationsInput | string
    id_reviews?: StringFieldUpdateOperationsInput | string
  }

  export type auth_userCreateManyAuthorInput = {
    id?: string
    name: string
    email: string
    email_verified?: boolean
    image?: string | null
    created_at?: Date | string
    updated_at?: Date | string | null
    username?: string | null
    display_username?: string | null
    two_factor_enabled?: boolean | null
    id_customer?: string | null
    id_affiliate?: string | null
    id_publisher?: string | null
    id_internal?: string | null
  }

  export type bookCreateManyAuthorInput = {
    id?: string
    name: string
    slug: string
    alias?: string
    submitted_price: Decimal | DecimalJsLike | number | string
    desc?: string
    info?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    currency?: string
    deleted_at?: Date | string | null
    img_file?: string
    cover?: string
    product_file?: string
    sku?: string
    published_date?: Date | string
    is_physical?: boolean
    preorder_min_qty?: number | null
    content_type?: string | null
    is_chapter?: boolean
    id_product?: string | null
    created_at?: Date | string
  }

  export type productCreateManyAuthorInput = {
    id?: string
    name: string
    slug: string
    alias?: string
    strike_price?: Decimal | DecimalJsLike | number | string | null
    real_price: Decimal | DecimalJsLike | number | string
    desc?: string
    info?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    currency?: string
    deleted_at?: Date | string | null
    img_file?: string
    cover?: string
    product_file?: string
    sku?: string
    published_date?: Date | string
    is_physical?: boolean
    preorder_min_qty?: number | null
    content_type?: string | null
    is_chapter?: boolean
  }

  export type publisher_authorCreateManyAuthorInput = {
    id?: string
    publisher_id: string
  }

  export type auth_userUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    email_verified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    display_username?: NullableStringFieldUpdateOperationsInput | string | null
    two_factor_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    auth_account?: auth_accountUpdateManyWithoutAuth_userNestedInput
    auth_session?: auth_sessionUpdateManyWithoutAuth_userNestedInput
    auth_two_factor?: auth_two_factorUpdateManyWithoutAuth_userNestedInput
    affiliate?: affiliateUpdateOneWithoutAuth_userNestedInput
    customer?: customerUpdateOneWithoutAuth_userNestedInput
    internal?: internalUpdateOneWithoutAuth_userNestedInput
    publisher?: publisherUpdateOneWithoutAuth_userNestedInput
    reviews?: reviewsUpdateManyWithoutAuth_userNestedInput
    reviews_likes?: reviews_likesUpdateManyWithoutAuth_userNestedInput
  }

  export type auth_userUncheckedUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    email_verified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    display_username?: NullableStringFieldUpdateOperationsInput | string | null
    two_factor_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    id_customer?: NullableStringFieldUpdateOperationsInput | string | null
    id_affiliate?: NullableStringFieldUpdateOperationsInput | string | null
    id_publisher?: NullableStringFieldUpdateOperationsInput | string | null
    id_internal?: NullableStringFieldUpdateOperationsInput | string | null
    auth_account?: auth_accountUncheckedUpdateManyWithoutAuth_userNestedInput
    auth_session?: auth_sessionUncheckedUpdateManyWithoutAuth_userNestedInput
    auth_two_factor?: auth_two_factorUncheckedUpdateManyWithoutAuth_userNestedInput
    reviews?: reviewsUncheckedUpdateManyWithoutAuth_userNestedInput
    reviews_likes?: reviews_likesUncheckedUpdateManyWithoutAuth_userNestedInput
  }

  export type auth_userUncheckedUpdateManyWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    email_verified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    display_username?: NullableStringFieldUpdateOperationsInput | string | null
    two_factor_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    id_customer?: NullableStringFieldUpdateOperationsInput | string | null
    id_affiliate?: NullableStringFieldUpdateOperationsInput | string | null
    id_publisher?: NullableStringFieldUpdateOperationsInput | string | null
    id_internal?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type bookUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    alias?: StringFieldUpdateOperationsInput | string
    submitted_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    desc?: StringFieldUpdateOperationsInput | string
    info?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    img_file?: StringFieldUpdateOperationsInput | string
    cover?: StringFieldUpdateOperationsInput | string
    product_file?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    published_date?: DateTimeFieldUpdateOperationsInput | Date | string
    is_physical?: BoolFieldUpdateOperationsInput | boolean
    preorder_min_qty?: NullableIntFieldUpdateOperationsInput | number | null
    content_type?: NullableStringFieldUpdateOperationsInput | string | null
    is_chapter?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: productUpdateOneWithoutBookNestedInput
    book_approval?: book_approvalUpdateManyWithoutBookNestedInput
    book_changes_log?: book_changes_logUpdateManyWithoutBookNestedInput
    book_genre?: book_genreUpdateManyWithoutBookNestedInput
    book_tags?: book_tagsUpdateManyWithoutBookNestedInput
    chapter?: chapterUpdateManyWithoutBookNestedInput
    ranking?: rankingUpdateManyWithoutBookNestedInput
    reviews?: reviewsUpdateManyWithoutBookNestedInput
  }

  export type bookUncheckedUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    alias?: StringFieldUpdateOperationsInput | string
    submitted_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    desc?: StringFieldUpdateOperationsInput | string
    info?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    img_file?: StringFieldUpdateOperationsInput | string
    cover?: StringFieldUpdateOperationsInput | string
    product_file?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    published_date?: DateTimeFieldUpdateOperationsInput | Date | string
    is_physical?: BoolFieldUpdateOperationsInput | boolean
    preorder_min_qty?: NullableIntFieldUpdateOperationsInput | number | null
    content_type?: NullableStringFieldUpdateOperationsInput | string | null
    is_chapter?: BoolFieldUpdateOperationsInput | boolean
    id_product?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    book_approval?: book_approvalUncheckedUpdateManyWithoutBookNestedInput
    book_changes_log?: book_changes_logUncheckedUpdateManyWithoutBookNestedInput
    book_genre?: book_genreUncheckedUpdateManyWithoutBookNestedInput
    book_tags?: book_tagsUncheckedUpdateManyWithoutBookNestedInput
    chapter?: chapterUncheckedUpdateManyWithoutBookNestedInput
    ranking?: rankingUncheckedUpdateManyWithoutBookNestedInput
    reviews?: reviewsUncheckedUpdateManyWithoutBookNestedInput
  }

  export type bookUncheckedUpdateManyWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    alias?: StringFieldUpdateOperationsInput | string
    submitted_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    desc?: StringFieldUpdateOperationsInput | string
    info?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    img_file?: StringFieldUpdateOperationsInput | string
    cover?: StringFieldUpdateOperationsInput | string
    product_file?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    published_date?: DateTimeFieldUpdateOperationsInput | Date | string
    is_physical?: BoolFieldUpdateOperationsInput | boolean
    preorder_min_qty?: NullableIntFieldUpdateOperationsInput | number | null
    content_type?: NullableStringFieldUpdateOperationsInput | string | null
    is_chapter?: BoolFieldUpdateOperationsInput | boolean
    id_product?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type productUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    alias?: StringFieldUpdateOperationsInput | string
    strike_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    real_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    desc?: StringFieldUpdateOperationsInput | string
    info?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    img_file?: StringFieldUpdateOperationsInput | string
    cover?: StringFieldUpdateOperationsInput | string
    product_file?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    published_date?: DateTimeFieldUpdateOperationsInput | Date | string
    is_physical?: BoolFieldUpdateOperationsInput | boolean
    preorder_min_qty?: NullableIntFieldUpdateOperationsInput | number | null
    content_type?: NullableStringFieldUpdateOperationsInput | string | null
    is_chapter?: BoolFieldUpdateOperationsInput | boolean
    book?: bookUpdateManyWithoutProductNestedInput
    bundle_product?: bundle_productUpdateManyWithoutProductNestedInput
    chapter?: chapterUpdateManyWithoutProductNestedInput
    customer_reader?: customer_readerUpdateManyWithoutProductNestedInput
    preorder?: preorderUpdateManyWithoutProductNestedInput
    product_category?: product_categoryUpdateManyWithoutProductNestedInput
    t_sales_download?: t_sales_downloadUpdateManyWithoutProductNestedInput
    t_sales_line?: t_sales_lineUpdateManyWithoutProductNestedInput
  }

  export type productUncheckedUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    alias?: StringFieldUpdateOperationsInput | string
    strike_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    real_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    desc?: StringFieldUpdateOperationsInput | string
    info?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    img_file?: StringFieldUpdateOperationsInput | string
    cover?: StringFieldUpdateOperationsInput | string
    product_file?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    published_date?: DateTimeFieldUpdateOperationsInput | Date | string
    is_physical?: BoolFieldUpdateOperationsInput | boolean
    preorder_min_qty?: NullableIntFieldUpdateOperationsInput | number | null
    content_type?: NullableStringFieldUpdateOperationsInput | string | null
    is_chapter?: BoolFieldUpdateOperationsInput | boolean
    book?: bookUncheckedUpdateManyWithoutProductNestedInput
    bundle_product?: bundle_productUncheckedUpdateManyWithoutProductNestedInput
    chapter?: chapterUncheckedUpdateManyWithoutProductNestedInput
    customer_reader?: customer_readerUncheckedUpdateManyWithoutProductNestedInput
    preorder?: preorderUncheckedUpdateManyWithoutProductNestedInput
    product_category?: product_categoryUncheckedUpdateManyWithoutProductNestedInput
    t_sales_download?: t_sales_downloadUncheckedUpdateManyWithoutProductNestedInput
    t_sales_line?: t_sales_lineUncheckedUpdateManyWithoutProductNestedInput
  }

  export type productUncheckedUpdateManyWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    alias?: StringFieldUpdateOperationsInput | string
    strike_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    real_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    desc?: StringFieldUpdateOperationsInput | string
    info?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    img_file?: StringFieldUpdateOperationsInput | string
    cover?: StringFieldUpdateOperationsInput | string
    product_file?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    published_date?: DateTimeFieldUpdateOperationsInput | Date | string
    is_physical?: BoolFieldUpdateOperationsInput | boolean
    preorder_min_qty?: NullableIntFieldUpdateOperationsInput | number | null
    content_type?: NullableStringFieldUpdateOperationsInput | string | null
    is_chapter?: BoolFieldUpdateOperationsInput | boolean
  }

  export type publisher_authorUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    publisher?: publisherUpdateOneRequiredWithoutPublisher_authorNestedInput
  }

  export type publisher_authorUncheckedUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    publisher_id?: StringFieldUpdateOperationsInput | string
  }

  export type publisher_authorUncheckedUpdateManyWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    publisher_id?: StringFieldUpdateOperationsInput | string
  }

  export type book_approvalCreateManyBookInput = {
    id?: string
    id_internal?: string | null
    comment?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    created_at?: Date | string
  }

  export type book_changes_logCreateManyBookInput = {
    created_at?: Date | string
    changes?: NullableJsonNullValueInput | InputJsonValue
  }

  export type book_genreCreateManyBookInput = {
    id?: string
    id_genre: string
  }

  export type book_tagsCreateManyBookInput = {
    id?: string
    id_tags: string
  }

  export type chapterCreateManyBookInput = {
    id?: string
    id_product?: string | null
    number: number
    name: string
    content?: JsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string | null
  }

  export type rankingCreateManyBookInput = {
    id?: string
  }

  export type reviewsCreateManyBookInput = {
    id?: string
    comments: string
    rating?: Decimal | DecimalJsLike | number | string | null
    created_at: Date | string
    deleted_at?: Date | string | null
    parent?: string | null
    id_user: string
  }

  export type book_approvalUpdateWithoutBookInput = {
    id?: StringFieldUpdateOperationsInput | string
    comment?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    internal?: internalUpdateOneWithoutBook_approvalNestedInput
  }

  export type book_approvalUncheckedUpdateWithoutBookInput = {
    id?: StringFieldUpdateOperationsInput | string
    id_internal?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type book_approvalUncheckedUpdateManyWithoutBookInput = {
    id?: StringFieldUpdateOperationsInput | string
    id_internal?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type book_changes_logUpdateWithoutBookInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    changes?: NullableJsonNullValueInput | InputJsonValue
  }

  export type book_changes_logUncheckedUpdateWithoutBookInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    changes?: NullableJsonNullValueInput | InputJsonValue
  }

  export type book_changes_logUncheckedUpdateManyWithoutBookInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    changes?: NullableJsonNullValueInput | InputJsonValue
  }

  export type book_genreUpdateWithoutBookInput = {
    id?: StringFieldUpdateOperationsInput | string
    genre?: genreUpdateOneRequiredWithoutBook_genreNestedInput
  }

  export type book_genreUncheckedUpdateWithoutBookInput = {
    id?: StringFieldUpdateOperationsInput | string
    id_genre?: StringFieldUpdateOperationsInput | string
  }

  export type book_genreUncheckedUpdateManyWithoutBookInput = {
    id?: StringFieldUpdateOperationsInput | string
    id_genre?: StringFieldUpdateOperationsInput | string
  }

  export type book_tagsUpdateWithoutBookInput = {
    id?: StringFieldUpdateOperationsInput | string
    tags?: tagsUpdateOneRequiredWithoutBook_tagsNestedInput
  }

  export type book_tagsUncheckedUpdateWithoutBookInput = {
    id?: StringFieldUpdateOperationsInput | string
    id_tags?: StringFieldUpdateOperationsInput | string
  }

  export type book_tagsUncheckedUpdateManyWithoutBookInput = {
    id?: StringFieldUpdateOperationsInput | string
    id_tags?: StringFieldUpdateOperationsInput | string
  }

  export type chapterUpdateWithoutBookInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    product?: productUpdateOneWithoutChapterNestedInput
  }

  export type chapterUncheckedUpdateWithoutBookInput = {
    id?: StringFieldUpdateOperationsInput | string
    id_product?: NullableStringFieldUpdateOperationsInput | string | null
    number?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type chapterUncheckedUpdateManyWithoutBookInput = {
    id?: StringFieldUpdateOperationsInput | string
    id_product?: NullableStringFieldUpdateOperationsInput | string | null
    number?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type rankingUpdateWithoutBookInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type rankingUncheckedUpdateWithoutBookInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type rankingUncheckedUpdateManyWithoutBookInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type reviewsUpdateWithoutBookInput = {
    id?: StringFieldUpdateOperationsInput | string
    comments?: StringFieldUpdateOperationsInput | string
    rating?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parent?: NullableStringFieldUpdateOperationsInput | string | null
    auth_user?: auth_userUpdateOneRequiredWithoutReviewsNestedInput
    reviews_likes?: reviews_likesUpdateManyWithoutReviewsNestedInput
  }

  export type reviewsUncheckedUpdateWithoutBookInput = {
    id?: StringFieldUpdateOperationsInput | string
    comments?: StringFieldUpdateOperationsInput | string
    rating?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parent?: NullableStringFieldUpdateOperationsInput | string | null
    id_user?: StringFieldUpdateOperationsInput | string
    reviews_likes?: reviews_likesUncheckedUpdateManyWithoutReviewsNestedInput
  }

  export type reviewsUncheckedUpdateManyWithoutBookInput = {
    id?: StringFieldUpdateOperationsInput | string
    comments?: StringFieldUpdateOperationsInput | string
    rating?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parent?: NullableStringFieldUpdateOperationsInput | string | null
    id_user?: StringFieldUpdateOperationsInput | string
  }

  export type bundle_categoryCreateManyBundleInput = {
    id?: string
    id_category: string
  }

  export type bundle_productCreateManyBundleInput = {
    id_product: string
    id?: string
    qty?: number | null
  }

  export type t_sales_lineCreateManyBundleInput = {
    id?: string
    id_sales: string
    unit_price: Decimal | DecimalJsLike | number | string
    qty: number
    total_price: Decimal | DecimalJsLike | number | string
    id_product?: string | null
  }

  export type bundle_categoryUpdateWithoutBundleInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: categoryUpdateOneRequiredWithoutBundle_categoryNestedInput
  }

  export type bundle_categoryUncheckedUpdateWithoutBundleInput = {
    id?: StringFieldUpdateOperationsInput | string
    id_category?: StringFieldUpdateOperationsInput | string
  }

  export type bundle_categoryUncheckedUpdateManyWithoutBundleInput = {
    id?: StringFieldUpdateOperationsInput | string
    id_category?: StringFieldUpdateOperationsInput | string
  }

  export type bundle_productUpdateWithoutBundleInput = {
    id?: StringFieldUpdateOperationsInput | string
    qty?: NullableIntFieldUpdateOperationsInput | number | null
    product?: productUpdateOneRequiredWithoutBundle_productNestedInput
  }

  export type bundle_productUncheckedUpdateWithoutBundleInput = {
    id_product?: StringFieldUpdateOperationsInput | string
    id?: StringFieldUpdateOperationsInput | string
    qty?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type bundle_productUncheckedUpdateManyWithoutBundleInput = {
    id_product?: StringFieldUpdateOperationsInput | string
    id?: StringFieldUpdateOperationsInput | string
    qty?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type t_sales_lineUpdateWithoutBundleInput = {
    id?: StringFieldUpdateOperationsInput | string
    unit_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    qty?: IntFieldUpdateOperationsInput | number
    total_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    product?: productUpdateOneWithoutT_sales_lineNestedInput
    t_sales?: t_salesUpdateOneRequiredWithoutT_sales_lineNestedInput
  }

  export type t_sales_lineUncheckedUpdateWithoutBundleInput = {
    id?: StringFieldUpdateOperationsInput | string
    id_sales?: StringFieldUpdateOperationsInput | string
    unit_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    qty?: IntFieldUpdateOperationsInput | number
    total_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    id_product?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type t_sales_lineUncheckedUpdateManyWithoutBundleInput = {
    id?: StringFieldUpdateOperationsInput | string
    id_sales?: StringFieldUpdateOperationsInput | string
    unit_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    qty?: IntFieldUpdateOperationsInput | number
    total_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    id_product?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type bundle_categoryCreateManyCategoryInput = {
    id?: string
    id_bundle: string
  }

  export type categoryCreateManyCategoryInput = {
    id?: string
    name: string
    deleted_at?: Date | string | null
    slug?: string | null
    img?: string | null
  }

  export type product_categoryCreateManyCategoryInput = {
    id_product: string
    id?: string
  }

  export type bundle_categoryUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    bundle?: bundleUpdateOneRequiredWithoutBundle_categoryNestedInput
  }

  export type bundle_categoryUncheckedUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    id_bundle?: StringFieldUpdateOperationsInput | string
  }

  export type bundle_categoryUncheckedUpdateManyWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    id_bundle?: StringFieldUpdateOperationsInput | string
  }

  export type categoryUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    img?: NullableStringFieldUpdateOperationsInput | string | null
    bundle_category?: bundle_categoryUpdateManyWithoutCategoryNestedInput
    other_category?: categoryUpdateManyWithoutCategoryNestedInput
    product_category?: product_categoryUpdateManyWithoutCategoryNestedInput
  }

  export type categoryUncheckedUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    img?: NullableStringFieldUpdateOperationsInput | string | null
    bundle_category?: bundle_categoryUncheckedUpdateManyWithoutCategoryNestedInput
    other_category?: categoryUncheckedUpdateManyWithoutCategoryNestedInput
    product_category?: product_categoryUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type categoryUncheckedUpdateManyWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    img?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type product_categoryUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    product?: productUpdateOneRequiredWithoutProduct_categoryNestedInput
  }

  export type product_categoryUncheckedUpdateWithoutCategoryInput = {
    id_product?: StringFieldUpdateOperationsInput | string
    id?: StringFieldUpdateOperationsInput | string
  }

  export type product_categoryUncheckedUpdateManyWithoutCategoryInput = {
    id_product?: StringFieldUpdateOperationsInput | string
    id?: StringFieldUpdateOperationsInput | string
  }

  export type auth_userCreateManyCustomerInput = {
    id?: string
    name: string
    email: string
    email_verified?: boolean
    image?: string | null
    created_at?: Date | string
    updated_at?: Date | string | null
    username?: string | null
    display_username?: string | null
    two_factor_enabled?: boolean | null
    id_author?: string | null
    id_affiliate?: string | null
    id_publisher?: string | null
    id_internal?: string | null
  }

  export type customer_readerCreateManyCustomerInput = {
    id?: string
    id_product: string
    last_page: number
    percent: number
  }

  export type customer_trackCreateManyCustomerInput = {
    id?: string
    ts?: Date | string
    path: string
    referrer: string
    info: JsonNullValueInput | InputJsonValue
    ip: string
  }

  export type t_salesCreateManyCustomerInput = {
    id?: string
    status?: string
    total: Decimal | DecimalJsLike | number | string
    currency?: string
    info: JsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    midtrans_order_id?: string
    midtrans_success?: NullableJsonNullValueInput | InputJsonValue
    midtrans_pending?: NullableJsonNullValueInput | InputJsonValue
    midtrans_error?: NullableJsonNullValueInput | InputJsonValue
  }

  export type t_sales_downloadCreateManyCustomerInput = {
    id?: string
    id_product: string
    downloaded_at?: Date | string | null
    ip_address?: string | null
    download_key?: string
  }

  export type auth_userUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    email_verified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    display_username?: NullableStringFieldUpdateOperationsInput | string | null
    two_factor_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    auth_account?: auth_accountUpdateManyWithoutAuth_userNestedInput
    auth_session?: auth_sessionUpdateManyWithoutAuth_userNestedInput
    auth_two_factor?: auth_two_factorUpdateManyWithoutAuth_userNestedInput
    affiliate?: affiliateUpdateOneWithoutAuth_userNestedInput
    author?: authorUpdateOneWithoutAuth_userNestedInput
    internal?: internalUpdateOneWithoutAuth_userNestedInput
    publisher?: publisherUpdateOneWithoutAuth_userNestedInput
    reviews?: reviewsUpdateManyWithoutAuth_userNestedInput
    reviews_likes?: reviews_likesUpdateManyWithoutAuth_userNestedInput
  }

  export type auth_userUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    email_verified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    display_username?: NullableStringFieldUpdateOperationsInput | string | null
    two_factor_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    id_author?: NullableStringFieldUpdateOperationsInput | string | null
    id_affiliate?: NullableStringFieldUpdateOperationsInput | string | null
    id_publisher?: NullableStringFieldUpdateOperationsInput | string | null
    id_internal?: NullableStringFieldUpdateOperationsInput | string | null
    auth_account?: auth_accountUncheckedUpdateManyWithoutAuth_userNestedInput
    auth_session?: auth_sessionUncheckedUpdateManyWithoutAuth_userNestedInput
    auth_two_factor?: auth_two_factorUncheckedUpdateManyWithoutAuth_userNestedInput
    reviews?: reviewsUncheckedUpdateManyWithoutAuth_userNestedInput
    reviews_likes?: reviews_likesUncheckedUpdateManyWithoutAuth_userNestedInput
  }

  export type auth_userUncheckedUpdateManyWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    email_verified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    display_username?: NullableStringFieldUpdateOperationsInput | string | null
    two_factor_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    id_author?: NullableStringFieldUpdateOperationsInput | string | null
    id_affiliate?: NullableStringFieldUpdateOperationsInput | string | null
    id_publisher?: NullableStringFieldUpdateOperationsInput | string | null
    id_internal?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type customer_readerUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    last_page?: IntFieldUpdateOperationsInput | number
    percent?: IntFieldUpdateOperationsInput | number
    product?: productUpdateOneRequiredWithoutCustomer_readerNestedInput
  }

  export type customer_readerUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    id_product?: StringFieldUpdateOperationsInput | string
    last_page?: IntFieldUpdateOperationsInput | number
    percent?: IntFieldUpdateOperationsInput | number
  }

  export type customer_readerUncheckedUpdateManyWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    id_product?: StringFieldUpdateOperationsInput | string
    last_page?: IntFieldUpdateOperationsInput | number
    percent?: IntFieldUpdateOperationsInput | number
  }

  export type customer_trackUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    ts?: DateTimeFieldUpdateOperationsInput | Date | string
    path?: StringFieldUpdateOperationsInput | string
    referrer?: StringFieldUpdateOperationsInput | string
    info?: JsonNullValueInput | InputJsonValue
    ip?: StringFieldUpdateOperationsInput | string
  }

  export type customer_trackUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    ts?: DateTimeFieldUpdateOperationsInput | Date | string
    path?: StringFieldUpdateOperationsInput | string
    referrer?: StringFieldUpdateOperationsInput | string
    info?: JsonNullValueInput | InputJsonValue
    ip?: StringFieldUpdateOperationsInput | string
  }

  export type customer_trackUncheckedUpdateManyWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    ts?: DateTimeFieldUpdateOperationsInput | Date | string
    path?: StringFieldUpdateOperationsInput | string
    referrer?: StringFieldUpdateOperationsInput | string
    info?: JsonNullValueInput | InputJsonValue
    ip?: StringFieldUpdateOperationsInput | string
  }

  export type t_salesUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    info?: JsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    midtrans_order_id?: StringFieldUpdateOperationsInput | string
    midtrans_success?: NullableJsonNullValueInput | InputJsonValue
    midtrans_pending?: NullableJsonNullValueInput | InputJsonValue
    midtrans_error?: NullableJsonNullValueInput | InputJsonValue
    t_sales_line?: t_sales_lineUpdateManyWithoutT_salesNestedInput
  }

  export type t_salesUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    info?: JsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    midtrans_order_id?: StringFieldUpdateOperationsInput | string
    midtrans_success?: NullableJsonNullValueInput | InputJsonValue
    midtrans_pending?: NullableJsonNullValueInput | InputJsonValue
    midtrans_error?: NullableJsonNullValueInput | InputJsonValue
    t_sales_line?: t_sales_lineUncheckedUpdateManyWithoutT_salesNestedInput
  }

  export type t_salesUncheckedUpdateManyWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    info?: JsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    midtrans_order_id?: StringFieldUpdateOperationsInput | string
    midtrans_success?: NullableJsonNullValueInput | InputJsonValue
    midtrans_pending?: NullableJsonNullValueInput | InputJsonValue
    midtrans_error?: NullableJsonNullValueInput | InputJsonValue
  }

  export type t_sales_downloadUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    downloaded_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    download_key?: StringFieldUpdateOperationsInput | string
    product?: productUpdateOneRequiredWithoutT_sales_downloadNestedInput
  }

  export type t_sales_downloadUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    id_product?: StringFieldUpdateOperationsInput | string
    downloaded_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    download_key?: StringFieldUpdateOperationsInput | string
  }

  export type t_sales_downloadUncheckedUpdateManyWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    id_product?: StringFieldUpdateOperationsInput | string
    downloaded_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    download_key?: StringFieldUpdateOperationsInput | string
  }

  export type book_genreCreateManyGenreInput = {
    id?: string
    id_book: string
  }

  export type genreCreateManyGenreInput = {
    id?: string
    name: string
    slug?: string | null
    img?: string | null
    deleted_at?: Date | string | null
  }

  export type book_genreUpdateWithoutGenreInput = {
    id?: StringFieldUpdateOperationsInput | string
    book?: bookUpdateOneRequiredWithoutBook_genreNestedInput
  }

  export type book_genreUncheckedUpdateWithoutGenreInput = {
    id?: StringFieldUpdateOperationsInput | string
    id_book?: StringFieldUpdateOperationsInput | string
  }

  export type book_genreUncheckedUpdateManyWithoutGenreInput = {
    id?: StringFieldUpdateOperationsInput | string
    id_book?: StringFieldUpdateOperationsInput | string
  }

  export type genreUpdateWithoutGenreInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    img?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    book_genre?: book_genreUpdateManyWithoutGenreNestedInput
    other_genre?: genreUpdateManyWithoutGenreNestedInput
  }

  export type genreUncheckedUpdateWithoutGenreInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    img?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    book_genre?: book_genreUncheckedUpdateManyWithoutGenreNestedInput
    other_genre?: genreUncheckedUpdateManyWithoutGenreNestedInput
  }

  export type genreUncheckedUpdateManyWithoutGenreInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    img?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type auth_userCreateManyInternalInput = {
    id?: string
    name: string
    email: string
    email_verified?: boolean
    image?: string | null
    created_at?: Date | string
    updated_at?: Date | string | null
    username?: string | null
    display_username?: string | null
    two_factor_enabled?: boolean | null
    id_customer?: string | null
    id_author?: string | null
    id_affiliate?: string | null
    id_publisher?: string | null
  }

  export type book_approvalCreateManyInternalInput = {
    id?: string
    id_book: string
    comment?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    created_at?: Date | string
  }

  export type auth_userUpdateWithoutInternalInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    email_verified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    display_username?: NullableStringFieldUpdateOperationsInput | string | null
    two_factor_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    auth_account?: auth_accountUpdateManyWithoutAuth_userNestedInput
    auth_session?: auth_sessionUpdateManyWithoutAuth_userNestedInput
    auth_two_factor?: auth_two_factorUpdateManyWithoutAuth_userNestedInput
    affiliate?: affiliateUpdateOneWithoutAuth_userNestedInput
    author?: authorUpdateOneWithoutAuth_userNestedInput
    customer?: customerUpdateOneWithoutAuth_userNestedInput
    publisher?: publisherUpdateOneWithoutAuth_userNestedInput
    reviews?: reviewsUpdateManyWithoutAuth_userNestedInput
    reviews_likes?: reviews_likesUpdateManyWithoutAuth_userNestedInput
  }

  export type auth_userUncheckedUpdateWithoutInternalInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    email_verified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    display_username?: NullableStringFieldUpdateOperationsInput | string | null
    two_factor_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    id_customer?: NullableStringFieldUpdateOperationsInput | string | null
    id_author?: NullableStringFieldUpdateOperationsInput | string | null
    id_affiliate?: NullableStringFieldUpdateOperationsInput | string | null
    id_publisher?: NullableStringFieldUpdateOperationsInput | string | null
    auth_account?: auth_accountUncheckedUpdateManyWithoutAuth_userNestedInput
    auth_session?: auth_sessionUncheckedUpdateManyWithoutAuth_userNestedInput
    auth_two_factor?: auth_two_factorUncheckedUpdateManyWithoutAuth_userNestedInput
    reviews?: reviewsUncheckedUpdateManyWithoutAuth_userNestedInput
    reviews_likes?: reviews_likesUncheckedUpdateManyWithoutAuth_userNestedInput
  }

  export type auth_userUncheckedUpdateManyWithoutInternalInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    email_verified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    display_username?: NullableStringFieldUpdateOperationsInput | string | null
    two_factor_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    id_customer?: NullableStringFieldUpdateOperationsInput | string | null
    id_author?: NullableStringFieldUpdateOperationsInput | string | null
    id_affiliate?: NullableStringFieldUpdateOperationsInput | string | null
    id_publisher?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type book_approvalUpdateWithoutInternalInput = {
    id?: StringFieldUpdateOperationsInput | string
    comment?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    book?: bookUpdateOneRequiredWithoutBook_approvalNestedInput
  }

  export type book_approvalUncheckedUpdateWithoutInternalInput = {
    id?: StringFieldUpdateOperationsInput | string
    id_book?: StringFieldUpdateOperationsInput | string
    comment?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type book_approvalUncheckedUpdateManyWithoutInternalInput = {
    id?: StringFieldUpdateOperationsInput | string
    id_book?: StringFieldUpdateOperationsInput | string
    comment?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type landing_itemsCreateManyLandingInput = {
    id?: string
    desc?: string
    img_file: string
    tag?: string
    link_to: string
    idx?: number
    color?: string
  }

  export type landing_itemsUpdateWithoutLandingInput = {
    id?: StringFieldUpdateOperationsInput | string
    desc?: StringFieldUpdateOperationsInput | string
    img_file?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
    link_to?: StringFieldUpdateOperationsInput | string
    idx?: IntFieldUpdateOperationsInput | number
    color?: StringFieldUpdateOperationsInput | string
  }

  export type landing_itemsUncheckedUpdateWithoutLandingInput = {
    id?: StringFieldUpdateOperationsInput | string
    desc?: StringFieldUpdateOperationsInput | string
    img_file?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
    link_to?: StringFieldUpdateOperationsInput | string
    idx?: IntFieldUpdateOperationsInput | number
    color?: StringFieldUpdateOperationsInput | string
  }

  export type landing_itemsUncheckedUpdateManyWithoutLandingInput = {
    id?: StringFieldUpdateOperationsInput | string
    desc?: StringFieldUpdateOperationsInput | string
    img_file?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
    link_to?: StringFieldUpdateOperationsInput | string
    idx?: IntFieldUpdateOperationsInput | number
    color?: StringFieldUpdateOperationsInput | string
  }

  export type bookCreateManyProductInput = {
    id?: string
    name: string
    slug: string
    alias?: string
    submitted_price: Decimal | DecimalJsLike | number | string
    desc?: string
    info?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    currency?: string
    deleted_at?: Date | string | null
    img_file?: string
    cover?: string
    product_file?: string
    sku?: string
    id_author?: string | null
    published_date?: Date | string
    is_physical?: boolean
    preorder_min_qty?: number | null
    content_type?: string | null
    is_chapter?: boolean
    created_at?: Date | string
  }

  export type bundle_productCreateManyProductInput = {
    id_bundle: string
    id?: string
    qty?: number | null
  }

  export type chapterCreateManyProductInput = {
    id?: string
    id_book?: string | null
    number: number
    name: string
    content?: JsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string | null
  }

  export type customer_readerCreateManyProductInput = {
    id?: string
    id_customer: string
    last_page: number
    percent: number
  }

  export type preorderCreateManyProductInput = {
    id?: string
    min_qty: number
    current_qty?: number
    status?: string
    deadline: Date | string
  }

  export type product_categoryCreateManyProductInput = {
    id_category: string
    id?: string
  }

  export type t_sales_downloadCreateManyProductInput = {
    id?: string
    id_customer: string
    downloaded_at?: Date | string | null
    ip_address?: string | null
    download_key?: string
  }

  export type t_sales_lineCreateManyProductInput = {
    id?: string
    id_sales: string
    unit_price: Decimal | DecimalJsLike | number | string
    qty: number
    total_price: Decimal | DecimalJsLike | number | string
    id_bundle?: string | null
  }

  export type bookUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    alias?: StringFieldUpdateOperationsInput | string
    submitted_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    desc?: StringFieldUpdateOperationsInput | string
    info?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    img_file?: StringFieldUpdateOperationsInput | string
    cover?: StringFieldUpdateOperationsInput | string
    product_file?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    published_date?: DateTimeFieldUpdateOperationsInput | Date | string
    is_physical?: BoolFieldUpdateOperationsInput | boolean
    preorder_min_qty?: NullableIntFieldUpdateOperationsInput | number | null
    content_type?: NullableStringFieldUpdateOperationsInput | string | null
    is_chapter?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: authorUpdateOneWithoutBookNestedInput
    book_approval?: book_approvalUpdateManyWithoutBookNestedInput
    book_changes_log?: book_changes_logUpdateManyWithoutBookNestedInput
    book_genre?: book_genreUpdateManyWithoutBookNestedInput
    book_tags?: book_tagsUpdateManyWithoutBookNestedInput
    chapter?: chapterUpdateManyWithoutBookNestedInput
    ranking?: rankingUpdateManyWithoutBookNestedInput
    reviews?: reviewsUpdateManyWithoutBookNestedInput
  }

  export type bookUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    alias?: StringFieldUpdateOperationsInput | string
    submitted_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    desc?: StringFieldUpdateOperationsInput | string
    info?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    img_file?: StringFieldUpdateOperationsInput | string
    cover?: StringFieldUpdateOperationsInput | string
    product_file?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    id_author?: NullableStringFieldUpdateOperationsInput | string | null
    published_date?: DateTimeFieldUpdateOperationsInput | Date | string
    is_physical?: BoolFieldUpdateOperationsInput | boolean
    preorder_min_qty?: NullableIntFieldUpdateOperationsInput | number | null
    content_type?: NullableStringFieldUpdateOperationsInput | string | null
    is_chapter?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    book_approval?: book_approvalUncheckedUpdateManyWithoutBookNestedInput
    book_changes_log?: book_changes_logUncheckedUpdateManyWithoutBookNestedInput
    book_genre?: book_genreUncheckedUpdateManyWithoutBookNestedInput
    book_tags?: book_tagsUncheckedUpdateManyWithoutBookNestedInput
    chapter?: chapterUncheckedUpdateManyWithoutBookNestedInput
    ranking?: rankingUncheckedUpdateManyWithoutBookNestedInput
    reviews?: reviewsUncheckedUpdateManyWithoutBookNestedInput
  }

  export type bookUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    alias?: StringFieldUpdateOperationsInput | string
    submitted_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    desc?: StringFieldUpdateOperationsInput | string
    info?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    img_file?: StringFieldUpdateOperationsInput | string
    cover?: StringFieldUpdateOperationsInput | string
    product_file?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    id_author?: NullableStringFieldUpdateOperationsInput | string | null
    published_date?: DateTimeFieldUpdateOperationsInput | Date | string
    is_physical?: BoolFieldUpdateOperationsInput | boolean
    preorder_min_qty?: NullableIntFieldUpdateOperationsInput | number | null
    content_type?: NullableStringFieldUpdateOperationsInput | string | null
    is_chapter?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type bundle_productUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    qty?: NullableIntFieldUpdateOperationsInput | number | null
    bundle?: bundleUpdateOneRequiredWithoutBundle_productNestedInput
  }

  export type bundle_productUncheckedUpdateWithoutProductInput = {
    id_bundle?: StringFieldUpdateOperationsInput | string
    id?: StringFieldUpdateOperationsInput | string
    qty?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type bundle_productUncheckedUpdateManyWithoutProductInput = {
    id_bundle?: StringFieldUpdateOperationsInput | string
    id?: StringFieldUpdateOperationsInput | string
    qty?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type chapterUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    book?: bookUpdateOneWithoutChapterNestedInput
  }

  export type chapterUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    id_book?: NullableStringFieldUpdateOperationsInput | string | null
    number?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type chapterUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    id_book?: NullableStringFieldUpdateOperationsInput | string | null
    number?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type customer_readerUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    last_page?: IntFieldUpdateOperationsInput | number
    percent?: IntFieldUpdateOperationsInput | number
    customer?: customerUpdateOneRequiredWithoutCustomer_readerNestedInput
  }

  export type customer_readerUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    id_customer?: StringFieldUpdateOperationsInput | string
    last_page?: IntFieldUpdateOperationsInput | number
    percent?: IntFieldUpdateOperationsInput | number
  }

  export type customer_readerUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    id_customer?: StringFieldUpdateOperationsInput | string
    last_page?: IntFieldUpdateOperationsInput | number
    percent?: IntFieldUpdateOperationsInput | number
  }

  export type preorderUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    min_qty?: IntFieldUpdateOperationsInput | number
    current_qty?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    deadline?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type preorderUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    min_qty?: IntFieldUpdateOperationsInput | number
    current_qty?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    deadline?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type preorderUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    min_qty?: IntFieldUpdateOperationsInput | number
    current_qty?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    deadline?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type product_categoryUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: categoryUpdateOneRequiredWithoutProduct_categoryNestedInput
  }

  export type product_categoryUncheckedUpdateWithoutProductInput = {
    id_category?: StringFieldUpdateOperationsInput | string
    id?: StringFieldUpdateOperationsInput | string
  }

  export type product_categoryUncheckedUpdateManyWithoutProductInput = {
    id_category?: StringFieldUpdateOperationsInput | string
    id?: StringFieldUpdateOperationsInput | string
  }

  export type t_sales_downloadUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    downloaded_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    download_key?: StringFieldUpdateOperationsInput | string
    customer?: customerUpdateOneRequiredWithoutT_sales_downloadNestedInput
  }

  export type t_sales_downloadUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    id_customer?: StringFieldUpdateOperationsInput | string
    downloaded_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    download_key?: StringFieldUpdateOperationsInput | string
  }

  export type t_sales_downloadUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    id_customer?: StringFieldUpdateOperationsInput | string
    downloaded_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    download_key?: StringFieldUpdateOperationsInput | string
  }

  export type t_sales_lineUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    unit_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    qty?: IntFieldUpdateOperationsInput | number
    total_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bundle?: bundleUpdateOneWithoutT_sales_lineNestedInput
    t_sales?: t_salesUpdateOneRequiredWithoutT_sales_lineNestedInput
  }

  export type t_sales_lineUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    id_sales?: StringFieldUpdateOperationsInput | string
    unit_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    qty?: IntFieldUpdateOperationsInput | number
    total_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    id_bundle?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type t_sales_lineUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    id_sales?: StringFieldUpdateOperationsInput | string
    unit_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    qty?: IntFieldUpdateOperationsInput | number
    total_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    id_bundle?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type auth_userCreateManyPublisherInput = {
    id?: string
    name: string
    email: string
    email_verified?: boolean
    image?: string | null
    created_at?: Date | string
    updated_at?: Date | string | null
    username?: string | null
    display_username?: string | null
    two_factor_enabled?: boolean | null
    id_customer?: string | null
    id_author?: string | null
    id_affiliate?: string | null
    id_internal?: string | null
  }

  export type promo_codeCreateManyPublisherInput = {
    id?: string
    code: string
    discount_type: string
    discount_value: Decimal | DecimalJsLike | number | string
    valid_from: Date | string
    valid_to: Date | string
    usage_limit: number
    used_count?: number
    status?: string
  }

  export type publisher_authorCreateManyPublisherInput = {
    id?: string
    author_id: string
  }

  export type t_ai_creditCreateManyPublisherInput = {
    id?: string
    balance?: number
    last_topup_at?: Date | string | null
  }

  export type transactionCreateManyPublisherInput = {
    id?: string
    type: string
    amount: Decimal | DecimalJsLike | number | string
    created_at?: Date | string
    info?: JsonNullValueInput | InputJsonValue
  }

  export type withdrawalCreateManyPublisherInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    status?: string
    requested_at?: Date | string
    processed_at?: Date | string | null
  }

  export type auth_userUpdateWithoutPublisherInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    email_verified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    display_username?: NullableStringFieldUpdateOperationsInput | string | null
    two_factor_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    auth_account?: auth_accountUpdateManyWithoutAuth_userNestedInput
    auth_session?: auth_sessionUpdateManyWithoutAuth_userNestedInput
    auth_two_factor?: auth_two_factorUpdateManyWithoutAuth_userNestedInput
    affiliate?: affiliateUpdateOneWithoutAuth_userNestedInput
    author?: authorUpdateOneWithoutAuth_userNestedInput
    customer?: customerUpdateOneWithoutAuth_userNestedInput
    internal?: internalUpdateOneWithoutAuth_userNestedInput
    reviews?: reviewsUpdateManyWithoutAuth_userNestedInput
    reviews_likes?: reviews_likesUpdateManyWithoutAuth_userNestedInput
  }

  export type auth_userUncheckedUpdateWithoutPublisherInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    email_verified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    display_username?: NullableStringFieldUpdateOperationsInput | string | null
    two_factor_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    id_customer?: NullableStringFieldUpdateOperationsInput | string | null
    id_author?: NullableStringFieldUpdateOperationsInput | string | null
    id_affiliate?: NullableStringFieldUpdateOperationsInput | string | null
    id_internal?: NullableStringFieldUpdateOperationsInput | string | null
    auth_account?: auth_accountUncheckedUpdateManyWithoutAuth_userNestedInput
    auth_session?: auth_sessionUncheckedUpdateManyWithoutAuth_userNestedInput
    auth_two_factor?: auth_two_factorUncheckedUpdateManyWithoutAuth_userNestedInput
    reviews?: reviewsUncheckedUpdateManyWithoutAuth_userNestedInput
    reviews_likes?: reviews_likesUncheckedUpdateManyWithoutAuth_userNestedInput
  }

  export type auth_userUncheckedUpdateManyWithoutPublisherInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    email_verified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    display_username?: NullableStringFieldUpdateOperationsInput | string | null
    two_factor_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    id_customer?: NullableStringFieldUpdateOperationsInput | string | null
    id_author?: NullableStringFieldUpdateOperationsInput | string | null
    id_affiliate?: NullableStringFieldUpdateOperationsInput | string | null
    id_internal?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type promo_codeUpdateWithoutPublisherInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    discount_type?: StringFieldUpdateOperationsInput | string
    discount_value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    valid_from?: DateTimeFieldUpdateOperationsInput | Date | string
    valid_to?: DateTimeFieldUpdateOperationsInput | Date | string
    usage_limit?: IntFieldUpdateOperationsInput | number
    used_count?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
  }

  export type promo_codeUncheckedUpdateWithoutPublisherInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    discount_type?: StringFieldUpdateOperationsInput | string
    discount_value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    valid_from?: DateTimeFieldUpdateOperationsInput | Date | string
    valid_to?: DateTimeFieldUpdateOperationsInput | Date | string
    usage_limit?: IntFieldUpdateOperationsInput | number
    used_count?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
  }

  export type promo_codeUncheckedUpdateManyWithoutPublisherInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    discount_type?: StringFieldUpdateOperationsInput | string
    discount_value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    valid_from?: DateTimeFieldUpdateOperationsInput | Date | string
    valid_to?: DateTimeFieldUpdateOperationsInput | Date | string
    usage_limit?: IntFieldUpdateOperationsInput | number
    used_count?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
  }

  export type publisher_authorUpdateWithoutPublisherInput = {
    id?: StringFieldUpdateOperationsInput | string
    author?: authorUpdateOneRequiredWithoutPublisher_authorNestedInput
  }

  export type publisher_authorUncheckedUpdateWithoutPublisherInput = {
    id?: StringFieldUpdateOperationsInput | string
    author_id?: StringFieldUpdateOperationsInput | string
  }

  export type publisher_authorUncheckedUpdateManyWithoutPublisherInput = {
    id?: StringFieldUpdateOperationsInput | string
    author_id?: StringFieldUpdateOperationsInput | string
  }

  export type t_ai_creditUpdateWithoutPublisherInput = {
    id?: StringFieldUpdateOperationsInput | string
    balance?: IntFieldUpdateOperationsInput | number
    last_topup_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    t_ai_credit_topup?: t_ai_credit_topupUpdateManyWithoutT_ai_creditNestedInput
  }

  export type t_ai_creditUncheckedUpdateWithoutPublisherInput = {
    id?: StringFieldUpdateOperationsInput | string
    balance?: IntFieldUpdateOperationsInput | number
    last_topup_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    t_ai_credit_topup?: t_ai_credit_topupUncheckedUpdateManyWithoutT_ai_creditNestedInput
  }

  export type t_ai_creditUncheckedUpdateManyWithoutPublisherInput = {
    id?: StringFieldUpdateOperationsInput | string
    balance?: IntFieldUpdateOperationsInput | number
    last_topup_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type transactionUpdateWithoutPublisherInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    info?: JsonNullValueInput | InputJsonValue
  }

  export type transactionUncheckedUpdateWithoutPublisherInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    info?: JsonNullValueInput | InputJsonValue
  }

  export type transactionUncheckedUpdateManyWithoutPublisherInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    info?: JsonNullValueInput | InputJsonValue
  }

  export type withdrawalUpdateWithoutPublisherInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    requested_at?: DateTimeFieldUpdateOperationsInput | Date | string
    processed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type withdrawalUncheckedUpdateWithoutPublisherInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    requested_at?: DateTimeFieldUpdateOperationsInput | Date | string
    processed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type withdrawalUncheckedUpdateManyWithoutPublisherInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    requested_at?: DateTimeFieldUpdateOperationsInput | Date | string
    processed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type reviews_likesCreateManyReviewsInput = {
    id?: string
    id_user: string
  }

  export type reviews_likesUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    auth_user?: auth_userUpdateOneRequiredWithoutReviews_likesNestedInput
  }

  export type reviews_likesUncheckedUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    id_user?: StringFieldUpdateOperationsInput | string
  }

  export type reviews_likesUncheckedUpdateManyWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    id_user?: StringFieldUpdateOperationsInput | string
  }

  export type t_ai_credit_topupCreateManyT_ai_creditInput = {
    id?: string
    amount: number
    created_at?: Date | string
    status?: string
  }

  export type t_ai_credit_topupUpdateWithoutT_ai_creditInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
  }

  export type t_ai_credit_topupUncheckedUpdateWithoutT_ai_creditInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
  }

  export type t_ai_credit_topupUncheckedUpdateManyWithoutT_ai_creditInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
  }

  export type t_sales_lineCreateManyT_salesInput = {
    id?: string
    unit_price: Decimal | DecimalJsLike | number | string
    qty: number
    total_price: Decimal | DecimalJsLike | number | string
    id_product?: string | null
    id_bundle?: string | null
  }

  export type t_sales_lineUpdateWithoutT_salesInput = {
    id?: StringFieldUpdateOperationsInput | string
    unit_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    qty?: IntFieldUpdateOperationsInput | number
    total_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bundle?: bundleUpdateOneWithoutT_sales_lineNestedInput
    product?: productUpdateOneWithoutT_sales_lineNestedInput
  }

  export type t_sales_lineUncheckedUpdateWithoutT_salesInput = {
    id?: StringFieldUpdateOperationsInput | string
    unit_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    qty?: IntFieldUpdateOperationsInput | number
    total_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    id_product?: NullableStringFieldUpdateOperationsInput | string | null
    id_bundle?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type t_sales_lineUncheckedUpdateManyWithoutT_salesInput = {
    id?: StringFieldUpdateOperationsInput | string
    unit_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    qty?: IntFieldUpdateOperationsInput | number
    total_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    id_product?: NullableStringFieldUpdateOperationsInput | string | null
    id_bundle?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type book_tagsCreateManyTagsInput = {
    id?: string
    id_book: string
  }

  export type tagsCreateManyTagsInput = {
    id?: string
    name: string
    deleted_at?: Date | string | null
    slug?: string | null
    img?: string | null
  }

  export type book_tagsUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    book?: bookUpdateOneRequiredWithoutBook_tagsNestedInput
  }

  export type book_tagsUncheckedUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    id_book?: StringFieldUpdateOperationsInput | string
  }

  export type book_tagsUncheckedUpdateManyWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    id_book?: StringFieldUpdateOperationsInput | string
  }

  export type tagsUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    img?: NullableStringFieldUpdateOperationsInput | string | null
    book_tags?: book_tagsUpdateManyWithoutTagsNestedInput
    other_tags?: tagsUpdateManyWithoutTagsNestedInput
  }

  export type tagsUncheckedUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    img?: NullableStringFieldUpdateOperationsInput | string | null
    book_tags?: book_tagsUncheckedUpdateManyWithoutTagsNestedInput
    other_tags?: tagsUncheckedUpdateManyWithoutTagsNestedInput
  }

  export type tagsUncheckedUpdateManyWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    img?: NullableStringFieldUpdateOperationsInput | string | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}